        -:    0:Source:/home/david/Programming/wakaamaNode/contrib/lwip/src/core/def.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/contrib/lwip/src/core/def.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/**
        -:    2: * @file
        -:    3: * Common functions used throughout the stack.
        -:    4: *
        -:    5: * These are reference implementations of the byte swapping functions.
        -:    6: * Again with the aim of being simple, correct and fully portable.
        -:    7: * Byte swapping is the second thing you would want to optimize. You will
        -:    8: * need to port it to your architecture and in your cc.h:
        -:    9: *
        -:   10: * \#define lwip_htons(x) your_htons
        -:   11: * \#define lwip_htonl(x) your_htonl
        -:   12: *
        -:   13: * Note lwip_ntohs() and lwip_ntohl() are merely references to the htonx counterparts.
        -:   14: * 
        -:   15: * If you \#define them to htons() and htonl(), you should
        -:   16: * \#define LWIP_DONT_PROVIDE_BYTEORDER_FUNCTIONS to prevent lwIP from
        -:   17: * defining htonx/ntohx compatibility macros.
        -:   18:
        -:   19: * @defgroup sys_nonstandard Non-standard functions
        -:   20: * @ingroup sys_layer
        -:   21: * lwIP provides default implementations for non-standard functions.
        -:   22: * These can be mapped to OS functions to reduce code footprint if desired.
        -:   23: * All defines related to this section must not be placed in lwipopts.h,
        -:   24: * but in arch/cc.h!
        -:   25: * These options cannot be \#defined in lwipopts.h since they are not options
        -:   26: * of lwIP itself, but options of the lwIP port to your system.
        -:   27: */
        -:   28:
        -:   29:/*
        -:   30: * Copyright (c) 2001-2004 Swedish Institute of Computer Science.
        -:   31: * All rights reserved.
        -:   32: *
        -:   33: * Redistribution and use in source and binary forms, with or without modification,
        -:   34: * are permitted provided that the following conditions are met:
        -:   35: *
        -:   36: * 1. Redistributions of source code must retain the above copyright notice,
        -:   37: *    this list of conditions and the following disclaimer.
        -:   38: * 2. Redistributions in binary form must reproduce the above copyright notice,
        -:   39: *    this list of conditions and the following disclaimer in the documentation
        -:   40: *    and/or other materials provided with the distribution.
        -:   41: * 3. The name of the author may not be used to endorse or promote products
        -:   42: *    derived from this software without specific prior written permission.
        -:   43: *
        -:   44: * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
        -:   45: * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
        -:   46: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
        -:   47: * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
        -:   48: * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
        -:   49: * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
        -:   50: * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
        -:   51: * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
        -:   52: * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
        -:   53: * OF SUCH DAMAGE.
        -:   54: *
        -:   55: * This file is part of the lwIP TCP/IP stack.
        -:   56: *
        -:   57: * Author: Simon Goldschmidt
        -:   58: *
        -:   59: */
        -:   60:
        -:   61:#include "lwip/opt.h"
        -:   62:#include "lwip/def.h"
        -:   63:
        -:   64:#include <string.h>
        -:   65:
        -:   66:#if BYTE_ORDER == LITTLE_ENDIAN
        -:   67:
        -:   68:#if !defined(lwip_htons)
        -:   69:/**
        -:   70: * Convert an u16_t from host- to network byte order.
        -:   71: *
        -:   72: * @param n u16_t in host byte order
        -:   73: * @return n in network byte order
        -:   74: */
        -:   75:u16_t
    #####:   76:lwip_htons(u16_t n)
        -:   77:{
    #####:   78:  return (u16_t)PP_HTONS(n);
        -:   79:}
        -:   80:#endif /* lwip_htons */
        -:   81:
        -:   82:#if !defined(lwip_htonl)
        -:   83:/**
        -:   84: * Convert an u32_t from host- to network byte order.
        -:   85: *
        -:   86: * @param n u32_t in host byte order
        -:   87: * @return n in network byte order
        -:   88: */
        -:   89:u32_t
    #####:   90:lwip_htonl(u32_t n)
        -:   91:{
    #####:   92:  return (u32_t)PP_HTONL(n);
        -:   93:}
        -:   94:#endif /* lwip_htonl */
        -:   95:
        -:   96:#endif /* BYTE_ORDER == LITTLE_ENDIAN */
        -:   97:
        -:   98:#ifndef lwip_strnstr
        -:   99:/**
        -:  100: * @ingroup sys_nonstandard
        -:  101: * lwIP default implementation for strnstr() non-standard function.
        -:  102: * This can be \#defined to strnstr() depending on your platform port.
        -:  103: */
        -:  104:char*
    #####:  105:lwip_strnstr(const char* buffer, const char* token, size_t n)
        -:  106:{
        -:  107:  const char* p;
    #####:  108:  size_t tokenlen = strlen(token);
    #####:  109:  if (tokenlen == 0) {
    #####:  110:    return LWIP_CONST_CAST(char *, buffer);
        -:  111:  }
    #####:  112:  for (p = buffer; *p && (p + tokenlen <= buffer + n); p++) {
    #####:  113:    if ((*p == *token) && (strncmp(p, token, tokenlen) == 0)) {
    #####:  114:      return LWIP_CONST_CAST(char *, p);
        -:  115:    }
        -:  116:  }
    #####:  117:  return NULL;
        -:  118:}
        -:  119:#endif
        -:  120:
        -:  121:#ifndef lwip_stricmp
        -:  122:/**
        -:  123: * @ingroup sys_nonstandard
        -:  124: * lwIP default implementation for stricmp() non-standard function.
        -:  125: * This can be \#defined to stricmp() depending on your platform port.
        -:  126: */
        -:  127:int
    #####:  128:lwip_stricmp(const char* str1, const char* str2)
        -:  129:{
        -:  130:  char c1, c2;
        -:  131:
        -:  132:  do {
    #####:  133:    c1 = *str1++;
    #####:  134:    c2 = *str2++;
    #####:  135:    if (c1 != c2) {
    #####:  136:      char c1_upc = c1 | 0x20;
    #####:  137:      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
        -:  138:        /* characters are not equal an one is in the alphabet range:
        -:  139:        downcase both chars and check again */
    #####:  140:        char c2_upc = c2 | 0x20;
    #####:  141:        if (c1_upc != c2_upc) {
        -:  142:          /* still not equal */
        -:  143:          /* don't care for < or > */
    #####:  144:          return 1;
        -:  145:        }
        -:  146:      } else {
        -:  147:        /* characters are not equal but none is in the alphabet range */
    #####:  148:        return 1;
        -:  149:      }
        -:  150:    }
    #####:  151:  } while (c1 != 0);
    #####:  152:  return 0;
        -:  153:}
        -:  154:#endif
        -:  155:
        -:  156:#ifndef lwip_strnicmp
        -:  157:/**
        -:  158: * @ingroup sys_nonstandard
        -:  159: * lwIP default implementation for strnicmp() non-standard function.
        -:  160: * This can be \#defined to strnicmp() depending on your platform port.
        -:  161: */
        -:  162:int
    #####:  163:lwip_strnicmp(const char* str1, const char* str2, size_t len)
        -:  164:{
        -:  165:  char c1, c2;
        -:  166:
        -:  167:  do {
    #####:  168:    c1 = *str1++;
    #####:  169:    c2 = *str2++;
    #####:  170:    if (c1 != c2) {
    #####:  171:      char c1_upc = c1 | 0x20;
    #####:  172:      if ((c1_upc >= 'a') && (c1_upc <= 'z')) {
        -:  173:        /* characters are not equal an one is in the alphabet range:
        -:  174:        downcase both chars and check again */
    #####:  175:        char c2_upc = c2 | 0x20;
    #####:  176:        if (c1_upc != c2_upc) {
        -:  177:          /* still not equal */
        -:  178:          /* don't care for < or > */
    #####:  179:          return 1;
        -:  180:        }
        -:  181:      } else {
        -:  182:        /* characters are not equal but none is in the alphabet range */
    #####:  183:        return 1;
        -:  184:      }
        -:  185:    }
    #####:  186:  } while (len-- && c1 != 0);
    #####:  187:  return 0;
        -:  188:}
        -:  189:#endif
        -:  190:
        -:  191:#ifndef lwip_itoa
        -:  192:/**
        -:  193: * @ingroup sys_nonstandard
        -:  194: * lwIP default implementation for itoa() non-standard function.
        -:  195: * This can be \#defined to itoa() or snprintf(result, bufsize, "%d", number) depending on your platform port.
        -:  196: */
        -:  197:void
    #####:  198:lwip_itoa(char* result, size_t bufsize, int number)
        -:  199:{
    #####:  200:  const int base = 10;
    #####:  201:  char* ptr = result, *ptr1 = result, tmp_char;
        -:  202:  int tmp_value;
        -:  203:  LWIP_UNUSED_ARG(bufsize);
        -:  204:
        -:  205:  do {
    #####:  206:    tmp_value = number;
    #####:  207:    number /= base;
    #####:  208:    *ptr++ = "zyxwvutsrqponmlkjihgfedcba9876543210123456789abcdefghijklmnopqrstuvwxyz"[35 + (tmp_value - number * base)];
    #####:  209:  } while(number);
        -:  210:
        -:  211:   /* Apply negative sign */
    #####:  212:  if (tmp_value < 0) {
    #####:  213:     *ptr++ = '-';
        -:  214:  }
    #####:  215:  *ptr-- = '\0';
    #####:  216:  while(ptr1 < ptr) {
    #####:  217:    tmp_char = *ptr;
    #####:  218:    *ptr--= *ptr1;
    #####:  219:    *ptr1++ = tmp_char;
        -:  220:  }
    #####:  221:}
        -:  222:#endif
