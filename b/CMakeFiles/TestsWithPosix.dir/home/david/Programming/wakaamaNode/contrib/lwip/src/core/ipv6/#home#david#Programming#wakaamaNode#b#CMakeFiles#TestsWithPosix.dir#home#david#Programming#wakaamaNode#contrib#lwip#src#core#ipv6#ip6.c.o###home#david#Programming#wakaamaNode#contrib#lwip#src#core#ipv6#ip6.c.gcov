        -:    0:Source:/home/david/Programming/wakaamaNode/contrib/lwip/src/core/ipv6/ip6.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/contrib/lwip/src/core/ipv6/ip6.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/**
        -:    2: * @file
        -:    3: *
        -:    4: * IPv6 layer.
        -:    5: */
        -:    6:
        -:    7:/*
        -:    8: * Copyright (c) 2010 Inico Technologies Ltd.
        -:    9: * All rights reserved.
        -:   10: *
        -:   11: * Redistribution and use in source and binary forms, with or without modification,
        -:   12: * are permitted provided that the following conditions are met:
        -:   13: *
        -:   14: * 1. Redistributions of source code must retain the above copyright notice,
        -:   15: *    this list of conditions and the following disclaimer.
        -:   16: * 2. Redistributions in binary form must reproduce the above copyright notice,
        -:   17: *    this list of conditions and the following disclaimer in the documentation
        -:   18: *    and/or other materials provided with the distribution.
        -:   19: * 3. The name of the author may not be used to endorse or promote products
        -:   20: *    derived from this software without specific prior written permission.
        -:   21: *
        -:   22: * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
        -:   23: * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
        -:   24: * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT
        -:   25: * SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
        -:   26: * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
        -:   27: * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
        -:   28: * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
        -:   29: * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
        -:   30: * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
        -:   31: * OF SUCH DAMAGE.
        -:   32: *
        -:   33: * This file is part of the lwIP TCP/IP stack.
        -:   34: *
        -:   35: * Author: Ivan Delamer <delamer@inicotech.com>
        -:   36: *
        -:   37: *
        -:   38: * Please coordinate changes and requests with Ivan Delamer
        -:   39: * <delamer@inicotech.com>
        -:   40: */
        -:   41:
        -:   42:#include "lwip/opt.h"
        -:   43:
        -:   44:#if LWIP_IPV6  /* don't build if not configured for use in lwipopts.h */
        -:   45:
        -:   46:#include "lwip/def.h"
        -:   47:#include "lwip/mem.h"
        -:   48:#include "lwip/netif.h"
        -:   49:#include "lwip/ip.h"
        -:   50:#include "lwip/ip6.h"
        -:   51:#include "lwip/ip6_addr.h"
        -:   52:#include "lwip/ip6_frag.h"
        -:   53:#include "lwip/icmp6.h"
        -:   54:#include "lwip/raw.h"
        -:   55:#include "lwip/udp.h"
        -:   56:#include "lwip/priv/tcp_priv.h"
        -:   57:#include "lwip/dhcp6.h"
        -:   58:#include "lwip/nd6.h"
        -:   59:#include "lwip/mld6.h"
        -:   60:#include "lwip/debug.h"
        -:   61:#include "lwip/stats.h"
        -:   62:
        -:   63:#ifdef LWIP_HOOK_FILENAME
        -:   64:#include LWIP_HOOK_FILENAME
        -:   65:#endif
        -:   66:
        -:   67:/**
        -:   68: * Finds the appropriate network interface for a given IPv6 address. It tries to select
        -:   69: * a netif following a sequence of heuristics:
        -:   70: * 1) if there is only 1 netif, return it
        -:   71: * 2) if the destination is a link-local address, try to match the src address to a netif.
        -:   72: *    this is a tricky case because with multiple netifs, link-local addresses only have
        -:   73: *    meaning within a particular subnet/link.
        -:   74: * 3) tries to match the destination subnet to a configured address
        -:   75: * 4) tries to find a router
        -:   76: * 5) tries to match the source address to the netif
        -:   77: * 6) returns the default netif, if configured
        -:   78: *
        -:   79: * @param src the source IPv6 address, if known
        -:   80: * @param dest the destination IPv6 address for which to find the route
        -:   81: * @return the netif on which to send to reach dest
        -:   82: */
        -:   83:struct netif *
    #####:   84:ip6_route(const ip6_addr_t *src, const ip6_addr_t *dest)
        -:   85:{
        -:   86:  struct netif *netif;
        -:   87:  s8_t i;
        -:   88:
        -:   89:  /* If single netif configuration, fast return. */
    #####:   90:  if ((netif_list != NULL) && (netif_list->next == NULL)) {
    #####:   91:    if (!netif_is_up(netif_list) || !netif_is_link_up(netif_list)) {
    #####:   92:      return NULL;
        -:   93:    }
    #####:   94:    return netif_list;
        -:   95:  }
        -:   96:
        -:   97:  /* Special processing for link-local addresses. */
    #####:   98:  if (ip6_addr_islinklocal(dest)) {
    #####:   99:    if (ip6_addr_isany(src)) {
        -:  100:      /* Use default netif, if Up. */
    #####:  101:      if (netif_default == NULL || !netif_is_up(netif_default) ||
    #####:  102:          !netif_is_link_up(netif_default)) {
    #####:  103:        return NULL;
        -:  104:      }
    #####:  105:      return netif_default;
        -:  106:    }
        -:  107:
        -:  108:    /* Try to find the netif for the source address, checking that link is up. */
    #####:  109:    for (netif = netif_list; netif != NULL; netif = netif->next) {
    #####:  110:      if (!netif_is_up(netif) || !netif_is_link_up(netif)) {
    #####:  111:        continue;
        -:  112:      }
    #####:  113:      for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
    #####:  114:        if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i)) &&
    #####:  115:            ip6_addr_cmp(src, netif_ip6_addr(netif, i))) {
    #####:  116:          return netif;
        -:  117:        }
        -:  118:      }
        -:  119:    }
        -:  120:
        -:  121:    /* netif not found, use default netif, if up */
    #####:  122:    if (netif_default == NULL || !netif_is_up(netif_default) ||
    #####:  123:        !netif_is_link_up(netif_default)) {
    #####:  124:      return NULL;
        -:  125:    }
    #####:  126:    return netif_default;
        -:  127:  }
        -:  128:
        -:  129:  /* we come here for non-link-local addresses */
        -:  130:#ifdef LWIP_HOOK_IP6_ROUTE
        -:  131:  netif = LWIP_HOOK_IP6_ROUTE(src, dest);
        -:  132:  if (netif != NULL) {
        -:  133:    return netif;
        -:  134:  }
        -:  135:#endif
        -:  136:
        -:  137:  /* See if the destination subnet matches a configured address. */
    #####:  138:  for (netif = netif_list; netif != NULL; netif = netif->next) {
    #####:  139:    if (!netif_is_up(netif) || !netif_is_link_up(netif)) {
    #####:  140:      continue;
        -:  141:    }
    #####:  142:    for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
    #####:  143:      if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i)) &&
    #####:  144:          ip6_addr_netcmp(dest, netif_ip6_addr(netif, i))) {
    #####:  145:        return netif;
        -:  146:      }
        -:  147:    }
        -:  148:  }
        -:  149:
        -:  150:  /* Get the netif for a suitable router. */
    #####:  151:  netif = nd6_find_route(dest);
    #####:  152:  if ((netif != NULL) && netif_is_up(netif) && netif_is_link_up(netif)) {
    #####:  153:    return netif;
        -:  154:  }
        -:  155:
        -:  156:  /* try with the netif that matches the source address. */
    #####:  157:  if (!ip6_addr_isany(src)) {
    #####:  158:    for (netif = netif_list; netif != NULL; netif = netif->next) {
    #####:  159:      if (!netif_is_up(netif) || !netif_is_link_up(netif)) {
    #####:  160:        continue;
        -:  161:      }
    #####:  162:      for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
    #####:  163:        if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i)) &&
    #####:  164:            ip6_addr_cmp(src, netif_ip6_addr(netif, i))) {
    #####:  165:          return netif;
        -:  166:        }
        -:  167:      }
        -:  168:    }
        -:  169:  }
        -:  170:
        -:  171:#if LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF
        -:  172:  /* loopif is disabled, loopback traffic is passed through any netif */
        -:  173:  if (ip6_addr_isloopback(dest)) {
        -:  174:    /* don't check for link on loopback traffic */
        -:  175:    if (netif_default != NULL && netif_is_up(netif_default)) {
        -:  176:      return netif_default;
        -:  177:    }
        -:  178:    /* default netif is not up, just use any netif for loopback traffic */
        -:  179:    for (netif = netif_list; netif != NULL; netif = netif->next) {
        -:  180:      if (netif_is_up(netif)) {
        -:  181:        return netif;
        -:  182:      }
        -:  183:    }
        -:  184:    return NULL;
        -:  185:  }
        -:  186:#endif /* LWIP_NETIF_LOOPBACK && !LWIP_HAVE_LOOPIF */
        -:  187:
        -:  188:  /* no matching netif found, use default netif, if up */
    #####:  189:  if ((netif_default == NULL) || !netif_is_up(netif_default) || !netif_is_link_up(netif_default)) {
    #####:  190:    return NULL;
        -:  191:  }
    #####:  192:  return netif_default;
        -:  193:}
        -:  194:
        -:  195:/**
        -:  196: * @ingroup ip6
        -:  197: * Select the best IPv6 source address for a given destination
        -:  198: * IPv6 address. Loosely follows RFC 3484. "Strong host" behavior
        -:  199: * is assumed.
        -:  200: *
        -:  201: * @param netif the netif on which to send a packet
        -:  202: * @param dest the destination we are trying to reach
        -:  203: * @return the most suitable source address to use, or NULL if no suitable
        -:  204: *         source address is found
        -:  205: */
        -:  206:const ip_addr_t *
    #####:  207:ip6_select_source_address(struct netif *netif, const ip6_addr_t *dest)
        -:  208:{
    #####:  209:  const ip_addr_t *src = NULL;
        -:  210:  u8_t i;
        -:  211:
        -:  212:  /* If dest is link-local, choose a link-local source. */
    #####:  213:  if (ip6_addr_islinklocal(dest) || ip6_addr_ismulticast_linklocal(dest) || ip6_addr_ismulticast_iflocal(dest)) {
    #####:  214:    for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
    #####:  215:      if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i)) &&
    #####:  216:          ip6_addr_islinklocal(netif_ip6_addr(netif, i))) {
    #####:  217:        return netif_ip_addr6(netif, i);
        -:  218:      }
        -:  219:    }
        -:  220:  }
        -:  221:
        -:  222:  /* Choose a site-local with matching prefix. */
    #####:  223:  if (ip6_addr_issitelocal(dest) || ip6_addr_ismulticast_sitelocal(dest)) {
    #####:  224:    for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
    #####:  225:      if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i)) &&
    #####:  226:          ip6_addr_issitelocal(netif_ip6_addr(netif, i)) &&
    #####:  227:          ip6_addr_netcmp(dest, netif_ip6_addr(netif, i))) {
    #####:  228:        return netif_ip_addr6(netif, i);
        -:  229:      }
        -:  230:    }
        -:  231:  }
        -:  232:
        -:  233:  /* Choose a unique-local with matching prefix. */
    #####:  234:  if (ip6_addr_isuniquelocal(dest) || ip6_addr_ismulticast_orglocal(dest)) {
    #####:  235:    for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
    #####:  236:      if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i)) &&
    #####:  237:          ip6_addr_isuniquelocal(netif_ip6_addr(netif, i)) &&
    #####:  238:          ip6_addr_netcmp(dest, netif_ip6_addr(netif, i))) {
    #####:  239:        return netif_ip_addr6(netif, i);
        -:  240:      }
        -:  241:    }
        -:  242:  }
        -:  243:
        -:  244:  /* Choose a global with best matching prefix. */
    #####:  245:  if (ip6_addr_isglobal(dest) || ip6_addr_ismulticast_global(dest)) {
    #####:  246:    for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
    #####:  247:      if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i)) &&
    #####:  248:          ip6_addr_isglobal(netif_ip6_addr(netif, i))) {
    #####:  249:        if (src == NULL) {
    #####:  250:          src = netif_ip_addr6(netif, i);
        -:  251:        }
        -:  252:        else {
        -:  253:          /* Replace src only if we find a prefix match. */
        -:  254:          /* @todo find longest matching prefix. */
    #####:  255:          if ((!(ip6_addr_netcmp(ip_2_ip6(src), dest))) &&
    #####:  256:              ip6_addr_netcmp(netif_ip6_addr(netif, i), dest)) {
    #####:  257:            src = netif_ip_addr6(netif, i);
        -:  258:          }
        -:  259:        }
        -:  260:      }
        -:  261:    }
    #####:  262:    if (src != NULL) {
    #####:  263:      return src;
        -:  264:    }
        -:  265:  }
        -:  266:
        -:  267:  /* Last resort: see if arbitrary prefix matches. */
    #####:  268:  for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
    #####:  269:    if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i)) &&
    #####:  270:        ip6_addr_netcmp(dest, netif_ip6_addr(netif, i))) {
    #####:  271:      return netif_ip_addr6(netif, i);
        -:  272:    }
        -:  273:  }
        -:  274:
    #####:  275:  return NULL;
        -:  276:}
        -:  277:
        -:  278:#if LWIP_IPV6_FORWARD
        -:  279:/**
        -:  280: * Forwards an IPv6 packet. It finds an appropriate route for the
        -:  281: * packet, decrements the HL value of the packet, and outputs
        -:  282: * the packet on the appropriate interface.
        -:  283: *
        -:  284: * @param p the packet to forward (p->payload points to IP header)
        -:  285: * @param iphdr the IPv6 header of the input packet
        -:  286: * @param inp the netif on which this packet was received
        -:  287: */
        -:  288:static void
        -:  289:ip6_forward(struct pbuf *p, struct ip6_hdr *iphdr, struct netif *inp)
        -:  290:{
        -:  291:  struct netif *netif;
        -:  292:
        -:  293:  /* do not forward link-local or loopback addresses */
        -:  294:  if (ip6_addr_islinklocal(ip6_current_dest_addr()) ||
        -:  295:      ip6_addr_isloopback(ip6_current_dest_addr())) {
        -:  296:    LWIP_DEBUGF(IP6_DEBUG, ("ip6_forward: not forwarding link-local address.\n"));
        -:  297:    IP6_STATS_INC(ip6.rterr);
        -:  298:    IP6_STATS_INC(ip6.drop);
        -:  299:    return;
        -:  300:  }
        -:  301:
        -:  302:  /* Find network interface where to forward this IP packet to. */
        -:  303:  netif = ip6_route(IP6_ADDR_ANY6, ip6_current_dest_addr());
        -:  304:  if (netif == NULL) {
        -:  305:    LWIP_DEBUGF(IP6_DEBUG, ("ip6_forward: no route for %"X16_F":%"X16_F":%"X16_F":%"X16_F":%"X16_F":%"X16_F":%"X16_F":%"X16_F"\n",
        -:  306:        IP6_ADDR_BLOCK1(ip6_current_dest_addr()),
        -:  307:        IP6_ADDR_BLOCK2(ip6_current_dest_addr()),
        -:  308:        IP6_ADDR_BLOCK3(ip6_current_dest_addr()),
        -:  309:        IP6_ADDR_BLOCK4(ip6_current_dest_addr()),
        -:  310:        IP6_ADDR_BLOCK5(ip6_current_dest_addr()),
        -:  311:        IP6_ADDR_BLOCK6(ip6_current_dest_addr()),
        -:  312:        IP6_ADDR_BLOCK7(ip6_current_dest_addr()),
        -:  313:        IP6_ADDR_BLOCK8(ip6_current_dest_addr())));
        -:  314:#if LWIP_ICMP6
        -:  315:    /* Don't send ICMP messages in response to ICMP messages */
        -:  316:    if (IP6H_NEXTH(iphdr) != IP6_NEXTH_ICMP6) {
        -:  317:      icmp6_dest_unreach(p, ICMP6_DUR_NO_ROUTE);
        -:  318:    }
        -:  319:#endif /* LWIP_ICMP6 */
        -:  320:    IP6_STATS_INC(ip6.rterr);
        -:  321:    IP6_STATS_INC(ip6.drop);
        -:  322:    return;
        -:  323:  }
        -:  324:  /* Do not forward packets onto the same network interface on which
        -:  325:   * they arrived. */
        -:  326:  if (netif == inp) {
        -:  327:    LWIP_DEBUGF(IP6_DEBUG, ("ip6_forward: not bouncing packets back on incoming interface.\n"));
        -:  328:    IP6_STATS_INC(ip6.rterr);
        -:  329:    IP6_STATS_INC(ip6.drop);
        -:  330:    return;
        -:  331:  }
        -:  332:
        -:  333:  /* decrement HL */
        -:  334:  IP6H_HOPLIM_SET(iphdr, IP6H_HOPLIM(iphdr) - 1);
        -:  335:  /* send ICMP6 if HL == 0 */
        -:  336:  if (IP6H_HOPLIM(iphdr) == 0) {
        -:  337:#if LWIP_ICMP6
        -:  338:    /* Don't send ICMP messages in response to ICMP messages */
        -:  339:    if (IP6H_NEXTH(iphdr) != IP6_NEXTH_ICMP6) {
        -:  340:      icmp6_time_exceeded(p, ICMP6_TE_HL);
        -:  341:    }
        -:  342:#endif /* LWIP_ICMP6 */
        -:  343:    IP6_STATS_INC(ip6.drop);
        -:  344:    return;
        -:  345:  }
        -:  346:
        -:  347:  if (netif->mtu && (p->tot_len > netif->mtu)) {
        -:  348:#if LWIP_ICMP6
        -:  349:    /* Don't send ICMP messages in response to ICMP messages */
        -:  350:    if (IP6H_NEXTH(iphdr) != IP6_NEXTH_ICMP6) {
        -:  351:      icmp6_packet_too_big(p, netif->mtu);
        -:  352:    }
        -:  353:#endif /* LWIP_ICMP6 */
        -:  354:    IP6_STATS_INC(ip6.drop);
        -:  355:    return;
        -:  356:  }
        -:  357:
        -:  358:  LWIP_DEBUGF(IP6_DEBUG, ("ip6_forward: forwarding packet to %"X16_F":%"X16_F":%"X16_F":%"X16_F":%"X16_F":%"X16_F":%"X16_F":%"X16_F"\n",
        -:  359:      IP6_ADDR_BLOCK1(ip6_current_dest_addr()),
        -:  360:      IP6_ADDR_BLOCK2(ip6_current_dest_addr()),
        -:  361:      IP6_ADDR_BLOCK3(ip6_current_dest_addr()),
        -:  362:      IP6_ADDR_BLOCK4(ip6_current_dest_addr()),
        -:  363:      IP6_ADDR_BLOCK5(ip6_current_dest_addr()),
        -:  364:      IP6_ADDR_BLOCK6(ip6_current_dest_addr()),
        -:  365:      IP6_ADDR_BLOCK7(ip6_current_dest_addr()),
        -:  366:      IP6_ADDR_BLOCK8(ip6_current_dest_addr())));
        -:  367:
        -:  368:  /* transmit pbuf on chosen interface */
        -:  369:  netif->output_ip6(netif, p, ip6_current_dest_addr());
        -:  370:  IP6_STATS_INC(ip6.fw);
        -:  371:  IP6_STATS_INC(ip6.xmit);
        -:  372:  return;
        -:  373:}
        -:  374:#endif /* LWIP_IPV6_FORWARD */
        -:  375:
        -:  376:/**
        -:  377: * This function is called by the network interface device driver when
        -:  378: * an IPv6 packet is received. The function does the basic checks of the
        -:  379: * IP header such as packet size being at least larger than the header
        -:  380: * size etc. If the packet was not destined for us, the packet is
        -:  381: * forwarded (using ip6_forward).
        -:  382: *
        -:  383: * Finally, the packet is sent to the upper layer protocol input function.
        -:  384: *
        -:  385: * @param p the received IPv6 packet (p->payload points to IPv6 header)
        -:  386: * @param inp the netif on which this packet was received
        -:  387: * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
        -:  388: *         processed, but currently always returns ERR_OK)
        -:  389: */
        -:  390:err_t
    #####:  391:ip6_input(struct pbuf *p, struct netif *inp)
        -:  392:{
        -:  393:  struct ip6_hdr *ip6hdr;
        -:  394:  struct netif *netif;
        -:  395:  u8_t nexth;
        -:  396:  u16_t hlen; /* the current header length */
        -:  397:  u8_t i;
        -:  398:#if 0 /*IP_ACCEPT_LINK_LAYER_ADDRESSING*/
        -:  399:  @todo
        -:  400:  int check_ip_src=1;
        -:  401:#endif /* IP_ACCEPT_LINK_LAYER_ADDRESSING */
        -:  402:
        -:  403:  IP6_STATS_INC(ip6.recv);
        -:  404:
        -:  405:  /* identify the IP header */
    #####:  406:  ip6hdr = (struct ip6_hdr *)p->payload;
    #####:  407:  if (IP6H_V(ip6hdr) != 6) {
        -:  408:    LWIP_DEBUGF(IP6_DEBUG | LWIP_DBG_LEVEL_WARNING, ("IPv6 packet dropped due to bad version number %"U32_F"\n",
        -:  409:        IP6H_V(ip6hdr)));
    #####:  410:    pbuf_free(p);
        -:  411:    IP6_STATS_INC(ip6.err);
        -:  412:    IP6_STATS_INC(ip6.drop);
    #####:  413:    return ERR_OK;
        -:  414:  }
        -:  415:
        -:  416:#ifdef LWIP_HOOK_IP6_INPUT
        -:  417:  if (LWIP_HOOK_IP6_INPUT(p, inp)) {
        -:  418:    /* the packet has been eaten */
        -:  419:    return ERR_OK;
        -:  420:  }
        -:  421:#endif
        -:  422:
        -:  423:  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
    #####:  424:  if ((IP6_HLEN > p->len) || ((IP6H_PLEN(ip6hdr) + IP6_HLEN) > p->tot_len)) {
    #####:  425:    if (IP6_HLEN > p->len) {
        -:  426:      LWIP_DEBUGF(IP6_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        -:  427:        ("IPv6 header (len %"U16_F") does not fit in first pbuf (len %"U16_F"), IP packet dropped.\n",
        -:  428:            (u16_t)IP6_HLEN, p->len));
        -:  429:    }
    #####:  430:    if ((IP6H_PLEN(ip6hdr) + IP6_HLEN) > p->tot_len) {
        -:  431:      LWIP_DEBUGF(IP6_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        -:  432:        ("IPv6 (plen %"U16_F") is longer than pbuf (len %"U16_F"), IP packet dropped.\n",
        -:  433:            (u16_t)(IP6H_PLEN(ip6hdr) + IP6_HLEN), p->tot_len));
        -:  434:    }
        -:  435:    /* free (drop) packet pbufs */
    #####:  436:    pbuf_free(p);
        -:  437:    IP6_STATS_INC(ip6.lenerr);
        -:  438:    IP6_STATS_INC(ip6.drop);
    #####:  439:    return ERR_OK;
        -:  440:  }
        -:  441:
        -:  442:  /* Trim pbuf. This should have been done at the netif layer,
        -:  443:   * but we'll do it anyway just to be sure that its done. */
    #####:  444:  pbuf_realloc(p, IP6_HLEN + IP6H_PLEN(ip6hdr));
        -:  445:
        -:  446:  /* copy IP addresses to aligned ip6_addr_t */
    #####:  447:  ip_addr_copy_from_ip6(ip_data.current_iphdr_dest, ip6hdr->dest);
    #####:  448:  ip_addr_copy_from_ip6(ip_data.current_iphdr_src, ip6hdr->src);
        -:  449:
        -:  450:  /* Don't accept virtual IPv4 mapped IPv6 addresses.
        -:  451:   * Don't accept multicast source addresses. */
    #####:  452:  if (ip6_addr_isipv4mappedipv6(ip_2_ip6(&ip_data.current_iphdr_dest)) ||
    #####:  453:     ip6_addr_isipv4mappedipv6(ip_2_ip6(&ip_data.current_iphdr_src)) ||
    #####:  454:     ip6_addr_ismulticast(ip_2_ip6(&ip_data.current_iphdr_src))) {
        -:  455:    IP6_STATS_INC(ip6.err);
        -:  456:    IP6_STATS_INC(ip6.drop);
    #####:  457:    return ERR_OK;
        -:  458:  }
        -:  459:
        -:  460:  /* current header pointer. */
    #####:  461:  ip_data.current_ip6_header = ip6hdr;
        -:  462:
        -:  463:  /* In netif, used in case we need to send ICMPv6 packets back. */
    #####:  464:  ip_data.current_netif = inp;
    #####:  465:  ip_data.current_input_netif = inp;
        -:  466:
        -:  467:  /* match packet against an interface, i.e. is this packet for us? */
    #####:  468:  if (ip6_addr_ismulticast(ip6_current_dest_addr())) {
        -:  469:    /* Always joined to multicast if-local and link-local all-nodes group. */
    #####:  470:    if (ip6_addr_isallnodes_iflocal(ip6_current_dest_addr()) ||
    #####:  471:        ip6_addr_isallnodes_linklocal(ip6_current_dest_addr())) {
    #####:  472:      netif = inp;
        -:  473:    }
        -:  474:#if LWIP_IPV6_MLD
    #####:  475:    else if (mld6_lookfor_group(inp, ip6_current_dest_addr())) {
    #####:  476:      netif = inp;
        -:  477:    }
        -:  478:#else /* LWIP_IPV6_MLD */
        -:  479:    else if (ip6_addr_issolicitednode(ip6_current_dest_addr())) {
        -:  480:      /* Filter solicited node packets when MLD is not enabled
        -:  481:       * (for Neighbor discovery). */
        -:  482:      netif = NULL;
        -:  483:      for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
        -:  484:        if (ip6_addr_isvalid(netif_ip6_addr_state(inp, i)) &&
        -:  485:            ip6_addr_cmp_solicitednode(ip6_current_dest_addr(), netif_ip6_addr(inp, i))) {
        -:  486:          netif = inp;
        -:  487:          LWIP_DEBUGF(IP6_DEBUG, ("ip6_input: solicited node packet accepted on interface %c%c\n",
        -:  488:              netif->name[0], netif->name[1]));
        -:  489:          break;
        -:  490:        }
        -:  491:      }
        -:  492:    }
        -:  493:#endif /* LWIP_IPV6_MLD */
        -:  494:    else {
    #####:  495:      netif = NULL;
        -:  496:    }
        -:  497:  } else {
        -:  498:    /* start trying with inp. if that's not acceptable, start walking the
        -:  499:       list of configured netifs.
        -:  500:       'first' is used as a boolean to mark whether we started walking the list */
    #####:  501:    int first = 1;
    #####:  502:    netif = inp;
        -:  503:    do {
        -:  504:      /* interface is up? */
    #####:  505:      if (netif_is_up(netif)) {
        -:  506:        /* unicast to this interface address? address configured? */
    #####:  507:        for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
    #####:  508:          if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i)) &&
    #####:  509:              ip6_addr_cmp(ip6_current_dest_addr(), netif_ip6_addr(netif, i))) {
        -:  510:            /* exit outer loop */
    #####:  511:            goto netif_found;
        -:  512:          }
        -:  513:        }
        -:  514:      }
    #####:  515:      if (first) {
    #####:  516:        if (ip6_addr_islinklocal(ip6_current_dest_addr())
        -:  517:#if !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF
    #####:  518:            || ip6_addr_isloopback(ip6_current_dest_addr())
        -:  519:#endif /* !LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF */
        -:  520:        ) {
        -:  521:          /* Do not match link-local addresses to other netifs. The loopback
        -:  522:           * address is to be considered link-local and packets to it should be
        -:  523:           * dropped on other interfaces, as per RFC 4291 Sec. 2.5.3. This
        -:  524:           * requirement cannot be implemented in the case that loopback
        -:  525:           * traffic is sent across a non-loopback interface, however.
        -:  526:           */
    #####:  527:          netif = NULL;
    #####:  528:          break;
        -:  529:        }
    #####:  530:        first = 0;
    #####:  531:        netif = netif_list;
        -:  532:      } else {
    #####:  533:        netif = netif->next;
        -:  534:      }
    #####:  535:      if (netif == inp) {
    #####:  536:        netif = netif->next;
        -:  537:      }
    #####:  538:    } while (netif != NULL);
    #####:  539:netif_found:
        -:  540:    LWIP_DEBUGF(IP6_DEBUG, ("ip6_input: packet accepted on interface %c%c\n",
        -:  541:        netif ? netif->name[0] : 'X', netif? netif->name[1] : 'X'));
        -:  542:  }
        -:  543:
        -:  544:  /* "::" packet source address? (used in duplicate address detection) */
    #####:  545:  if (ip6_addr_isany(ip6_current_src_addr()) &&
    #####:  546:      (!ip6_addr_issolicitednode(ip6_current_dest_addr()))) {
        -:  547:    /* packet source is not valid */
        -:  548:    /* free (drop) packet pbufs */
        -:  549:    LWIP_DEBUGF(IP6_DEBUG, ("ip6_input: packet with src ANY_ADDRESS dropped\n"));
    #####:  550:    pbuf_free(p);
        -:  551:    IP6_STATS_INC(ip6.drop);
    #####:  552:    goto ip6_input_cleanup;
        -:  553:  }
        -:  554:
        -:  555:  /* packet not for us? */
    #####:  556:  if (netif == NULL) {
        -:  557:    /* packet not for us, route or discard */
        -:  558:    LWIP_DEBUGF(IP6_DEBUG | LWIP_DBG_TRACE, ("ip6_input: packet not for us.\n"));
        -:  559:#if LWIP_IPV6_FORWARD
        -:  560:    /* non-multicast packet? */
        -:  561:    if (!ip6_addr_ismulticast(ip6_current_dest_addr())) {
        -:  562:      /* try to forward IP packet on (other) interfaces */
        -:  563:      ip6_forward(p, ip6hdr, inp);
        -:  564:    }
        -:  565:#endif /* LWIP_IPV6_FORWARD */
    #####:  566:    pbuf_free(p);
    #####:  567:    goto ip6_input_cleanup;
        -:  568:  }
        -:  569:
        -:  570:  /* current netif pointer. */
    #####:  571:  ip_data.current_netif = netif;
        -:  572:
        -:  573:  /* Save next header type. */
    #####:  574:  nexth = IP6H_NEXTH(ip6hdr);
        -:  575:
        -:  576:  /* Init header length. */
    #####:  577:  hlen = ip_data.current_ip_header_tot_len = IP6_HLEN;
        -:  578:
        -:  579:  /* Move to payload. */
    #####:  580:  pbuf_header(p, -IP6_HLEN);
        -:  581:
        -:  582:  /* Process known option extension headers, if present. */
    #####:  583:  while (nexth != IP6_NEXTH_NONE)
        -:  584:  {
    #####:  585:    switch (nexth) {
    #####:  586:    case IP6_NEXTH_HOPBYHOP:
        -:  587:      LWIP_DEBUGF(IP6_DEBUG, ("ip6_input: packet with Hop-by-Hop options header\n"));
        -:  588:      /* Get next header type. */
    #####:  589:      nexth = *((u8_t *)p->payload);
        -:  590:
        -:  591:      /* Get the header length. */
    #####:  592:      hlen = 8 * (1 + *((u8_t *)p->payload + 1));
    #####:  593:      ip_data.current_ip_header_tot_len += hlen;
        -:  594:
        -:  595:      /* Skip over this header. */
    #####:  596:      if (hlen > p->len) {
        -:  597:        LWIP_DEBUGF(IP6_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        -:  598:          ("IPv6 options header (hlen %"U16_F") does not fit in first pbuf (len %"U16_F"), IPv6 packet dropped.\n",
        -:  599:              hlen, p->len));
        -:  600:        /* free (drop) packet pbufs */
    #####:  601:        pbuf_free(p);
        -:  602:        IP6_STATS_INC(ip6.lenerr);
        -:  603:        IP6_STATS_INC(ip6.drop);
    #####:  604:        goto ip6_input_cleanup;
        -:  605:      }
        -:  606:
    #####:  607:      pbuf_header(p, -(s16_t)hlen);
    #####:  608:      break;
    #####:  609:    case IP6_NEXTH_DESTOPTS:
        -:  610:      LWIP_DEBUGF(IP6_DEBUG, ("ip6_input: packet with Destination options header\n"));
        -:  611:      /* Get next header type. */
    #####:  612:      nexth = *((u8_t *)p->payload);
        -:  613:
        -:  614:      /* Get the header length. */
    #####:  615:      hlen = 8 * (1 + *((u8_t *)p->payload + 1));
    #####:  616:      ip_data.current_ip_header_tot_len += hlen;
        -:  617:
        -:  618:      /* Skip over this header. */
    #####:  619:      if (hlen > p->len) {
        -:  620:        LWIP_DEBUGF(IP6_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        -:  621:          ("IPv6 options header (hlen %"U16_F") does not fit in first pbuf (len %"U16_F"), IPv6 packet dropped.\n",
        -:  622:              hlen, p->len));
        -:  623:        /* free (drop) packet pbufs */
    #####:  624:        pbuf_free(p);
        -:  625:        IP6_STATS_INC(ip6.lenerr);
        -:  626:        IP6_STATS_INC(ip6.drop);
    #####:  627:        goto ip6_input_cleanup;
        -:  628:      }
        -:  629:
    #####:  630:      pbuf_header(p, -(s16_t)hlen);
    #####:  631:      break;
    #####:  632:    case IP6_NEXTH_ROUTING:
        -:  633:      LWIP_DEBUGF(IP6_DEBUG, ("ip6_input: packet with Routing header\n"));
        -:  634:      /* Get next header type. */
    #####:  635:      nexth = *((u8_t *)p->payload);
        -:  636:
        -:  637:      /* Get the header length. */
    #####:  638:      hlen = 8 * (1 + *((u8_t *)p->payload + 1));
    #####:  639:      ip_data.current_ip_header_tot_len += hlen;
        -:  640:
        -:  641:      /* Skip over this header. */
    #####:  642:      if (hlen > p->len) {
        -:  643:        LWIP_DEBUGF(IP6_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        -:  644:          ("IPv6 options header (hlen %"U16_F") does not fit in first pbuf (len %"U16_F"), IPv6 packet dropped.\n",
        -:  645:              hlen, p->len));
        -:  646:        /* free (drop) packet pbufs */
    #####:  647:        pbuf_free(p);
        -:  648:        IP6_STATS_INC(ip6.lenerr);
        -:  649:        IP6_STATS_INC(ip6.drop);
    #####:  650:        goto ip6_input_cleanup;
        -:  651:      }
        -:  652:
    #####:  653:      pbuf_header(p, -(s16_t)hlen);
    #####:  654:      break;
        -:  655:
    #####:  656:    case IP6_NEXTH_FRAGMENT:
        -:  657:    {
        -:  658:      struct ip6_frag_hdr *frag_hdr;
        -:  659:      LWIP_DEBUGF(IP6_DEBUG, ("ip6_input: packet with Fragment header\n"));
        -:  660:
    #####:  661:      frag_hdr = (struct ip6_frag_hdr *)p->payload;
        -:  662:
        -:  663:      /* Get next header type. */
    #####:  664:      nexth = frag_hdr->_nexth;
        -:  665:
        -:  666:      /* Fragment Header length. */
    #####:  667:      hlen = 8;
    #####:  668:      ip_data.current_ip_header_tot_len += hlen;
        -:  669:
        -:  670:      /* Make sure this header fits in current pbuf. */
    #####:  671:      if (hlen > p->len) {
        -:  672:        LWIP_DEBUGF(IP6_DEBUG | LWIP_DBG_LEVEL_SERIOUS,
        -:  673:          ("IPv6 options header (hlen %"U16_F") does not fit in first pbuf (len %"U16_F"), IPv6 packet dropped.\n",
        -:  674:              hlen, p->len));
        -:  675:        /* free (drop) packet pbufs */
    #####:  676:        pbuf_free(p);
        -:  677:        IP6_FRAG_STATS_INC(ip6_frag.lenerr);
        -:  678:        IP6_FRAG_STATS_INC(ip6_frag.drop);
    #####:  679:        goto ip6_input_cleanup;
        -:  680:      }
        -:  681:
        -:  682:      /* Offset == 0 and more_fragments == 0? */
    #####:  683:      if ((frag_hdr->_fragment_offset &
        -:  684:           PP_HTONS(IP6_FRAG_OFFSET_MASK | IP6_FRAG_MORE_FLAG)) == 0) {
        -:  685:        /* This is a 1-fragment packet, usually a packet that we have
        -:  686:         * already reassembled. Skip this header anc continue. */
    #####:  687:        pbuf_header(p, -(s16_t)hlen);
        -:  688:      } else {
        -:  689:#if LWIP_IPV6_REASS
        -:  690:
        -:  691:        /* reassemble the packet */
        -:  692:        p = ip6_reass(p);
        -:  693:        /* packet not fully reassembled yet? */
        -:  694:        if (p == NULL) {
        -:  695:          goto ip6_input_cleanup;
        -:  696:        }
        -:  697:
        -:  698:        /* Returned p point to IPv6 header.
        -:  699:         * Update all our variables and pointers and continue. */
        -:  700:        ip6hdr = (struct ip6_hdr *)p->payload;
        -:  701:        nexth = IP6H_NEXTH(ip6hdr);
        -:  702:        hlen = ip_data.current_ip_header_tot_len = IP6_HLEN;
        -:  703:        pbuf_header(p, -IP6_HLEN);
        -:  704:
        -:  705:#else /* LWIP_IPV6_REASS */
        -:  706:        /* free (drop) packet pbufs */
        -:  707:        LWIP_DEBUGF(IP6_DEBUG, ("ip6_input: packet with Fragment header dropped (with LWIP_IPV6_REASS==0)\n"));
    #####:  708:        pbuf_free(p);
        -:  709:        IP6_STATS_INC(ip6.opterr);
        -:  710:        IP6_STATS_INC(ip6.drop);
    #####:  711:        goto ip6_input_cleanup;
        -:  712:#endif /* LWIP_IPV6_REASS */
        -:  713:      }
    #####:  714:      break;
        -:  715:    }
    #####:  716:    default:
    #####:  717:      goto options_done;
        -:  718:      break;
        -:  719:    }
        -:  720:  }
    #####:  721:options_done:
        -:  722:
        -:  723:  /* p points to IPv6 header again. */
    #####:  724:  pbuf_header_force(p, (s16_t)ip_data.current_ip_header_tot_len);
        -:  725:
        -:  726:  /* send to upper layers */
        -:  727:  LWIP_DEBUGF(IP6_DEBUG, ("ip6_input: \n"));
        -:  728:  ip6_debug_print(p);
        -:  729:  LWIP_DEBUGF(IP6_DEBUG, ("ip6_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));
        -:  730:
        -:  731:#if LWIP_RAW
        -:  732:  /* raw input did not eat the packet? */
        -:  733:  if (raw_input(p, inp) == 0)
        -:  734:#endif /* LWIP_RAW */
        -:  735:  {
    #####:  736:    switch (nexth) {
    #####:  737:    case IP6_NEXTH_NONE:
    #####:  738:      pbuf_free(p);
    #####:  739:      break;
        -:  740:#if LWIP_UDP
    #####:  741:    case IP6_NEXTH_UDP:
        -:  742:#if LWIP_UDPLITE
        -:  743:    case IP6_NEXTH_UDPLITE:
        -:  744:#endif /* LWIP_UDPLITE */
        -:  745:      /* Point to payload. */
    #####:  746:      pbuf_header(p, -(s16_t)ip_data.current_ip_header_tot_len);
    #####:  747:      udp_input(p, inp);
    #####:  748:      break;
        -:  749:#endif /* LWIP_UDP */
        -:  750:#if LWIP_TCP
        -:  751:    case IP6_NEXTH_TCP:
        -:  752:      /* Point to payload. */
        -:  753:      pbuf_header(p, -(s16_t)ip_data.current_ip_header_tot_len);
        -:  754:      tcp_input(p, inp);
        -:  755:      break;
        -:  756:#endif /* LWIP_TCP */
        -:  757:#if LWIP_ICMP6
    #####:  758:    case IP6_NEXTH_ICMP6:
        -:  759:      /* Point to payload. */
    #####:  760:      pbuf_header(p, -(s16_t)ip_data.current_ip_header_tot_len);
    #####:  761:      icmp6_input(p, inp);
    #####:  762:      break;
        -:  763:#endif /* LWIP_ICMP */
    #####:  764:    default:
        -:  765:#if LWIP_ICMP6
        -:  766:      /* send ICMP parameter problem unless it was a multicast or ICMPv6 */
    #####:  767:      if ((!ip6_addr_ismulticast(ip6_current_dest_addr())) &&
    #####:  768:          (IP6H_NEXTH(ip6hdr) != IP6_NEXTH_ICMP6)) {
    #####:  769:        icmp6_param_problem(p, ICMP6_PP_HEADER, ip_data.current_ip_header_tot_len - hlen);
        -:  770:      }
        -:  771:#endif /* LWIP_ICMP */
        -:  772:      LWIP_DEBUGF(IP6_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip6_input: Unsupported transport protocol %"U16_F"\n", (u16_t)IP6H_NEXTH(ip6hdr)));
    #####:  773:      pbuf_free(p);
        -:  774:      IP6_STATS_INC(ip6.proterr);
        -:  775:      IP6_STATS_INC(ip6.drop);
    #####:  776:      break;
        -:  777:    }
        -:  778:  }
        -:  779:
    #####:  780:ip6_input_cleanup:
    #####:  781:  ip_data.current_netif = NULL;
    #####:  782:  ip_data.current_input_netif = NULL;
    #####:  783:  ip_data.current_ip6_header = NULL;
    #####:  784:  ip_data.current_ip_header_tot_len = 0;
    #####:  785:  ip6_addr_set_zero(ip6_current_src_addr());
    #####:  786:  ip6_addr_set_zero(ip6_current_dest_addr());
        -:  787:
    #####:  788:  return ERR_OK;
        -:  789:}
        -:  790:
        -:  791:
        -:  792:/**
        -:  793: * Sends an IPv6 packet on a network interface. This function constructs
        -:  794: * the IPv6 header. If the source IPv6 address is NULL, the IPv6 "ANY" address is
        -:  795: * used as source (usually during network startup). If the source IPv6 address it
        -:  796: * IP6_ADDR_ANY, the most appropriate IPv6 address of the outgoing network
        -:  797: * interface is filled in as source address. If the destination IPv6 address is
        -:  798: * LWIP_IP_HDRINCL, p is assumed to already include an IPv6 header and
        -:  799: * p->payload points to it instead of the data.
        -:  800: *
        -:  801: * @param p the packet to send (p->payload points to the data, e.g. next
        -:  802:            protocol header; if dest == LWIP_IP_HDRINCL, p already includes an
        -:  803:            IPv6 header and p->payload points to that IPv6 header)
        -:  804: * @param src the source IPv6 address to send from (if src == IP6_ADDR_ANY, an
        -:  805: *         IP address of the netif is selected and used as source address.
        -:  806: *         if src == NULL, IP6_ADDR_ANY is used as source)
        -:  807: * @param dest the destination IPv6 address to send the packet to
        -:  808: * @param hl the Hop Limit value to be set in the IPv6 header
        -:  809: * @param tc the Traffic Class value to be set in the IPv6 header
        -:  810: * @param nexth the Next Header to be set in the IPv6 header
        -:  811: * @param netif the netif on which to send this packet
        -:  812: * @return ERR_OK if the packet was sent OK
        -:  813: *         ERR_BUF if p doesn't have enough space for IPv6/LINK headers
        -:  814: *         returns errors returned by netif->output
        -:  815: */
        -:  816:err_t
    #####:  817:ip6_output_if(struct pbuf *p, const ip6_addr_t *src, const ip6_addr_t *dest,
        -:  818:             u8_t hl, u8_t tc,
        -:  819:             u8_t nexth, struct netif *netif)
        -:  820:{
    #####:  821:  const ip6_addr_t *src_used = src;
    #####:  822:  if (dest != LWIP_IP_HDRINCL) {
    #####:  823:    if (src != NULL && ip6_addr_isany(src)) {
    #####:  824:      src_used = ip_2_ip6(ip6_select_source_address(netif, dest));
    #####:  825:      if ((src_used == NULL) || ip6_addr_isany(src_used)) {
        -:  826:        /* No appropriate source address was found for this packet. */
        -:  827:        LWIP_DEBUGF(IP6_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip6_output: No suitable source address for packet.\n"));
        -:  828:        IP6_STATS_INC(ip6.rterr);
    #####:  829:        return ERR_RTE;
        -:  830:      }
        -:  831:    }
        -:  832:  }
    #####:  833:  return ip6_output_if_src(p, src_used, dest, hl, tc, nexth, netif);
        -:  834:}
        -:  835:
        -:  836:/**
        -:  837: * Same as ip6_output_if() but 'src' address is not replaced by netif address
        -:  838: * when it is 'any'.
        -:  839: */
        -:  840:err_t
    #####:  841:ip6_output_if_src(struct pbuf *p, const ip6_addr_t *src, const ip6_addr_t *dest,
        -:  842:             u8_t hl, u8_t tc,
        -:  843:             u8_t nexth, struct netif *netif)
        -:  844:{
        -:  845:  struct ip6_hdr *ip6hdr;
        -:  846:  ip6_addr_t dest_addr;
        -:  847:
    #####:  848:  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
        -:  849:
        -:  850:  /* Should the IPv6 header be generated or is it already included in p? */
    #####:  851:  if (dest != LWIP_IP_HDRINCL) {
        -:  852:    /* generate IPv6 header */
    #####:  853:    if (pbuf_header(p, IP6_HLEN)) {
        -:  854:      LWIP_DEBUGF(IP6_DEBUG | LWIP_DBG_LEVEL_SERIOUS, ("ip6_output: not enough room for IPv6 header in pbuf\n"));
        -:  855:      IP6_STATS_INC(ip6.err);
    #####:  856:      return ERR_BUF;
        -:  857:    }
        -:  858:
    #####:  859:    ip6hdr = (struct ip6_hdr *)p->payload;
    #####:  860:    LWIP_ASSERT("check that first pbuf can hold struct ip6_hdr",
        -:  861:               (p->len >= sizeof(struct ip6_hdr)));
        -:  862:
    #####:  863:    IP6H_HOPLIM_SET(ip6hdr, hl);
    #####:  864:    IP6H_NEXTH_SET(ip6hdr, nexth);
        -:  865:
        -:  866:    /* dest cannot be NULL here */
    #####:  867:    ip6_addr_copy(ip6hdr->dest, *dest);
        -:  868:
    #####:  869:    IP6H_VTCFL_SET(ip6hdr, 6, tc, 0);
    #####:  870:    IP6H_PLEN_SET(ip6hdr, p->tot_len - IP6_HLEN);
        -:  871:
    #####:  872:    if (src == NULL) {
    #####:  873:      src = IP6_ADDR_ANY6;
        -:  874:    }
        -:  875:    /* src cannot be NULL here */
    #####:  876:    ip6_addr_copy(ip6hdr->src, *src);
        -:  877:
        -:  878:  } else {
        -:  879:    /* IP header already included in p */
    #####:  880:    ip6hdr = (struct ip6_hdr *)p->payload;
    #####:  881:    ip6_addr_copy(dest_addr, ip6hdr->dest);
    #####:  882:    dest = &dest_addr;
        -:  883:  }
        -:  884:
        -:  885:  IP6_STATS_INC(ip6.xmit);
        -:  886:
        -:  887:  LWIP_DEBUGF(IP6_DEBUG, ("ip6_output_if: %c%c%"U16_F"\n", netif->name[0], netif->name[1], (u16_t)netif->num));
        -:  888:  ip6_debug_print(p);
        -:  889:
        -:  890:#if ENABLE_LOOPBACK
        -:  891:  {
        -:  892:    int i;
        -:  893:#if !LWIP_HAVE_LOOPIF
        -:  894:    if (ip6_addr_isloopback(dest)) {
        -:  895:      return netif_loop_output(netif, p);
        -:  896:    }
        -:  897:#endif /* !LWIP_HAVE_LOOPIF */
        -:  898:    for (i = 0; i < LWIP_IPV6_NUM_ADDRESSES; i++) {
        -:  899:      if (ip6_addr_isvalid(netif_ip6_addr_state(netif, i)) &&
        -:  900:          ip6_addr_cmp(dest, netif_ip6_addr(netif, i))) {
        -:  901:        /* Packet to self, enqueue it for loopback */
        -:  902:        LWIP_DEBUGF(IP6_DEBUG, ("netif_loop_output()\n"));
        -:  903:        return netif_loop_output(netif, p);
        -:  904:      }
        -:  905:    }
        -:  906:  }
        -:  907:#endif /* ENABLE_LOOPBACK */
        -:  908:#if LWIP_IPV6_FRAG
        -:  909:  /* don't fragment if interface has mtu set to 0 [loopif] */
        -:  910:  if (netif->mtu && (p->tot_len > nd6_get_destination_mtu(dest, netif))) {
        -:  911:    return ip6_frag(p, netif, dest);
        -:  912:  }
        -:  913:#endif /* LWIP_IPV6_FRAG */
        -:  914:
        -:  915:  LWIP_DEBUGF(IP6_DEBUG, ("netif->output_ip6()\n"));
    #####:  916:  return netif->output_ip6(netif, p, dest);
        -:  917:}
        -:  918:
        -:  919:/**
        -:  920: * Simple interface to ip6_output_if. It finds the outgoing network
        -:  921: * interface and calls upon ip6_output_if to do the actual work.
        -:  922: *
        -:  923: * @param p the packet to send (p->payload points to the data, e.g. next
        -:  924:            protocol header; if dest == LWIP_IP_HDRINCL, p already includes an
        -:  925:            IPv6 header and p->payload points to that IPv6 header)
        -:  926: * @param src the source IPv6 address to send from (if src == IP6_ADDR_ANY, an
        -:  927: *         IP address of the netif is selected and used as source address.
        -:  928: *         if src == NULL, IP6_ADDR_ANY is used as source)
        -:  929: * @param dest the destination IPv6 address to send the packet to
        -:  930: * @param hl the Hop Limit value to be set in the IPv6 header
        -:  931: * @param tc the Traffic Class value to be set in the IPv6 header
        -:  932: * @param nexth the Next Header to be set in the IPv6 header
        -:  933: *
        -:  934: * @return ERR_RTE if no route is found
        -:  935: *         see ip_output_if() for more return values
        -:  936: */
        -:  937:err_t
    #####:  938:ip6_output(struct pbuf *p, const ip6_addr_t *src, const ip6_addr_t *dest,
        -:  939:          u8_t hl, u8_t tc, u8_t nexth)
        -:  940:{
        -:  941:  struct netif *netif;
        -:  942:  struct ip6_hdr *ip6hdr;
        -:  943:  ip6_addr_t src_addr, dest_addr;
        -:  944:
    #####:  945:  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
        -:  946:
    #####:  947:  if (dest != LWIP_IP_HDRINCL) {
    #####:  948:    netif = ip6_route(src, dest);
        -:  949:  } else {
        -:  950:    /* IP header included in p, read addresses. */
    #####:  951:    ip6hdr = (struct ip6_hdr *)p->payload;
    #####:  952:    ip6_addr_copy(src_addr, ip6hdr->src);
    #####:  953:    ip6_addr_copy(dest_addr, ip6hdr->dest);
    #####:  954:    netif = ip6_route(&src_addr, &dest_addr);
        -:  955:  }
        -:  956:
    #####:  957:  if (netif == NULL) {
        -:  958:    LWIP_DEBUGF(IP6_DEBUG, ("ip6_output: no route for %"X16_F":%"X16_F":%"X16_F":%"X16_F":%"X16_F":%"X16_F":%"X16_F":%"X16_F"\n",
        -:  959:        IP6_ADDR_BLOCK1(dest),
        -:  960:        IP6_ADDR_BLOCK2(dest),
        -:  961:        IP6_ADDR_BLOCK3(dest),
        -:  962:        IP6_ADDR_BLOCK4(dest),
        -:  963:        IP6_ADDR_BLOCK5(dest),
        -:  964:        IP6_ADDR_BLOCK6(dest),
        -:  965:        IP6_ADDR_BLOCK7(dest),
        -:  966:        IP6_ADDR_BLOCK8(dest)));
        -:  967:    IP6_STATS_INC(ip6.rterr);
    #####:  968:    return ERR_RTE;
        -:  969:  }
        -:  970:
    #####:  971:  return ip6_output_if(p, src, dest, hl, tc, nexth, netif);
        -:  972:}
        -:  973:
        -:  974:
        -:  975:#if LWIP_NETIF_HWADDRHINT
        -:  976:/** Like ip6_output, but takes and addr_hint pointer that is passed on to netif->addr_hint
        -:  977: *  before calling ip6_output_if.
        -:  978: *
        -:  979: * @param p the packet to send (p->payload points to the data, e.g. next
        -:  980:            protocol header; if dest == LWIP_IP_HDRINCL, p already includes an
        -:  981:            IPv6 header and p->payload points to that IPv6 header)
        -:  982: * @param src the source IPv6 address to send from (if src == IP6_ADDR_ANY, an
        -:  983: *         IP address of the netif is selected and used as source address.
        -:  984: *         if src == NULL, IP6_ADDR_ANY is used as source)
        -:  985: * @param dest the destination IPv6 address to send the packet to
        -:  986: * @param hl the Hop Limit value to be set in the IPv6 header
        -:  987: * @param tc the Traffic Class value to be set in the IPv6 header
        -:  988: * @param nexth the Next Header to be set in the IPv6 header
        -:  989: * @param addr_hint address hint pointer set to netif->addr_hint before
        -:  990: *        calling ip_output_if()
        -:  991: *
        -:  992: * @return ERR_RTE if no route is found
        -:  993: *         see ip_output_if() for more return values
        -:  994: */
        -:  995:err_t
        -:  996:ip6_output_hinted(struct pbuf *p, const ip6_addr_t *src, const ip6_addr_t *dest,
        -:  997:          u8_t hl, u8_t tc, u8_t nexth, u8_t *addr_hint)
        -:  998:{
        -:  999:  struct netif *netif;
        -: 1000:  struct ip6_hdr *ip6hdr;
        -: 1001:  ip6_addr_t src_addr, dest_addr;
        -: 1002:  err_t err;
        -: 1003:
        -: 1004:  LWIP_IP_CHECK_PBUF_REF_COUNT_FOR_TX(p);
        -: 1005:
        -: 1006:  if (dest != LWIP_IP_HDRINCL) {
        -: 1007:    netif = ip6_route(src, dest);
        -: 1008:  } else {
        -: 1009:    /* IP header included in p, read addresses. */
        -: 1010:    ip6hdr = (struct ip6_hdr *)p->payload;
        -: 1011:    ip6_addr_copy(src_addr, ip6hdr->src);
        -: 1012:    ip6_addr_copy(dest_addr, ip6hdr->dest);
        -: 1013:    netif = ip6_route(&src_addr, &dest_addr);
        -: 1014:  }
        -: 1015:
        -: 1016:  if (netif == NULL) {
        -: 1017:    LWIP_DEBUGF(IP6_DEBUG, ("ip6_output: no route for %"X16_F":%"X16_F":%"X16_F":%"X16_F":%"X16_F":%"X16_F":%"X16_F":%"X16_F"\n",
        -: 1018:        IP6_ADDR_BLOCK1(dest),
        -: 1019:        IP6_ADDR_BLOCK2(dest),
        -: 1020:        IP6_ADDR_BLOCK3(dest),
        -: 1021:        IP6_ADDR_BLOCK4(dest),
        -: 1022:        IP6_ADDR_BLOCK5(dest),
        -: 1023:        IP6_ADDR_BLOCK6(dest),
        -: 1024:        IP6_ADDR_BLOCK7(dest),
        -: 1025:        IP6_ADDR_BLOCK8(dest)));
        -: 1026:    IP6_STATS_INC(ip6.rterr);
        -: 1027:    return ERR_RTE;
        -: 1028:  }
        -: 1029:
        -: 1030:  NETIF_SET_HWADDRHINT(netif, addr_hint);
        -: 1031:  err = ip6_output_if(p, src, dest, hl, tc, nexth, netif);
        -: 1032:  NETIF_SET_HWADDRHINT(netif, NULL);
        -: 1033:
        -: 1034:  return err;
        -: 1035:}
        -: 1036:#endif /* LWIP_NETIF_HWADDRHINT*/
        -: 1037:
        -: 1038:#if LWIP_IPV6_MLD
        -: 1039:/**
        -: 1040: * Add a hop-by-hop options header with a router alert option and padding.
        -: 1041: *
        -: 1042: * Used by MLD when sending a Multicast listener report/done message.
        -: 1043: *
        -: 1044: * @param p the packet to which we will prepend the options header
        -: 1045: * @param nexth the next header protocol number (e.g. IP6_NEXTH_ICMP6)
        -: 1046: * @param value the value of the router alert option data (e.g. IP6_ROUTER_ALERT_VALUE_MLD)
        -: 1047: * @return ERR_OK if hop-by-hop header was added, ERR_* otherwise
        -: 1048: */
        -: 1049:err_t
    #####: 1050:ip6_options_add_hbh_ra(struct pbuf *p, u8_t nexth, u8_t value)
        -: 1051:{
        -: 1052:  struct ip6_hbh_hdr *hbh_hdr;
        -: 1053:
        -: 1054:  /* Move pointer to make room for hop-by-hop options header. */
    #####: 1055:  if (pbuf_header(p, sizeof(struct ip6_hbh_hdr))) {
        -: 1056:    LWIP_DEBUGF(IP6_DEBUG, ("ip6_options: no space for options header\n"));
        -: 1057:    IP6_STATS_INC(ip6.err);
    #####: 1058:    return ERR_BUF;
        -: 1059:  }
        -: 1060:
    #####: 1061:  hbh_hdr = (struct ip6_hbh_hdr *)p->payload;
        -: 1062:
        -: 1063:  /* Set fields. */
    #####: 1064:  hbh_hdr->_nexth = nexth;
    #####: 1065:  hbh_hdr->_hlen = 0;
    #####: 1066:  hbh_hdr->_ra_opt_type = IP6_ROUTER_ALERT_OPTION;
    #####: 1067:  hbh_hdr->_ra_opt_dlen = 2;
    #####: 1068:  hbh_hdr->_ra_opt_data = value;
    #####: 1069:  hbh_hdr->_padn_opt_type = IP6_PADN_ALERT_OPTION;
    #####: 1070:  hbh_hdr->_padn_opt_dlen = 0;
        -: 1071:
    #####: 1072:  return ERR_OK;
        -: 1073:}
        -: 1074:#endif /* LWIP_IPV6_MLD */
        -: 1075:
        -: 1076:#if IP6_DEBUG
        -: 1077:/* Print an IPv6 header by using LWIP_DEBUGF
        -: 1078: * @param p an IPv6 packet, p->payload pointing to the IPv6 header
        -: 1079: */
        -: 1080:void
        -: 1081:ip6_debug_print(struct pbuf *p)
        -: 1082:{
        -: 1083:  struct ip6_hdr *ip6hdr = (struct ip6_hdr *)p->payload;
        -: 1084:
        -: 1085:  LWIP_DEBUGF(IP6_DEBUG, ("IPv6 header:\n"));
        -: 1086:  LWIP_DEBUGF(IP6_DEBUG, ("+-------------------------------+\n"));
        -: 1087:  LWIP_DEBUGF(IP6_DEBUG, ("| %2"U16_F" |  %3"U16_F"  |      %7"U32_F"     | (ver, class, flow)\n",
        -: 1088:                    IP6H_V(ip6hdr),
        -: 1089:                    IP6H_TC(ip6hdr),
        -: 1090:                    IP6H_FL(ip6hdr)));
        -: 1091:  LWIP_DEBUGF(IP6_DEBUG, ("+-------------------------------+\n"));
        -: 1092:  LWIP_DEBUGF(IP6_DEBUG, ("|     %5"U16_F"     |  %3"U16_F"  |  %3"U16_F"  | (plen, nexth, hopl)\n",
        -: 1093:                    IP6H_PLEN(ip6hdr),
        -: 1094:                    IP6H_NEXTH(ip6hdr),
        -: 1095:                    IP6H_HOPLIM(ip6hdr)));
        -: 1096:  LWIP_DEBUGF(IP6_DEBUG, ("+-------------------------------+\n"));
        -: 1097:  LWIP_DEBUGF(IP6_DEBUG, ("|  %4"X32_F" |  %4"X32_F" |  %4"X32_F" |  %4"X32_F" | (src)\n",
        -: 1098:                    IP6_ADDR_BLOCK1(&(ip6hdr->src)),
        -: 1099:                    IP6_ADDR_BLOCK2(&(ip6hdr->src)),
        -: 1100:                    IP6_ADDR_BLOCK3(&(ip6hdr->src)),
        -: 1101:                    IP6_ADDR_BLOCK4(&(ip6hdr->src))));
        -: 1102:  LWIP_DEBUGF(IP6_DEBUG, ("|  %4"X32_F" |  %4"X32_F" |  %4"X32_F" |  %4"X32_F" |\n",
        -: 1103:                    IP6_ADDR_BLOCK5(&(ip6hdr->src)),
        -: 1104:                    IP6_ADDR_BLOCK6(&(ip6hdr->src)),
        -: 1105:                    IP6_ADDR_BLOCK7(&(ip6hdr->src)),
        -: 1106:                    IP6_ADDR_BLOCK8(&(ip6hdr->src))));
        -: 1107:  LWIP_DEBUGF(IP6_DEBUG, ("+-------------------------------+\n"));
        -: 1108:  LWIP_DEBUGF(IP6_DEBUG, ("|  %4"X32_F" |  %4"X32_F" |  %4"X32_F" |  %4"X32_F" | (dest)\n",
        -: 1109:                    IP6_ADDR_BLOCK1(&(ip6hdr->dest)),
        -: 1110:                    IP6_ADDR_BLOCK2(&(ip6hdr->dest)),
        -: 1111:                    IP6_ADDR_BLOCK3(&(ip6hdr->dest)),
        -: 1112:                    IP6_ADDR_BLOCK4(&(ip6hdr->dest))));
        -: 1113:  LWIP_DEBUGF(IP6_DEBUG, ("|  %4"X32_F" |  %4"X32_F" |  %4"X32_F" |  %4"X32_F" |\n",
        -: 1114:                    IP6_ADDR_BLOCK5(&(ip6hdr->dest)),
        -: 1115:                    IP6_ADDR_BLOCK6(&(ip6hdr->dest)),
        -: 1116:                    IP6_ADDR_BLOCK7(&(ip6hdr->dest)),
        -: 1117:                    IP6_ADDR_BLOCK8(&(ip6hdr->dest))));
        -: 1118:  LWIP_DEBUGF(IP6_DEBUG, ("+-------------------------------+\n"));
        -: 1119:}
        -: 1120:#endif /* IP6_DEBUG */
        -: 1121:
        -: 1122:#endif /* LWIP_IPV6 */
