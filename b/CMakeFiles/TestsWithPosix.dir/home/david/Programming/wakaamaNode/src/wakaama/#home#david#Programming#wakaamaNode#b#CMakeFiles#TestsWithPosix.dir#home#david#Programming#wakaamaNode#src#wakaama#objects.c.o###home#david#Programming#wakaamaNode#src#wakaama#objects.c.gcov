        -:    0:Source:/home/david/Programming/wakaamaNode/src/wakaama/objects.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/wakaama/objects.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*******************************************************************************
        -:    2: *
        -:    3: * Copyright (c) 2013, 2014 Intel Corporation and others.
        -:    4: * All rights reserved. This program and the accompanying materials
        -:    5: * are made available under the terms of the Eclipse Public License v1.0
        -:    6: * and Eclipse Distribution License v1.0 which accompany this distribution.
        -:    7: *
        -:    8: * The Eclipse Public License is available at
        -:    9: *    http://www.eclipse.org/legal/epl-v10.html
        -:   10: * The Eclipse Distribution License is available at
        -:   11: *    http://www.eclipse.org/org/documents/edl-v10.php.
        -:   12: *
        -:   13: * Contributors:
        -:   14: *    David Navarro, Intel Corporation - initial API and implementation
        -:   15: *    Fabien Fleutot - Please refer to git log
        -:   16: *    Toby Jaffey - Please refer to git log
        -:   17: *    Benjamin CabeÃÅ - Please refer to git log
        -:   18: *    Bosch Software Innovations GmbH - Please refer to git log
        -:   19: *    Pascal Rieux - Please refer to git log
        -:   20: *    Scott Bertin - Please refer to git log
        -:   21: *
        -:   22: *******************************************************************************/
        -:   23:
        -:   24:/*
        -:   25: Copyright (c) 2013, 2014 Intel Corporation
        -:   26:
        -:   27: Redistribution and use in source and binary forms, with or without modification,
        -:   28: are permitted provided that the following conditions are met:
        -:   29:
        -:   30:     * Redistributions of source code must retain the above copyright notice,
        -:   31:       this list of conditions and the following disclaimer.
        -:   32:     * Redistributions in binary form must reproduce the above copyright notice,
        -:   33:       this list of conditions and the following disclaimer in the documentation
        -:   34:       and/or other materials provided with the distribution.
        -:   35:     * Neither the name of Intel Corporation nor the names of its contributors
        -:   36:       may be used to endorse or promote products derived from this software
        -:   37:       without specific prior written permission.
        -:   38:
        -:   39: THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   40: ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   41: WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
        -:   42: IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
        -:   43: INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
        -:   44: BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   45: DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
        -:   46: LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
        -:   47: OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
        -:   48: THE POSSIBILITY OF SUCH DAMAGE.
        -:   49:
        -:   50: David Navarro <david.navarro@intel.com>
        -:   51:
        -:   52:*/
        -:   53:#include "internals.h"
        -:   54:
        -:   55:#ifdef LWM2M_CLIENT_MODE
        -:   56:
        -:   57:
        -:   58:#include <stdlib.h>
        -:   59:#include <string.h>
        -:   60:#include <stdio.h>
        -:   61:
        -:   62:
    #####:   63:uint8_t object_checkReadable(lwm2m_context_t * contextP,
        -:   64:                             lwm2m_uri_t * uriP,
        -:   65:                             lwm2m_attributes_t * attrP)
        -:   66:{
        -:   67:    uint8_t result;
        -:   68:    lwm2m_object_t * targetP;
    #####:   69:    lwm2m_data_t * dataP = NULL;
        -:   70:    int size;
        -:   71:
        -:   72:    LOG_URI(uriP);
    #####:   73:    targetP = (lwm2m_object_t *)LWM2M_LIST_FIND(contextP->objectList, uriP->objectId);
    #####:   74:    if (NULL == targetP) return COAP_404_NOT_FOUND;
    #####:   75:    if (NULL == targetP->readFunc) return COAP_405_METHOD_NOT_ALLOWED;
        -:   76:
    #####:   77:    if (!LWM2M_URI_IS_SET_INSTANCE(uriP)) return COAP_205_CONTENT;
        -:   78:
    #####:   79:    if (NULL == LWM2M_LIST_FIND(targetP->instanceList, uriP->instanceId)) return COAP_404_NOT_FOUND;
        -:   80:
    #####:   81:    if (!LWM2M_URI_IS_SET_RESOURCE(uriP)) return COAP_205_CONTENT;
        -:   82:
    #####:   83:    size = 1;
    #####:   84:    dataP = lwm2m_data_new(1);
    #####:   85:    if (dataP == NULL) return COAP_500_INTERNAL_SERVER_ERROR;
        -:   86:
    #####:   87:    dataP->id = uriP->resourceId;
        -:   88:
    #####:   89:    result = targetP->readFunc(uriP->instanceId, &size, &dataP, targetP, contextP);
    #####:   90:    if (result == COAP_205_CONTENT)
        -:   91:    {
    #####:   92:        if (attrP->toSet & ATTR_FLAG_NUMERIC)
        -:   93:        {
    #####:   94:            switch (dataP->type)
        -:   95:            {
    #####:   96:                case LWM2M_TYPE_INTEGER:
        -:   97:                case LWM2M_TYPE_FLOAT:
    #####:   98:                    break;
    #####:   99:                default:
    #####:  100:                    result = COAP_405_METHOD_NOT_ALLOWED;
        -:  101:            }
    #####:  102:        }
        -:  103:    }
    #####:  104:    lwm2m_data_free(1, dataP);
    #####:  105:    return result;
        -:  106:}
        -:  107:
    #####:  108:uint8_t object_readData(lwm2m_context_t * contextP,
        -:  109:                        lwm2m_uri_t * uriP,
        -:  110:                        int * sizeP,
        -:  111:                        lwm2m_data_t ** dataP)
        -:  112:{
        -:  113:    uint8_t result;
        -:  114:    lwm2m_object_t * targetP;
        -:  115:
        -:  116:    LOG_URI(uriP);
    #####:  117:    targetP = (lwm2m_object_t *)LWM2M_LIST_FIND(contextP->objectList, uriP->objectId);
    #####:  118:    if (NULL == targetP) return COAP_404_NOT_FOUND;
    #####:  119:    if (NULL == targetP->readFunc) return COAP_405_METHOD_NOT_ALLOWED;
        -:  120:
    #####:  121:    if (LWM2M_URI_IS_SET_INSTANCE(uriP))
        -:  122:    {
    #####:  123:        if (NULL == lwm2m_list_find(targetP->instanceList, uriP->instanceId)) return COAP_404_NOT_FOUND;
        -:  124:
        -:  125:        // single instance read
    #####:  126:        if (LWM2M_URI_IS_SET_RESOURCE(uriP))
        -:  127:        {
    #####:  128:            *sizeP = 1;
    #####:  129:            *dataP = lwm2m_data_new(*sizeP);
    #####:  130:            if (*dataP == NULL) return COAP_500_INTERNAL_SERVER_ERROR;
        -:  131:
    #####:  132:            (*dataP)->id = uriP->resourceId;
        -:  133:        }
        -:  134:
    #####:  135:        result = targetP->readFunc(uriP->instanceId, sizeP, dataP, targetP, contextP);
        -:  136:    }
        -:  137:    else
        -:  138:    {
        -:  139:        // multiple object instances read
        -:  140:        lwm2m_list_t * instanceP;
        -:  141:        int i;
        -:  142:
    #####:  143:        result = COAP_205_CONTENT;
        -:  144:
    #####:  145:        *sizeP = 0;
    #####:  146:        for (instanceP = targetP->instanceList; instanceP != NULL ; instanceP = instanceP->next)
        -:  147:        {
    #####:  148:            (*sizeP)++;
        -:  149:        }
        -:  150:
    #####:  151:        if (*sizeP == 0)
        -:  152:        {
    #####:  153:            *dataP = NULL;
        -:  154:        }
        -:  155:        else
        -:  156:        {
    #####:  157:            *dataP = lwm2m_data_new(*sizeP);
    #####:  158:            if (*dataP == NULL) return COAP_500_INTERNAL_SERVER_ERROR;
        -:  159:
    #####:  160:            instanceP = targetP->instanceList;
    #####:  161:            i = 0;
    #####:  162:            while (instanceP != NULL && result == COAP_205_CONTENT)
        -:  163:            {
    #####:  164:                result = targetP->readFunc(instanceP->id, (int*)&((*dataP)[i].value.asChildren.count), &((*dataP)[i].value.asChildren.array), targetP,contextP);
    #####:  165:                (*dataP)[i].type = LWM2M_TYPE_OBJECT_INSTANCE;
    #####:  166:                (*dataP)[i].id = instanceP->id;
    #####:  167:                i++;
    #####:  168:                instanceP = instanceP->next;
        -:  169:            }
        -:  170:        }
        -:  171:    }
        -:  172:
        -:  173:    LOG_ARG("result: %u.%2u, size: %d", (result & 0xFF) >> 5, (result & 0x1F), *sizeP);
    #####:  174:    return result;
        -:  175:}
        -:  176:
    #####:  177:uint8_t object_read(lwm2m_context_t * contextP,
        -:  178:                    lwm2m_uri_t * uriP,
        -:  179:                    lwm2m_media_type_t * formatP,
        -:  180:                    uint8_t ** bufferP,
        -:  181:                    size_t * lengthP)
        -:  182:{
        -:  183:    uint8_t result;
    #####:  184:    lwm2m_data_t * dataP = NULL;
    #####:  185:    int size = 0;
        -:  186:    int res;
        -:  187:
        -:  188:    LOG_URI(uriP);
    #####:  189:    result = object_readData(contextP, uriP, &size, &dataP);
        -:  190:
    #####:  191:    if (result == COAP_205_CONTENT)
        -:  192:    {
    #####:  193:        res = lwm2m_data_serialize(uriP, size, dataP, formatP, bufferP);
    #####:  194:        if (res < 0)
        -:  195:        {
    #####:  196:            result = COAP_500_INTERNAL_SERVER_ERROR;
        -:  197:        }
        -:  198:        else
        -:  199:        {
    #####:  200:            *lengthP = (size_t)res;
        -:  201:        }
        -:  202:    }
    #####:  203:    lwm2m_data_free(size, dataP);
        -:  204:
        -:  205:    LOG_ARG("result: %u.%2u, length: %d", (result & 0xFF) >> 5, (result & 0x1F), *lengthP);
        -:  206:
    #####:  207:    return result;
        -:  208:}
        -:  209:
    #####:  210:uint8_t object_write(lwm2m_context_t * contextP,
        -:  211:                     lwm2m_uri_t * uriP,
        -:  212:                     lwm2m_media_type_t format,
        -:  213:                     uint8_t * buffer,
        -:  214:                     size_t length)
        -:  215:{
    #####:  216:    uint8_t result = NO_ERROR;
        -:  217:    lwm2m_object_t * targetP;
    #####:  218:    lwm2m_data_t * dataP = NULL;
    #####:  219:    int size = 0;
        -:  220:
        -:  221:    LOG_URI(uriP);
    #####:  222:    targetP = (lwm2m_object_t *)LWM2M_LIST_FIND(contextP->objectList, uriP->objectId);
    #####:  223:    if (NULL == targetP)
        -:  224:    {
    #####:  225:        result = COAP_404_NOT_FOUND;
        -:  226:    }
    #####:  227:    else if (NULL == targetP->writeFunc)
        -:  228:    {
    #####:  229:        result = COAP_405_METHOD_NOT_ALLOWED;
        -:  230:    }
        -:  231:    else
        -:  232:    {
    #####:  233:        size = lwm2m_data_parse(uriP, buffer, length, format, &dataP);
    #####:  234:        if (size == 0)
        -:  235:        {
    #####:  236:            result = COAP_406_NOT_ACCEPTABLE;
        -:  237:        }
        -:  238:    }
    #####:  239:    if (result == NO_ERROR)
        -:  240:    {
    #####:  241:        result = targetP->writeFunc(uriP->instanceId, size, dataP, targetP, contextP);
    #####:  242:        lwm2m_data_free(size, dataP);
        -:  243:    }
        -:  244:
        -:  245:    LOG_ARG("result: %u.%2u", (result & 0xFF) >> 5, (result & 0x1F));
        -:  246:
    #####:  247:    return result;
        -:  248:}
        -:  249:
    #####:  250:uint8_t object_execute(lwm2m_context_t * contextP,
        -:  251:                       lwm2m_uri_t * uriP,
        -:  252:                       uint8_t * buffer,
        -:  253:                       size_t length)
        -:  254:{
        -:  255:    lwm2m_object_t * targetP;
        -:  256:
        -:  257:    LOG_URI(uriP);
    #####:  258:    targetP = (lwm2m_object_t *)LWM2M_LIST_FIND(contextP->objectList, uriP->objectId);
    #####:  259:    if (NULL == targetP) return COAP_404_NOT_FOUND;
    #####:  260:    if (NULL == targetP->executeFunc) return COAP_405_METHOD_NOT_ALLOWED;
    #####:  261:    if (NULL == lwm2m_list_find(targetP->instanceList, uriP->instanceId)) return COAP_404_NOT_FOUND;
        -:  262:
    #####:  263:    return targetP->executeFunc(uriP->instanceId, uriP->resourceId, contextP, targetP);
        -:  264:}
        -:  265:
    #####:  266:uint8_t object_create(lwm2m_context_t * contextP,
        -:  267:                      lwm2m_uri_t * uriP,
        -:  268:                      lwm2m_media_type_t format,
        -:  269:                      uint8_t * buffer,
        -:  270:                      size_t length)
        -:  271:{
        -:  272:    lwm2m_object_t * targetP;
    #####:  273:    lwm2m_data_t * dataP = NULL;
    #####:  274:    int size = 0;
        -:  275:    uint8_t result;
        -:  276:
        -:  277:    LOG_URI(uriP);
        -:  278:
    #####:  279:    if (length == 0 || buffer == 0)
        -:  280:    {
    #####:  281:        return COAP_400_BAD_REQUEST;
        -:  282:    }
        -:  283:
    #####:  284:    targetP = (lwm2m_object_t *)LWM2M_LIST_FIND(contextP->objectList, uriP->objectId);
    #####:  285:    if (NULL == targetP) return COAP_404_NOT_FOUND;
    #####:  286:    if (NULL == targetP->createFunc) return COAP_405_METHOD_NOT_ALLOWED;
        -:  287:
    #####:  288:    size = lwm2m_data_parse(uriP, buffer, length, format, &dataP);
    #####:  289:    if (size <= 0) return COAP_400_BAD_REQUEST;
        -:  290:
    #####:  291:    switch (dataP[0].type)
        -:  292:    {
    #####:  293:    case LWM2M_TYPE_OBJECT:
    #####:  294:        result = COAP_400_BAD_REQUEST;
    #####:  295:        goto exit;
        -:  296:
    #####:  297:    case LWM2M_TYPE_OBJECT_INSTANCE:
    #####:  298:        if (size != 1)
        -:  299:        {
    #####:  300:            result = COAP_400_BAD_REQUEST;
    #####:  301:            goto exit;
        -:  302:        }
    #####:  303:        if (NULL != lwm2m_list_find(targetP->instanceList, dataP[0].id))
        -:  304:        {
        -:  305:            // Instance already exists
    #####:  306:            result = COAP_406_NOT_ACCEPTABLE;
    #####:  307:            goto exit;
        -:  308:        }
    #####:  309:        result = targetP->createFunc(dataP[0].id, dataP[0].value.asChildren.count,
    #####:  310:                dataP[0].value.asChildren.array, targetP,contextP);
    #####:  311:        uriP->instanceId = dataP[0].id;
    #####:  312:        uriP->flag |= LWM2M_URI_FLAG_INSTANCE_ID;
    #####:  313:        break;
        -:  314:
    #####:  315:    default:
    #####:  316:        if (!LWM2M_URI_IS_SET_INSTANCE(uriP))
        -:  317:        {
    #####:  318:            uriP->instanceId = lwm2m_list_newId(targetP->instanceList);
    #####:  319:            uriP->flag |= LWM2M_URI_FLAG_INSTANCE_ID;
        -:  320:        }
    #####:  321:        result = targetP->createFunc(uriP->instanceId, size, dataP, targetP,contextP);
    #####:  322:        break;
        -:  323:    }
        -:  324:
    #####:  325:exit:
    #####:  326:    lwm2m_data_free(size, dataP);
        -:  327:
        -:  328:    LOG_ARG("result: %u.%2u", (result & 0xFF) >> 5, (result & 0x1F));
        -:  329:
    #####:  330:    return result;
        -:  331:}
        -:  332:
    #####:  333:uint8_t object_delete(lwm2m_context_t * contextP,
        -:  334:                      lwm2m_uri_t * uriP)
        -:  335:{
        -:  336:    lwm2m_object_t * objectP;
        -:  337:    uint8_t result;
        -:  338:
        -:  339:    LOG_URI(uriP);
    #####:  340:    objectP = (lwm2m_object_t *)LWM2M_LIST_FIND(contextP->objectList, uriP->objectId);
    #####:  341:    if (NULL == objectP) return COAP_404_NOT_FOUND;
    #####:  342:    if (NULL == objectP->deleteFunc) return COAP_405_METHOD_NOT_ALLOWED;
        -:  343:
    #####:  344:    if (LWM2M_URI_IS_SET_INSTANCE(uriP))
        -:  345:    {
    #####:  346:        result = objectP->deleteFunc(uriP->instanceId, objectP);
    #####:  347:        if (result == COAP_202_DELETED)
        -:  348:        {
    #####:  349:            observe_clear(contextP, uriP);
        -:  350:        }
        -:  351:    }
        -:  352:    else
        -:  353:    {
        -:  354:        lwm2m_list_t * instanceP;
        -:  355:
    #####:  356:        result = COAP_202_DELETED;
    #####:  357:        instanceP = objectP->instanceList;
    #####:  358:        while (NULL != instanceP
    #####:  359:            && result == COAP_202_DELETED)
        -:  360:        {
    #####:  361:            uriP->instanceId = instanceP->id;
    #####:  362:            result = objectP->deleteFunc(instanceP->id, objectP);
    #####:  363:            if (result == COAP_202_DELETED)
        -:  364:            {
    #####:  365:                uriP->flag |= LWM2M_URI_FLAG_INSTANCE_ID;
    #####:  366:                observe_clear(contextP, uriP);
    #####:  367:                uriP->flag &= ~LWM2M_URI_FLAG_INSTANCE_ID;
        -:  368:            }
    #####:  369:            instanceP = objectP->instanceList;
        -:  370:        }
        -:  371:    }
        -:  372:
        -:  373:    LOG_ARG("result: %u.%2u", (result & 0xFF) >> 5, (result & 0x1F));
        -:  374:
    #####:  375:    return result;
        -:  376:}
        -:  377:
    #####:  378:uint8_t object_discover(lwm2m_context_t * contextP,
        -:  379:                        lwm2m_uri_t * uriP,
        -:  380:                        lwm2m_server_t * serverP,
        -:  381:                        uint8_t ** bufferP,
        -:  382:                        size_t * lengthP)
        -:  383:{
        -:  384:    uint8_t result;
        -:  385:    lwm2m_object_t * targetP;
    #####:  386:    lwm2m_data_t * dataP = NULL;
    #####:  387:    int size = 0;
        -:  388:
        -:  389:    LOG_URI(uriP);
    #####:  390:    targetP = (lwm2m_object_t *)LWM2M_LIST_FIND(contextP->objectList, uriP->objectId);
    #####:  391:    if (NULL == targetP) return COAP_404_NOT_FOUND;
    #####:  392:    if (NULL == targetP->discoverFunc) return COAP_501_NOT_IMPLEMENTED;
        -:  393:
    #####:  394:    if (LWM2M_URI_IS_SET_INSTANCE(uriP))
        -:  395:    {
    #####:  396:        if (NULL == lwm2m_list_find(targetP->instanceList, uriP->instanceId)) return COAP_404_NOT_FOUND;
        -:  397:
        -:  398:        // single instance read
    #####:  399:        if (LWM2M_URI_IS_SET_RESOURCE(uriP))
        -:  400:        {
    #####:  401:            size = 1;
    #####:  402:            dataP = lwm2m_data_new(size);
    #####:  403:            if (dataP == NULL) return COAP_500_INTERNAL_SERVER_ERROR;
        -:  404:
    #####:  405:            dataP->id = uriP->resourceId;
        -:  406:        }
        -:  407:
    #####:  408:        result = targetP->discoverFunc(uriP->instanceId, &size, &dataP, targetP);
        -:  409:    }
        -:  410:    else
        -:  411:    {
        -:  412:        // multiple object instances read
        -:  413:        lwm2m_list_t * instanceP;
        -:  414:        int i;
        -:  415:
    #####:  416:        result = COAP_205_CONTENT;
        -:  417:
    #####:  418:        size = 0;
    #####:  419:        for (instanceP = targetP->instanceList; instanceP != NULL ; instanceP = instanceP->next)
        -:  420:        {
    #####:  421:            size++;
        -:  422:        }
        -:  423:
    #####:  424:        if (size != 0)
        -:  425:        {
    #####:  426:            dataP = lwm2m_data_new(size);
    #####:  427:            if (dataP == NULL) return COAP_500_INTERNAL_SERVER_ERROR;
        -:  428:
    #####:  429:            instanceP = targetP->instanceList;
    #####:  430:            i = 0;
    #####:  431:            while (instanceP != NULL && result == COAP_205_CONTENT)
        -:  432:            {
    #####:  433:                result = targetP->discoverFunc(instanceP->id, (int*)&(dataP[i].value.asChildren.count), &(dataP[i].value.asChildren.array), targetP);
    #####:  434:                dataP[i].type = LWM2M_TYPE_OBJECT_INSTANCE;
    #####:  435:                dataP[i].id = instanceP->id;
    #####:  436:                i++;
    #####:  437:                instanceP = instanceP->next;
        -:  438:            }
        -:  439:        }
        -:  440:    }
        -:  441:
    #####:  442:    if (result == COAP_205_CONTENT)
        -:  443:    {
        -:  444:        int len;
        -:  445:
    #####:  446:        len = discover_serialize(contextP, uriP, serverP, size, dataP, bufferP);
    #####:  447:        if (len <= 0) result = COAP_500_INTERNAL_SERVER_ERROR;
    #####:  448:        else *lengthP = len;
        -:  449:    }
    #####:  450:    lwm2m_data_free(size, dataP);
        -:  451:
        -:  452:    LOG_ARG("result: %u.%2u", (result & 0xFF) >> 5, (result & 0x1F));
        -:  453:
    #####:  454:    return result;
        -:  455:}
        -:  456:
    #####:  457:bool object_isInstanceNew(lwm2m_context_t * contextP,
        -:  458:                          uint16_t objectId,
        -:  459:                          uint16_t instanceId)
        -:  460:{
        -:  461:    lwm2m_object_t * targetP;
        -:  462:
    #####:  463:    targetP = (lwm2m_object_t *)LWM2M_LIST_FIND(contextP->objectList, objectId);
    #####:  464:    if (targetP != NULL)
        -:  465:    {
    #####:  466:        if (NULL != lwm2m_list_find(targetP->instanceList, instanceId))
        -:  467:        {
    #####:  468:            return false;
        -:  469:        }
        -:  470:    }
        -:  471:
    #####:  472:    return true;
        -:  473:}
        -:  474:
    #####:  475:static int prv_getObjectTemplate(uint8_t * buffer,
        -:  476:                                 size_t length,
        -:  477:                                 uint16_t id)
        -:  478:{
        -:  479:    int index;
        -:  480:    int result;
        -:  481:
    #####:  482:    if (length < REG_OBJECT_MIN_LEN) return -1;
        -:  483:
    #####:  484:    buffer[0] = '<';
    #####:  485:    buffer[1] = '/';
    #####:  486:    index = 2;
        -:  487:
    #####:  488:    result = utils_intToText(id, buffer + index, length - index);
    #####:  489:    if (result == 0) return -1;
    #####:  490:    index += result;
        -:  491:
    #####:  492:    if (length - index < REG_OBJECT_MIN_LEN - 3) return -1;
    #####:  493:    buffer[index] = '/';
    #####:  494:    index++;
        -:  495:
    #####:  496:    return index;
        -:  497:}
        -:  498:
    #####:  499:int object_getRegisterPayloadBufferLength(lwm2m_context_t * contextP)
        -:  500:{
        -:  501:    size_t index;
        -:  502:    int result;
        -:  503:    lwm2m_object_t * objectP;
        -:  504:    uint8_t buffer[REG_OBJECT_MIN_LEN + 5];
        -:  505:
    #####:  506:    index = strlen(REG_START);
        -:  507:
    #####:  508:    if ((contextP->altPath != NULL)
    #####:  509:     && (contextP->altPath[0] != 0))
        -:  510:    {
    #####:  511:        index += strlen(contextP->altPath);
        -:  512:    }
        -:  513:    else
        -:  514:    {
    #####:  515:        index += strlen(REG_DEFAULT_PATH);
        -:  516:    }
        -:  517:
    #####:  518:    index += strlen(REG_LWM2M_RESOURCE_TYPE);
        -:  519:
    #####:  520:    for (objectP = contextP->objectList; objectP != NULL; objectP = objectP->next)
        -:  521:    {
        -:  522:        size_t start;
        -:  523:        size_t length;
        -:  524:
    #####:  525:        if (objectP->objID == LWM2M_SECURITY_OBJECT_ID) continue;
        -:  526:
    #####:  527:        start = index;
    #####:  528:        result = prv_getObjectTemplate(buffer, sizeof(buffer), objectP->objID);
    #####:  529:        if (result < 0) return 0;
    #####:  530:        length = (size_t)result;
    #####:  531:        index += length;
        -:  532:
    #####:  533:        if (objectP->instanceList == NULL)
        -:  534:        {
    #####:  535:            index -= 1;
    #####:  536:            index += strlen(REG_PATH_END);
        -:  537:        }
        -:  538:        else
        -:  539:        {
        -:  540:            lwm2m_list_t * targetP;
    #####:  541:            for (targetP = objectP->instanceList ; targetP != NULL ; targetP = targetP->next)
        -:  542:            {
    #####:  543:                if (index != start + length)
        -:  544:                {
    #####:  545:                    index += length;
        -:  546:                }
        -:  547:
    #####:  548:                result = (int)utils_intToText(targetP->id, buffer, sizeof(buffer));
    #####:  549:                if (result == 0) return 0;
    #####:  550:                index += (size_t)result;
        -:  551:
    #####:  552:                index += strlen(REG_PATH_END);
        -:  553:            }
        -:  554:        }
        -:  555:    }
        -:  556:
    #####:  557:    index += 1;  // account for trailing null
        -:  558:
        -:  559:    // Note that object_getRegisterPayload() has REG_PATH_END added after each
        -:  560:    // object or instance, and then the trailing comma is replaced by null. The
        -:  561:    // trailing nulls are not counted as part of the payload length, so this
        -:  562:    // will return a size two bytes greater than what
        -:  563:    // object_getRegisterPayload() returns.
        -:  564:
    #####:  565:    return index;
        -:  566:}
        -:  567:
    #####:  568:int object_getRegisterPayload(lwm2m_context_t * contextP,
        -:  569:                           uint8_t * buffer,
        -:  570:                           size_t bufferLen)
        -:  571:{
        -:  572:    size_t index;
        -:  573:    int result;
        -:  574:    lwm2m_object_t * objectP;
        -:  575:
        -:  576:    // index can not be greater than bufferLen
    #####:  577:    index = 0;
        -:  578:
    #####:  579:    result = utils_stringCopy((char *)buffer, bufferLen, REG_START);
    #####:  580:    if (result < 0) return 0;
    #####:  581:    index += result;
        -:  582:
    #####:  583:    if ((contextP->altPath != NULL)
    #####:  584:     && (contextP->altPath[0] != 0))
        -:  585:    {
    #####:  586:        result = utils_stringCopy((char *)buffer + index, bufferLen - index, contextP->altPath);
        -:  587:    }
        -:  588:    else
        -:  589:    {
    #####:  590:        result = utils_stringCopy((char *)buffer + index, bufferLen - index, REG_DEFAULT_PATH);
        -:  591:    }
    #####:  592:    if (result < 0) return 0;
    #####:  593:    index += result;
        -:  594:
    #####:  595:    result = utils_stringCopy((char *)buffer + index, bufferLen - index, REG_LWM2M_RESOURCE_TYPE);
    #####:  596:    if (result < 0) return 0;
    #####:  597:    index += result;
        -:  598:
    #####:  599:    for (objectP = contextP->objectList; objectP != NULL; objectP = objectP->next)
        -:  600:    {
        -:  601:        size_t start;
        -:  602:        size_t length;
        -:  603:
    #####:  604:        if (objectP->objID == LWM2M_SECURITY_OBJECT_ID) continue;
        -:  605:
    #####:  606:        start = index;
    #####:  607:        result = prv_getObjectTemplate(buffer + index, bufferLen - index, objectP->objID);
    #####:  608:        if (result < 0) return 0;
    #####:  609:        length = result;
    #####:  610:        index += length;
        -:  611:
    #####:  612:        if (objectP->instanceList == NULL)
        -:  613:        {
    #####:  614:            index--;
    #####:  615:            result = utils_stringCopy((char *)buffer + index, bufferLen - index, REG_PATH_END);
    #####:  616:            if (result < 0) return 0;
    #####:  617:            index += result;
        -:  618:        }
        -:  619:        else
        -:  620:        {
        -:  621:            lwm2m_list_t * targetP;
    #####:  622:            for (targetP = objectP->instanceList ; targetP != NULL ; targetP = targetP->next)
        -:  623:            {
    #####:  624:                if (index != start + length)
        -:  625:                {
    #####:  626:                    if (bufferLen - index <= length) return 0;
    #####:  627:                    memcpy(buffer + index, buffer + start, length);
    #####:  628:                    index += length;
        -:  629:                }
        -:  630:
    #####:  631:                result = utils_intToText(targetP->id, buffer + index, bufferLen - index);
    #####:  632:                if (result == 0) return 0;
    #####:  633:                index += result;
        -:  634:
    #####:  635:                result = utils_stringCopy((char *)buffer + index, bufferLen - index, REG_PATH_END);
    #####:  636:                if (result < 0) return 0;
    #####:  637:                index += result;
        -:  638:            }
        -:  639:        }
        -:  640:    }
        -:  641:
    #####:  642:    if (index > 0)
        -:  643:    {
    #####:  644:        index = index - 1;  // remove trailing ','
        -:  645:    }
        -:  646:
    #####:  647:    buffer[index] = 0;
        -:  648:
    #####:  649:    return index;
        -:  650:}
        -:  651:
    #####:  652:static lwm2m_list_t * prv_findServerInstance(lwm2m_object_t * objectP,
        -:  653:                                             uint16_t shortID)
        -:  654:{
        -:  655:    lwm2m_list_t * instanceP;
        -:  656:
    #####:  657:    instanceP = objectP->instanceList;
    #####:  658:    while (NULL != instanceP)
        -:  659:    {
        -:  660:        int64_t value;
        -:  661:        lwm2m_data_t * dataP;
        -:  662:        int size;
        -:  663:
    #####:  664:        size = 1;
    #####:  665:        dataP = lwm2m_data_new(size);
    #####:  666:        if (dataP == NULL) return NULL;
    #####:  667:        dataP->id = LWM2M_SERVER_SHORT_ID_ID;
        -:  668:
    #####:  669:        if (objectP->readFunc(instanceP->id, &size, &dataP, objectP,NULL) != COAP_205_CONTENT)
        -:  670:        {
    #####:  671:            lwm2m_data_free(size, dataP);
    #####:  672:            return NULL;
        -:  673:        }
        -:  674:
    #####:  675:        if (1 == lwm2m_data_decode_int(dataP, &value))
        -:  676:        {
    #####:  677:            if (value == shortID)
        -:  678:            {
    #####:  679:                lwm2m_data_free(size, dataP);
    #####:  680:                break;
        -:  681:            }
        -:  682:        }
    #####:  683:        lwm2m_data_free(size, dataP);
    #####:  684:        instanceP = instanceP->next;
        -:  685:    }
        -:  686:
    #####:  687:    return instanceP;
        -:  688:}
        -:  689:
    #####:  690:static int prv_getMandatoryInfo(lwm2m_object_t * objectP,
        -:  691:                                uint16_t instanceID,
        -:  692:                                lwm2m_server_t * targetP)
        -:  693:{
        -:  694:    lwm2m_data_t * dataP;
        -:  695:    int size;
        -:  696:    int64_t value;
        -:  697:
    #####:  698:    size = 2;
    #####:  699:    dataP = lwm2m_data_new(size);
    #####:  700:    if (dataP == NULL) return -1;
    #####:  701:    dataP[0].id = LWM2M_SERVER_LIFETIME_ID;
    #####:  702:    dataP[1].id = LWM2M_SERVER_BINDING_ID;
        -:  703:
    #####:  704:    if (objectP->readFunc(instanceID, &size, &dataP, objectP,NULL) != COAP_205_CONTENT)
        -:  705:    {
    #####:  706:        lwm2m_data_free(size, dataP);
    #####:  707:        return -1;
        -:  708:    }
        -:  709:
    #####:  710:    if (0 == lwm2m_data_decode_int(dataP, &value)
    #####:  711:     || value < 0 || value >0xFFFFFFFF)             // This is an implementation limit
        -:  712:    {
    #####:  713:        lwm2m_data_free(size, dataP);
    #####:  714:        return -1;
        -:  715:    }
    #####:  716:    targetP->lifetime = value;
        -:  717:
    #####:  718:    targetP->binding = utils_stringToBinding(dataP[1].value.asBuffer.buffer, dataP[1].value.asBuffer.length);
        -:  719:
    #####:  720:    lwm2m_data_free(size, dataP);
        -:  721:
    #####:  722:    if (targetP->binding == BINDING_UNKNOWN)
        -:  723:    {
    #####:  724:        return -1;
        -:  725:    }
        -:  726:
    #####:  727:    return 0;
        -:  728:}
        -:  729:
    #####:  730:int object_getServers(lwm2m_context_t * contextP, bool checkOnly)
        -:  731:{
        -:  732:    lwm2m_object_t * objectP;
    #####:  733:    lwm2m_object_t * securityObjP = NULL;
    #####:  734:    lwm2m_object_t * serverObjP = NULL;
        -:  735:    lwm2m_list_t * securityInstP;   // instanceID of the server in the LWM2M Security Object
        -:  736:
    #####:  737:    for (objectP = contextP->objectList; objectP != NULL; objectP = objectP->next)
        -:  738:    {
    #####:  739:        if (objectP->objID == LWM2M_SECURITY_OBJECT_ID)
        -:  740:        {
    #####:  741:            securityObjP = objectP;
        -:  742:        }
    #####:  743:        else if (objectP->objID == LWM2M_SERVER_OBJECT_ID)
        -:  744:        {
    #####:  745:            serverObjP = objectP;
        -:  746:        }
        -:  747:    }
        -:  748:
    #####:  749:    if (NULL == securityObjP) return -1;
        -:  750:
    #####:  751:    securityInstP = securityObjP->instanceList;
    #####:  752:    while (securityInstP != NULL)
        -:  753:    {
    #####:  754:        if (LWM2M_LIST_FIND(contextP->bootstrapServerList, securityInstP->id) == NULL
    #####:  755:         && LWM2M_LIST_FIND(contextP->serverList, securityInstP->id) == NULL)
        -:  756:        {
        -:  757:            // This server is new. eg created by last bootstrap
        -:  758:
        -:  759:            lwm2m_data_t * dataP;
        -:  760:            int size;
        -:  761:            lwm2m_server_t * targetP;
        -:  762:            bool isBootstrap;
    #####:  763:            int64_t value = 0;
        -:  764:
    #####:  765:            size = 3;
    #####:  766:            dataP = lwm2m_data_new(size);
    #####:  767:            if (dataP == NULL) return -1;
    #####:  768:            dataP[0].id = LWM2M_SECURITY_BOOTSTRAP_ID;
    #####:  769:            dataP[1].id = LWM2M_SECURITY_SHORT_SERVER_ID;
    #####:  770:            dataP[2].id = LWM2M_SECURITY_HOLD_OFF_ID;
        -:  771:
    #####:  772:            if (securityObjP->readFunc(securityInstP->id, &size, &dataP, securityObjP,contextP) != COAP_205_CONTENT)
        -:  773:            {
    #####:  774:                lwm2m_data_free(size, dataP);
    #####:  775:                return -1;
        -:  776:            }
        -:  777:
    #####:  778:            targetP = (lwm2m_server_t *)lwm2m_malloc(sizeof(lwm2m_server_t));
    #####:  779:            if (targetP == NULL) {
    #####:  780:                lwm2m_data_free(size, dataP);
    #####:  781:                return -1;
        -:  782:            }
    #####:  783:            memset(targetP, 0, sizeof(lwm2m_server_t));
    #####:  784:            targetP->secObjInstID = securityInstP->id;
        -:  785:
    #####:  786:            if (0 == lwm2m_data_decode_bool(dataP + 0, &isBootstrap))
        -:  787:            {
    #####:  788:                lwm2m_free(targetP);
    #####:  789:                lwm2m_data_free(size, dataP);
    #####:  790:                return -1;
        -:  791:            }
        -:  792:
    #####:  793:            if (0 == lwm2m_data_decode_int(dataP + 1, &value)
    #####:  794:             || value < (isBootstrap ? 0 : 1) || value > 0xFFFF)                // 0 is forbidden as a Short Server ID
        -:  795:            {
    #####:  796:                lwm2m_free(targetP);
    #####:  797:                lwm2m_data_free(size, dataP);
    #####:  798:                return -1;
        -:  799:            }
    #####:  800:            targetP->shortID = value;
        -:  801:
    #####:  802:            if (isBootstrap == true)
        -:  803:            {
    #####:  804:                if (0 == lwm2m_data_decode_int(dataP + 2, &value)
    #####:  805:                 || value < 0 || value > 0xFFFFFFFF)             // This is an implementation limit
        -:  806:                {
    #####:  807:                    lwm2m_free(targetP);
    #####:  808:                    lwm2m_data_free(size, dataP);
    #####:  809:                    return -1;
        -:  810:                }
        -:  811:                // lifetime of a bootstrap server is set to ClientHoldOffTime
    #####:  812:                targetP->lifetime = value;
        -:  813:
    #####:  814:                if (checkOnly)
        -:  815:                {
    #####:  816:                    lwm2m_free(targetP);
        -:  817:                }
        -:  818:                else
        -:  819:                {
    #####:  820:                    contextP->bootstrapServerList = (lwm2m_server_t*)LWM2M_LIST_ADD(contextP->bootstrapServerList, targetP);
        -:  821:                }
        -:  822:            }
        -:  823:            else
        -:  824:            {
        -:  825:                lwm2m_list_t * serverInstP;     // instanceID of the server in the LWM2M Server Object
        -:  826:
    #####:  827:                serverInstP = prv_findServerInstance(serverObjP, targetP->shortID);
    #####:  828:                if (serverInstP == NULL)
        -:  829:                {
    #####:  830:                    lwm2m_free(targetP);
        -:  831:                }
        -:  832:                else
        -:  833:                {
    #####:  834:                    if (0 != prv_getMandatoryInfo(serverObjP, serverInstP->id, targetP))
        -:  835:                    {
    #####:  836:                        lwm2m_free(targetP);
    #####:  837:                        lwm2m_data_free(size, dataP);
    #####:  838:                        return -1;
        -:  839:                    }
    #####:  840:                    targetP->status = STATE_DEREGISTERED;
    #####:  841:                    if (checkOnly)
        -:  842:                    {
    #####:  843:                        lwm2m_free(targetP);
        -:  844:                    }
        -:  845:                    else
        -:  846:                    {
    #####:  847:                        contextP->serverList = (lwm2m_server_t*)LWM2M_LIST_ADD(contextP->serverList, targetP);
        -:  848:                    }
        -:  849:                }
        -:  850:            }
    #####:  851:            lwm2m_data_free(size, dataP);
        -:  852:        }
    #####:  853:        securityInstP = securityInstP->next;
        -:  854:    }
        -:  855:
    #####:  856:    return 0;
        -:  857:}
        -:  858:
    #####:  859:uint8_t object_createInstance(lwm2m_context_t * contextP,
        -:  860:                                    lwm2m_uri_t * uriP,
        -:  861:                                    lwm2m_data_t * dataP)
        -:  862:{
        -:  863:    lwm2m_object_t * targetP;
        -:  864:
        -:  865:    LOG_URI(uriP);
    #####:  866:    targetP = (lwm2m_object_t *)LWM2M_LIST_FIND(contextP->objectList, uriP->objectId);
    #####:  867:    if (NULL == targetP) return COAP_404_NOT_FOUND;
        -:  868:
    #####:  869:    if (NULL == targetP->createFunc)
        -:  870:    {
    #####:  871:        return COAP_405_METHOD_NOT_ALLOWED;
        -:  872:    }
        -:  873:
    #####:  874:    return targetP->createFunc(lwm2m_list_newId(targetP->instanceList),
    #####:  875:                               dataP->value.asChildren.count, dataP->value.asChildren.array, targetP,contextP);
        -:  876:}
        -:  877:
    #####:  878:uint8_t object_writeInstance(lwm2m_context_t * contextP,
        -:  879:                            lwm2m_uri_t * uriP,
        -:  880:                            lwm2m_data_t * dataP)
        -:  881:{
        -:  882:    lwm2m_object_t * targetP;
        -:  883:
        -:  884:    LOG_URI(uriP);
    #####:  885:    targetP = (lwm2m_object_t *)LWM2M_LIST_FIND(contextP->objectList, uriP->objectId);
    #####:  886:    if (NULL == targetP) return COAP_404_NOT_FOUND;
        -:  887:
    #####:  888:    if (NULL == targetP->writeFunc)
        -:  889:    {
    #####:  890:        return COAP_405_METHOD_NOT_ALLOWED;
        -:  891:    }
        -:  892:
    #####:  893:    return targetP->writeFunc(dataP->id, dataP->value.asChildren.count, dataP->value.asChildren.array, targetP,contextP);
        -:  894:}
        -:  895:
        -:  896:#endif
