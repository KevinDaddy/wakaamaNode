        -:    0:Source:/home/david/Programming/wakaamaNode/src/network/mbedtls/library/bignum.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/network/mbedtls/library/bignum.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*
        -:    2: *  Multi-precision integer library
        -:    3: *
        -:    4: *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
        -:    5: *  SPDX-License-Identifier: Apache-2.0
        -:    6: *
        -:    7: *  Licensed under the Apache License, Version 2.0 (the "License"); you may
        -:    8: *  not use this file except in compliance with the License.
        -:    9: *  You may obtain a copy of the License at
        -:   10: *
        -:   11: *  http://www.apache.org/licenses/LICENSE-2.0
        -:   12: *
        -:   13: *  Unless required by applicable law or agreed to in writing, software
        -:   14: *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
        -:   15: *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   16: *  See the License for the specific language governing permissions and
        -:   17: *  limitations under the License.
        -:   18: *
        -:   19: *  This file is part of mbed TLS (https://tls.mbed.org)
        -:   20: */
        -:   21:
        -:   22:/*
        -:   23: *  The following sources were referenced in the design of this Multi-precision
        -:   24: *  Integer library:
        -:   25: *
        -:   26: *  [1] Handbook of Applied Cryptography - 1997
        -:   27: *      Menezes, van Oorschot and Vanstone
        -:   28: *
        -:   29: *  [2] Multi-Precision Math
        -:   30: *      Tom St Denis
        -:   31: *      https://github.com/libtom/libtommath/blob/develop/tommath.pdf
        -:   32: *
        -:   33: *  [3] GNU Multi-Precision Arithmetic Library
        -:   34: *      https://gmplib.org/manual/index.html
        -:   35: *
        -:   36: */
        -:   37:
        -:   38:#if !defined(MBEDTLS_CONFIG_FILE)
        -:   39:#include "mbedtls/config.h"
        -:   40:#else
        -:   41:#include MBEDTLS_CONFIG_FILE
        -:   42:#endif
        -:   43:
        -:   44:#if defined(MBEDTLS_BIGNUM_C)
        -:   45:
        -:   46:#include "mbedtls/bignum.h"
        -:   47:#include "mbedtls/bn_mul.h"
        -:   48:#include "mbedtls/platform_util.h"
        -:   49:
        -:   50:#include <string.h>
        -:   51:
        -:   52:#if defined(MBEDTLS_PLATFORM_C)
        -:   53:#include "mbedtls/platform.h"
        -:   54:#else
        -:   55:#include <stdio.h>
        -:   56:#include <stdlib.h>
        -:   57:#define mbedtls_printf     printf
        -:   58:#define mbedtls_calloc    calloc
        -:   59:#define mbedtls_free       free
        -:   60:#endif
        -:   61:
        -:   62:#define ciL    (sizeof(mbedtls_mpi_uint))         /* chars in limb  */
        -:   63:#define biL    (ciL << 3)               /* bits  in limb  */
        -:   64:#define biH    (ciL << 2)               /* half limb size */
        -:   65:
        -:   66:#define MPI_SIZE_T_MAX  ( (size_t) -1 ) /* SIZE_T_MAX is not standard */
        -:   67:
        -:   68:/*
        -:   69: * Convert between bits/chars and number of limbs
        -:   70: * Divide first in order to avoid potential overflows
        -:   71: */
        -:   72:#define BITS_TO_LIMBS(i)  ( (i) / biL + ( (i) % biL != 0 ) )
        -:   73:#define CHARS_TO_LIMBS(i) ( (i) / ciL + ( (i) % ciL != 0 ) )
        -:   74:
        -:   75:/* Implementation that should never be optimized out by the compiler */
    #####:   76:static void mbedtls_mpi_zeroize( mbedtls_mpi_uint *v, size_t n )
        -:   77:{
    #####:   78:    mbedtls_platform_zeroize( v, ciL * n );
    #####:   79:}
        -:   80:
        -:   81:/*
        -:   82: * Initialize one MPI
        -:   83: */
    #####:   84:void mbedtls_mpi_init( mbedtls_mpi *X )
        -:   85:{
    #####:   86:    if( X == NULL )
    #####:   87:        return;
        -:   88:
    #####:   89:    X->s = 1;
    #####:   90:    X->n = 0;
    #####:   91:    X->p = NULL;
        -:   92:}
        -:   93:
        -:   94:/*
        -:   95: * Unallocate one MPI
        -:   96: */
    #####:   97:void mbedtls_mpi_free( mbedtls_mpi *X )
        -:   98:{
    #####:   99:    if( X == NULL )
    #####:  100:        return;
        -:  101:
    #####:  102:    if( X->p != NULL )
        -:  103:    {
    #####:  104:        mbedtls_mpi_zeroize( X->p, X->n );
    #####:  105:        mbedtls_free( X->p );
        -:  106:    }
        -:  107:
    #####:  108:    X->s = 1;
    #####:  109:    X->n = 0;
    #####:  110:    X->p = NULL;
        -:  111:}
        -:  112:
        -:  113:/*
        -:  114: * Enlarge to the specified number of limbs
        -:  115: */
    #####:  116:int mbedtls_mpi_grow( mbedtls_mpi *X, size_t nblimbs )
        -:  117:{
        -:  118:    mbedtls_mpi_uint *p;
        -:  119:
    #####:  120:    if( nblimbs > MBEDTLS_MPI_MAX_LIMBS )
    #####:  121:        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
        -:  122:
    #####:  123:    if( X->n < nblimbs )
        -:  124:    {
    #####:  125:        if( ( p = (mbedtls_mpi_uint*)mbedtls_calloc( nblimbs, ciL ) ) == NULL )
    #####:  126:            return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
        -:  127:
    #####:  128:        if( X->p != NULL )
        -:  129:        {
    #####:  130:            memcpy( p, X->p, X->n * ciL );
    #####:  131:            mbedtls_mpi_zeroize( X->p, X->n );
    #####:  132:            mbedtls_free( X->p );
        -:  133:        }
        -:  134:
    #####:  135:        X->n = nblimbs;
    #####:  136:        X->p = p;
        -:  137:    }
        -:  138:
    #####:  139:    return( 0 );
        -:  140:}
        -:  141:
        -:  142:/*
        -:  143: * Resize down as much as possible,
        -:  144: * while keeping at least the specified number of limbs
        -:  145: */
    #####:  146:int mbedtls_mpi_shrink( mbedtls_mpi *X, size_t nblimbs )
        -:  147:{
        -:  148:    mbedtls_mpi_uint *p;
        -:  149:    size_t i;
        -:  150:
        -:  151:    /* Actually resize up in this case */
    #####:  152:    if( X->n <= nblimbs )
    #####:  153:        return( mbedtls_mpi_grow( X, nblimbs ) );
        -:  154:
    #####:  155:    for( i = X->n - 1; i > 0; i-- )
    #####:  156:        if( X->p[i] != 0 )
    #####:  157:            break;
    #####:  158:    i++;
        -:  159:
    #####:  160:    if( i < nblimbs )
    #####:  161:        i = nblimbs;
        -:  162:
    #####:  163:    if( ( p = (mbedtls_mpi_uint*)mbedtls_calloc( i, ciL ) ) == NULL )
    #####:  164:        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
        -:  165:
    #####:  166:    if( X->p != NULL )
        -:  167:    {
    #####:  168:        memcpy( p, X->p, i * ciL );
    #####:  169:        mbedtls_mpi_zeroize( X->p, X->n );
    #####:  170:        mbedtls_free( X->p );
        -:  171:    }
        -:  172:
    #####:  173:    X->n = i;
    #####:  174:    X->p = p;
        -:  175:
    #####:  176:    return( 0 );
        -:  177:}
        -:  178:
        -:  179:/*
        -:  180: * Copy the contents of Y into X
        -:  181: */
    #####:  182:int mbedtls_mpi_copy( mbedtls_mpi *X, const mbedtls_mpi *Y )
        -:  183:{
    #####:  184:    int ret = 0;
        -:  185:    size_t i;
        -:  186:
    #####:  187:    if( X == Y )
    #####:  188:        return( 0 );
        -:  189:
    #####:  190:    if( Y->p == NULL )
        -:  191:    {
    #####:  192:        mbedtls_mpi_free( X );
    #####:  193:        return( 0 );
        -:  194:    }
        -:  195:
    #####:  196:    for( i = Y->n - 1; i > 0; i-- )
    #####:  197:        if( Y->p[i] != 0 )
    #####:  198:            break;
    #####:  199:    i++;
        -:  200:
    #####:  201:    X->s = Y->s;
        -:  202:
    #####:  203:    if( X->n < i )
        -:  204:    {
    #####:  205:        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i ) );
        -:  206:    }
        -:  207:    else
        -:  208:    {
    #####:  209:        memset( X->p + i, 0, ( X->n - i ) * ciL );
        -:  210:    }
        -:  211:
    #####:  212:    memcpy( X->p, Y->p, i * ciL );
        -:  213:
    #####:  214:cleanup:
        -:  215:
    #####:  216:    return( ret );
        -:  217:}
        -:  218:
        -:  219:/*
        -:  220: * Swap the contents of X and Y
        -:  221: */
    #####:  222:void mbedtls_mpi_swap( mbedtls_mpi *X, mbedtls_mpi *Y )
        -:  223:{
        -:  224:    mbedtls_mpi T;
        -:  225:
    #####:  226:    memcpy( &T,  X, sizeof( mbedtls_mpi ) );
    #####:  227:    memcpy(  X,  Y, sizeof( mbedtls_mpi ) );
    #####:  228:    memcpy(  Y, &T, sizeof( mbedtls_mpi ) );
    #####:  229:}
        -:  230:
        -:  231:/*
        -:  232: * Conditionally assign X = Y, without leaking information
        -:  233: * about whether the assignment was made or not.
        -:  234: * (Leaking information about the respective sizes of X and Y is ok however.)
        -:  235: */
    #####:  236:int mbedtls_mpi_safe_cond_assign( mbedtls_mpi *X, const mbedtls_mpi *Y, unsigned char assign )
        -:  237:{
    #####:  238:    int ret = 0;
        -:  239:    size_t i;
        -:  240:
        -:  241:    /* make sure assign is 0 or 1 in a time-constant manner */
    #####:  242:    assign = (assign | (unsigned char)-assign) >> 7;
        -:  243:
    #####:  244:    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, Y->n ) );
        -:  245:
    #####:  246:    X->s = X->s * ( 1 - assign ) + Y->s * assign;
        -:  247:
    #####:  248:    for( i = 0; i < Y->n; i++ )
    #####:  249:        X->p[i] = X->p[i] * ( 1 - assign ) + Y->p[i] * assign;
        -:  250:
    #####:  251:    for( ; i < X->n; i++ )
    #####:  252:        X->p[i] *= ( 1 - assign );
        -:  253:
    #####:  254:cleanup:
    #####:  255:    return( ret );
        -:  256:}
        -:  257:
        -:  258:/*
        -:  259: * Conditionally swap X and Y, without leaking information
        -:  260: * about whether the swap was made or not.
        -:  261: * Here it is not ok to simply swap the pointers, which whould lead to
        -:  262: * different memory access patterns when X and Y are used afterwards.
        -:  263: */
    #####:  264:int mbedtls_mpi_safe_cond_swap( mbedtls_mpi *X, mbedtls_mpi *Y, unsigned char swap )
        -:  265:{
        -:  266:    int ret, s;
        -:  267:    size_t i;
        -:  268:    mbedtls_mpi_uint tmp;
        -:  269:
    #####:  270:    if( X == Y )
    #####:  271:        return( 0 );
        -:  272:
        -:  273:    /* make sure swap is 0 or 1 in a time-constant manner */
    #####:  274:    swap = (swap | (unsigned char)-swap) >> 7;
        -:  275:
    #####:  276:    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, Y->n ) );
    #####:  277:    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( Y, X->n ) );
        -:  278:
    #####:  279:    s = X->s;
    #####:  280:    X->s = X->s * ( 1 - swap ) + Y->s * swap;
    #####:  281:    Y->s = Y->s * ( 1 - swap ) +    s * swap;
        -:  282:
        -:  283:
    #####:  284:    for( i = 0; i < X->n; i++ )
        -:  285:    {
    #####:  286:        tmp = X->p[i];
    #####:  287:        X->p[i] = X->p[i] * ( 1 - swap ) + Y->p[i] * swap;
    #####:  288:        Y->p[i] = Y->p[i] * ( 1 - swap ) +     tmp * swap;
        -:  289:    }
        -:  290:
    #####:  291:cleanup:
    #####:  292:    return( ret );
        -:  293:}
        -:  294:
        -:  295:/*
        -:  296: * Set value from integer
        -:  297: */
    #####:  298:int mbedtls_mpi_lset( mbedtls_mpi *X, mbedtls_mpi_sint z )
        -:  299:{
        -:  300:    int ret;
        -:  301:
    #####:  302:    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, 1 ) );
    #####:  303:    memset( X->p, 0, X->n * ciL );
        -:  304:
    #####:  305:    X->p[0] = ( z < 0 ) ? -z : z;
    #####:  306:    X->s    = ( z < 0 ) ? -1 : 1;
        -:  307:
    #####:  308:cleanup:
        -:  309:
    #####:  310:    return( ret );
        -:  311:}
        -:  312:
        -:  313:/*
        -:  314: * Get a specific bit
        -:  315: */
    #####:  316:int mbedtls_mpi_get_bit( const mbedtls_mpi *X, size_t pos )
        -:  317:{
    #####:  318:    if( X->n * biL <= pos )
    #####:  319:        return( 0 );
        -:  320:
    #####:  321:    return( ( X->p[pos / biL] >> ( pos % biL ) ) & 0x01 );
        -:  322:}
        -:  323:
        -:  324:/*
        -:  325: * Set a bit to a specific value of 0 or 1
        -:  326: */
    #####:  327:int mbedtls_mpi_set_bit( mbedtls_mpi *X, size_t pos, unsigned char val )
        -:  328:{
    #####:  329:    int ret = 0;
    #####:  330:    size_t off = pos / biL;
    #####:  331:    size_t idx = pos % biL;
        -:  332:
    #####:  333:    if( val != 0 && val != 1 )
    #####:  334:        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
        -:  335:
    #####:  336:    if( X->n * biL <= pos )
        -:  337:    {
    #####:  338:        if( val == 0 )
    #####:  339:            return( 0 );
        -:  340:
    #####:  341:        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, off + 1 ) );
        -:  342:    }
        -:  343:
    #####:  344:    X->p[off] &= ~( (mbedtls_mpi_uint) 0x01 << idx );
    #####:  345:    X->p[off] |= (mbedtls_mpi_uint) val << idx;
        -:  346:
    #####:  347:cleanup:
        -:  348:
    #####:  349:    return( ret );
        -:  350:}
        -:  351:
        -:  352:/*
        -:  353: * Return the number of less significant zero-bits
        -:  354: */
    #####:  355:size_t mbedtls_mpi_lsb( const mbedtls_mpi *X )
        -:  356:{
    #####:  357:    size_t i, j, count = 0;
        -:  358:
    #####:  359:    for( i = 0; i < X->n; i++ )
    #####:  360:        for( j = 0; j < biL; j++, count++ )
    #####:  361:            if( ( ( X->p[i] >> j ) & 1 ) != 0 )
    #####:  362:                return( count );
        -:  363:
    #####:  364:    return( 0 );
        -:  365:}
        -:  366:
        -:  367:/*
        -:  368: * Count leading zero bits in a given integer
        -:  369: */
    #####:  370:static size_t mbedtls_clz( const mbedtls_mpi_uint x )
        -:  371:{
        -:  372:    size_t j;
    #####:  373:    mbedtls_mpi_uint mask = (mbedtls_mpi_uint) 1 << (biL - 1);
        -:  374:
    #####:  375:    for( j = 0; j < biL; j++ )
        -:  376:    {
    #####:  377:        if( x & mask ) break;
        -:  378:
    #####:  379:        mask >>= 1;
        -:  380:    }
        -:  381:
    #####:  382:    return j;
        -:  383:}
        -:  384:
        -:  385:/*
        -:  386: * Return the number of bits
        -:  387: */
    #####:  388:size_t mbedtls_mpi_bitlen( const mbedtls_mpi *X )
        -:  389:{
        -:  390:    size_t i, j;
        -:  391:
    #####:  392:    if( X->n == 0 )
    #####:  393:        return( 0 );
        -:  394:
    #####:  395:    for( i = X->n - 1; i > 0; i-- )
    #####:  396:        if( X->p[i] != 0 )
    #####:  397:            break;
        -:  398:
    #####:  399:    j = biL - mbedtls_clz( X->p[i] );
        -:  400:
    #####:  401:    return( ( i * biL ) + j );
        -:  402:}
        -:  403:
        -:  404:/*
        -:  405: * Return the total size in bytes
        -:  406: */
    #####:  407:size_t mbedtls_mpi_size( const mbedtls_mpi *X )
        -:  408:{
    #####:  409:    return( ( mbedtls_mpi_bitlen( X ) + 7 ) >> 3 );
        -:  410:}
        -:  411:
        -:  412:/*
        -:  413: * Convert an ASCII character to digit value
        -:  414: */
    #####:  415:static int mpi_get_digit( mbedtls_mpi_uint *d, int radix, char c )
        -:  416:{
    #####:  417:    *d = 255;
        -:  418:
    #####:  419:    if( c >= 0x30 && c <= 0x39 ) *d = c - 0x30;
    #####:  420:    if( c >= 0x41 && c <= 0x46 ) *d = c - 0x37;
    #####:  421:    if( c >= 0x61 && c <= 0x66 ) *d = c - 0x57;
        -:  422:
    #####:  423:    if( *d >= (mbedtls_mpi_uint) radix )
    #####:  424:        return( MBEDTLS_ERR_MPI_INVALID_CHARACTER );
        -:  425:
    #####:  426:    return( 0 );
        -:  427:}
        -:  428:
        -:  429:/*
        -:  430: * Import from an ASCII string
        -:  431: */
    #####:  432:int mbedtls_mpi_read_string( mbedtls_mpi *X, int radix, const char *s )
        -:  433:{
        -:  434:    int ret;
        -:  435:    size_t i, j, slen, n;
        -:  436:    mbedtls_mpi_uint d;
        -:  437:    mbedtls_mpi T;
        -:  438:
    #####:  439:    if( radix < 2 || radix > 16 )
    #####:  440:        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
        -:  441:
    #####:  442:    mbedtls_mpi_init( &T );
        -:  443:
    #####:  444:    slen = strlen( s );
        -:  445:
    #####:  446:    if( radix == 16 )
        -:  447:    {
    #####:  448:        if( slen > MPI_SIZE_T_MAX >> 2 )
    #####:  449:            return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
        -:  450:
    #####:  451:        n = BITS_TO_LIMBS( slen << 2 );
        -:  452:
    #####:  453:        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, n ) );
    #####:  454:        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
        -:  455:
    #####:  456:        for( i = slen, j = 0; i > 0; i--, j++ )
        -:  457:        {
    #####:  458:            if( i == 1 && s[i - 1] == '-' )
        -:  459:            {
    #####:  460:                X->s = -1;
    #####:  461:                break;
        -:  462:            }
        -:  463:
    #####:  464:            MBEDTLS_MPI_CHK( mpi_get_digit( &d, radix, s[i - 1] ) );
    #####:  465:            X->p[j / ( 2 * ciL )] |= d << ( ( j % ( 2 * ciL ) ) << 2 );
        -:  466:        }
        -:  467:    }
        -:  468:    else
        -:  469:    {
    #####:  470:        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
        -:  471:
    #####:  472:        for( i = 0; i < slen; i++ )
        -:  473:        {
    #####:  474:            if( i == 0 && s[i] == '-' )
        -:  475:            {
    #####:  476:                X->s = -1;
    #####:  477:                continue;
        -:  478:            }
        -:  479:
    #####:  480:            MBEDTLS_MPI_CHK( mpi_get_digit( &d, radix, s[i] ) );
    #####:  481:            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T, X, radix ) );
        -:  482:
    #####:  483:            if( X->s == 1 )
        -:  484:            {
    #####:  485:                MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( X, &T, d ) );
        -:  486:            }
        -:  487:            else
        -:  488:            {
    #####:  489:                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( X, &T, d ) );
        -:  490:            }
        -:  491:        }
        -:  492:    }
        -:  493:
    #####:  494:cleanup:
        -:  495:
    #####:  496:    mbedtls_mpi_free( &T );
        -:  497:
    #####:  498:    return( ret );
        -:  499:}
        -:  500:
        -:  501:/*
        -:  502: * Helper to write the digits high-order first
        -:  503: */
    #####:  504:static int mpi_write_hlp( mbedtls_mpi *X, int radix, char **p )
        -:  505:{
        -:  506:    int ret;
        -:  507:    mbedtls_mpi_uint r;
        -:  508:
    #####:  509:    if( radix < 2 || radix > 16 )
    #####:  510:        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
        -:  511:
    #####:  512:    MBEDTLS_MPI_CHK( mbedtls_mpi_mod_int( &r, X, radix ) );
    #####:  513:    MBEDTLS_MPI_CHK( mbedtls_mpi_div_int( X, NULL, X, radix ) );
        -:  514:
    #####:  515:    if( mbedtls_mpi_cmp_int( X, 0 ) != 0 )
    #####:  516:        MBEDTLS_MPI_CHK( mpi_write_hlp( X, radix, p ) );
        -:  517:
    #####:  518:    if( r < 10 )
    #####:  519:        *(*p)++ = (char)( r + 0x30 );
        -:  520:    else
    #####:  521:        *(*p)++ = (char)( r + 0x37 );
        -:  522:
    #####:  523:cleanup:
        -:  524:
    #####:  525:    return( ret );
        -:  526:}
        -:  527:
        -:  528:/*
        -:  529: * Export into an ASCII string
        -:  530: */
    #####:  531:int mbedtls_mpi_write_string( const mbedtls_mpi *X, int radix,
        -:  532:                              char *buf, size_t buflen, size_t *olen )
        -:  533:{
    #####:  534:    int ret = 0;
        -:  535:    size_t n;
        -:  536:    char *p;
        -:  537:    mbedtls_mpi T;
        -:  538:
    #####:  539:    if( radix < 2 || radix > 16 )
    #####:  540:        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
        -:  541:
    #####:  542:    n = mbedtls_mpi_bitlen( X );
    #####:  543:    if( radix >=  4 ) n >>= 1;
    #####:  544:    if( radix >= 16 ) n >>= 1;
        -:  545:    /*
        -:  546:     * Round up the buffer length to an even value to ensure that there is
        -:  547:     * enough room for hexadecimal values that can be represented in an odd
        -:  548:     * number of digits.
        -:  549:     */
    #####:  550:    n += 3 + ( ( n + 1 ) & 1 );
        -:  551:
    #####:  552:    if( buflen < n )
        -:  553:    {
    #####:  554:        *olen = n;
    #####:  555:        return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );
        -:  556:    }
        -:  557:
    #####:  558:    p = buf;
    #####:  559:    mbedtls_mpi_init( &T );
        -:  560:
    #####:  561:    if( X->s == -1 )
    #####:  562:        *p++ = '-';
        -:  563:
    #####:  564:    if( radix == 16 )
        -:  565:    {
        -:  566:        int c;
        -:  567:        size_t i, j, k;
        -:  568:
    #####:  569:        for( i = X->n, k = 0; i > 0; i-- )
        -:  570:        {
    #####:  571:            for( j = ciL; j > 0; j-- )
        -:  572:            {
    #####:  573:                c = ( X->p[i - 1] >> ( ( j - 1 ) << 3) ) & 0xFF;
        -:  574:
    #####:  575:                if( c == 0 && k == 0 && ( i + j ) != 2 )
    #####:  576:                    continue;
        -:  577:
    #####:  578:                *(p++) = "0123456789ABCDEF" [c / 16];
    #####:  579:                *(p++) = "0123456789ABCDEF" [c % 16];
    #####:  580:                k = 1;
        -:  581:            }
        -:  582:        }
        -:  583:    }
        -:  584:    else
        -:  585:    {
    #####:  586:        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &T, X ) );
        -:  587:
    #####:  588:        if( T.s == -1 )
    #####:  589:            T.s = 1;
        -:  590:
    #####:  591:        MBEDTLS_MPI_CHK( mpi_write_hlp( &T, radix, &p ) );
        -:  592:    }
        -:  593:
    #####:  594:    *p++ = '\0';
    #####:  595:    *olen = p - buf;
        -:  596:
    #####:  597:cleanup:
        -:  598:
    #####:  599:    mbedtls_mpi_free( &T );
        -:  600:
    #####:  601:    return( ret );
        -:  602:}
        -:  603:
        -:  604:#if defined(MBEDTLS_FS_IO)
        -:  605:/*
        -:  606: * Read X from an opened file
        -:  607: */
        -:  608:int mbedtls_mpi_read_file( mbedtls_mpi *X, int radix, FILE *fin )
        -:  609:{
        -:  610:    mbedtls_mpi_uint d;
        -:  611:    size_t slen;
        -:  612:    char *p;
        -:  613:    /*
        -:  614:     * Buffer should have space for (short) label and decimal formatted MPI,
        -:  615:     * newline characters and '\0'
        -:  616:     */
        -:  617:    char s[ MBEDTLS_MPI_RW_BUFFER_SIZE ];
        -:  618:
        -:  619:    memset( s, 0, sizeof( s ) );
        -:  620:    if( fgets( s, sizeof( s ) - 1, fin ) == NULL )
        -:  621:        return( MBEDTLS_ERR_MPI_FILE_IO_ERROR );
        -:  622:
        -:  623:    slen = strlen( s );
        -:  624:    if( slen == sizeof( s ) - 2 )
        -:  625:        return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );
        -:  626:
        -:  627:    if( slen > 0 && s[slen - 1] == '\n' ) { slen--; s[slen] = '\0'; }
        -:  628:    if( slen > 0 && s[slen - 1] == '\r' ) { slen--; s[slen] = '\0'; }
        -:  629:
        -:  630:    p = s + slen;
        -:  631:    while( p-- > s )
        -:  632:        if( mpi_get_digit( &d, radix, *p ) != 0 )
        -:  633:            break;
        -:  634:
        -:  635:    return( mbedtls_mpi_read_string( X, radix, p + 1 ) );
        -:  636:}
        -:  637:
        -:  638:/*
        -:  639: * Write X into an opened file (or stdout if fout == NULL)
        -:  640: */
        -:  641:int mbedtls_mpi_write_file( const char *p, const mbedtls_mpi *X, int radix, FILE *fout )
        -:  642:{
        -:  643:    int ret;
        -:  644:    size_t n, slen, plen;
        -:  645:    /*
        -:  646:     * Buffer should have space for (short) label and decimal formatted MPI,
        -:  647:     * newline characters and '\0'
        -:  648:     */
        -:  649:    char s[ MBEDTLS_MPI_RW_BUFFER_SIZE ];
        -:  650:
        -:  651:    memset( s, 0, sizeof( s ) );
        -:  652:
        -:  653:    MBEDTLS_MPI_CHK( mbedtls_mpi_write_string( X, radix, s, sizeof( s ) - 2, &n ) );
        -:  654:
        -:  655:    if( p == NULL ) p = "";
        -:  656:
        -:  657:    plen = strlen( p );
        -:  658:    slen = strlen( s );
        -:  659:    s[slen++] = '\r';
        -:  660:    s[slen++] = '\n';
        -:  661:
        -:  662:    if( fout != NULL )
        -:  663:    {
        -:  664:        if( fwrite( p, 1, plen, fout ) != plen ||
        -:  665:            fwrite( s, 1, slen, fout ) != slen )
        -:  666:            return( MBEDTLS_ERR_MPI_FILE_IO_ERROR );
        -:  667:    }
        -:  668:    else
        -:  669:        mbedtls_printf( "%s%s", p, s );
        -:  670:
        -:  671:cleanup:
        -:  672:
        -:  673:    return( ret );
        -:  674:}
        -:  675:#endif /* MBEDTLS_FS_IO */
        -:  676:
        -:  677:/*
        -:  678: * Import X from unsigned binary data, big endian
        -:  679: */
    #####:  680:int mbedtls_mpi_read_binary( mbedtls_mpi *X, const unsigned char *buf, size_t buflen )
        -:  681:{
        -:  682:    int ret;
        -:  683:    size_t i, j;
    #####:  684:    size_t const limbs = CHARS_TO_LIMBS( buflen );
        -:  685:
        -:  686:    /* Ensure that target MPI has exactly the necessary number of limbs */
    #####:  687:    if( X->n != limbs )
        -:  688:    {
    #####:  689:        mbedtls_mpi_free( X );
    #####:  690:        mbedtls_mpi_init( X );
    #####:  691:        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, limbs ) );
        -:  692:    }
        -:  693:
    #####:  694:    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
        -:  695:
    #####:  696:    for( i = buflen, j = 0; i > 0; i--, j++ )
    #####:  697:        X->p[j / ciL] |= ((mbedtls_mpi_uint) buf[i - 1]) << ((j % ciL) << 3);
        -:  698:
    #####:  699:cleanup:
        -:  700:
    #####:  701:    return( ret );
        -:  702:}
        -:  703:
        -:  704:/*
        -:  705: * Export X into unsigned binary data, big endian
        -:  706: */
    #####:  707:int mbedtls_mpi_write_binary( const mbedtls_mpi *X, unsigned char *buf, size_t buflen )
        -:  708:{
        -:  709:    size_t i, j, n;
        -:  710:
    #####:  711:    n = mbedtls_mpi_size( X );
        -:  712:
    #####:  713:    if( buflen < n )
    #####:  714:        return( MBEDTLS_ERR_MPI_BUFFER_TOO_SMALL );
        -:  715:
    #####:  716:    memset( buf, 0, buflen );
        -:  717:
    #####:  718:    for( i = buflen - 1, j = 0; n > 0; i--, j++, n-- )
    #####:  719:        buf[i] = (unsigned char)( X->p[j / ciL] >> ((j % ciL) << 3) );
        -:  720:
    #####:  721:    return( 0 );
        -:  722:}
        -:  723:
        -:  724:/*
        -:  725: * Left-shift: X <<= count
        -:  726: */
    #####:  727:int mbedtls_mpi_shift_l( mbedtls_mpi *X, size_t count )
        -:  728:{
        -:  729:    int ret;
        -:  730:    size_t i, v0, t1;
    #####:  731:    mbedtls_mpi_uint r0 = 0, r1;
        -:  732:
    #####:  733:    v0 = count / (biL    );
    #####:  734:    t1 = count & (biL - 1);
        -:  735:
    #####:  736:    i = mbedtls_mpi_bitlen( X ) + count;
        -:  737:
    #####:  738:    if( X->n * biL < i )
    #####:  739:        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, BITS_TO_LIMBS( i ) ) );
        -:  740:
    #####:  741:    ret = 0;
        -:  742:
        -:  743:    /*
        -:  744:     * shift by count / limb_size
        -:  745:     */
    #####:  746:    if( v0 > 0 )
        -:  747:    {
    #####:  748:        for( i = X->n; i > v0; i-- )
    #####:  749:            X->p[i - 1] = X->p[i - v0 - 1];
        -:  750:
    #####:  751:        for( ; i > 0; i-- )
    #####:  752:            X->p[i - 1] = 0;
        -:  753:    }
        -:  754:
        -:  755:    /*
        -:  756:     * shift by count % limb_size
        -:  757:     */
    #####:  758:    if( t1 > 0 )
        -:  759:    {
    #####:  760:        for( i = v0; i < X->n; i++ )
        -:  761:        {
    #####:  762:            r1 = X->p[i] >> (biL - t1);
    #####:  763:            X->p[i] <<= t1;
    #####:  764:            X->p[i] |= r0;
    #####:  765:            r0 = r1;
        -:  766:        }
        -:  767:    }
        -:  768:
    #####:  769:cleanup:
        -:  770:
    #####:  771:    return( ret );
        -:  772:}
        -:  773:
        -:  774:/*
        -:  775: * Right-shift: X >>= count
        -:  776: */
    #####:  777:int mbedtls_mpi_shift_r( mbedtls_mpi *X, size_t count )
        -:  778:{
        -:  779:    size_t i, v0, v1;
    #####:  780:    mbedtls_mpi_uint r0 = 0, r1;
        -:  781:
    #####:  782:    v0 = count /  biL;
    #####:  783:    v1 = count & (biL - 1);
        -:  784:
    #####:  785:    if( v0 > X->n || ( v0 == X->n && v1 > 0 ) )
    #####:  786:        return mbedtls_mpi_lset( X, 0 );
        -:  787:
        -:  788:    /*
        -:  789:     * shift by count / limb_size
        -:  790:     */
    #####:  791:    if( v0 > 0 )
        -:  792:    {
    #####:  793:        for( i = 0; i < X->n - v0; i++ )
    #####:  794:            X->p[i] = X->p[i + v0];
        -:  795:
    #####:  796:        for( ; i < X->n; i++ )
    #####:  797:            X->p[i] = 0;
        -:  798:    }
        -:  799:
        -:  800:    /*
        -:  801:     * shift by count % limb_size
        -:  802:     */
    #####:  803:    if( v1 > 0 )
        -:  804:    {
    #####:  805:        for( i = X->n; i > 0; i-- )
        -:  806:        {
    #####:  807:            r1 = X->p[i - 1] << (biL - v1);
    #####:  808:            X->p[i - 1] >>= v1;
    #####:  809:            X->p[i - 1] |= r0;
    #####:  810:            r0 = r1;
        -:  811:        }
        -:  812:    }
        -:  813:
    #####:  814:    return( 0 );
        -:  815:}
        -:  816:
        -:  817:/*
        -:  818: * Compare unsigned values
        -:  819: */
    #####:  820:int mbedtls_mpi_cmp_abs( const mbedtls_mpi *X, const mbedtls_mpi *Y )
        -:  821:{
        -:  822:    size_t i, j;
        -:  823:
    #####:  824:    for( i = X->n; i > 0; i-- )
    #####:  825:        if( X->p[i - 1] != 0 )
    #####:  826:            break;
        -:  827:
    #####:  828:    for( j = Y->n; j > 0; j-- )
    #####:  829:        if( Y->p[j - 1] != 0 )
    #####:  830:            break;
        -:  831:
    #####:  832:    if( i == 0 && j == 0 )
    #####:  833:        return( 0 );
        -:  834:
    #####:  835:    if( i > j ) return(  1 );
    #####:  836:    if( j > i ) return( -1 );
        -:  837:
    #####:  838:    for( ; i > 0; i-- )
        -:  839:    {
    #####:  840:        if( X->p[i - 1] > Y->p[i - 1] ) return(  1 );
    #####:  841:        if( X->p[i - 1] < Y->p[i - 1] ) return( -1 );
        -:  842:    }
        -:  843:
    #####:  844:    return( 0 );
        -:  845:}
        -:  846:
        -:  847:/*
        -:  848: * Compare signed values
        -:  849: */
    #####:  850:int mbedtls_mpi_cmp_mpi( const mbedtls_mpi *X, const mbedtls_mpi *Y )
        -:  851:{
        -:  852:    size_t i, j;
        -:  853:
    #####:  854:    for( i = X->n; i > 0; i-- )
    #####:  855:        if( X->p[i - 1] != 0 )
    #####:  856:            break;
        -:  857:
    #####:  858:    for( j = Y->n; j > 0; j-- )
    #####:  859:        if( Y->p[j - 1] != 0 )
    #####:  860:            break;
        -:  861:
    #####:  862:    if( i == 0 && j == 0 )
    #####:  863:        return( 0 );
        -:  864:
    #####:  865:    if( i > j ) return(  X->s );
    #####:  866:    if( j > i ) return( -Y->s );
        -:  867:
    #####:  868:    if( X->s > 0 && Y->s < 0 ) return(  1 );
    #####:  869:    if( Y->s > 0 && X->s < 0 ) return( -1 );
        -:  870:
    #####:  871:    for( ; i > 0; i-- )
        -:  872:    {
    #####:  873:        if( X->p[i - 1] > Y->p[i - 1] ) return(  X->s );
    #####:  874:        if( X->p[i - 1] < Y->p[i - 1] ) return( -X->s );
        -:  875:    }
        -:  876:
    #####:  877:    return( 0 );
        -:  878:}
        -:  879:
        -:  880:/*
        -:  881: * Compare signed values
        -:  882: */
    #####:  883:int mbedtls_mpi_cmp_int( const mbedtls_mpi *X, mbedtls_mpi_sint z )
        -:  884:{
        -:  885:    mbedtls_mpi Y;
        -:  886:    mbedtls_mpi_uint p[1];
        -:  887:
    #####:  888:    *p  = ( z < 0 ) ? -z : z;
    #####:  889:    Y.s = ( z < 0 ) ? -1 : 1;
    #####:  890:    Y.n = 1;
    #####:  891:    Y.p = p;
        -:  892:
    #####:  893:    return( mbedtls_mpi_cmp_mpi( X, &Y ) );
        -:  894:}
        -:  895:
        -:  896:/*
        -:  897: * Unsigned addition: X = |A| + |B|  (HAC 14.7)
        -:  898: */
    #####:  899:int mbedtls_mpi_add_abs( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B )
        -:  900:{
        -:  901:    int ret;
        -:  902:    size_t i, j;
        -:  903:    mbedtls_mpi_uint *o, *p, c, tmp;
        -:  904:
    #####:  905:    if( X == B )
        -:  906:    {
    #####:  907:        const mbedtls_mpi *T = A; A = X; B = T;
        -:  908:    }
        -:  909:
    #####:  910:    if( X != A )
    #####:  911:        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, A ) );
        -:  912:
        -:  913:    /*
        -:  914:     * X should always be positive as a result of unsigned additions.
        -:  915:     */
    #####:  916:    X->s = 1;
        -:  917:
    #####:  918:    for( j = B->n; j > 0; j-- )
    #####:  919:        if( B->p[j - 1] != 0 )
    #####:  920:            break;
        -:  921:
    #####:  922:    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
        -:  923:
    #####:  924:    o = B->p; p = X->p; c = 0;
        -:  925:
        -:  926:    /*
        -:  927:     * tmp is used because it might happen that p == o
        -:  928:     */
    #####:  929:    for( i = 0; i < j; i++, o++, p++ )
        -:  930:    {
    #####:  931:        tmp= *o;
    #####:  932:        *p +=  c; c  = ( *p <  c );
    #####:  933:        *p += tmp; c += ( *p < tmp );
        -:  934:    }
        -:  935:
    #####:  936:    while( c != 0 )
        -:  937:    {
    #####:  938:        if( i >= X->n )
        -:  939:        {
    #####:  940:            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + 1 ) );
    #####:  941:            p = X->p + i;
        -:  942:        }
        -:  943:
    #####:  944:        *p += c; c = ( *p < c ); i++; p++;
        -:  945:    }
        -:  946:
    #####:  947:cleanup:
        -:  948:
    #####:  949:    return( ret );
        -:  950:}
        -:  951:
        -:  952:/*
        -:  953: * Helper for mbedtls_mpi subtraction
        -:  954: */
    #####:  955:static void mpi_sub_hlp( size_t n, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d )
        -:  956:{
        -:  957:    size_t i;
        -:  958:    mbedtls_mpi_uint c, z;
        -:  959:
    #####:  960:    for( i = c = 0; i < n; i++, s++, d++ )
        -:  961:    {
    #####:  962:        z = ( *d <  c );     *d -=  c;
    #####:  963:        c = ( *d < *s ) + z; *d -= *s;
        -:  964:    }
        -:  965:
    #####:  966:    while( c != 0 )
        -:  967:    {
    #####:  968:        z = ( *d < c ); *d -= c;
    #####:  969:        c = z; d++;
        -:  970:    }
    #####:  971:}
        -:  972:
        -:  973:/*
        -:  974: * Unsigned subtraction: X = |A| - |B|  (HAC 14.9)
        -:  975: */
    #####:  976:int mbedtls_mpi_sub_abs( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B )
        -:  977:{
        -:  978:    mbedtls_mpi TB;
        -:  979:    int ret;
        -:  980:    size_t n;
        -:  981:
    #####:  982:    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
    #####:  983:        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
        -:  984:
    #####:  985:    mbedtls_mpi_init( &TB );
        -:  986:
    #####:  987:    if( X == B )
        -:  988:    {
    #####:  989:        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) );
    #####:  990:        B = &TB;
        -:  991:    }
        -:  992:
    #####:  993:    if( X != A )
    #####:  994:        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, A ) );
        -:  995:
        -:  996:    /*
        -:  997:     * X should always be positive as a result of unsigned subtractions.
        -:  998:     */
    #####:  999:    X->s = 1;
        -: 1000:
    #####: 1001:    ret = 0;
        -: 1002:
    #####: 1003:    for( n = B->n; n > 0; n-- )
    #####: 1004:        if( B->p[n - 1] != 0 )
    #####: 1005:            break;
        -: 1006:
    #####: 1007:    mpi_sub_hlp( n, B->p, X->p );
        -: 1008:
    #####: 1009:cleanup:
        -: 1010:
    #####: 1011:    mbedtls_mpi_free( &TB );
        -: 1012:
    #####: 1013:    return( ret );
        -: 1014:}
        -: 1015:
        -: 1016:/*
        -: 1017: * Signed addition: X = A + B
        -: 1018: */
    #####: 1019:int mbedtls_mpi_add_mpi( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B )
        -: 1020:{
    #####: 1021:    int ret, s = A->s;
        -: 1022:
    #####: 1023:    if( A->s * B->s < 0 )
        -: 1024:    {
    #####: 1025:        if( mbedtls_mpi_cmp_abs( A, B ) >= 0 )
        -: 1026:        {
    #####: 1027:            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );
    #####: 1028:            X->s =  s;
        -: 1029:        }
        -: 1030:        else
        -: 1031:        {
    #####: 1032:            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
    #####: 1033:            X->s = -s;
        -: 1034:        }
        -: 1035:    }
        -: 1036:    else
        -: 1037:    {
    #####: 1038:        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
    #####: 1039:        X->s = s;
        -: 1040:    }
        -: 1041:
    #####: 1042:cleanup:
        -: 1043:
    #####: 1044:    return( ret );
        -: 1045:}
        -: 1046:
        -: 1047:/*
        -: 1048: * Signed subtraction: X = A - B
        -: 1049: */
    #####: 1050:int mbedtls_mpi_sub_mpi( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B )
        -: 1051:{
    #####: 1052:    int ret, s = A->s;
        -: 1053:
    #####: 1054:    if( A->s * B->s > 0 )
        -: 1055:    {
    #####: 1056:        if( mbedtls_mpi_cmp_abs( A, B ) >= 0 )
        -: 1057:        {
    #####: 1058:            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, A, B ) );
    #####: 1059:            X->s =  s;
        -: 1060:        }
        -: 1061:        else
        -: 1062:        {
    #####: 1063:            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( X, B, A ) );
    #####: 1064:            X->s = -s;
        -: 1065:        }
        -: 1066:    }
        -: 1067:    else
        -: 1068:    {
    #####: 1069:        MBEDTLS_MPI_CHK( mbedtls_mpi_add_abs( X, A, B ) );
    #####: 1070:        X->s = s;
        -: 1071:    }
        -: 1072:
    #####: 1073:cleanup:
        -: 1074:
    #####: 1075:    return( ret );
        -: 1076:}
        -: 1077:
        -: 1078:/*
        -: 1079: * Signed addition: X = A + b
        -: 1080: */
    #####: 1081:int mbedtls_mpi_add_int( mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_sint b )
        -: 1082:{
        -: 1083:    mbedtls_mpi _B;
        -: 1084:    mbedtls_mpi_uint p[1];
        -: 1085:
    #####: 1086:    p[0] = ( b < 0 ) ? -b : b;
    #####: 1087:    _B.s = ( b < 0 ) ? -1 : 1;
    #####: 1088:    _B.n = 1;
    #####: 1089:    _B.p = p;
        -: 1090:
    #####: 1091:    return( mbedtls_mpi_add_mpi( X, A, &_B ) );
        -: 1092:}
        -: 1093:
        -: 1094:/*
        -: 1095: * Signed subtraction: X = A - b
        -: 1096: */
    #####: 1097:int mbedtls_mpi_sub_int( mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_sint b )
        -: 1098:{
        -: 1099:    mbedtls_mpi _B;
        -: 1100:    mbedtls_mpi_uint p[1];
        -: 1101:
    #####: 1102:    p[0] = ( b < 0 ) ? -b : b;
    #####: 1103:    _B.s = ( b < 0 ) ? -1 : 1;
    #####: 1104:    _B.n = 1;
    #####: 1105:    _B.p = p;
        -: 1106:
    #####: 1107:    return( mbedtls_mpi_sub_mpi( X, A, &_B ) );
        -: 1108:}
        -: 1109:
        -: 1110:/*
        -: 1111: * Helper for mbedtls_mpi multiplication
        -: 1112: */
        -: 1113:static
        -: 1114:#if defined(__APPLE__) && defined(__arm__)
        -: 1115:/*
        -: 1116: * Apple LLVM version 4.2 (clang-425.0.24) (based on LLVM 3.2svn)
        -: 1117: * appears to need this to prevent bad ARM code generation at -O3.
        -: 1118: */
        -: 1119:__attribute__ ((noinline))
        -: 1120:#endif
    #####: 1121:void mpi_mul_hlp( size_t i, mbedtls_mpi_uint *s, mbedtls_mpi_uint *d, mbedtls_mpi_uint b )
        -: 1122:{
    #####: 1123:    mbedtls_mpi_uint c = 0, t = 0;
        -: 1124:
        -: 1125:#if defined(MULADDC_HUIT)
        -: 1126:    for( ; i >= 8; i -= 8 )
        -: 1127:    {
        -: 1128:        MULADDC_INIT
        -: 1129:        MULADDC_HUIT
        -: 1130:        MULADDC_STOP
        -: 1131:    }
        -: 1132:
        -: 1133:    for( ; i > 0; i-- )
        -: 1134:    {
        -: 1135:        MULADDC_INIT
        -: 1136:        MULADDC_CORE
        -: 1137:        MULADDC_STOP
        -: 1138:    }
        -: 1139:#else /* MULADDC_HUIT */
    #####: 1140:    for( ; i >= 16; i -= 16 )
        -: 1141:    {
    #####: 1142:        MULADDC_INIT
        -: 1143:        MULADDC_CORE   MULADDC_CORE
        -: 1144:        MULADDC_CORE   MULADDC_CORE
        -: 1145:        MULADDC_CORE   MULADDC_CORE
        -: 1146:        MULADDC_CORE   MULADDC_CORE
        -: 1147:
        -: 1148:        MULADDC_CORE   MULADDC_CORE
        -: 1149:        MULADDC_CORE   MULADDC_CORE
        -: 1150:        MULADDC_CORE   MULADDC_CORE
        -: 1151:        MULADDC_CORE   MULADDC_CORE
        -: 1152:        MULADDC_STOP
        -: 1153:    }
        -: 1154:
    #####: 1155:    for( ; i >= 8; i -= 8 )
        -: 1156:    {
    #####: 1157:        MULADDC_INIT
        -: 1158:        MULADDC_CORE   MULADDC_CORE
        -: 1159:        MULADDC_CORE   MULADDC_CORE
        -: 1160:
        -: 1161:        MULADDC_CORE   MULADDC_CORE
        -: 1162:        MULADDC_CORE   MULADDC_CORE
        -: 1163:        MULADDC_STOP
        -: 1164:    }
        -: 1165:
    #####: 1166:    for( ; i > 0; i-- )
        -: 1167:    {
    #####: 1168:        MULADDC_INIT
        -: 1169:        MULADDC_CORE
        -: 1170:        MULADDC_STOP
        -: 1171:    }
        -: 1172:#endif /* MULADDC_HUIT */
        -: 1173:
    #####: 1174:    t++;
        -: 1175:
        -: 1176:    do {
    #####: 1177:        *d += c; c = ( *d < c ); d++;
        -: 1178:    }
    #####: 1179:    while( c != 0 );
    #####: 1180:}
        -: 1181:
        -: 1182:/*
        -: 1183: * Baseline multiplication: X = A * B  (HAC 14.12)
        -: 1184: */
    #####: 1185:int mbedtls_mpi_mul_mpi( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *B )
        -: 1186:{
        -: 1187:    int ret;
        -: 1188:    size_t i, j;
        -: 1189:    mbedtls_mpi TA, TB;
        -: 1190:
    #####: 1191:    mbedtls_mpi_init( &TA ); mbedtls_mpi_init( &TB );
        -: 1192:
    #####: 1193:    if( X == A ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) ); A = &TA; }
    #####: 1194:    if( X == B ) { MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) ); B = &TB; }
        -: 1195:
    #####: 1196:    for( i = A->n; i > 0; i-- )
    #####: 1197:        if( A->p[i - 1] != 0 )
    #####: 1198:            break;
        -: 1199:
    #####: 1200:    for( j = B->n; j > 0; j-- )
    #####: 1201:        if( B->p[j - 1] != 0 )
    #####: 1202:            break;
        -: 1203:
    #####: 1204:    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, i + j ) );
    #####: 1205:    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( X, 0 ) );
        -: 1206:
    #####: 1207:    for( ; j > 0; j-- )
    #####: 1208:        mpi_mul_hlp( i, A->p, X->p + j - 1, B->p[j - 1] );
        -: 1209:
    #####: 1210:    X->s = A->s * B->s;
        -: 1211:
    #####: 1212:cleanup:
        -: 1213:
    #####: 1214:    mbedtls_mpi_free( &TB ); mbedtls_mpi_free( &TA );
        -: 1215:
    #####: 1216:    return( ret );
        -: 1217:}
        -: 1218:
        -: 1219:/*
        -: 1220: * Baseline multiplication: X = A * b
        -: 1221: */
    #####: 1222:int mbedtls_mpi_mul_int( mbedtls_mpi *X, const mbedtls_mpi *A, mbedtls_mpi_uint b )
        -: 1223:{
        -: 1224:    mbedtls_mpi _B;
        -: 1225:    mbedtls_mpi_uint p[1];
        -: 1226:
    #####: 1227:    _B.s = 1;
    #####: 1228:    _B.n = 1;
    #####: 1229:    _B.p = p;
    #####: 1230:    p[0] = b;
        -: 1231:
    #####: 1232:    return( mbedtls_mpi_mul_mpi( X, A, &_B ) );
        -: 1233:}
        -: 1234:
        -: 1235:/*
        -: 1236: * Unsigned integer divide - double mbedtls_mpi_uint dividend, u1/u0, and
        -: 1237: * mbedtls_mpi_uint divisor, d
        -: 1238: */
    #####: 1239:static mbedtls_mpi_uint mbedtls_int_div_int( mbedtls_mpi_uint u1,
        -: 1240:            mbedtls_mpi_uint u0, mbedtls_mpi_uint d, mbedtls_mpi_uint *r )
        -: 1241:{
        -: 1242:#if defined(MBEDTLS_HAVE_UDBL)
        -: 1243:    mbedtls_t_udbl dividend, quotient;
        -: 1244:#else
        -: 1245:    const mbedtls_mpi_uint radix = (mbedtls_mpi_uint) 1 << biH;
        -: 1246:    const mbedtls_mpi_uint uint_halfword_mask = ( (mbedtls_mpi_uint) 1 << biH ) - 1;
        -: 1247:    mbedtls_mpi_uint d0, d1, q0, q1, rAX, r0, quotient;
        -: 1248:    mbedtls_mpi_uint u0_msw, u0_lsw;
        -: 1249:    size_t s;
        -: 1250:#endif
        -: 1251:
        -: 1252:    /*
        -: 1253:     * Check for overflow
        -: 1254:     */
    #####: 1255:    if( 0 == d || u1 >= d )
        -: 1256:    {
    #####: 1257:        if (r != NULL) *r = ~0;
        -: 1258:
    #####: 1259:        return ( ~0 );
        -: 1260:    }
        -: 1261:
        -: 1262:#if defined(MBEDTLS_HAVE_UDBL)
    #####: 1263:    dividend  = (mbedtls_t_udbl) u1 << biL;
    #####: 1264:    dividend |= (mbedtls_t_udbl) u0;
    #####: 1265:    quotient = dividend / d;
    #####: 1266:    if( quotient > ( (mbedtls_t_udbl) 1 << biL ) - 1 )
    #####: 1267:        quotient = ( (mbedtls_t_udbl) 1 << biL ) - 1;
        -: 1268:
    #####: 1269:    if( r != NULL )
    #####: 1270:        *r = (mbedtls_mpi_uint)( dividend - (quotient * d ) );
        -: 1271:
    #####: 1272:    return (mbedtls_mpi_uint) quotient;
        -: 1273:#else
        -: 1274:
        -: 1275:    /*
        -: 1276:     * Algorithm D, Section 4.3.1 - The Art of Computer Programming
        -: 1277:     *   Vol. 2 - Seminumerical Algorithms, Knuth
        -: 1278:     */
        -: 1279:
        -: 1280:    /*
        -: 1281:     * Normalize the divisor, d, and dividend, u0, u1
        -: 1282:     */
        -: 1283:    s = mbedtls_clz( d );
        -: 1284:    d = d << s;
        -: 1285:
        -: 1286:    u1 = u1 << s;
        -: 1287:    u1 |= ( u0 >> ( biL - s ) ) & ( -(mbedtls_mpi_sint)s >> ( biL - 1 ) );
        -: 1288:    u0 =  u0 << s;
        -: 1289:
        -: 1290:    d1 = d >> biH;
        -: 1291:    d0 = d & uint_halfword_mask;
        -: 1292:
        -: 1293:    u0_msw = u0 >> biH;
        -: 1294:    u0_lsw = u0 & uint_halfword_mask;
        -: 1295:
        -: 1296:    /*
        -: 1297:     * Find the first quotient and remainder
        -: 1298:     */
        -: 1299:    q1 = u1 / d1;
        -: 1300:    r0 = u1 - d1 * q1;
        -: 1301:
        -: 1302:    while( q1 >= radix || ( q1 * d0 > radix * r0 + u0_msw ) )
        -: 1303:    {
        -: 1304:        q1 -= 1;
        -: 1305:        r0 += d1;
        -: 1306:
        -: 1307:        if ( r0 >= radix ) break;
        -: 1308:    }
        -: 1309:
        -: 1310:    rAX = ( u1 * radix ) + ( u0_msw - q1 * d );
        -: 1311:    q0 = rAX / d1;
        -: 1312:    r0 = rAX - q0 * d1;
        -: 1313:
        -: 1314:    while( q0 >= radix || ( q0 * d0 > radix * r0 + u0_lsw ) )
        -: 1315:    {
        -: 1316:        q0 -= 1;
        -: 1317:        r0 += d1;
        -: 1318:
        -: 1319:        if ( r0 >= radix ) break;
        -: 1320:    }
        -: 1321:
        -: 1322:    if (r != NULL)
        -: 1323:        *r = ( rAX * radix + u0_lsw - q0 * d ) >> s;
        -: 1324:
        -: 1325:    quotient = q1 * radix + q0;
        -: 1326:
        -: 1327:    return quotient;
        -: 1328:#endif
        -: 1329:}
        -: 1330:
        -: 1331:/*
        -: 1332: * Division by mbedtls_mpi: A = Q * B + R  (HAC 14.20)
        -: 1333: */
    #####: 1334:int mbedtls_mpi_div_mpi( mbedtls_mpi *Q, mbedtls_mpi *R, const mbedtls_mpi *A, const mbedtls_mpi *B )
        -: 1335:{
        -: 1336:    int ret;
        -: 1337:    size_t i, n, t, k;
        -: 1338:    mbedtls_mpi X, Y, Z, T1, T2;
        -: 1339:
    #####: 1340:    if( mbedtls_mpi_cmp_int( B, 0 ) == 0 )
    #####: 1341:        return( MBEDTLS_ERR_MPI_DIVISION_BY_ZERO );
        -: 1342:
    #####: 1343:    mbedtls_mpi_init( &X ); mbedtls_mpi_init( &Y ); mbedtls_mpi_init( &Z );
    #####: 1344:    mbedtls_mpi_init( &T1 ); mbedtls_mpi_init( &T2 );
        -: 1345:
    #####: 1346:    if( mbedtls_mpi_cmp_abs( A, B ) < 0 )
        -: 1347:    {
    #####: 1348:        if( Q != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_lset( Q, 0 ) );
    #####: 1349:        if( R != NULL ) MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, A ) );
    #####: 1350:        return( 0 );
        -: 1351:    }
        -: 1352:
    #####: 1353:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &X, A ) );
    #####: 1354:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Y, B ) );
    #####: 1355:    X.s = Y.s = 1;
        -: 1356:
    #####: 1357:    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &Z, A->n + 2 ) );
    #####: 1358:    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &Z,  0 ) );
    #####: 1359:    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T1, 2 ) );
    #####: 1360:    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T2, 3 ) );
        -: 1361:
    #####: 1362:    k = mbedtls_mpi_bitlen( &Y ) % biL;
    #####: 1363:    if( k < biL - 1 )
        -: 1364:    {
    #####: 1365:        k = biL - 1 - k;
    #####: 1366:        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &X, k ) );
    #####: 1367:        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, k ) );
        -: 1368:    }
    #####: 1369:    else k = 0;
        -: 1370:
    #####: 1371:    n = X.n - 1;
    #####: 1372:    t = Y.n - 1;
    #####: 1373:    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &Y, biL * ( n - t ) ) );
        -: 1374:
    #####: 1375:    while( mbedtls_mpi_cmp_mpi( &X, &Y ) >= 0 )
        -: 1376:    {
    #####: 1377:        Z.p[n - t]++;
    #####: 1378:        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &Y ) );
        -: 1379:    }
    #####: 1380:    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &Y, biL * ( n - t ) ) );
        -: 1381:
    #####: 1382:    for( i = n; i > t ; i-- )
        -: 1383:    {
    #####: 1384:        if( X.p[i] >= Y.p[t] )
    #####: 1385:            Z.p[i - t - 1] = ~0;
        -: 1386:        else
        -: 1387:        {
    #####: 1388:            Z.p[i - t - 1] = mbedtls_int_div_int( X.p[i], X.p[i - 1],
    #####: 1389:                                                            Y.p[t], NULL);
        -: 1390:        }
        -: 1391:
    #####: 1392:        Z.p[i - t - 1]++;
        -: 1393:        do
        -: 1394:        {
    #####: 1395:            Z.p[i - t - 1]--;
        -: 1396:
    #####: 1397:            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T1, 0 ) );
    #####: 1398:            T1.p[0] = ( t < 1 ) ? 0 : Y.p[t - 1];
    #####: 1399:            T1.p[1] = Y.p[t];
    #####: 1400:            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &T1, Z.p[i - t - 1] ) );
        -: 1401:
    #####: 1402:            MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &T2, 0 ) );
    #####: 1403:            T2.p[0] = ( i < 2 ) ? 0 : X.p[i - 2];
    #####: 1404:            T2.p[1] = ( i < 1 ) ? 0 : X.p[i - 1];
    #####: 1405:            T2.p[2] = X.p[i];
        -: 1406:        }
    #####: 1407:        while( mbedtls_mpi_cmp_mpi( &T1, &T2 ) > 0 );
        -: 1408:
    #####: 1409:        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_int( &T1, &Y, Z.p[i - t - 1] ) );
    #####: 1410:        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T1,  biL * ( i - t - 1 ) ) );
    #####: 1411:        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &X, &X, &T1 ) );
        -: 1412:
    #####: 1413:        if( mbedtls_mpi_cmp_int( &X, 0 ) < 0 )
        -: 1414:        {
    #####: 1415:            MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &T1, &Y ) );
    #####: 1416:            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &T1, biL * ( i - t - 1 ) ) );
    #####: 1417:            MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &X, &X, &T1 ) );
    #####: 1418:            Z.p[i - t - 1]--;
        -: 1419:        }
        -: 1420:    }
        -: 1421:
    #####: 1422:    if( Q != NULL )
        -: 1423:    {
    #####: 1424:        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( Q, &Z ) );
    #####: 1425:        Q->s = A->s * B->s;
        -: 1426:    }
        -: 1427:
    #####: 1428:    if( R != NULL )
        -: 1429:    {
    #####: 1430:        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &X, k ) );
    #####: 1431:        X.s = A->s;
    #####: 1432:        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( R, &X ) );
        -: 1433:
    #####: 1434:        if( mbedtls_mpi_cmp_int( R, 0 ) == 0 )
    #####: 1435:            R->s = 1;
        -: 1436:    }
        -: 1437:
    #####: 1438:cleanup:
        -: 1439:
    #####: 1440:    mbedtls_mpi_free( &X ); mbedtls_mpi_free( &Y ); mbedtls_mpi_free( &Z );
    #####: 1441:    mbedtls_mpi_free( &T1 ); mbedtls_mpi_free( &T2 );
        -: 1442:
    #####: 1443:    return( ret );
        -: 1444:}
        -: 1445:
        -: 1446:/*
        -: 1447: * Division by int: A = Q * b + R
        -: 1448: */
    #####: 1449:int mbedtls_mpi_div_int( mbedtls_mpi *Q, mbedtls_mpi *R, const mbedtls_mpi *A, mbedtls_mpi_sint b )
        -: 1450:{
        -: 1451:    mbedtls_mpi _B;
        -: 1452:    mbedtls_mpi_uint p[1];
        -: 1453:
    #####: 1454:    p[0] = ( b < 0 ) ? -b : b;
    #####: 1455:    _B.s = ( b < 0 ) ? -1 : 1;
    #####: 1456:    _B.n = 1;
    #####: 1457:    _B.p = p;
        -: 1458:
    #####: 1459:    return( mbedtls_mpi_div_mpi( Q, R, A, &_B ) );
        -: 1460:}
        -: 1461:
        -: 1462:/*
        -: 1463: * Modulo: R = A mod B
        -: 1464: */
    #####: 1465:int mbedtls_mpi_mod_mpi( mbedtls_mpi *R, const mbedtls_mpi *A, const mbedtls_mpi *B )
        -: 1466:{
        -: 1467:    int ret;
        -: 1468:
    #####: 1469:    if( mbedtls_mpi_cmp_int( B, 0 ) < 0 )
    #####: 1470:        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
        -: 1471:
    #####: 1472:    MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( NULL, R, A, B ) );
        -: 1473:
    #####: 1474:    while( mbedtls_mpi_cmp_int( R, 0 ) < 0 )
    #####: 1475:      MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( R, R, B ) );
        -: 1476:
    #####: 1477:    while( mbedtls_mpi_cmp_mpi( R, B ) >= 0 )
    #####: 1478:      MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( R, R, B ) );
        -: 1479:
    #####: 1480:cleanup:
        -: 1481:
    #####: 1482:    return( ret );
        -: 1483:}
        -: 1484:
        -: 1485:/*
        -: 1486: * Modulo: r = A mod b
        -: 1487: */
    #####: 1488:int mbedtls_mpi_mod_int( mbedtls_mpi_uint *r, const mbedtls_mpi *A, mbedtls_mpi_sint b )
        -: 1489:{
        -: 1490:    size_t i;
        -: 1491:    mbedtls_mpi_uint x, y, z;
        -: 1492:
    #####: 1493:    if( b == 0 )
    #####: 1494:        return( MBEDTLS_ERR_MPI_DIVISION_BY_ZERO );
        -: 1495:
    #####: 1496:    if( b < 0 )
    #####: 1497:        return( MBEDTLS_ERR_MPI_NEGATIVE_VALUE );
        -: 1498:
        -: 1499:    /*
        -: 1500:     * handle trivial cases
        -: 1501:     */
    #####: 1502:    if( b == 1 )
        -: 1503:    {
    #####: 1504:        *r = 0;
    #####: 1505:        return( 0 );
        -: 1506:    }
        -: 1507:
    #####: 1508:    if( b == 2 )
        -: 1509:    {
    #####: 1510:        *r = A->p[0] & 1;
    #####: 1511:        return( 0 );
        -: 1512:    }
        -: 1513:
        -: 1514:    /*
        -: 1515:     * general case
        -: 1516:     */
    #####: 1517:    for( i = A->n, y = 0; i > 0; i-- )
        -: 1518:    {
    #####: 1519:        x  = A->p[i - 1];
    #####: 1520:        y  = ( y << biH ) | ( x >> biH );
    #####: 1521:        z  = y / b;
    #####: 1522:        y -= z * b;
        -: 1523:
    #####: 1524:        x <<= biH;
    #####: 1525:        y  = ( y << biH ) | ( x >> biH );
    #####: 1526:        z  = y / b;
    #####: 1527:        y -= z * b;
        -: 1528:    }
        -: 1529:
        -: 1530:    /*
        -: 1531:     * If A is negative, then the current y represents a negative value.
        -: 1532:     * Flipping it to the positive side.
        -: 1533:     */
    #####: 1534:    if( A->s < 0 && y != 0 )
    #####: 1535:        y = b - y;
        -: 1536:
    #####: 1537:    *r = y;
        -: 1538:
    #####: 1539:    return( 0 );
        -: 1540:}
        -: 1541:
        -: 1542:/*
        -: 1543: * Fast Montgomery initialization (thanks to Tom St Denis)
        -: 1544: */
    #####: 1545:static void mpi_montg_init( mbedtls_mpi_uint *mm, const mbedtls_mpi *N )
        -: 1546:{
    #####: 1547:    mbedtls_mpi_uint x, m0 = N->p[0];
        -: 1548:    unsigned int i;
        -: 1549:
    #####: 1550:    x  = m0;
    #####: 1551:    x += ( ( m0 + 2 ) & 4 ) << 1;
        -: 1552:
    #####: 1553:    for( i = biL; i >= 8; i /= 2 )
    #####: 1554:        x *= ( 2 - ( m0 * x ) );
        -: 1555:
    #####: 1556:    *mm = ~x + 1;
    #####: 1557:}
        -: 1558:
        -: 1559:/*
        -: 1560: * Montgomery multiplication: A = A * B * R^-1 mod N  (HAC 14.36)
        -: 1561: */
    #####: 1562:static int mpi_montmul( mbedtls_mpi *A, const mbedtls_mpi *B, const mbedtls_mpi *N, mbedtls_mpi_uint mm,
        -: 1563:                         const mbedtls_mpi *T )
        -: 1564:{
        -: 1565:    size_t i, n, m;
        -: 1566:    mbedtls_mpi_uint u0, u1, *d;
        -: 1567:
    #####: 1568:    if( T->n < N->n + 1 || T->p == NULL )
    #####: 1569:        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
        -: 1570:
    #####: 1571:    memset( T->p, 0, T->n * ciL );
        -: 1572:
    #####: 1573:    d = T->p;
    #####: 1574:    n = N->n;
    #####: 1575:    m = ( B->n < n ) ? B->n : n;
        -: 1576:
    #####: 1577:    for( i = 0; i < n; i++ )
        -: 1578:    {
        -: 1579:        /*
        -: 1580:         * T = (T + u0*B + u1*N) / 2^biL
        -: 1581:         */
    #####: 1582:        u0 = A->p[i];
    #####: 1583:        u1 = ( d[0] + u0 * B->p[0] ) * mm;
        -: 1584:
    #####: 1585:        mpi_mul_hlp( m, B->p, d, u0 );
    #####: 1586:        mpi_mul_hlp( n, N->p, d, u1 );
        -: 1587:
    #####: 1588:        *d++ = u0; d[n + 1] = 0;
        -: 1589:    }
        -: 1590:
    #####: 1591:    memcpy( A->p, d, ( n + 1 ) * ciL );
        -: 1592:
    #####: 1593:    if( mbedtls_mpi_cmp_abs( A, N ) >= 0 )
    #####: 1594:        mpi_sub_hlp( n, N->p, A->p );
        -: 1595:    else
        -: 1596:        /* prevent timing attacks */
    #####: 1597:        mpi_sub_hlp( n, A->p, T->p );
        -: 1598:
    #####: 1599:    return( 0 );
        -: 1600:}
        -: 1601:
        -: 1602:/*
        -: 1603: * Montgomery reduction: A = A * R^-1 mod N
        -: 1604: */
    #####: 1605:static int mpi_montred( mbedtls_mpi *A, const mbedtls_mpi *N, mbedtls_mpi_uint mm, const mbedtls_mpi *T )
        -: 1606:{
    #####: 1607:    mbedtls_mpi_uint z = 1;
        -: 1608:    mbedtls_mpi U;
        -: 1609:
    #####: 1610:    U.n = U.s = (int) z;
    #####: 1611:    U.p = &z;
        -: 1612:
    #####: 1613:    return( mpi_montmul( A, &U, N, mm, T ) );
        -: 1614:}
        -: 1615:
        -: 1616:/*
        -: 1617: * Sliding-window exponentiation: X = A^E mod N  (HAC 14.85)
        -: 1618: */
    #####: 1619:int mbedtls_mpi_exp_mod( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *E, const mbedtls_mpi *N, mbedtls_mpi *_RR )
        -: 1620:{
        -: 1621:    int ret;
    #####: 1622:    size_t wbits, wsize, one = 1;
        -: 1623:    size_t i, j, nblimbs;
        -: 1624:    size_t bufsize, nbits;
        -: 1625:    mbedtls_mpi_uint ei, mm, state;
        -: 1626:    mbedtls_mpi RR, T, W[ 2 << MBEDTLS_MPI_WINDOW_SIZE ], Apos;
        -: 1627:    int neg;
        -: 1628:
    #####: 1629:    if( mbedtls_mpi_cmp_int( N, 0 ) <= 0 || ( N->p[0] & 1 ) == 0 )
    #####: 1630:        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
        -: 1631:
    #####: 1632:    if( mbedtls_mpi_cmp_int( E, 0 ) < 0 )
    #####: 1633:        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
        -: 1634:
        -: 1635:    /*
        -: 1636:     * Init temps and window size
        -: 1637:     */
    #####: 1638:    mpi_montg_init( &mm, N );
    #####: 1639:    mbedtls_mpi_init( &RR ); mbedtls_mpi_init( &T );
    #####: 1640:    mbedtls_mpi_init( &Apos );
    #####: 1641:    memset( W, 0, sizeof( W ) );
        -: 1642:
    #####: 1643:    i = mbedtls_mpi_bitlen( E );
        -: 1644:
    #####: 1645:    wsize = ( i > 671 ) ? 6 : ( i > 239 ) ? 5 :
        -: 1646:            ( i >  79 ) ? 4 : ( i >  23 ) ? 3 : 1;
        -: 1647:
    #####: 1648:    if( wsize > MBEDTLS_MPI_WINDOW_SIZE )
    #####: 1649:        wsize = MBEDTLS_MPI_WINDOW_SIZE;
        -: 1650:
    #####: 1651:    j = N->n + 1;
    #####: 1652:    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( X, j ) );
    #####: 1653:    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[1],  j ) );
    #####: 1654:    MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &T, j * 2 ) );
        -: 1655:
        -: 1656:    /*
        -: 1657:     * Compensate for negative A (and correct at the end)
        -: 1658:     */
    #####: 1659:    neg = ( A->s == -1 );
    #####: 1660:    if( neg )
        -: 1661:    {
    #####: 1662:        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Apos, A ) );
    #####: 1663:        Apos.s = 1;
    #####: 1664:        A = &Apos;
        -: 1665:    }
        -: 1666:
        -: 1667:    /*
        -: 1668:     * If 1st call, pre-compute R^2 mod N
        -: 1669:     */
    #####: 1670:    if( _RR == NULL || _RR->p == NULL )
        -: 1671:    {
    #####: 1672:        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &RR, 1 ) );
    #####: 1673:        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &RR, N->n * 2 * biL ) );
    #####: 1674:        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &RR, &RR, N ) );
        -: 1675:
    #####: 1676:        if( _RR != NULL )
    #####: 1677:            memcpy( _RR, &RR, sizeof( mbedtls_mpi ) );
        -: 1678:    }
        -: 1679:    else
    #####: 1680:        memcpy( &RR, _RR, sizeof( mbedtls_mpi ) );
        -: 1681:
        -: 1682:    /*
        -: 1683:     * W[1] = A * R^2 * R^-1 mod N = A * R mod N
        -: 1684:     */
    #####: 1685:    if( mbedtls_mpi_cmp_mpi( A, N ) >= 0 )
    #####: 1686:        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &W[1], A, N ) );
        -: 1687:    else
    #####: 1688:        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[1], A ) );
        -: 1689:
    #####: 1690:    MBEDTLS_MPI_CHK( mpi_montmul( &W[1], &RR, N, mm, &T ) );
        -: 1691:
        -: 1692:    /*
        -: 1693:     * X = R^2 * R^-1 mod N = R mod N
        -: 1694:     */
    #####: 1695:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, &RR ) );
    #####: 1696:    MBEDTLS_MPI_CHK( mpi_montred( X, N, mm, &T ) );
        -: 1697:
    #####: 1698:    if( wsize > 1 )
        -: 1699:    {
        -: 1700:        /*
        -: 1701:         * W[1 << (wsize - 1)] = W[1] ^ (wsize - 1)
        -: 1702:         */
    #####: 1703:        j =  one << ( wsize - 1 );
        -: 1704:
    #####: 1705:        MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[j], N->n + 1 ) );
    #####: 1706:        MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[j], &W[1]    ) );
        -: 1707:
    #####: 1708:        for( i = 0; i < wsize - 1; i++ )
    #####: 1709:            MBEDTLS_MPI_CHK( mpi_montmul( &W[j], &W[j], N, mm, &T ) );
        -: 1710:
        -: 1711:        /*
        -: 1712:         * W[i] = W[i - 1] * W[1]
        -: 1713:         */
    #####: 1714:        for( i = j + 1; i < ( one << wsize ); i++ )
        -: 1715:        {
    #####: 1716:            MBEDTLS_MPI_CHK( mbedtls_mpi_grow( &W[i], N->n + 1 ) );
    #####: 1717:            MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &W[i], &W[i - 1] ) );
        -: 1718:
    #####: 1719:            MBEDTLS_MPI_CHK( mpi_montmul( &W[i], &W[1], N, mm, &T ) );
        -: 1720:        }
        -: 1721:    }
        -: 1722:
    #####: 1723:    nblimbs = E->n;
    #####: 1724:    bufsize = 0;
    #####: 1725:    nbits   = 0;
    #####: 1726:    wbits   = 0;
    #####: 1727:    state   = 0;
        -: 1728:
        -: 1729:    while( 1 )
        -: 1730:    {
    #####: 1731:        if( bufsize == 0 )
        -: 1732:        {
    #####: 1733:            if( nblimbs == 0 )
    #####: 1734:                break;
        -: 1735:
    #####: 1736:            nblimbs--;
        -: 1737:
    #####: 1738:            bufsize = sizeof( mbedtls_mpi_uint ) << 3;
        -: 1739:        }
        -: 1740:
    #####: 1741:        bufsize--;
        -: 1742:
    #####: 1743:        ei = (E->p[nblimbs] >> bufsize) & 1;
        -: 1744:
        -: 1745:        /*
        -: 1746:         * skip leading 0s
        -: 1747:         */
    #####: 1748:        if( ei == 0 && state == 0 )
    #####: 1749:            continue;
        -: 1750:
    #####: 1751:        if( ei == 0 && state == 1 )
        -: 1752:        {
        -: 1753:            /*
        -: 1754:             * out of window, square X
        -: 1755:             */
    #####: 1756:            MBEDTLS_MPI_CHK( mpi_montmul( X, X, N, mm, &T ) );
    #####: 1757:            continue;
        -: 1758:        }
        -: 1759:
        -: 1760:        /*
        -: 1761:         * add ei to current window
        -: 1762:         */
    #####: 1763:        state = 2;
        -: 1764:
    #####: 1765:        nbits++;
    #####: 1766:        wbits |= ( ei << ( wsize - nbits ) );
        -: 1767:
    #####: 1768:        if( nbits == wsize )
        -: 1769:        {
        -: 1770:            /*
        -: 1771:             * X = X^wsize R^-1 mod N
        -: 1772:             */
    #####: 1773:            for( i = 0; i < wsize; i++ )
    #####: 1774:                MBEDTLS_MPI_CHK( mpi_montmul( X, X, N, mm, &T ) );
        -: 1775:
        -: 1776:            /*
        -: 1777:             * X = X * W[wbits] R^-1 mod N
        -: 1778:             */
    #####: 1779:            MBEDTLS_MPI_CHK( mpi_montmul( X, &W[wbits], N, mm, &T ) );
        -: 1780:
    #####: 1781:            state--;
    #####: 1782:            nbits = 0;
    #####: 1783:            wbits = 0;
        -: 1784:        }
        -: 1785:    }
        -: 1786:
        -: 1787:    /*
        -: 1788:     * process the remaining bits
        -: 1789:     */
    #####: 1790:    for( i = 0; i < nbits; i++ )
        -: 1791:    {
    #####: 1792:        MBEDTLS_MPI_CHK( mpi_montmul( X, X, N, mm, &T ) );
        -: 1793:
    #####: 1794:        wbits <<= 1;
        -: 1795:
    #####: 1796:        if( ( wbits & ( one << wsize ) ) != 0 )
    #####: 1797:            MBEDTLS_MPI_CHK( mpi_montmul( X, &W[1], N, mm, &T ) );
        -: 1798:    }
        -: 1799:
        -: 1800:    /*
        -: 1801:     * X = A^E * R * R^-1 mod N = A^E mod N
        -: 1802:     */
    #####: 1803:    MBEDTLS_MPI_CHK( mpi_montred( X, N, mm, &T ) );
        -: 1804:
    #####: 1805:    if( neg && E->n != 0 && ( E->p[0] & 1 ) != 0 )
        -: 1806:    {
    #####: 1807:        X->s = -1;
    #####: 1808:        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( X, N, X ) );
        -: 1809:    }
        -: 1810:
    #####: 1811:cleanup:
        -: 1812:
    #####: 1813:    for( i = ( one << ( wsize - 1 ) ); i < ( one << wsize ); i++ )
    #####: 1814:        mbedtls_mpi_free( &W[i] );
        -: 1815:
    #####: 1816:    mbedtls_mpi_free( &W[1] ); mbedtls_mpi_free( &T ); mbedtls_mpi_free( &Apos );
        -: 1817:
    #####: 1818:    if( _RR == NULL || _RR->p == NULL )
    #####: 1819:        mbedtls_mpi_free( &RR );
        -: 1820:
    #####: 1821:    return( ret );
        -: 1822:}
        -: 1823:
        -: 1824:/*
        -: 1825: * Greatest common divisor: G = gcd(A, B)  (HAC 14.54)
        -: 1826: */
    #####: 1827:int mbedtls_mpi_gcd( mbedtls_mpi *G, const mbedtls_mpi *A, const mbedtls_mpi *B )
        -: 1828:{
        -: 1829:    int ret;
        -: 1830:    size_t lz, lzt;
        -: 1831:    mbedtls_mpi TG, TA, TB;
        -: 1832:
    #####: 1833:    mbedtls_mpi_init( &TG ); mbedtls_mpi_init( &TA ); mbedtls_mpi_init( &TB );
        -: 1834:
    #####: 1835:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TA, A ) );
    #####: 1836:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, B ) );
        -: 1837:
    #####: 1838:    lz = mbedtls_mpi_lsb( &TA );
    #####: 1839:    lzt = mbedtls_mpi_lsb( &TB );
        -: 1840:
    #####: 1841:    if( lzt < lz )
    #####: 1842:        lz = lzt;
        -: 1843:
    #####: 1844:    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, lz ) );
    #####: 1845:    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, lz ) );
        -: 1846:
    #####: 1847:    TA.s = TB.s = 1;
        -: 1848:
    #####: 1849:    while( mbedtls_mpi_cmp_int( &TA, 0 ) != 0 )
        -: 1850:    {
    #####: 1851:        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, mbedtls_mpi_lsb( &TA ) ) );
    #####: 1852:        MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, mbedtls_mpi_lsb( &TB ) ) );
        -: 1853:
    #####: 1854:        if( mbedtls_mpi_cmp_mpi( &TA, &TB ) >= 0 )
        -: 1855:        {
    #####: 1856:            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &TA, &TA, &TB ) );
    #####: 1857:            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TA, 1 ) );
        -: 1858:        }
        -: 1859:        else
        -: 1860:        {
    #####: 1861:            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_abs( &TB, &TB, &TA ) );
    #####: 1862:            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TB, 1 ) );
        -: 1863:        }
        -: 1864:    }
        -: 1865:
    #####: 1866:    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_l( &TB, lz ) );
    #####: 1867:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( G, &TB ) );
        -: 1868:
    #####: 1869:cleanup:
        -: 1870:
    #####: 1871:    mbedtls_mpi_free( &TG ); mbedtls_mpi_free( &TA ); mbedtls_mpi_free( &TB );
        -: 1872:
    #####: 1873:    return( ret );
        -: 1874:}
        -: 1875:
        -: 1876:/*
        -: 1877: * Fill X with size bytes of random.
        -: 1878: *
        -: 1879: * Use a temporary bytes representation to make sure the result is the same
        -: 1880: * regardless of the platform endianness (useful when f_rng is actually
        -: 1881: * deterministic, eg for tests).
        -: 1882: */
    #####: 1883:int mbedtls_mpi_fill_random( mbedtls_mpi *X, size_t size,
        -: 1884:                     int (*f_rng)(void *, unsigned char *, size_t),
        -: 1885:                     void *p_rng )
        -: 1886:{
        -: 1887:    int ret;
        -: 1888:    unsigned char buf[MBEDTLS_MPI_MAX_SIZE];
        -: 1889:
    #####: 1890:    if( size > MBEDTLS_MPI_MAX_SIZE )
    #####: 1891:        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
        -: 1892:
    #####: 1893:    MBEDTLS_MPI_CHK( f_rng( p_rng, buf, size ) );
    #####: 1894:    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( X, buf, size ) );
        -: 1895:
    #####: 1896:cleanup:
    #####: 1897:    mbedtls_platform_zeroize( buf, sizeof( buf ) );
    #####: 1898:    return( ret );
        -: 1899:}
        -: 1900:
        -: 1901:/*
        -: 1902: * Modular inverse: X = A^-1 mod N  (HAC 14.61 / 14.64)
        -: 1903: */
    #####: 1904:int mbedtls_mpi_inv_mod( mbedtls_mpi *X, const mbedtls_mpi *A, const mbedtls_mpi *N )
        -: 1905:{
        -: 1906:    int ret;
        -: 1907:    mbedtls_mpi G, TA, TU, U1, U2, TB, TV, V1, V2;
        -: 1908:
    #####: 1909:    if( mbedtls_mpi_cmp_int( N, 1 ) <= 0 )
    #####: 1910:        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
        -: 1911:
    #####: 1912:    mbedtls_mpi_init( &TA ); mbedtls_mpi_init( &TU ); mbedtls_mpi_init( &U1 ); mbedtls_mpi_init( &U2 );
    #####: 1913:    mbedtls_mpi_init( &G ); mbedtls_mpi_init( &TB ); mbedtls_mpi_init( &TV );
    #####: 1914:    mbedtls_mpi_init( &V1 ); mbedtls_mpi_init( &V2 );
        -: 1915:
    #####: 1916:    MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, A, N ) );
        -: 1917:
    #####: 1918:    if( mbedtls_mpi_cmp_int( &G, 1 ) != 0 )
        -: 1919:    {
    #####: 1920:        ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
    #####: 1921:        goto cleanup;
        -: 1922:    }
        -: 1923:
    #####: 1924:    MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &TA, A, N ) );
    #####: 1925:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TU, &TA ) );
    #####: 1926:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TB, N ) );
    #####: 1927:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &TV, N ) );
        -: 1928:
    #####: 1929:    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &U1, 1 ) );
    #####: 1930:    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &U2, 0 ) );
    #####: 1931:    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &V1, 0 ) );
    #####: 1932:    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &V2, 1 ) );
        -: 1933:
        -: 1934:    do
        -: 1935:    {
    #####: 1936:        while( ( TU.p[0] & 1 ) == 0 )
        -: 1937:        {
    #####: 1938:            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TU, 1 ) );
        -: 1939:
    #####: 1940:            if( ( U1.p[0] & 1 ) != 0 || ( U2.p[0] & 1 ) != 0 )
        -: 1941:            {
    #####: 1942:                MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &U1, &U1, &TB ) );
    #####: 1943:                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U2, &U2, &TA ) );
        -: 1944:            }
        -: 1945:
    #####: 1946:            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U1, 1 ) );
    #####: 1947:            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &U2, 1 ) );
        -: 1948:        }
        -: 1949:
    #####: 1950:        while( ( TV.p[0] & 1 ) == 0 )
        -: 1951:        {
    #####: 1952:            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &TV, 1 ) );
        -: 1953:
    #####: 1954:            if( ( V1.p[0] & 1 ) != 0 || ( V2.p[0] & 1 ) != 0 )
        -: 1955:            {
    #####: 1956:                MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &V1, &V1, &TB ) );
    #####: 1957:                MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V2, &V2, &TA ) );
        -: 1958:            }
        -: 1959:
    #####: 1960:            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &V1, 1 ) );
    #####: 1961:            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &V2, 1 ) );
        -: 1962:        }
        -: 1963:
    #####: 1964:        if( mbedtls_mpi_cmp_mpi( &TU, &TV ) >= 0 )
        -: 1965:        {
    #####: 1966:            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &TU, &TU, &TV ) );
    #####: 1967:            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U1, &U1, &V1 ) );
    #####: 1968:            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &U2, &U2, &V2 ) );
        -: 1969:        }
        -: 1970:        else
        -: 1971:        {
    #####: 1972:            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &TV, &TV, &TU ) );
    #####: 1973:            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V1, &V1, &U1 ) );
    #####: 1974:            MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V2, &V2, &U2 ) );
        -: 1975:        }
        -: 1976:    }
    #####: 1977:    while( mbedtls_mpi_cmp_int( &TU, 0 ) != 0 );
        -: 1978:
    #####: 1979:    while( mbedtls_mpi_cmp_int( &V1, 0 ) < 0 )
    #####: 1980:        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &V1, &V1, N ) );
        -: 1981:
    #####: 1982:    while( mbedtls_mpi_cmp_mpi( &V1, N ) >= 0 )
    #####: 1983:        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &V1, &V1, N ) );
        -: 1984:
    #####: 1985:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( X, &V1 ) );
        -: 1986:
    #####: 1987:cleanup:
        -: 1988:
    #####: 1989:    mbedtls_mpi_free( &TA ); mbedtls_mpi_free( &TU ); mbedtls_mpi_free( &U1 ); mbedtls_mpi_free( &U2 );
    #####: 1990:    mbedtls_mpi_free( &G ); mbedtls_mpi_free( &TB ); mbedtls_mpi_free( &TV );
    #####: 1991:    mbedtls_mpi_free( &V1 ); mbedtls_mpi_free( &V2 );
        -: 1992:
    #####: 1993:    return( ret );
        -: 1994:}
        -: 1995:
        -: 1996:#if defined(MBEDTLS_GENPRIME)
        -: 1997:
        -: 1998:static const int small_prime[] =
        -: 1999:{
        -: 2000:        3,    5,    7,   11,   13,   17,   19,   23,
        -: 2001:       29,   31,   37,   41,   43,   47,   53,   59,
        -: 2002:       61,   67,   71,   73,   79,   83,   89,   97,
        -: 2003:      101,  103,  107,  109,  113,  127,  131,  137,
        -: 2004:      139,  149,  151,  157,  163,  167,  173,  179,
        -: 2005:      181,  191,  193,  197,  199,  211,  223,  227,
        -: 2006:      229,  233,  239,  241,  251,  257,  263,  269,
        -: 2007:      271,  277,  281,  283,  293,  307,  311,  313,
        -: 2008:      317,  331,  337,  347,  349,  353,  359,  367,
        -: 2009:      373,  379,  383,  389,  397,  401,  409,  419,
        -: 2010:      421,  431,  433,  439,  443,  449,  457,  461,
        -: 2011:      463,  467,  479,  487,  491,  499,  503,  509,
        -: 2012:      521,  523,  541,  547,  557,  563,  569,  571,
        -: 2013:      577,  587,  593,  599,  601,  607,  613,  617,
        -: 2014:      619,  631,  641,  643,  647,  653,  659,  661,
        -: 2015:      673,  677,  683,  691,  701,  709,  719,  727,
        -: 2016:      733,  739,  743,  751,  757,  761,  769,  773,
        -: 2017:      787,  797,  809,  811,  821,  823,  827,  829,
        -: 2018:      839,  853,  857,  859,  863,  877,  881,  883,
        -: 2019:      887,  907,  911,  919,  929,  937,  941,  947,
        -: 2020:      953,  967,  971,  977,  983,  991,  997, -103
        -: 2021:};
        -: 2022:
        -: 2023:/*
        -: 2024: * Small divisors test (X must be positive)
        -: 2025: *
        -: 2026: * Return values:
        -: 2027: * 0: no small factor (possible prime, more tests needed)
        -: 2028: * 1: certain prime
        -: 2029: * MBEDTLS_ERR_MPI_NOT_ACCEPTABLE: certain non-prime
        -: 2030: * other negative: error
        -: 2031: */
    #####: 2032:static int mpi_check_small_factors( const mbedtls_mpi *X )
        -: 2033:{
    #####: 2034:    int ret = 0;
        -: 2035:    size_t i;
        -: 2036:    mbedtls_mpi_uint r;
        -: 2037:
    #####: 2038:    if( ( X->p[0] & 1 ) == 0 )
    #####: 2039:        return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );
        -: 2040:
    #####: 2041:    for( i = 0; small_prime[i] > 0; i++ )
        -: 2042:    {
    #####: 2043:        if( mbedtls_mpi_cmp_int( X, small_prime[i] ) <= 0 )
    #####: 2044:            return( 1 );
        -: 2045:
    #####: 2046:        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_int( &r, X, small_prime[i] ) );
        -: 2047:
    #####: 2048:        if( r == 0 )
    #####: 2049:            return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );
        -: 2050:    }
        -: 2051:
    #####: 2052:cleanup:
    #####: 2053:    return( ret );
        -: 2054:}
        -: 2055:
        -: 2056:/*
        -: 2057: * Miller-Rabin pseudo-primality test  (HAC 4.24)
        -: 2058: */
    #####: 2059:static int mpi_miller_rabin( const mbedtls_mpi *X,
        -: 2060:                             int (*f_rng)(void *, unsigned char *, size_t),
        -: 2061:                             void *p_rng )
        -: 2062:{
        -: 2063:    int ret, count;
        -: 2064:    size_t i, j, k, n, s;
        -: 2065:    mbedtls_mpi W, R, T, A, RR;
        -: 2066:
    #####: 2067:    mbedtls_mpi_init( &W ); mbedtls_mpi_init( &R ); mbedtls_mpi_init( &T ); mbedtls_mpi_init( &A );
    #####: 2068:    mbedtls_mpi_init( &RR );
        -: 2069:
        -: 2070:    /*
        -: 2071:     * W = |X| - 1
        -: 2072:     * R = W >> lsb( W )
        -: 2073:     */
    #####: 2074:    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &W, X, 1 ) );
    #####: 2075:    s = mbedtls_mpi_lsb( &W );
    #####: 2076:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &R, &W ) );
    #####: 2077:    MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &R, s ) );
        -: 2078:
    #####: 2079:    i = mbedtls_mpi_bitlen( X );
        -: 2080:    /*
        -: 2081:     * HAC, table 4.4
        -: 2082:     */
    #####: 2083:    n = ( ( i >= 1300 ) ?  2 : ( i >=  850 ) ?  3 :
        -: 2084:          ( i >=  650 ) ?  4 : ( i >=  350 ) ?  8 :
        -: 2085:          ( i >=  250 ) ? 12 : ( i >=  150 ) ? 18 : 27 );
        -: 2086:
    #####: 2087:    for( i = 0; i < n; i++ )
        -: 2088:    {
        -: 2089:        /*
        -: 2090:         * pick a random A, 1 < A < |X| - 1
        -: 2091:         */
    #####: 2092:        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &A, X->n * ciL, f_rng, p_rng ) );
        -: 2093:
    #####: 2094:        if( mbedtls_mpi_cmp_mpi( &A, &W ) >= 0 )
        -: 2095:        {
    #####: 2096:            j = mbedtls_mpi_bitlen( &A ) - mbedtls_mpi_bitlen( &W );
    #####: 2097:            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &A, j + 1 ) );
        -: 2098:        }
    #####: 2099:        A.p[0] |= 3;
        -: 2100:
    #####: 2101:        count = 0;
        -: 2102:        do {
    #####: 2103:            MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &A, X->n * ciL, f_rng, p_rng ) );
        -: 2104:
    #####: 2105:            j = mbedtls_mpi_bitlen( &A );
    #####: 2106:            k = mbedtls_mpi_bitlen( &W );
    #####: 2107:            if (j > k) {
    #####: 2108:                MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &A, j - k ) );
        -: 2109:            }
        -: 2110:
    #####: 2111:            if (count++ > 30) {
    #####: 2112:                return MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
        -: 2113:            }
        -: 2114:
    #####: 2115:        } while ( mbedtls_mpi_cmp_mpi( &A, &W ) >= 0 ||
    #####: 2116:                  mbedtls_mpi_cmp_int( &A, 1 )  <= 0    );
        -: 2117:
        -: 2118:        /*
        -: 2119:         * A = A^R mod |X|
        -: 2120:         */
    #####: 2121:        MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &A, &A, &R, X, &RR ) );
        -: 2122:
    #####: 2123:        if( mbedtls_mpi_cmp_mpi( &A, &W ) == 0 ||
    #####: 2124:            mbedtls_mpi_cmp_int( &A,  1 ) == 0 )
    #####: 2125:            continue;
        -: 2126:
    #####: 2127:        j = 1;
    #####: 2128:        while( j < s && mbedtls_mpi_cmp_mpi( &A, &W ) != 0 )
        -: 2129:        {
        -: 2130:            /*
        -: 2131:             * A = A * A mod |X|
        -: 2132:             */
    #####: 2133:            MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T, &A, &A ) );
    #####: 2134:            MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &A, &T, X  ) );
        -: 2135:
    #####: 2136:            if( mbedtls_mpi_cmp_int( &A, 1 ) == 0 )
    #####: 2137:                break;
        -: 2138:
    #####: 2139:            j++;
        -: 2140:        }
        -: 2141:
        -: 2142:        /*
        -: 2143:         * not prime if A != |X| - 1 or A == 1
        -: 2144:         */
    #####: 2145:        if( mbedtls_mpi_cmp_mpi( &A, &W ) != 0 ||
    #####: 2146:            mbedtls_mpi_cmp_int( &A,  1 ) == 0 )
        -: 2147:        {
    #####: 2148:            ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
    #####: 2149:            break;
        -: 2150:        }
        -: 2151:    }
        -: 2152:
    #####: 2153:cleanup:
    #####: 2154:    mbedtls_mpi_free( &W ); mbedtls_mpi_free( &R ); mbedtls_mpi_free( &T ); mbedtls_mpi_free( &A );
    #####: 2155:    mbedtls_mpi_free( &RR );
        -: 2156:
    #####: 2157:    return( ret );
        -: 2158:}
        -: 2159:
        -: 2160:/*
        -: 2161: * Pseudo-primality test: small factors, then Miller-Rabin
        -: 2162: */
    #####: 2163:int mbedtls_mpi_is_prime( const mbedtls_mpi *X,
        -: 2164:                  int (*f_rng)(void *, unsigned char *, size_t),
        -: 2165:                  void *p_rng )
        -: 2166:{
        -: 2167:    int ret;
        -: 2168:    mbedtls_mpi XX;
        -: 2169:
    #####: 2170:    XX.s = 1;
    #####: 2171:    XX.n = X->n;
    #####: 2172:    XX.p = X->p;
        -: 2173:
    #####: 2174:    if( mbedtls_mpi_cmp_int( &XX, 0 ) == 0 ||
    #####: 2175:        mbedtls_mpi_cmp_int( &XX, 1 ) == 0 )
    #####: 2176:        return( MBEDTLS_ERR_MPI_NOT_ACCEPTABLE );
        -: 2177:
    #####: 2178:    if( mbedtls_mpi_cmp_int( &XX, 2 ) == 0 )
    #####: 2179:        return( 0 );
        -: 2180:
    #####: 2181:    if( ( ret = mpi_check_small_factors( &XX ) ) != 0 )
        -: 2182:    {
    #####: 2183:        if( ret == 1 )
    #####: 2184:            return( 0 );
        -: 2185:
    #####: 2186:        return( ret );
        -: 2187:    }
        -: 2188:
    #####: 2189:    return( mpi_miller_rabin( &XX, f_rng, p_rng ) );
        -: 2190:}
        -: 2191:
        -: 2192:/*
        -: 2193: * Prime number generation
        -: 2194: *
        -: 2195: * If dh_flag is 0 and nbits is at least 1024, then the procedure
        -: 2196: * follows the RSA probably-prime generation method of FIPS 186-4.
        -: 2197: * NB. FIPS 186-4 only allows the specific bit lengths of 1024 and 1536.
        -: 2198: */
    #####: 2199:int mbedtls_mpi_gen_prime( mbedtls_mpi *X, size_t nbits, int dh_flag,
        -: 2200:                   int (*f_rng)(void *, unsigned char *, size_t),
        -: 2201:                   void *p_rng )
        -: 2202:{
        -: 2203:#ifdef MBEDTLS_HAVE_INT64
        -: 2204:// ceil(2^63.5)
        -: 2205:#define CEIL_MAXUINT_DIV_SQRT2 0xb504f333f9de6485ULL
        -: 2206:#else
        -: 2207:// ceil(2^31.5)
        -: 2208:#define CEIL_MAXUINT_DIV_SQRT2 0xb504f334U
        -: 2209:#endif
    #####: 2210:    int ret = MBEDTLS_ERR_MPI_NOT_ACCEPTABLE;
        -: 2211:    size_t k, n;
        -: 2212:    mbedtls_mpi_uint r;
        -: 2213:    mbedtls_mpi Y;
        -: 2214:
    #####: 2215:    if( nbits < 3 || nbits > MBEDTLS_MPI_MAX_BITS )
    #####: 2216:        return( MBEDTLS_ERR_MPI_BAD_INPUT_DATA );
        -: 2217:
    #####: 2218:    mbedtls_mpi_init( &Y );
        -: 2219:
    #####: 2220:    n = BITS_TO_LIMBS( nbits );
        -: 2221:
        -: 2222:    while( 1 )
        -: 2223:    {
    #####: 2224:        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( X, n * ciL, f_rng, p_rng ) );
        -: 2225:        /* make sure generated number is at least (nbits-1)+0.5 bits (FIPS 186-4 §B.3.3 steps 4.4, 5.5) */
    #####: 2226:        if( X->p[n-1] < CEIL_MAXUINT_DIV_SQRT2 ) continue;
        -: 2227:
    #####: 2228:        k = n * biL;
    #####: 2229:        if( k > nbits ) MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( X, k - nbits ) );
    #####: 2230:        X->p[0] |= 1;
        -: 2231:
    #####: 2232:        if( dh_flag == 0 )
        -: 2233:        {
    #####: 2234:            ret = mbedtls_mpi_is_prime( X, f_rng, p_rng );
        -: 2235:
    #####: 2236:            if( ret != MBEDTLS_ERR_MPI_NOT_ACCEPTABLE )
    #####: 2237:                goto cleanup;
        -: 2238:        }
        -: 2239:        else
        -: 2240:        {
        -: 2241:            /*
        -: 2242:             * An necessary condition for Y and X = 2Y + 1 to be prime
        -: 2243:             * is X = 2 mod 3 (which is equivalent to Y = 2 mod 3).
        -: 2244:             * Make sure it is satisfied, while keeping X = 3 mod 4
        -: 2245:             */
        -: 2246:
    #####: 2247:            X->p[0] |= 2;
        -: 2248:
    #####: 2249:            MBEDTLS_MPI_CHK( mbedtls_mpi_mod_int( &r, X, 3 ) );
    #####: 2250:            if( r == 0 )
    #####: 2251:                MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( X, X, 8 ) );
    #####: 2252:            else if( r == 1 )
    #####: 2253:                MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( X, X, 4 ) );
        -: 2254:
        -: 2255:            /* Set Y = (X-1) / 2, which is X / 2 because X is odd */
    #####: 2256:            MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &Y, X ) );
    #####: 2257:            MBEDTLS_MPI_CHK( mbedtls_mpi_shift_r( &Y, 1 ) );
        -: 2258:
        -: 2259:            while( 1 )
        -: 2260:            {
        -: 2261:                /*
        -: 2262:                 * First, check small factors for X and Y
        -: 2263:                 * before doing Miller-Rabin on any of them
        -: 2264:                 */
    #####: 2265:                if( ( ret = mpi_check_small_factors(  X         ) ) == 0 &&
    #####: 2266:                    ( ret = mpi_check_small_factors( &Y         ) ) == 0 &&
    #####: 2267:                    ( ret = mpi_miller_rabin(  X, f_rng, p_rng  ) ) == 0 &&
    #####: 2268:                    ( ret = mpi_miller_rabin( &Y, f_rng, p_rng  ) ) == 0 )
    #####: 2269:                    goto cleanup;
        -: 2270:
    #####: 2271:                if( ret != MBEDTLS_ERR_MPI_NOT_ACCEPTABLE )
    #####: 2272:                    goto cleanup;
        -: 2273:
        -: 2274:                /*
        -: 2275:                 * Next candidates. We want to preserve Y = (X-1) / 2 and
        -: 2276:                 * Y = 1 mod 2 and Y = 2 mod 3 (eq X = 3 mod 4 and X = 2 mod 3)
        -: 2277:                 * so up Y by 6 and X by 12.
        -: 2278:                 */
    #####: 2279:                MBEDTLS_MPI_CHK( mbedtls_mpi_add_int(  X,  X, 12 ) );
    #####: 2280:                MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( &Y, &Y, 6  ) );
        -: 2281:            }
        -: 2282:        }
        -: 2283:    }
        -: 2284:
    #####: 2285:cleanup:
        -: 2286:
    #####: 2287:    mbedtls_mpi_free( &Y );
        -: 2288:
    #####: 2289:    return( ret );
        -: 2290:}
        -: 2291:
        -: 2292:#endif /* MBEDTLS_GENPRIME */
        -: 2293:
        -: 2294:#if defined(MBEDTLS_SELF_TEST)
        -: 2295:
        -: 2296:#define GCD_PAIR_COUNT  3
        -: 2297:
        -: 2298:static const int gcd_pairs[GCD_PAIR_COUNT][3] =
        -: 2299:{
        -: 2300:    { 693, 609, 21 },
        -: 2301:    { 1764, 868, 28 },
        -: 2302:    { 768454923, 542167814, 1 }
        -: 2303:};
        -: 2304:
        -: 2305:/*
        -: 2306: * Checkup routine
        -: 2307: */
        -: 2308:int mbedtls_mpi_self_test( int verbose )
        -: 2309:{
        -: 2310:    int ret, i;
        -: 2311:    mbedtls_mpi A, E, N, X, Y, U, V;
        -: 2312:
        -: 2313:    mbedtls_mpi_init( &A ); mbedtls_mpi_init( &E ); mbedtls_mpi_init( &N ); mbedtls_mpi_init( &X );
        -: 2314:    mbedtls_mpi_init( &Y ); mbedtls_mpi_init( &U ); mbedtls_mpi_init( &V );
        -: 2315:
        -: 2316:    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &A, 16,
        -: 2317:        "EFE021C2645FD1DC586E69184AF4A31E" \
        -: 2318:        "D5F53E93B5F123FA41680867BA110131" \
        -: 2319:        "944FE7952E2517337780CB0DB80E61AA" \
        -: 2320:        "E7C8DDC6C5C6AADEB34EB38A2F40D5E6" ) );
        -: 2321:
        -: 2322:    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &E, 16,
        -: 2323:        "B2E7EFD37075B9F03FF989C7C5051C20" \
        -: 2324:        "34D2A323810251127E7BF8625A4F49A5" \
        -: 2325:        "F3E27F4DA8BD59C47D6DAABA4C8127BD" \
        -: 2326:        "5B5C25763222FEFCCFC38B832366C29E" ) );
        -: 2327:
        -: 2328:    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &N, 16,
        -: 2329:        "0066A198186C18C10B2F5ED9B522752A" \
        -: 2330:        "9830B69916E535C8F047518A889A43A5" \
        -: 2331:        "94B6BED27A168D31D4A52F88925AA8F5" ) );
        -: 2332:
        -: 2333:    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &X, &A, &N ) );
        -: 2334:
        -: 2335:    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &U, 16,
        -: 2336:        "602AB7ECA597A3D6B56FF9829A5E8B85" \
        -: 2337:        "9E857EA95A03512E2BAE7391688D264A" \
        -: 2338:        "A5663B0341DB9CCFD2C4C5F421FEC814" \
        -: 2339:        "8001B72E848A38CAE1C65F78E56ABDEF" \
        -: 2340:        "E12D3C039B8A02D6BE593F0BBBDA56F1" \
        -: 2341:        "ECF677152EF804370C1A305CAF3B5BF1" \
        -: 2342:        "30879B56C61DE584A0F53A2447A51E" ) );
        -: 2343:
        -: 2344:    if( verbose != 0 )
        -: 2345:        mbedtls_printf( "  MPI test #1 (mul_mpi): " );
        -: 2346:
        -: 2347:    if( mbedtls_mpi_cmp_mpi( &X, &U ) != 0 )
        -: 2348:    {
        -: 2349:        if( verbose != 0 )
        -: 2350:            mbedtls_printf( "failed\n" );
        -: 2351:
        -: 2352:        ret = 1;
        -: 2353:        goto cleanup;
        -: 2354:    }
        -: 2355:
        -: 2356:    if( verbose != 0 )
        -: 2357:        mbedtls_printf( "passed\n" );
        -: 2358:
        -: 2359:    MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( &X, &Y, &A, &N ) );
        -: 2360:
        -: 2361:    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &U, 16,
        -: 2362:        "256567336059E52CAE22925474705F39A94" ) );
        -: 2363:
        -: 2364:    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &V, 16,
        -: 2365:        "6613F26162223DF488E9CD48CC132C7A" \
        -: 2366:        "0AC93C701B001B092E4E5B9F73BCD27B" \
        -: 2367:        "9EE50D0657C77F374E903CDFA4C642" ) );
        -: 2368:
        -: 2369:    if( verbose != 0 )
        -: 2370:        mbedtls_printf( "  MPI test #2 (div_mpi): " );
        -: 2371:
        -: 2372:    if( mbedtls_mpi_cmp_mpi( &X, &U ) != 0 ||
        -: 2373:        mbedtls_mpi_cmp_mpi( &Y, &V ) != 0 )
        -: 2374:    {
        -: 2375:        if( verbose != 0 )
        -: 2376:            mbedtls_printf( "failed\n" );
        -: 2377:
        -: 2378:        ret = 1;
        -: 2379:        goto cleanup;
        -: 2380:    }
        -: 2381:
        -: 2382:    if( verbose != 0 )
        -: 2383:        mbedtls_printf( "passed\n" );
        -: 2384:
        -: 2385:    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &X, &A, &E, &N, NULL ) );
        -: 2386:
        -: 2387:    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &U, 16,
        -: 2388:        "36E139AEA55215609D2816998ED020BB" \
        -: 2389:        "BD96C37890F65171D948E9BC7CBAA4D9" \
        -: 2390:        "325D24D6A3C12710F10A09FA08AB87" ) );
        -: 2391:
        -: 2392:    if( verbose != 0 )
        -: 2393:        mbedtls_printf( "  MPI test #3 (exp_mod): " );
        -: 2394:
        -: 2395:    if( mbedtls_mpi_cmp_mpi( &X, &U ) != 0 )
        -: 2396:    {
        -: 2397:        if( verbose != 0 )
        -: 2398:            mbedtls_printf( "failed\n" );
        -: 2399:
        -: 2400:        ret = 1;
        -: 2401:        goto cleanup;
        -: 2402:    }
        -: 2403:
        -: 2404:    if( verbose != 0 )
        -: 2405:        mbedtls_printf( "passed\n" );
        -: 2406:
        -: 2407:    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &X, &A, &N ) );
        -: 2408:
        -: 2409:    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &U, 16,
        -: 2410:        "003A0AAEDD7E784FC07D8F9EC6E3BFD5" \
        -: 2411:        "C3DBA76456363A10869622EAC2DD84EC" \
        -: 2412:        "C5B8A74DAC4D09E03B5E0BE779F2DF61" ) );
        -: 2413:
        -: 2414:    if( verbose != 0 )
        -: 2415:        mbedtls_printf( "  MPI test #4 (inv_mod): " );
        -: 2416:
        -: 2417:    if( mbedtls_mpi_cmp_mpi( &X, &U ) != 0 )
        -: 2418:    {
        -: 2419:        if( verbose != 0 )
        -: 2420:            mbedtls_printf( "failed\n" );
        -: 2421:
        -: 2422:        ret = 1;
        -: 2423:        goto cleanup;
        -: 2424:    }
        -: 2425:
        -: 2426:    if( verbose != 0 )
        -: 2427:        mbedtls_printf( "passed\n" );
        -: 2428:
        -: 2429:    if( verbose != 0 )
        -: 2430:        mbedtls_printf( "  MPI test #5 (simple gcd): " );
        -: 2431:
        -: 2432:    for( i = 0; i < GCD_PAIR_COUNT; i++ )
        -: 2433:    {
        -: 2434:        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &X, gcd_pairs[i][0] ) );
        -: 2435:        MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &Y, gcd_pairs[i][1] ) );
        -: 2436:
        -: 2437:        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &A, &X, &Y ) );
        -: 2438:
        -: 2439:        if( mbedtls_mpi_cmp_int( &A, gcd_pairs[i][2] ) != 0 )
        -: 2440:        {
        -: 2441:            if( verbose != 0 )
        -: 2442:                mbedtls_printf( "failed at %d\n", i );
        -: 2443:
        -: 2444:            ret = 1;
        -: 2445:            goto cleanup;
        -: 2446:        }
        -: 2447:    }
        -: 2448:
        -: 2449:    if( verbose != 0 )
        -: 2450:        mbedtls_printf( "passed\n" );
        -: 2451:
        -: 2452:cleanup:
        -: 2453:
        -: 2454:    if( ret != 0 && verbose != 0 )
        -: 2455:        mbedtls_printf( "Unexpected error, return code = %08X\n", ret );
        -: 2456:
        -: 2457:    mbedtls_mpi_free( &A ); mbedtls_mpi_free( &E ); mbedtls_mpi_free( &N ); mbedtls_mpi_free( &X );
        -: 2458:    mbedtls_mpi_free( &Y ); mbedtls_mpi_free( &U ); mbedtls_mpi_free( &V );
        -: 2459:
        -: 2460:    if( verbose != 0 )
        -: 2461:        mbedtls_printf( "\n" );
        -: 2462:
        -: 2463:    return( ret );
        -: 2464:}
        -: 2465:
        -: 2466:#endif /* MBEDTLS_SELF_TEST */
        -: 2467:
        -: 2468:#endif /* MBEDTLS_BIGNUM_C */
