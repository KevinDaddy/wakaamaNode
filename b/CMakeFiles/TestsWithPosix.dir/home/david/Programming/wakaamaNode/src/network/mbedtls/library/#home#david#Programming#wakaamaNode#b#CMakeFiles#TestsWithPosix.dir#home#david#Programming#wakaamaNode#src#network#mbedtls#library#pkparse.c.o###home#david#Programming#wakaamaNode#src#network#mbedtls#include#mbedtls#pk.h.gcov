        -:    0:Source:/home/david/Programming/wakaamaNode/src/network/mbedtls/include/mbedtls/pk.h
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/network/mbedtls/library/pkparse.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/**
        -:    2: * \file pk.h
        -:    3: *
        -:    4: * \brief Public Key abstraction layer
        -:    5: */
        -:    6:/*
        -:    7: *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
        -:    8: *  SPDX-License-Identifier: Apache-2.0
        -:    9: *
        -:   10: *  Licensed under the Apache License, Version 2.0 (the "License"); you may
        -:   11: *  not use this file except in compliance with the License.
        -:   12: *  You may obtain a copy of the License at
        -:   13: *
        -:   14: *  http://www.apache.org/licenses/LICENSE-2.0
        -:   15: *
        -:   16: *  Unless required by applicable law or agreed to in writing, software
        -:   17: *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
        -:   18: *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   19: *  See the License for the specific language governing permissions and
        -:   20: *  limitations under the License.
        -:   21: *
        -:   22: *  This file is part of mbed TLS (https://tls.mbed.org)
        -:   23: */
        -:   24:
        -:   25:#ifndef MBEDTLS_PK_H
        -:   26:#define MBEDTLS_PK_H
        -:   27:
        -:   28:#if !defined(MBEDTLS_CONFIG_FILE)
        -:   29:#include "config.h"
        -:   30:#else
        -:   31:#include MBEDTLS_CONFIG_FILE
        -:   32:#endif
        -:   33:
        -:   34:#include "md.h"
        -:   35:
        -:   36:#if defined(MBEDTLS_RSA_C)
        -:   37:#include "rsa.h"
        -:   38:#endif
        -:   39:
        -:   40:#if defined(MBEDTLS_ECP_C)
        -:   41:#include "ecp.h"
        -:   42:#endif
        -:   43:
        -:   44:#if defined(MBEDTLS_ECDSA_C)
        -:   45:#include "ecdsa.h"
        -:   46:#endif
        -:   47:
        -:   48:#if ( defined(__ARMCC_VERSION) || defined(_MSC_VER) ) && \
        -:   49:    !defined(inline) && !defined(__cplusplus)
        -:   50:#define inline __inline
        -:   51:#endif
        -:   52:
        -:   53:#define MBEDTLS_ERR_PK_ALLOC_FAILED        -0x3F80  /**< Memory allocation failed. */
        -:   54:#define MBEDTLS_ERR_PK_TYPE_MISMATCH       -0x3F00  /**< Type mismatch, eg attempt to encrypt with an ECDSA key */
        -:   55:#define MBEDTLS_ERR_PK_BAD_INPUT_DATA      -0x3E80  /**< Bad input parameters to function. */
        -:   56:#define MBEDTLS_ERR_PK_FILE_IO_ERROR       -0x3E00  /**< Read/write of file failed. */
        -:   57:#define MBEDTLS_ERR_PK_KEY_INVALID_VERSION -0x3D80  /**< Unsupported key version */
        -:   58:#define MBEDTLS_ERR_PK_KEY_INVALID_FORMAT  -0x3D00  /**< Invalid key tag or value. */
        -:   59:#define MBEDTLS_ERR_PK_UNKNOWN_PK_ALG      -0x3C80  /**< Key algorithm is unsupported (only RSA and EC are supported). */
        -:   60:#define MBEDTLS_ERR_PK_PASSWORD_REQUIRED   -0x3C00  /**< Private key password can't be empty. */
        -:   61:#define MBEDTLS_ERR_PK_PASSWORD_MISMATCH   -0x3B80  /**< Given private key password does not allow for correct decryption. */
        -:   62:#define MBEDTLS_ERR_PK_INVALID_PUBKEY      -0x3B00  /**< The pubkey tag or value is invalid (only RSA and EC are supported). */
        -:   63:#define MBEDTLS_ERR_PK_INVALID_ALG         -0x3A80  /**< The algorithm tag or value is invalid. */
        -:   64:#define MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE -0x3A00  /**< Elliptic curve is unsupported (only NIST curves are supported). */
        -:   65:#define MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE -0x3980  /**< Unavailable feature, e.g. RSA disabled for RSA key. */
        -:   66:#define MBEDTLS_ERR_PK_SIG_LEN_MISMATCH    -0x3900  /**< The buffer contains a valid signature followed by more data. */
        -:   67:#define MBEDTLS_ERR_PK_HW_ACCEL_FAILED     -0x3880  /**< PK hardware accelerator failed. */
        -:   68:
        -:   69:#ifdef __cplusplus
        -:   70:extern "C" {
        -:   71:#endif
        -:   72:
        -:   73:/**
        -:   74: * \brief          Public key types
        -:   75: */
        -:   76:typedef enum {
        -:   77:    MBEDTLS_PK_NONE=0,
        -:   78:    MBEDTLS_PK_RSA,
        -:   79:    MBEDTLS_PK_ECKEY,
        -:   80:    MBEDTLS_PK_ECKEY_DH,
        -:   81:    MBEDTLS_PK_ECDSA,
        -:   82:    MBEDTLS_PK_RSA_ALT,
        -:   83:    MBEDTLS_PK_RSASSA_PSS,
        -:   84:} mbedtls_pk_type_t;
        -:   85:
        -:   86:/**
        -:   87: * \brief           Options for RSASSA-PSS signature verification.
        -:   88: *                  See \c mbedtls_rsa_rsassa_pss_verify_ext()
        -:   89: */
        -:   90:typedef struct
        -:   91:{
        -:   92:    mbedtls_md_type_t mgf1_hash_id;
        -:   93:    int expected_salt_len;
        -:   94:
        -:   95:} mbedtls_pk_rsassa_pss_options;
        -:   96:
        -:   97:/**
        -:   98: * \brief           Types for interfacing with the debug module
        -:   99: */
        -:  100:typedef enum
        -:  101:{
        -:  102:    MBEDTLS_PK_DEBUG_NONE = 0,
        -:  103:    MBEDTLS_PK_DEBUG_MPI,
        -:  104:    MBEDTLS_PK_DEBUG_ECP,
        -:  105:} mbedtls_pk_debug_type;
        -:  106:
        -:  107:/**
        -:  108: * \brief           Item to send to the debug module
        -:  109: */
        -:  110:typedef struct
        -:  111:{
        -:  112:    mbedtls_pk_debug_type type;
        -:  113:    const char *name;
        -:  114:    void *value;
        -:  115:} mbedtls_pk_debug_item;
        -:  116:
        -:  117:/** Maximum number of item send for debugging, plus 1 */
        -:  118:#define MBEDTLS_PK_DEBUG_MAX_ITEMS 3
        -:  119:
        -:  120:/**
        -:  121: * \brief           Public key information and operations
        -:  122: */
        -:  123:typedef struct mbedtls_pk_info_t mbedtls_pk_info_t;
        -:  124:
        -:  125:/**
        -:  126: * \brief           Public key container
        -:  127: */
        -:  128:typedef struct
        -:  129:{
        -:  130:    const mbedtls_pk_info_t *   pk_info; /**< Public key informations        */
        -:  131:    void *                      pk_ctx;  /**< Underlying public key context  */
        -:  132:} mbedtls_pk_context;
        -:  133:
        -:  134:#if defined(MBEDTLS_RSA_C)
        -:  135:/**
        -:  136: * Quick access to an RSA context inside a PK context.
        -:  137: *
        -:  138: * \warning You must make sure the PK context actually holds an RSA context
        -:  139: * before using this function!
        -:  140: */
    #####:  141:static inline mbedtls_rsa_context *mbedtls_pk_rsa( const mbedtls_pk_context pk )
        -:  142:{
    #####:  143:    return( (mbedtls_rsa_context *) (pk).pk_ctx );
        -:  144:}
        -:  145:#endif /* MBEDTLS_RSA_C */
        -:  146:
        -:  147:#if defined(MBEDTLS_ECP_C)
        -:  148:/**
        -:  149: * Quick access to an EC context inside a PK context.
        -:  150: *
        -:  151: * \warning You must make sure the PK context actually holds an EC context
        -:  152: * before using this function!
        -:  153: */
        -:  154:static inline mbedtls_ecp_keypair *mbedtls_pk_ec( const mbedtls_pk_context pk )
        -:  155:{
        -:  156:    return( (mbedtls_ecp_keypair *) (pk).pk_ctx );
        -:  157:}
        -:  158:#endif /* MBEDTLS_ECP_C */
        -:  159:
        -:  160:#if defined(MBEDTLS_PK_RSA_ALT_SUPPORT)
        -:  161:/**
        -:  162: * \brief           Types for RSA-alt abstraction
        -:  163: */
        -:  164:typedef int (*mbedtls_pk_rsa_alt_decrypt_func)( void *ctx, int mode, size_t *olen,
        -:  165:                    const unsigned char *input, unsigned char *output,
        -:  166:                    size_t output_max_len );
        -:  167:typedef int (*mbedtls_pk_rsa_alt_sign_func)( void *ctx,
        -:  168:                    int (*f_rng)(void *, unsigned char *, size_t), void *p_rng,
        -:  169:                    int mode, mbedtls_md_type_t md_alg, unsigned int hashlen,
        -:  170:                    const unsigned char *hash, unsigned char *sig );
        -:  171:typedef size_t (*mbedtls_pk_rsa_alt_key_len_func)( void *ctx );
        -:  172:#endif /* MBEDTLS_PK_RSA_ALT_SUPPORT */
        -:  173:
        -:  174:/**
        -:  175: * \brief           Return information associated with the given PK type
        -:  176: *
        -:  177: * \param pk_type   PK type to search for.
        -:  178: *
        -:  179: * \return          The PK info associated with the type or NULL if not found.
        -:  180: */
        -:  181:const mbedtls_pk_info_t *mbedtls_pk_info_from_type( mbedtls_pk_type_t pk_type );
        -:  182:
        -:  183:/**
        -:  184: * \brief           Initialize a mbedtls_pk_context (as NONE)
        -:  185: */
        -:  186:void mbedtls_pk_init( mbedtls_pk_context *ctx );
        -:  187:
        -:  188:/**
        -:  189: * \brief           Free a mbedtls_pk_context
        -:  190: */
        -:  191:void mbedtls_pk_free( mbedtls_pk_context *ctx );
        -:  192:
        -:  193:/**
        -:  194: * \brief           Initialize a PK context with the information given
        -:  195: *                  and allocates the type-specific PK subcontext.
        -:  196: *
        -:  197: * \param ctx       Context to initialize. Must be empty (type NONE).
        -:  198: * \param info      Information to use
        -:  199: *
        -:  200: * \return          0 on success,
        -:  201: *                  MBEDTLS_ERR_PK_BAD_INPUT_DATA on invalid input,
        -:  202: *                  MBEDTLS_ERR_PK_ALLOC_FAILED on allocation failure.
        -:  203: *
        -:  204: * \note            For contexts holding an RSA-alt key, use
        -:  205: *                  \c mbedtls_pk_setup_rsa_alt() instead.
        -:  206: */
        -:  207:int mbedtls_pk_setup( mbedtls_pk_context *ctx, const mbedtls_pk_info_t *info );
        -:  208:
        -:  209:#if defined(MBEDTLS_PK_RSA_ALT_SUPPORT)
        -:  210:/**
        -:  211: * \brief           Initialize an RSA-alt context
        -:  212: *
        -:  213: * \param ctx       Context to initialize. Must be empty (type NONE).
        -:  214: * \param key       RSA key pointer
        -:  215: * \param decrypt_func  Decryption function
        -:  216: * \param sign_func     Signing function
        -:  217: * \param key_len_func  Function returning key length in bytes
        -:  218: *
        -:  219: * \return          0 on success, or MBEDTLS_ERR_PK_BAD_INPUT_DATA if the
        -:  220: *                  context wasn't already initialized as RSA_ALT.
        -:  221: *
        -:  222: * \note            This function replaces \c mbedtls_pk_setup() for RSA-alt.
        -:  223: */
        -:  224:int mbedtls_pk_setup_rsa_alt( mbedtls_pk_context *ctx, void * key,
        -:  225:                         mbedtls_pk_rsa_alt_decrypt_func decrypt_func,
        -:  226:                         mbedtls_pk_rsa_alt_sign_func sign_func,
        -:  227:                         mbedtls_pk_rsa_alt_key_len_func key_len_func );
        -:  228:#endif /* MBEDTLS_PK_RSA_ALT_SUPPORT */
        -:  229:
        -:  230:/**
        -:  231: * \brief           Get the size in bits of the underlying key
        -:  232: *
        -:  233: * \param ctx       Context to use
        -:  234: *
        -:  235: * \return          Key size in bits, or 0 on error
        -:  236: */
        -:  237:size_t mbedtls_pk_get_bitlen( const mbedtls_pk_context *ctx );
        -:  238:
        -:  239:/**
        -:  240: * \brief           Get the length in bytes of the underlying key
        -:  241: * \param ctx       Context to use
        -:  242: *
        -:  243: * \return          Key length in bytes, or 0 on error
        -:  244: */
        -:  245:static inline size_t mbedtls_pk_get_len( const mbedtls_pk_context *ctx )
        -:  246:{
        -:  247:    return( ( mbedtls_pk_get_bitlen( ctx ) + 7 ) / 8 );
        -:  248:}
        -:  249:
        -:  250:/**
        -:  251: * \brief           Tell if a context can do the operation given by type
        -:  252: *
        -:  253: * \param ctx       Context to test
        -:  254: * \param type      Target type
        -:  255: *
        -:  256: * \return          0 if context can't do the operations,
        -:  257: *                  1 otherwise.
        -:  258: */
        -:  259:int mbedtls_pk_can_do( const mbedtls_pk_context *ctx, mbedtls_pk_type_t type );
        -:  260:
        -:  261:/**
        -:  262: * \brief           Verify signature (including padding if relevant).
        -:  263: *
        -:  264: * \param ctx       PK context to use
        -:  265: * \param md_alg    Hash algorithm used (see notes)
        -:  266: * \param hash      Hash of the message to sign
        -:  267: * \param hash_len  Hash length or 0 (see notes)
        -:  268: * \param sig       Signature to verify
        -:  269: * \param sig_len   Signature length
        -:  270: *
        -:  271: * \return          0 on success (signature is valid),
        -:  272: *                  #MBEDTLS_ERR_PK_SIG_LEN_MISMATCH if there is a valid
        -:  273: *                  signature in sig but its length is less than \p siglen,
        -:  274: *                  or a specific error code.
        -:  275: *
        -:  276: * \note            For RSA keys, the default padding type is PKCS#1 v1.5.
        -:  277: *                  Use \c mbedtls_pk_verify_ext( MBEDTLS_PK_RSASSA_PSS, ... )
        -:  278: *                  to verify RSASSA_PSS signatures.
        -:  279: *
        -:  280: * \note            If hash_len is 0, then the length associated with md_alg
        -:  281: *                  is used instead, or an error returned if it is invalid.
        -:  282: *
        -:  283: * \note            md_alg may be MBEDTLS_MD_NONE, only if hash_len != 0
        -:  284: */
        -:  285:int mbedtls_pk_verify( mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
        -:  286:               const unsigned char *hash, size_t hash_len,
        -:  287:               const unsigned char *sig, size_t sig_len );
        -:  288:
        -:  289:/**
        -:  290: * \brief           Verify signature, with options.
        -:  291: *                  (Includes verification of the padding depending on type.)
        -:  292: *
        -:  293: * \param type      Signature type (inc. possible padding type) to verify
        -:  294: * \param options   Pointer to type-specific options, or NULL
        -:  295: * \param ctx       PK context to use
        -:  296: * \param md_alg    Hash algorithm used (see notes)
        -:  297: * \param hash      Hash of the message to sign
        -:  298: * \param hash_len  Hash length or 0 (see notes)
        -:  299: * \param sig       Signature to verify
        -:  300: * \param sig_len   Signature length
        -:  301: *
        -:  302: * \return          0 on success (signature is valid),
        -:  303: *                  #MBEDTLS_ERR_PK_TYPE_MISMATCH if the PK context can't be
        -:  304: *                  used for this type of signatures,
        -:  305: *                  #MBEDTLS_ERR_PK_SIG_LEN_MISMATCH if there is a valid
        -:  306: *                  signature in sig but its length is less than \p siglen,
        -:  307: *                  or a specific error code.
        -:  308: *
        -:  309: * \note            If hash_len is 0, then the length associated with md_alg
        -:  310: *                  is used instead, or an error returned if it is invalid.
        -:  311: *
        -:  312: * \note            md_alg may be MBEDTLS_MD_NONE, only if hash_len != 0
        -:  313: *
        -:  314: * \note            If type is MBEDTLS_PK_RSASSA_PSS, then options must point
        -:  315: *                  to a mbedtls_pk_rsassa_pss_options structure,
        -:  316: *                  otherwise it must be NULL.
        -:  317: */
        -:  318:int mbedtls_pk_verify_ext( mbedtls_pk_type_t type, const void *options,
        -:  319:                   mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
        -:  320:                   const unsigned char *hash, size_t hash_len,
        -:  321:                   const unsigned char *sig, size_t sig_len );
        -:  322:
        -:  323:/**
        -:  324: * \brief           Make signature, including padding if relevant.
        -:  325: *
        -:  326: * \param ctx       PK context to use - must hold a private key
        -:  327: * \param md_alg    Hash algorithm used (see notes)
        -:  328: * \param hash      Hash of the message to sign
        -:  329: * \param hash_len  Hash length or 0 (see notes)
        -:  330: * \param sig       Place to write the signature
        -:  331: * \param sig_len   Number of bytes written
        -:  332: * \param f_rng     RNG function
        -:  333: * \param p_rng     RNG parameter
        -:  334: *
        -:  335: * \return          0 on success, or a specific error code.
        -:  336: *
        -:  337: * \note            For RSA keys, the default padding type is PKCS#1 v1.5.
        -:  338: *                  There is no interface in the PK module to make RSASSA-PSS
        -:  339: *                  signatures yet.
        -:  340: *
        -:  341: * \note            If hash_len is 0, then the length associated with md_alg
        -:  342: *                  is used instead, or an error returned if it is invalid.
        -:  343: *
        -:  344: * \note            For RSA, md_alg may be MBEDTLS_MD_NONE if hash_len != 0.
        -:  345: *                  For ECDSA, md_alg may never be MBEDTLS_MD_NONE.
        -:  346: */
        -:  347:int mbedtls_pk_sign( mbedtls_pk_context *ctx, mbedtls_md_type_t md_alg,
        -:  348:             const unsigned char *hash, size_t hash_len,
        -:  349:             unsigned char *sig, size_t *sig_len,
        -:  350:             int (*f_rng)(void *, unsigned char *, size_t), void *p_rng );
        -:  351:
        -:  352:/**
        -:  353: * \brief           Decrypt message (including padding if relevant).
        -:  354: *
        -:  355: * \param ctx       PK context to use - must hold a private key
        -:  356: * \param input     Input to decrypt
        -:  357: * \param ilen      Input size
        -:  358: * \param output    Decrypted output
        -:  359: * \param olen      Decrypted message length
        -:  360: * \param osize     Size of the output buffer
        -:  361: * \param f_rng     RNG function
        -:  362: * \param p_rng     RNG parameter
        -:  363: *
        -:  364: * \note            For RSA keys, the default padding type is PKCS#1 v1.5.
        -:  365: *
        -:  366: * \return          0 on success, or a specific error code.
        -:  367: */
        -:  368:int mbedtls_pk_decrypt( mbedtls_pk_context *ctx,
        -:  369:                const unsigned char *input, size_t ilen,
        -:  370:                unsigned char *output, size_t *olen, size_t osize,
        -:  371:                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng );
        -:  372:
        -:  373:/**
        -:  374: * \brief           Encrypt message (including padding if relevant).
        -:  375: *
        -:  376: * \param ctx       PK context to use
        -:  377: * \param input     Message to encrypt
        -:  378: * \param ilen      Message size
        -:  379: * \param output    Encrypted output
        -:  380: * \param olen      Encrypted output length
        -:  381: * \param osize     Size of the output buffer
        -:  382: * \param f_rng     RNG function
        -:  383: * \param p_rng     RNG parameter
        -:  384: *
        -:  385: * \note            For RSA keys, the default padding type is PKCS#1 v1.5.
        -:  386: *
        -:  387: * \return          0 on success, or a specific error code.
        -:  388: */
        -:  389:int mbedtls_pk_encrypt( mbedtls_pk_context *ctx,
        -:  390:                const unsigned char *input, size_t ilen,
        -:  391:                unsigned char *output, size_t *olen, size_t osize,
        -:  392:                int (*f_rng)(void *, unsigned char *, size_t), void *p_rng );
        -:  393:
        -:  394:/**
        -:  395: * \brief           Check if a public-private pair of keys matches.
        -:  396: *
        -:  397: * \param pub       Context holding a public key.
        -:  398: * \param prv       Context holding a private (and public) key.
        -:  399: *
        -:  400: * \return          0 on success or MBEDTLS_ERR_PK_BAD_INPUT_DATA
        -:  401: */
        -:  402:int mbedtls_pk_check_pair( const mbedtls_pk_context *pub, const mbedtls_pk_context *prv );
        -:  403:
        -:  404:/**
        -:  405: * \brief           Export debug information
        -:  406: *
        -:  407: * \param ctx       Context to use
        -:  408: * \param items     Place to write debug items
        -:  409: *
        -:  410: * \return          0 on success or MBEDTLS_ERR_PK_BAD_INPUT_DATA
        -:  411: */
        -:  412:int mbedtls_pk_debug( const mbedtls_pk_context *ctx, mbedtls_pk_debug_item *items );
        -:  413:
        -:  414:/**
        -:  415: * \brief           Access the type name
        -:  416: *
        -:  417: * \param ctx       Context to use
        -:  418: *
        -:  419: * \return          Type name on success, or "invalid PK"
        -:  420: */
        -:  421:const char * mbedtls_pk_get_name( const mbedtls_pk_context *ctx );
        -:  422:
        -:  423:/**
        -:  424: * \brief           Get the key type
        -:  425: *
        -:  426: * \param ctx       Context to use
        -:  427: *
        -:  428: * \return          Type on success, or MBEDTLS_PK_NONE
        -:  429: */
        -:  430:mbedtls_pk_type_t mbedtls_pk_get_type( const mbedtls_pk_context *ctx );
        -:  431:
        -:  432:#if defined(MBEDTLS_PK_PARSE_C)
        -:  433:/** \ingroup pk_module */
        -:  434:/**
        -:  435: * \brief           Parse a private key in PEM or DER format
        -:  436: *
        -:  437: * \param ctx       key to be initialized
        -:  438: * \param key       input buffer
        -:  439: * \param keylen    size of the buffer
        -:  440: *                  (including the terminating null byte for PEM data)
        -:  441: * \param pwd       password for decryption (optional)
        -:  442: * \param pwdlen    size of the password
        -:  443: *
        -:  444: * \note            On entry, ctx must be empty, either freshly initialised
        -:  445: *                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a
        -:  446: *                  specific key type, check the result with mbedtls_pk_can_do().
        -:  447: *
        -:  448: * \note            The key is also checked for correctness.
        -:  449: *
        -:  450: * \return          0 if successful, or a specific PK or PEM error code
        -:  451: */
        -:  452:int mbedtls_pk_parse_key( mbedtls_pk_context *ctx,
        -:  453:                  const unsigned char *key, size_t keylen,
        -:  454:                  const unsigned char *pwd, size_t pwdlen );
        -:  455:
        -:  456:/** \ingroup pk_module */
        -:  457:/**
        -:  458: * \brief           Parse a public key in PEM or DER format
        -:  459: *
        -:  460: * \param ctx       key to be initialized
        -:  461: * \param key       input buffer
        -:  462: * \param keylen    size of the buffer
        -:  463: *                  (including the terminating null byte for PEM data)
        -:  464: *
        -:  465: * \note            On entry, ctx must be empty, either freshly initialised
        -:  466: *                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a
        -:  467: *                  specific key type, check the result with mbedtls_pk_can_do().
        -:  468: *
        -:  469: * \note            The key is also checked for correctness.
        -:  470: *
        -:  471: * \return          0 if successful, or a specific PK or PEM error code
        -:  472: */
        -:  473:int mbedtls_pk_parse_public_key( mbedtls_pk_context *ctx,
        -:  474:                         const unsigned char *key, size_t keylen );
        -:  475:
        -:  476:#if defined(MBEDTLS_FS_IO)
        -:  477:/** \ingroup pk_module */
        -:  478:/**
        -:  479: * \brief           Load and parse a private key
        -:  480: *
        -:  481: * \param ctx       key to be initialized
        -:  482: * \param path      filename to read the private key from
        -:  483: * \param password  password to decrypt the file (can be NULL)
        -:  484: *
        -:  485: * \note            On entry, ctx must be empty, either freshly initialised
        -:  486: *                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If you need a
        -:  487: *                  specific key type, check the result with mbedtls_pk_can_do().
        -:  488: *
        -:  489: * \note            The key is also checked for correctness.
        -:  490: *
        -:  491: * \return          0 if successful, or a specific PK or PEM error code
        -:  492: */
        -:  493:int mbedtls_pk_parse_keyfile( mbedtls_pk_context *ctx,
        -:  494:                      const char *path, const char *password );
        -:  495:
        -:  496:/** \ingroup pk_module */
        -:  497:/**
        -:  498: * \brief           Load and parse a public key
        -:  499: *
        -:  500: * \param ctx       key to be initialized
        -:  501: * \param path      filename to read the public key from
        -:  502: *
        -:  503: * \note            On entry, ctx must be empty, either freshly initialised
        -:  504: *                  with mbedtls_pk_init() or reset with mbedtls_pk_free(). If
        -:  505: *                  you need a specific key type, check the result with
        -:  506: *                  mbedtls_pk_can_do().
        -:  507: *
        -:  508: * \note            The key is also checked for correctness.
        -:  509: *
        -:  510: * \return          0 if successful, or a specific PK or PEM error code
        -:  511: */
        -:  512:int mbedtls_pk_parse_public_keyfile( mbedtls_pk_context *ctx, const char *path );
        -:  513:#endif /* MBEDTLS_FS_IO */
        -:  514:#endif /* MBEDTLS_PK_PARSE_C */
        -:  515:
        -:  516:#if defined(MBEDTLS_PK_WRITE_C)
        -:  517:/**
        -:  518: * \brief           Write a private key to a PKCS#1 or SEC1 DER structure
        -:  519: *                  Note: data is written at the end of the buffer! Use the
        -:  520: *                        return value to determine where you should start
        -:  521: *                        using the buffer
        -:  522: *
        -:  523: * \param ctx       private to write away
        -:  524: * \param buf       buffer to write to
        -:  525: * \param size      size of the buffer
        -:  526: *
        -:  527: * \return          length of data written if successful, or a specific
        -:  528: *                  error code
        -:  529: */
        -:  530:int mbedtls_pk_write_key_der( mbedtls_pk_context *ctx, unsigned char *buf, size_t size );
        -:  531:
        -:  532:/**
        -:  533: * \brief           Write a public key to a SubjectPublicKeyInfo DER structure
        -:  534: *                  Note: data is written at the end of the buffer! Use the
        -:  535: *                        return value to determine where you should start
        -:  536: *                        using the buffer
        -:  537: *
        -:  538: * \param ctx       public key to write away
        -:  539: * \param buf       buffer to write to
        -:  540: * \param size      size of the buffer
        -:  541: *
        -:  542: * \return          length of data written if successful, or a specific
        -:  543: *                  error code
        -:  544: */
        -:  545:int mbedtls_pk_write_pubkey_der( mbedtls_pk_context *ctx, unsigned char *buf, size_t size );
        -:  546:
        -:  547:#if defined(MBEDTLS_PEM_WRITE_C)
        -:  548:/**
        -:  549: * \brief           Write a public key to a PEM string
        -:  550: *
        -:  551: * \param ctx       public key to write away
        -:  552: * \param buf       buffer to write to
        -:  553: * \param size      size of the buffer
        -:  554: *
        -:  555: * \return          0 if successful, or a specific error code
        -:  556: */
        -:  557:int mbedtls_pk_write_pubkey_pem( mbedtls_pk_context *ctx, unsigned char *buf, size_t size );
        -:  558:
        -:  559:/**
        -:  560: * \brief           Write a private key to a PKCS#1 or SEC1 PEM string
        -:  561: *
        -:  562: * \param ctx       private to write away
        -:  563: * \param buf       buffer to write to
        -:  564: * \param size      size of the buffer
        -:  565: *
        -:  566: * \return          0 if successful, or a specific error code
        -:  567: */
        -:  568:int mbedtls_pk_write_key_pem( mbedtls_pk_context *ctx, unsigned char *buf, size_t size );
        -:  569:#endif /* MBEDTLS_PEM_WRITE_C */
        -:  570:#endif /* MBEDTLS_PK_WRITE_C */
        -:  571:
        -:  572:/*
        -:  573: * WARNING: Low-level functions. You probably do not want to use these unless
        -:  574: *          you are certain you do ;)
        -:  575: */
        -:  576:
        -:  577:#if defined(MBEDTLS_PK_PARSE_C)
        -:  578:/**
        -:  579: * \brief           Parse a SubjectPublicKeyInfo DER structure
        -:  580: *
        -:  581: * \param p         the position in the ASN.1 data
        -:  582: * \param end       end of the buffer
        -:  583: * \param pk        the key to fill
        -:  584: *
        -:  585: * \return          0 if successful, or a specific PK error code
        -:  586: */
        -:  587:int mbedtls_pk_parse_subpubkey( unsigned char **p, const unsigned char *end,
        -:  588:                        mbedtls_pk_context *pk );
        -:  589:#endif /* MBEDTLS_PK_PARSE_C */
        -:  590:
        -:  591:#if defined(MBEDTLS_PK_WRITE_C)
        -:  592:/**
        -:  593: * \brief           Write a subjectPublicKey to ASN.1 data
        -:  594: *                  Note: function works backwards in data buffer
        -:  595: *
        -:  596: * \param p         reference to current position pointer
        -:  597: * \param start     start of the buffer (for bounds-checking)
        -:  598: * \param key       public key to write away
        -:  599: *
        -:  600: * \return          the length written or a negative error code
        -:  601: */
        -:  602:int mbedtls_pk_write_pubkey( unsigned char **p, unsigned char *start,
        -:  603:                     const mbedtls_pk_context *key );
        -:  604:#endif /* MBEDTLS_PK_WRITE_C */
        -:  605:
        -:  606:/*
        -:  607: * Internal module functions. You probably do not want to use these unless you
        -:  608: * know you do.
        -:  609: */
        -:  610:#if defined(MBEDTLS_FS_IO)
        -:  611:int mbedtls_pk_load_file( const char *path, unsigned char **buf, size_t *n );
        -:  612:#endif
        -:  613:
        -:  614:#ifdef __cplusplus
        -:  615:}
        -:  616:#endif
        -:  617:
        -:  618:#endif /* MBEDTLS_PK_H */
