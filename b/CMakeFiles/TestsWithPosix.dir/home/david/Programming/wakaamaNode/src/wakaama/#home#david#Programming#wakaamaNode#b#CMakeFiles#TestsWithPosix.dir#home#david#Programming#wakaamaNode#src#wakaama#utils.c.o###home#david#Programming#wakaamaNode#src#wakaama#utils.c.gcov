        -:    0:Source:/home/david/Programming/wakaamaNode/src/wakaama/utils.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/wakaama/utils.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*******************************************************************************
        -:    2: *
        -:    3: * Copyright (c) 2013, 2014 Intel Corporation and others.
        -:    4: * All rights reserved. This program and the accompanying materials
        -:    5: * are made available under the terms of the Eclipse Public License v1.0
        -:    6: * and Eclipse Distribution License v1.0 which accompany this distribution.
        -:    7: *
        -:    8: * The Eclipse Public License is available at
        -:    9: *    http://www.eclipse.org/legal/epl-v10.html
        -:   10: * The Eclipse Distribution License is available at
        -:   11: *    http://www.eclipse.org/org/documents/edl-v10.php.
        -:   12: *
        -:   13: * Contributors:
        -:   14: *    David Navarro, Intel Corporation - initial API and implementation
        -:   15: *    Toby Jaffey - Please refer to git log
        -:   16: *    
        -:   17: *******************************************************************************/
        -:   18:
        -:   19:/*
        -:   20: Copyright (c) 2013, 2014 Intel Corporation
        -:   21:
        -:   22: Redistribution and use in source and binary forms, with or without modification,
        -:   23: are permitted provided that the following conditions are met:
        -:   24:
        -:   25:     * Redistributions of source code must retain the above copyright notice,
        -:   26:       this list of conditions and the following disclaimer.
        -:   27:     * Redistributions in binary form must reproduce the above copyright notice,
        -:   28:       this list of conditions and the following disclaimer in the documentation
        -:   29:       and/or other materials provided with the distribution.
        -:   30:     * Neither the name of Intel Corporation nor the names of its contributors
        -:   31:       may be used to endorse or promote products derived from this software
        -:   32:       without specific prior written permission.
        -:   33:
        -:   34: THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   35: ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   36: WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
        -:   37: IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
        -:   38: INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
        -:   39: BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   40: DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
        -:   41: LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
        -:   42: OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
        -:   43: THE POSSIBILITY OF SUCH DAMAGE.
        -:   44:
        -:   45: David Navarro <david.navarro@intel.com>
        -:   46:
        -:   47:*/
        -:   48:
        -:   49:#include "internals.h"
        -:   50:#include <stdlib.h>
        -:   51:#include <string.h>
        -:   52:#include <stdio.h>
        -:   53:#include <float.h>
        -:   54:
        -:   55:
    #####:   56:int utils_textToInt(uint8_t * buffer,
        -:   57:                    int length,
        -:   58:                    int64_t * dataP)
        -:   59:{
    #####:   60:    uint64_t result = 0;
    #####:   61:    int sign = 1;
    #####:   62:    int i = 0;
        -:   63:
    #####:   64:    if (0 == length) return 0;
        -:   65:
    #####:   66:    if (buffer[0] == '-')
        -:   67:    {
    #####:   68:        sign = -1;
    #####:   69:        i = 1;
        -:   70:    }
        -:   71:
    #####:   72:    while (i < length)
        -:   73:    {
    #####:   74:        if ('0' <= buffer[i] && buffer[i] <= '9')
        -:   75:        {
    #####:   76:            if (result > (UINT64_MAX / 10)) return 0;
    #####:   77:            result *= 10;
    #####:   78:            result += buffer[i] - '0';
        -:   79:        }
        -:   80:        else
        -:   81:        {
    #####:   82:            return 0;
        -:   83:        }
    #####:   84:        i++;
        -:   85:    }
        -:   86:
    #####:   87:    if (result > INT64_MAX) return 0;
        -:   88:
    #####:   89:    if (sign == -1)
        -:   90:    {
    #####:   91:        *dataP = 0 - result;
        -:   92:    }
        -:   93:    else
        -:   94:    {
    #####:   95:        *dataP = result;
        -:   96:    }
        -:   97:
    #####:   98:    return 1;
        -:   99:}
        -:  100:
    #####:  101:int utils_textToFloat(uint8_t * buffer,
        -:  102:                      int length,
        -:  103:                      double * dataP)
        -:  104:{
        -:  105:    double result;
        -:  106:    int sign;
        -:  107:    int i;
        -:  108:
    #####:  109:    if (0 == length) return 0;
        -:  110:
    #####:  111:    if (buffer[0] == '-')
        -:  112:    {
    #####:  113:        sign = -1;
    #####:  114:        i = 1;
        -:  115:    }
        -:  116:    else
        -:  117:    {
    #####:  118:        sign = 1;
    #####:  119:        i = 0;
        -:  120:    }
        -:  121:
    #####:  122:    result = 0;
    #####:  123:    while (i < length && buffer[i] != '.')
        -:  124:    {
    #####:  125:        if ('0' <= buffer[i] && buffer[i] <= '9')
        -:  126:        {
    #####:  127:            if (result > (DBL_MAX / 10)) return 0;
    #####:  128:            result *= 10;
    #####:  129:            result += (buffer[i] - '0');
        -:  130:        }
        -:  131:        else
        -:  132:        {
    #####:  133:            return 0;
        -:  134:        }
    #####:  135:        i++;
        -:  136:    }
    #####:  137:    if (buffer[i] == '.')
        -:  138:    {
        -:  139:        double dec;
        -:  140:
    #####:  141:        i++;
    #####:  142:        if (i == length) return 0;
        -:  143:
    #####:  144:        dec = 0.1;
    #####:  145:        while (i < length)
        -:  146:        {
    #####:  147:            if ('0' <= buffer[i] && buffer[i] <= '9')
        -:  148:            {
    #####:  149:                if (result > (DBL_MAX - 1)) return 0;
    #####:  150:                result += (buffer[i] - '0') * dec;
    #####:  151:                dec /= 10;
        -:  152:            }
        -:  153:            else
        -:  154:            {
    #####:  155:                return 0;
        -:  156:            }
    #####:  157:            i++;
        -:  158:        }
        -:  159:    }
        -:  160:
    #####:  161:    *dataP = result * sign;
    #####:  162:    return 1;
        -:  163:}
        -:  164:
    #####:  165:size_t utils_intToText(int64_t data,
        -:  166:                       uint8_t * string,
        -:  167:                       size_t length)
        -:  168:{
        -:  169:    int index;
        -:  170:    bool minus;
        -:  171:    size_t result;
        -:  172:
    #####:  173:    if (data < 0)
        -:  174:    {
    #####:  175:        minus = true;
    #####:  176:        data = 0 - data;
        -:  177:    }
        -:  178:    else
        -:  179:    {
    #####:  180:        minus = false;
        -:  181:    }
        -:  182:
    #####:  183:    index = length - 1;
        -:  184:    do
        -:  185:    {
    #####:  186:        string[index] = '0' + data%10;
    #####:  187:        data /= 10;
    #####:  188:        index --;
    #####:  189:    } while (index >= 0 && data > 0);
        -:  190:
    #####:  191:    if (data > 0) return 0;
        -:  192:
    #####:  193:    if (minus == true)
        -:  194:    {
    #####:  195:        if (index == 0) return 0;
    #####:  196:        string[index] = '-';
        -:  197:    }
        -:  198:    else
        -:  199:    {
    #####:  200:        index++;
        -:  201:    }
        -:  202:
    #####:  203:    result = length - index;
        -:  204:
    #####:  205:    if (result < length)
        -:  206:    {
    #####:  207:        memmove(string, string + index, result);
        -:  208:    }
        -:  209:
    #####:  210:    return result;
        -:  211:}
        -:  212:
    #####:  213:size_t utils_floatToText(double data,
        -:  214:                         uint8_t * string,
        -:  215:                         size_t length)
        -:  216:{
        -:  217:    size_t intLength;
        -:  218:    size_t decLength;
        -:  219:    int64_t intPart;
        -:  220:    double decPart;
        -:  221:
    #####:  222:    if (data <= (double)INT64_MIN || data >= (double)INT64_MAX) return 0;
        -:  223:
    #####:  224:    intPart = (int64_t)data;
    #####:  225:    decPart = data - intPart;
    #####:  226:    if (decPart < 0)
        -:  227:    {
    #####:  228:        decPart = 1 - decPart;
        -:  229:    }
        -:  230:    else
        -:  231:    {
    #####:  232:        decPart = 1 + decPart;
        -:  233:    }
        -:  234:
    #####:  235:    if (decPart <= 1 + FLT_EPSILON)
        -:  236:    {
    #####:  237:        decPart = 0;
        -:  238:    }
        -:  239:
    #####:  240:    if (intPart == 0 && data < 0)
        -:  241:    {
        -:  242:        // deal with numbers between -1 and 0
    #####:  243:        if (length < 4) return 0;   // "-0.n"
    #####:  244:        string[0] = '-';
    #####:  245:        string[1] = '0';
    #####:  246:        intLength = 2;
        -:  247:    }
        -:  248:    else
        -:  249:    {
    #####:  250:        intLength = utils_intToText(intPart, string, length);
    #####:  251:        if (intLength == 0) return 0;
        -:  252:    }
    #####:  253:    decLength = 0;
    #####:  254:    if (decPart >= FLT_EPSILON)
        -:  255:    {
        -:  256:        double noiseFloor;
        -:  257:
    #####:  258:        if (intLength >= length - 1) return 0;
        -:  259:
    #####:  260:        noiseFloor = FLT_EPSILON;
        -:  261:        do
        -:  262:        {
    #####:  263:            decPart *= 10;
    #####:  264:            noiseFloor *= 10;
    #####:  265:        } while (decPart - (int64_t)decPart > noiseFloor);
        -:  266:
    #####:  267:        decLength = utils_intToText(decPart, string + intLength, length - intLength);
    #####:  268:        if (decLength <= 1) return 0;
        -:  269:
        -:  270:        // replace the leading 1 with a dot
    #####:  271:        string[intLength] = '.';
        -:  272:    }
        -:  273:
    #####:  274:    return intLength + decLength;
        -:  275:}
        -:  276:
    #####:  277:lwm2m_binding_t utils_stringToBinding(uint8_t * buffer,
        -:  278:                                      size_t length)
        -:  279:{
    #####:  280:    if (length == 0) return BINDING_UNKNOWN;
        -:  281:
    #####:  282:    switch (buffer[0])
        -:  283:    {
    #####:  284:    case 'U':
        -:  285:        switch (length)
        -:  286:        {
    #####:  287:        case 1:
    #####:  288:            return BINDING_U;
    #####:  289:        case 2:
    #####:  290:            switch (buffer[1])
        -:  291:            {
    #####:  292:            case 'Q':
    #####:  293:                 return BINDING_UQ;
    #####:  294:            case 'S':
    #####:  295:                 return BINDING_US;
    #####:  296:            default:
    #####:  297:                break;
        -:  298:            }
    #####:  299:            break;
    #####:  300:        case 3:
    #####:  301:            if (buffer[1] == 'Q' && buffer[2] == 'S')
        -:  302:            {
    #####:  303:                return BINDING_UQS;
        -:  304:            }
    #####:  305:            break;
    #####:  306:        default:
    #####:  307:            break;
        -:  308:        }
    #####:  309:        break;
        -:  310:
    #####:  311:        case 'S':
        -:  312:            switch (length)
        -:  313:            {
    #####:  314:            case 1:
    #####:  315:                return BINDING_S;
    #####:  316:            case 2:
    #####:  317:                if (buffer[1] == 'Q')
        -:  318:                {
    #####:  319:                    return BINDING_SQ;
        -:  320:                }
    #####:  321:                break;
    #####:  322:            default:
    #####:  323:                break;
        -:  324:            }
    #####:  325:            break;
        -:  326:
    #####:  327:        default:
    #####:  328:            break;
        -:  329:    }
        -:  330:
    #####:  331:    return BINDING_UNKNOWN;
        -:  332:}
        -:  333:
    #####:  334:lwm2m_media_type_t utils_convertMediaType(coap_content_type_t type)
        -:  335:{
        -:  336:    // Here we just check the content type is a valid value for LWM2M
    #####:  337:    switch((uint16_t)type)
        -:  338:    {
    #####:  339:    case TEXT_PLAIN:
    #####:  340:        return LWM2M_CONTENT_TEXT;
    #####:  341:    case APPLICATION_OCTET_STREAM:
    #####:  342:        return LWM2M_CONTENT_OPAQUE;
    #####:  343:    case LWM2M_CONTENT_TLV_OLD:
    #####:  344:        return LWM2M_CONTENT_TLV_OLD;
    #####:  345:    case LWM2M_CONTENT_TLV:
    #####:  346:        return LWM2M_CONTENT_TLV;
    #####:  347:    case LWM2M_CONTENT_JSON_OLD:
    #####:  348:        return LWM2M_CONTENT_JSON_OLD;
    #####:  349:    case LWM2M_CONTENT_JSON:
    #####:  350:        return LWM2M_CONTENT_JSON;
    #####:  351:    case APPLICATION_LINK_FORMAT:
    #####:  352:        return LWM2M_CONTENT_LINK;
        -:  353:
    #####:  354:    default:
    #####:  355:        return LWM2M_CONTENT_TEXT;
        -:  356:    }
        -:  357:}
        -:  358:
        -:  359:#ifdef LWM2M_CLIENT_MODE
    #####:  360:lwm2m_server_t * utils_findServer(lwm2m_context_t * contextP,
        -:  361:                                  void * fromSessionH)
        -:  362:{
        -:  363:    lwm2m_server_t * targetP;
        -:  364:
    #####:  365:    targetP = contextP->serverList;
    #####:  366:    while (targetP != NULL
    #####:  367:        && false == lwm2m_session_is_equal(targetP->sessionH, fromSessionH, contextP->userData))
        -:  368:    {
    #####:  369:        targetP = targetP->next;
        -:  370:    }
        -:  371:
    #####:  372:    return targetP;
        -:  373:}
        -:  374:#endif
        -:  375:
    #####:  376:lwm2m_server_t * utils_findBootstrapServer(lwm2m_context_t * contextP,
        -:  377:                                           void * fromSessionH)
        -:  378:{
        -:  379:#ifdef LWM2M_CLIENT_MODE
        -:  380:
        -:  381:    lwm2m_server_t * targetP;
        -:  382:
    #####:  383:    targetP = contextP->bootstrapServerList;
    #####:  384:    while (targetP != NULL
    #####:  385:        && false == lwm2m_session_is_equal(targetP->sessionH, fromSessionH, contextP->userData))
        -:  386:    {
    #####:  387:        targetP = targetP->next;
        -:  388:    }
        -:  389:
    #####:  390:    return targetP;
        -:  391:
        -:  392:#else
        -:  393:
        -:  394:    return NULL;
        -:  395:
        -:  396:#endif
        -:  397:}
        -:  398:
    #####:  399:int utils_isAltPathValid(const char * altPath)
        -:  400:{
        -:  401:    int i;
        -:  402:
    #####:  403:    if (altPath == NULL) return 0;
        -:  404:
    #####:  405:    if (altPath[0] != '/') return 0;
        -:  406:
    #####:  407:    for (i = 1 ; altPath[i] != 0 ; i++)
        -:  408:    {
        -:  409:        // TODO: Support multi-segment alternative path
    #####:  410:        if (altPath[i] == '/') return 0;
        -:  411:        // TODO: Check needs for sub-delims, ':' and '@'
    #####:  412:        if ((altPath[i] < 'A' || altPath[i] > 'Z')      // ALPHA
    #####:  413:         && (altPath[i] < 'a' || altPath[i] > 'z')
    #####:  414:         && (altPath[i] < '0' || altPath[i] > '9')      // DIGIT
    #####:  415:         && (altPath[i] != '-')                         // Other unreserved
    #####:  416:         && (altPath[i] != '.')
    #####:  417:         && (altPath[i] != '_')
    #####:  418:         && (altPath[i] != '~')
    #####:  419:         && (altPath[i] != '%'))                        // pct_encoded
        -:  420:        {
    #####:  421:            return 0;
        -:  422:        }
        -:  423:
        -:  424:    }
    #####:  425:    return 1;
        -:  426:}
        -:  427:
        -:  428:// copy a string in a buffer.
        -:  429:// return the number of copied bytes or -1 if the buffer is not large enough
    #####:  430:int utils_stringCopy(char * buffer,
        -:  431:                     size_t length,
        -:  432:                     const char * str)
        -:  433:{
        -:  434:    size_t i;
        -:  435:
    #####:  436:    for (i = 0 ; i < length && str[i] != 0 ; i++)
        -:  437:    {
    #####:  438:        buffer[i] = str[i];
        -:  439:    }
        -:  440:
    #####:  441:    if (i == length) return -1;
        -:  442:
    #####:  443:    buffer[i] = 0;
        -:  444:
    #####:  445:    return (int)i;
        -:  446:}
        -:  447:
    #####:  448:void utils_copyValue(void * dst,
        -:  449:                     const void * src,
        -:  450:                     size_t len)
        -:  451:{		
        -:  452:#ifdef LWM2M_BIG_ENDIAN
        -:  453:    memcpy(dst, src, len);
        -:  454:#else
        -:  455:#ifdef LWM2M_LITTLE_ENDIAN
        -:  456:    size_t i;
        -:  457:
    #####:  458:    for (i = 0; i < len; i++)
        -:  459:    {
    #####:  460:        ((uint8_t *)dst)[i] = ((uint8_t *)src)[len - 1 - i];
        -:  461:    }
        -:  462:#endif
        -:  463:#endif
    #####:  464:}
        -:  465:
        -:  466:
        -:  467:#define PRV_B64_PADDING '='
        -:  468:
        -:  469:static char b64Alphabet[64] =
        -:  470:{
        -:  471:    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
        -:  472:    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
        -:  473:    'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
        -:  474:    'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/'
        -:  475:};
        -:  476:
    #####:  477:static void prv_encodeBlock(uint8_t input[3],
        -:  478:                            uint8_t output[4])
        -:  479:{
    #####:  480:    output[0] = b64Alphabet[input[0] >> 2];
    #####:  481:    output[1] = b64Alphabet[((input[0] & 0x03) << 4) | (input[1] >> 4)];
    #####:  482:    output[2] = b64Alphabet[((input[1] & 0x0F) << 2) | (input[2] >> 6)];
    #####:  483:    output[3] = b64Alphabet[input[2] & 0x3F];
    #####:  484:}
        -:  485:
    #####:  486:size_t utils_base64GetSize(size_t dataLen)
        -:  487:{
        -:  488:    size_t result_len;
        -:  489:
    #####:  490:    result_len = 4 * (dataLen / 3);
    #####:  491:    if (dataLen % 3) result_len += 4;
        -:  492:
    #####:  493:    return result_len;
        -:  494:}
        -:  495:
    #####:  496:size_t utils_base64Encode(uint8_t * dataP,
        -:  497:                          size_t dataLen, 
        -:  498:                          uint8_t * bufferP,
        -:  499:                          size_t bufferLen)
        -:  500:{
        -:  501:    unsigned int data_index;
        -:  502:    unsigned int result_index;
        -:  503:    size_t result_len;
        -:  504:
    #####:  505:    result_len = utils_base64GetSize(dataLen);
        -:  506:
    #####:  507:    if (result_len > bufferLen) return 0;
        -:  508:
    #####:  509:    data_index = 0;
    #####:  510:    result_index = 0;
    #####:  511:    while (data_index < dataLen)
        -:  512:    {
    #####:  513:        switch (dataLen - data_index)
        -:  514:        {
    #####:  515:        case 0:
        -:  516:            // should never happen
    #####:  517:            break;
    #####:  518:        case 1:
    #####:  519:            bufferP[result_index] = b64Alphabet[dataP[data_index] >> 2];
    #####:  520:            bufferP[result_index + 1] = b64Alphabet[(dataP[data_index] & 0x03) << 4];
    #####:  521:            bufferP[result_index + 2] = PRV_B64_PADDING;
    #####:  522:            bufferP[result_index + 3] = PRV_B64_PADDING;
    #####:  523:            break;
    #####:  524:        case 2:
    #####:  525:            bufferP[result_index] = b64Alphabet[dataP[data_index] >> 2];
    #####:  526:            bufferP[result_index + 1] = b64Alphabet[(dataP[data_index] & 0x03) << 4 | (dataP[data_index + 1] >> 4)];
    #####:  527:            bufferP[result_index + 2] = b64Alphabet[(dataP[data_index + 1] & 0x0F) << 2];
    #####:  528:            bufferP[result_index + 3] = PRV_B64_PADDING;
    #####:  529:            break;
    #####:  530:        default:
    #####:  531:            prv_encodeBlock(dataP + data_index, bufferP + result_index);
    #####:  532:            break;
        -:  533:        }
    #####:  534:        data_index += 3;
    #####:  535:        result_index += 4;
        -:  536:    }
        -:  537:
    #####:  538:    return result_len;
        -:  539:}
        -:  540:
    #####:  541:lwm2m_data_type_t utils_depthToDatatype(uri_depth_t depth)
        -:  542:{
    #####:  543:    switch (depth)
        -:  544:    {
    #####:  545:    case URI_DEPTH_OBJECT:
    #####:  546:        return LWM2M_TYPE_OBJECT;
    #####:  547:    case URI_DEPTH_OBJECT_INSTANCE:
    #####:  548:        return LWM2M_TYPE_OBJECT_INSTANCE;
    #####:  549:    default:
    #####:  550:        break;
        -:  551:    }
        -:  552:
    #####:  553:    return LWM2M_TYPE_UNDEFINED;
        -:  554:}
