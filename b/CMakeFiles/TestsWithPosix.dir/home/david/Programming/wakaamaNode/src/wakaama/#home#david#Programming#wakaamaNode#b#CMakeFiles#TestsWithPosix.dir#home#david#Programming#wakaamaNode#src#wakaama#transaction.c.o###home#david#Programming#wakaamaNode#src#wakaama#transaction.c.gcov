        -:    0:Source:/home/david/Programming/wakaamaNode/src/wakaama/transaction.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/wakaama/transaction.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*******************************************************************************
        -:    2: *
        -:    3: * Copyright (c) 2013, 2014 Intel Corporation and others.
        -:    4: * All rights reserved. This program and the accompanying materials
        -:    5: * are made available under the terms of the Eclipse Public License v1.0
        -:    6: * and Eclipse Distribution License v1.0 which accompany this distribution.
        -:    7: *
        -:    8: * The Eclipse Public License is available at
        -:    9: *    http://www.eclipse.org/legal/epl-v10.html
        -:   10: * The Eclipse Distribution License is available at
        -:   11: *    http://www.eclipse.org/org/documents/edl-v10.php.
        -:   12: *
        -:   13: * Contributors:
        -:   14: *    David Navarro, Intel Corporation - initial API and implementation
        -:   15: *    Simon Bernard - Please refer to git log
        -:   16: *    Toby Jaffey - Please refer to git log
        -:   17: *    Pascal Rieux - Please refer to git log
        -:   18: *    Bosch Software Innovations GmbH - Please refer to git log
        -:   19: *
        -:   20: *******************************************************************************/
        -:   21:
        -:   22:/*
        -:   23: Copyright (c) 2013, 2014 Intel Corporation
        -:   24:
        -:   25: Redistribution and use in source and binary forms, with or without modification,
        -:   26: are permitted provided that the following conditions are met:
        -:   27:
        -:   28:     * Redistributions of source code must retain the above copyright notice,
        -:   29:       this list of conditions and the following disclaimer.
        -:   30:     * Redistributions in binary form must reproduce the above copyright notice,
        -:   31:       this list of conditions and the following disclaimer in the documentation
        -:   32:       and/or other materials provided with the distribution.
        -:   33:     * Neither the name of Intel Corporation nor the names of its contributors
        -:   34:       may be used to endorse or promote products derived from this software
        -:   35:       without specific prior written permission.
        -:   36:
        -:   37: THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   38: ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   39: WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
        -:   40: IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
        -:   41: INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
        -:   42: BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   43: DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
        -:   44: LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
        -:   45: OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
        -:   46: THE POSSIBILITY OF SUCH DAMAGE.
        -:   47:
        -:   48: David Navarro <david.navarro@intel.com>
        -:   49:
        -:   50:*/
        -:   51:
        -:   52:/*
        -:   53:Contains code snippets which are:
        -:   54:
        -:   55: * Copyright (c) 2013, Institute for Pervasive Computing, ETH Zurich
        -:   56: * All rights reserved.
        -:   57: *
        -:   58: * Redistribution and use in source and binary forms, with or without
        -:   59: * modification, are permitted provided that the following conditions
        -:   60: * are met:
        -:   61: * 1. Redistributions of source code must retain the above copyright
        -:   62: *    notice, this list of conditions and the following disclaimer.
        -:   63: * 2. Redistributions in binary form must reproduce the above copyright
        -:   64: *    notice, this list of conditions and the following disclaimer in the
        -:   65: *    documentation and/or other materials provided with the distribution.
        -:   66: * 3. Neither the name of the Institute nor the names of its contributors
        -:   67: *    may be used to endorse or promote products derived from this software
        -:   68: *    without specific prior written permission.
        -:   69: *
        -:   70: * THIS SOFTWARE IS PROVIDED BY THE INSTITUTE AND CONTRIBUTORS ``AS IS'' AND
        -:   71: * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
        -:   72: * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
        -:   73: * ARE DISCLAIMED.  IN NO EVENT SHALL THE INSTITUTE OR CONTRIBUTORS BE LIABLE
        -:   74: * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
        -:   75: * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
        -:   76: * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
        -:   77: * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
        -:   78: * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
        -:   79: * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
        -:   80: * SUCH DAMAGE.
        -:   81:
        -:   82:*/
        -:   83:
        -:   84:/************************************************************************
        -:   85: *  Function for communications transactions.
        -:   86: *
        -:   87: *  Basic specification: rfc7252
        -:   88: *
        -:   89: *  Transaction implements processing of piggybacked and separate response communication
        -:   90: *  dialogs specified in section 2.2 of the above specification.
        -:   91: *  The caller registers a callback function, which is called, when either the result is
        -:   92: *  received or a timeout occurs.
        -:   93: *
        -:   94: *  Supported dialogs:
        -:   95: *  Requests (GET - DELETE):
        -:   96: *  - CON with mid, without token => regular finished with corresponding ACK.MID
        -:   97: *  - CON with mid, with token => regular finished with corresponding ACK.MID and response containing
        -:   98: *                  the token. Supports both versions, with piggybacked ACK and separate ACK/response.
        -:   99: *                  Though the ACK.MID may be lost in the separate version, a matching response may
        -:  100: *                  finish the transaction even without the ACK.MID.
        -:  101: *  - NON without token => no transaction, no result expected!
        -:  102: *  - NON with token => regular finished with response containing the token.
        -:  103: *  Responses (COAP_201_CREATED - ?):
        -:  104: *  - CON with mid => regular finished with corresponding ACK.MID
        -:  105: */
        -:  106:
        -:  107:#include "internals.h"
        -:  108:
        -:  109:
        -:  110:/*
        -:  111: * Modulo mask (+1 and +0.5 for rounding) for a random number to get the tick number for the random
        -:  112: * retransmission time between COAP_RESPONSE_TIMEOUT and COAP_RESPONSE_TIMEOUT*COAP_RESPONSE_RANDOM_FACTOR.
        -:  113: */
        -:  114:#define COAP_RESPONSE_TIMEOUT_TICKS         (CLOCK_SECOND * COAP_RESPONSE_TIMEOUT)
        -:  115:#define COAP_RESPONSE_TIMEOUT_BACKOFF_MASK  ((CLOCK_SECOND * COAP_RESPONSE_TIMEOUT * (COAP_RESPONSE_RANDOM_FACTOR - 1)) + 1.5)
        -:  116:
    #####:  117:static int prv_checkFinished(lwm2m_transaction_t * transacP,
        -:  118:                             coap_packet_t * receivedMessage)
        -:  119:{
        -:  120:    int len;
        -:  121:    const uint8_t* token;
    #####:  122:    coap_packet_t * transactionMessage = transacP->message;
        -:  123:
    #####:  124:    if (COAP_DELETE < transactionMessage->code)
        -:  125:    {
        -:  126:        // response
    #####:  127:        return transacP->ack_received ? 1 : 0;
        -:  128:    }
    #####:  129:    if (!IS_OPTION(transactionMessage, COAP_OPTION_TOKEN))
        -:  130:    {
        -:  131:        // request without token
    #####:  132:        return transacP->ack_received ? 1 : 0;
        -:  133:    }
        -:  134:
    #####:  135:    len = coap_get_header_token(receivedMessage, &token);
    #####:  136:    if (transactionMessage->token_len == len)
        -:  137:    {
    #####:  138:        if (memcmp(transactionMessage->token, token, len)==0) return 1;
        -:  139:    }
        -:  140:
    #####:  141:    return 0;
        -:  142:}
        -:  143:
    #####:  144:lwm2m_transaction_t * transaction_new(void * sessionH,
        -:  145:                                      coap_method_t method,
        -:  146:                                      char * altPath,
        -:  147:                                      lwm2m_uri_t * uriP,
        -:  148:                                      uint16_t mID,
        -:  149:                                      uint8_t token_len,
        -:  150:                                      uint8_t* token)
        -:  151:{
        -:  152:    lwm2m_transaction_t * transacP;
        -:  153:    int result;
        -:  154:
        -:  155://    LOG_ARG("method: %d, altPath: \"%s\", mID: %d, token_len: %d",
        -:  156://            method, altPath, mID, token_len);
        -:  157:
        -:  158:    // no transactions without peer
    #####:  159:    if (NULL == sessionH) return NULL;
        -:  160:
    #####:  161:    transacP = (lwm2m_transaction_t *)lwm2m_malloc(sizeof(lwm2m_transaction_t));
        -:  162:
    #####:  163:    if (NULL == transacP) return NULL;
    #####:  164:    memset(transacP, 0, sizeof(lwm2m_transaction_t));
        -:  165:
    #####:  166:    transacP->message = lwm2m_malloc(sizeof(coap_packet_t));
    #####:  167:    if (NULL == transacP->message) goto error;
        -:  168:
    #####:  169:    coap_init_message(transacP->message, COAP_TYPE_CON, method, mID);
        -:  170:
    #####:  171:    transacP->peerH = sessionH;
        -:  172:
    #####:  173:    transacP->mID = mID;
        -:  174:
    #####:  175:    if (altPath != NULL)
        -:  176:    {
        -:  177:        // TODO: Support multi-segment alternative path
    #####:  178:        coap_set_header_uri_path_segment(transacP->message, altPath + 1);
        -:  179:    }
    #####:  180:    if (NULL != uriP)
        -:  181:    {
        -:  182:        char stringID[LWM2M_STRING_ID_MAX_LEN];
        -:  183:
    #####:  184:        result = utils_intToText(uriP->objectId, (uint8_t*)stringID, LWM2M_STRING_ID_MAX_LEN);
    #####:  185:        if (result == 0) goto error;
    #####:  186:        stringID[result] = 0;
    #####:  187:        coap_set_header_uri_path_segment(transacP->message, stringID);
        -:  188:
    #####:  189:        if (LWM2M_URI_IS_SET_INSTANCE(uriP))
        -:  190:        {
    #####:  191:            result = utils_intToText(uriP->instanceId, (uint8_t*)stringID, LWM2M_STRING_ID_MAX_LEN);
    #####:  192:            if (result == 0) goto error;
    #####:  193:            stringID[result] = 0;
    #####:  194:            coap_set_header_uri_path_segment(transacP->message, stringID);
        -:  195:        }
        -:  196:        else
        -:  197:        {
    #####:  198:            if (LWM2M_URI_IS_SET_RESOURCE(uriP))
        -:  199:            {
    #####:  200:                coap_set_header_uri_path_segment(transacP->message, NULL);
        -:  201:            }
        -:  202:        }
    #####:  203:        if (LWM2M_URI_IS_SET_RESOURCE(uriP))
        -:  204:        {
    #####:  205:            result = utils_intToText(uriP->resourceId, (uint8_t*)stringID, LWM2M_STRING_ID_MAX_LEN);
    #####:  206:            if (result == 0) goto error;
    #####:  207:            stringID[result] = 0;
    #####:  208:            coap_set_header_uri_path_segment(transacP->message, stringID);
        -:  209:        }
        -:  210:    }
    #####:  211:    if (0 < token_len)
        -:  212:    {
    #####:  213:        if (NULL != token)
        -:  214:        {
    #####:  215:            coap_set_header_token(transacP->message, token, token_len);
        -:  216:        }
        -:  217:        else {
        -:  218:            // generate a token
        -:  219:            uint8_t temp_token[COAP_TOKEN_LEN];
    #####:  220:            time_t tv_sec = lwm2m_gettime();
        -:  221:
        -:  222:            // initialize first 6 bytes, leave the last 2 random
    #####:  223:            temp_token[0] = mID;
    #####:  224:            temp_token[1] = mID >> 8;
    #####:  225:            temp_token[2] = tv_sec;
    #####:  226:            temp_token[3] = tv_sec >> 8;
    #####:  227:            temp_token[4] = tv_sec >> 16;
    #####:  228:            temp_token[5] = tv_sec >> 24;
        -:  229:            // use just the provided amount of bytes
    #####:  230:            coap_set_header_token(transacP->message, temp_token, token_len);
        -:  231:        }
        -:  232:    }
        -:  233:
    #####:  234:    return transacP;
        -:  235:
    #####:  236:error:
        -:  237:    LOG("Exiting on failure");
    #####:  238:    lwm2m_free(transacP);
    #####:  239:    return NULL;
        -:  240:}
        -:  241:
    #####:  242:void transaction_free(lwm2m_transaction_t * transacP)
        -:  243:{
    #####:  244:    if (transacP->message)
        -:  245:    {
    #####:  246:       coap_free_header(transacP->message);
    #####:  247:       lwm2m_free(transacP->message);
        -:  248:    }
        -:  249:
    #####:  250:    if (transacP->buffer) lwm2m_free(transacP->buffer);
    #####:  251:    lwm2m_free(transacP);
    #####:  252:}
        -:  253:
    #####:  254:void transaction_remove(lwm2m_context_t * contextP,
        -:  255:                        lwm2m_transaction_t * transacP)
        -:  256:{
    #####:  257:    contextP->transactionList = (lwm2m_transaction_t *) LWM2M_LIST_RM(contextP->transactionList, transacP->mID, NULL);
    #####:  258:    transaction_free(transacP);
    #####:  259:}
        -:  260:
    #####:  261:bool transaction_handleResponse(lwm2m_context_t * contextP,
        -:  262:                                 void * fromSessionH,
        -:  263:                                 coap_packet_t * message,
        -:  264:                                 coap_packet_t * response)
        -:  265:{
    #####:  266:    bool found = false;
    #####:  267:    bool reset = false;
        -:  268:    lwm2m_transaction_t * transacP;
        -:  269:
    #####:  270:    transacP = contextP->transactionList;
        -:  271:
    #####:  272:    while (NULL != transacP)
        -:  273:    {
    #####:  274:        if (lwm2m_session_is_equal(fromSessionH, transacP->peerH, contextP->userData) == true)
        -:  275:        {
    #####:  276:            if (!transacP->ack_received)
        -:  277:            {
    #####:  278:                if ((COAP_TYPE_ACK == message->type) || (COAP_TYPE_RST == message->type))
        -:  279:                {
    #####:  280:                    if (transacP->mID == message->mid)
        -:  281:	                {
    #####:  282:    	                found = true;
    #####:  283:        	            transacP->ack_received = true;
    #####:  284:            	        reset = COAP_TYPE_RST == message->type;
        -:  285:            	    }
        -:  286:                }
        -:  287:            }
        -:  288:
    #####:  289:            if (reset || prv_checkFinished(transacP, message))
        -:  290:            {
        -:  291:                // HACK: If a message is sent from the monitor callback,
        -:  292:                // it will arrive before the registration ACK.
        -:  293:                // So we resend transaction that were denied for authentication reason.
    #####:  294:                if (!reset)
        -:  295:                {
    #####:  296:                    if (COAP_TYPE_CON == message->type && NULL != response)
        -:  297:                    {
    #####:  298:                        coap_init_message(response, COAP_TYPE_ACK, 0, message->mid);
    #####:  299:                        message_send(contextP, response, fromSessionH);
        -:  300:                    }
        -:  301:                
    #####:  302:	                if ((COAP_401_UNAUTHORIZED == message->code) && (COAP_MAX_RETRANSMIT > transacP->retrans_counter))
        -:  303:    	            {
    #####:  304:        	            transacP->ack_received = false;
    #####:  305:            	        transacP->retrans_time += COAP_RESPONSE_TIMEOUT;
    #####:  306:                	    return true;
        -:  307:                	}
        -:  308:				}       
    #####:  309:                if (transacP->callback != NULL)
        -:  310:                {
    #####:  311:                    transacP->callback(transacP, message);
        -:  312:                }
    #####:  313:                transaction_remove(contextP, transacP);
    #####:  314:                return true;
        -:  315:            }
        -:  316:            // if we found our guy, exit
    #####:  317:            if (found)
        -:  318:            {
    #####:  319:                time_t tv_sec = lwm2m_gettime();
    #####:  320:                if (0 <= tv_sec)
        -:  321:                {
    #####:  322:                    transacP->retrans_time = tv_sec;
        -:  323:                }
    #####:  324:                if (transacP->response_timeout)
        -:  325:                {
    #####:  326:                    transacP->retrans_time += transacP->response_timeout;
        -:  327:                }
        -:  328:                else
        -:  329:                {
    #####:  330:                    transacP->retrans_time += COAP_RESPONSE_TIMEOUT * transacP->retrans_counter;
        -:  331:                }
    #####:  332:                return true;
        -:  333:            }
        -:  334:        }
        -:  335:
    #####:  336:        transacP = transacP->next;
        -:  337:    }
    #####:  338:    return false;
        -:  339:}
        -:  340:
    #####:  341:int transaction_send(lwm2m_context_t * contextP,
        -:  342:                     lwm2m_transaction_t * transacP)
        -:  343:{
    #####:  344:    bool maxRetriesReached = false;
        -:  345:
    #####:  346:    if (transacP->buffer == NULL)
        -:  347:    {
    #####:  348:        transacP->buffer_len = coap_serialize_get_size(transacP->message);
    #####:  349:        if (transacP->buffer_len == 0)
        -:  350:        {
    #####:  351:           transaction_remove(contextP, transacP);
    #####:  352:           return COAP_500_INTERNAL_SERVER_ERROR;
        -:  353:        }
        -:  354:
    #####:  355:        transacP->buffer = (uint8_t*)lwm2m_malloc(transacP->buffer_len);
    #####:  356:        if (transacP->buffer == NULL)
        -:  357:        {
    #####:  358:           transaction_remove(contextP, transacP);
    #####:  359:           return COAP_500_INTERNAL_SERVER_ERROR;
        -:  360:        }
        -:  361:
    #####:  362:        transacP->buffer_len = coap_serialize_message(transacP->message, transacP->buffer);
    #####:  363:        if (transacP->buffer_len == 0)
        -:  364:        {
    #####:  365:            lwm2m_free(transacP->buffer);
    #####:  366:            transacP->buffer = NULL;
    #####:  367:            transaction_remove(contextP, transacP);
    #####:  368:            return COAP_500_INTERNAL_SERVER_ERROR;
        -:  369:        }
        -:  370:    }
        -:  371:
    #####:  372:    if (!transacP->ack_received)
        -:  373:    {
    #####:  374:        long unsigned timeout=0;
        -:  375:
    #####:  376:        if (0 == transacP->retrans_counter)
        -:  377:        {
    #####:  378:            time_t tv_sec = lwm2m_gettime();
    #####:  379:            if (0 <= tv_sec)
        -:  380:            {
    #####:  381:                transacP->retrans_time = tv_sec + COAP_RESPONSE_TIMEOUT;
    #####:  382:                transacP->retrans_counter = 1;
        -:  383:            }
        -:  384:            else
        -:  385:            {
    #####:  386:                maxRetriesReached = true;
        -:  387:            }
        -:  388:        }
        -:  389:        else
        -:  390:        {
    #####:  391:            timeout = COAP_RESPONSE_TIMEOUT << (transacP->retrans_counter - 1);
        -:  392:        }
        -:  393:
    #####:  394:        if (COAP_MAX_RETRANSMIT + 1 >= transacP->retrans_counter)
        -:  395:        {
    #####:  396:            (void)lwm2m_buffer_send(transacP->peerH, transacP->buffer, transacP->buffer_len, contextP->userData);
        -:  397:
    #####:  398:            transacP->retrans_time += timeout;
    #####:  399:            transacP->retrans_counter += 1;
        -:  400:        }
        -:  401:        else
        -:  402:        {
    #####:  403:            maxRetriesReached = true;
        -:  404:        }
        -:  405:    }
        -:  406:
    #####:  407:    if (transacP->ack_received || maxRetriesReached)
        -:  408:    {
    #####:  409:        if (transacP->callback)
        -:  410:        {
    #####:  411:            transacP->callback(transacP, NULL);
        -:  412:        }
    #####:  413:        transaction_remove(contextP, transacP);
    #####:  414:        return -1;
        -:  415:    }
        -:  416:
    #####:  417:    return 0;
        -:  418:}
        -:  419:
    #####:  420:void transaction_step(lwm2m_context_t * contextP,
        -:  421:                      time_t currentTime,
        -:  422:                      time_t * timeoutP)
        -:  423:{
        -:  424:    lwm2m_transaction_t * transacP;
        -:  425:
    #####:  426:    transacP = contextP->transactionList;
    #####:  427:    while (transacP != NULL)
        -:  428:    {
        -:  429:        // transaction_send() may remove transaction from the linked list
    #####:  430:        lwm2m_transaction_t * nextP = transacP->next;
    #####:  431:        int removed = 0;
        -:  432:
    #####:  433:        if (transacP->retrans_time <= currentTime)
        -:  434:        {
    #####:  435:            removed = transaction_send(contextP, transacP);
        -:  436:        }
        -:  437:
    #####:  438:        if (0 == removed)
        -:  439:        {
        -:  440:            time_t interval;
        -:  441:
    #####:  442:            if (transacP->retrans_time > currentTime)
        -:  443:            {
    #####:  444:                interval = transacP->retrans_time - currentTime;
        -:  445:            }
        -:  446:            else
        -:  447:            {
    #####:  448:                interval = 1;
        -:  449:            }
        -:  450:
    #####:  451:            if (*timeoutP > interval)
        -:  452:            {
    #####:  453:                *timeoutP = interval;
        -:  454:            }
        -:  455:        }
        -:  456:        else
        -:  457:        {
    #####:  458:            *timeoutP = 1;
        -:  459:        }
        -:  460:
    #####:  461:        transacP = nextP;
        -:  462:    }
    #####:  463:}
