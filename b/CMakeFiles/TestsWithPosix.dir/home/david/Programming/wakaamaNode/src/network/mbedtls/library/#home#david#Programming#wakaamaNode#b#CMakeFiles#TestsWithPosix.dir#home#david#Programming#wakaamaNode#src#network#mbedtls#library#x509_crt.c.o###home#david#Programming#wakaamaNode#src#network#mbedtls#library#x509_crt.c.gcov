        -:    0:Source:/home/david/Programming/wakaamaNode/src/network/mbedtls/library/x509_crt.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/network/mbedtls/library/x509_crt.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*
        -:    2: *  X.509 certificate parsing and verification
        -:    3: *
        -:    4: *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
        -:    5: *  SPDX-License-Identifier: Apache-2.0
        -:    6: *
        -:    7: *  Licensed under the Apache License, Version 2.0 (the "License"); you may
        -:    8: *  not use this file except in compliance with the License.
        -:    9: *  You may obtain a copy of the License at
        -:   10: *
        -:   11: *  http://www.apache.org/licenses/LICENSE-2.0
        -:   12: *
        -:   13: *  Unless required by applicable law or agreed to in writing, software
        -:   14: *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
        -:   15: *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   16: *  See the License for the specific language governing permissions and
        -:   17: *  limitations under the License.
        -:   18: *
        -:   19: *  This file is part of mbed TLS (https://tls.mbed.org)
        -:   20: */
        -:   21:/*
        -:   22: *  The ITU-T X.509 standard defines a certificate format for PKI.
        -:   23: *
        -:   24: *  http://www.ietf.org/rfc/rfc5280.txt (Certificates and CRLs)
        -:   25: *  http://www.ietf.org/rfc/rfc3279.txt (Alg IDs for CRLs)
        -:   26: *  http://www.ietf.org/rfc/rfc2986.txt (CSRs, aka PKCS#10)
        -:   27: *
        -:   28: *  http://www.itu.int/ITU-T/studygroups/com17/languages/X.680-0207.pdf
        -:   29: *  http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf
        -:   30: *
        -:   31: *  [SIRO] https://cabforum.org/wp-content/uploads/Chunghwatelecom201503cabforumV4.pdf
        -:   32: */
        -:   33:
        -:   34:#if !defined(MBEDTLS_CONFIG_FILE)
        -:   35:#include "mbedtls/config.h"
        -:   36:#else
        -:   37:#include MBEDTLS_CONFIG_FILE
        -:   38:#endif
        -:   39:
        -:   40:#if defined(MBEDTLS_X509_CRT_PARSE_C)
        -:   41:
        -:   42:#include "mbedtls/x509_crt.h"
        -:   43:#include "mbedtls/oid.h"
        -:   44:#include "mbedtls/platform_util.h"
        -:   45:
        -:   46:#include <stdio.h>
        -:   47:#include <string.h>
        -:   48:
        -:   49:#if defined(MBEDTLS_PEM_PARSE_C)
        -:   50:#include "mbedtls/pem.h"
        -:   51:#endif
        -:   52:
        -:   53:#if defined(MBEDTLS_PLATFORM_C)
        -:   54:#include "mbedtls/platform.h"
        -:   55:#else
        -:   56:#include <stdlib.h>
        -:   57:#define mbedtls_free       free
        -:   58:#define mbedtls_calloc    calloc
        -:   59:#define mbedtls_snprintf   snprintf
        -:   60:#endif
        -:   61:
        -:   62:#if defined(MBEDTLS_THREADING_C)
        -:   63:#include "mbedtls/threading.h"
        -:   64:#endif
        -:   65:
        -:   66:#if defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)
        -:   67:#include <windows.h>
        -:   68:#else
        -:   69:#include <time.h>
        -:   70:#endif
        -:   71:
        -:   72:#if defined(MBEDTLS_FS_IO)
        -:   73:#include <stdio.h>
        -:   74:#if !defined(_WIN32) || defined(EFIX64) || defined(EFI32)
        -:   75:#include <sys/types.h>
        -:   76:#include <sys/stat.h>
        -:   77:#include <dirent.h>
        -:   78:#endif /* !_WIN32 || EFIX64 || EFI32 */
        -:   79:#endif
        -:   80:
        -:   81:/*
        -:   82: * Item in a verification chain: cert and flags for it
        -:   83: */
        -:   84:typedef struct {
        -:   85:    mbedtls_x509_crt *crt;
        -:   86:    uint32_t flags;
        -:   87:} x509_crt_verify_chain_item;
        -:   88:
        -:   89:/*
        -:   90: * Max size of verification chain: end-entity + intermediates + trusted root
        -:   91: */
        -:   92:#define X509_MAX_VERIFY_CHAIN_SIZE    ( MBEDTLS_X509_MAX_INTERMEDIATE_CA + 2 )
        -:   93:
        -:   94:/*
        -:   95: * Default profile
        -:   96: */
        -:   97:const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_default =
        -:   98:{
        -:   99:#if defined(MBEDTLS_TLS_DEFAULT_ALLOW_SHA1_IN_CERTIFICATES)
        -:  100:    /* Allow SHA-1 (weak, but still safe in controlled environments) */
        -:  101:    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA1 ) |
        -:  102:#endif
        -:  103:    /* Only SHA-2 hashes */
        -:  104:    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA224 ) |
        -:  105:    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA256 ) |
        -:  106:    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA384 ) |
        -:  107:    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA512 ),
        -:  108:    0xFFFFFFF, /* Any PK alg    */
        -:  109:    0xFFFFFFF, /* Any curve     */
        -:  110:    2048,
        -:  111:};
        -:  112:
        -:  113:/*
        -:  114: * Next-default profile
        -:  115: */
        -:  116:const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_next =
        -:  117:{
        -:  118:    /* Hashes from SHA-256 and above */
        -:  119:    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA256 ) |
        -:  120:    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA384 ) |
        -:  121:    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA512 ),
        -:  122:    0xFFFFFFF, /* Any PK alg    */
        -:  123:#if defined(MBEDTLS_ECP_C)
        -:  124:    /* Curves at or above 128-bit security level */
        -:  125:    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP256R1 ) |
        -:  126:    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP384R1 ) |
        -:  127:    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP521R1 ) |
        -:  128:    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_BP256R1 ) |
        -:  129:    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_BP384R1 ) |
        -:  130:    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_BP512R1 ) |
        -:  131:    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP256K1 ),
        -:  132:#else
        -:  133:    0,
        -:  134:#endif
        -:  135:    2048,
        -:  136:};
        -:  137:
        -:  138:/*
        -:  139: * NSA Suite B Profile
        -:  140: */
        -:  141:const mbedtls_x509_crt_profile mbedtls_x509_crt_profile_suiteb =
        -:  142:{
        -:  143:    /* Only SHA-256 and 384 */
        -:  144:    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA256 ) |
        -:  145:    MBEDTLS_X509_ID_FLAG( MBEDTLS_MD_SHA384 ),
        -:  146:    /* Only ECDSA */
        -:  147:    MBEDTLS_X509_ID_FLAG( MBEDTLS_PK_ECDSA ) |
        -:  148:    MBEDTLS_X509_ID_FLAG( MBEDTLS_PK_ECKEY ),
        -:  149:#if defined(MBEDTLS_ECP_C)
        -:  150:    /* Only NIST P-256 and P-384 */
        -:  151:    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP256R1 ) |
        -:  152:    MBEDTLS_X509_ID_FLAG( MBEDTLS_ECP_DP_SECP384R1 ),
        -:  153:#else
        -:  154:    0,
        -:  155:#endif
        -:  156:    0,
        -:  157:};
        -:  158:
        -:  159:/*
        -:  160: * Check md_alg against profile
        -:  161: * Return 0 if md_alg is acceptable for this profile, -1 otherwise
        -:  162: */
    #####:  163:static int x509_profile_check_md_alg( const mbedtls_x509_crt_profile *profile,
        -:  164:                                      mbedtls_md_type_t md_alg )
        -:  165:{
    #####:  166:    if( ( profile->allowed_mds & MBEDTLS_X509_ID_FLAG( md_alg ) ) != 0 )
    #####:  167:        return( 0 );
        -:  168:
    #####:  169:    return( -1 );
        -:  170:}
        -:  171:
        -:  172:/*
        -:  173: * Check pk_alg against profile
        -:  174: * Return 0 if pk_alg is acceptable for this profile, -1 otherwise
        -:  175: */
    #####:  176:static int x509_profile_check_pk_alg( const mbedtls_x509_crt_profile *profile,
        -:  177:                                      mbedtls_pk_type_t pk_alg )
        -:  178:{
    #####:  179:    if( ( profile->allowed_pks & MBEDTLS_X509_ID_FLAG( pk_alg ) ) != 0 )
    #####:  180:        return( 0 );
        -:  181:
    #####:  182:    return( -1 );
        -:  183:}
        -:  184:
        -:  185:/*
        -:  186: * Check key against profile
        -:  187: * Return 0 if pk is acceptable for this profile, -1 otherwise
        -:  188: */
    #####:  189:static int x509_profile_check_key( const mbedtls_x509_crt_profile *profile,
        -:  190:                                   const mbedtls_pk_context *pk )
        -:  191:{
    #####:  192:    const mbedtls_pk_type_t pk_alg = mbedtls_pk_get_type( pk );
        -:  193:
        -:  194:#if defined(MBEDTLS_RSA_C)
    #####:  195:    if( pk_alg == MBEDTLS_PK_RSA || pk_alg == MBEDTLS_PK_RSASSA_PSS )
        -:  196:    {
    #####:  197:        if( mbedtls_pk_get_bitlen( pk ) >= profile->rsa_min_bitlen )
    #####:  198:            return( 0 );
        -:  199:
    #####:  200:        return( -1 );
        -:  201:    }
        -:  202:#endif
        -:  203:
        -:  204:#if defined(MBEDTLS_ECP_C)
        -:  205:    if( pk_alg == MBEDTLS_PK_ECDSA ||
        -:  206:        pk_alg == MBEDTLS_PK_ECKEY ||
        -:  207:        pk_alg == MBEDTLS_PK_ECKEY_DH )
        -:  208:    {
        -:  209:        const mbedtls_ecp_group_id gid = mbedtls_pk_ec( *pk )->grp.id;
        -:  210:
        -:  211:        if( ( profile->allowed_curves & MBEDTLS_X509_ID_FLAG( gid ) ) != 0 )
        -:  212:            return( 0 );
        -:  213:
        -:  214:        return( -1 );
        -:  215:    }
        -:  216:#endif
        -:  217:
    #####:  218:    return( -1 );
        -:  219:}
        -:  220:
        -:  221:/*
        -:  222: *  Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }
        -:  223: */
    #####:  224:static int x509_get_version( unsigned char **p,
        -:  225:                             const unsigned char *end,
        -:  226:                             int *ver )
        -:  227:{
        -:  228:    int ret;
        -:  229:    size_t len;
        -:  230:
    #####:  231:    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
        -:  232:            MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 0 ) ) != 0 )
        -:  233:    {
    #####:  234:        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
        -:  235:        {
    #####:  236:            *ver = 0;
    #####:  237:            return( 0 );
        -:  238:        }
        -:  239:
    #####:  240:        return( ret );
        -:  241:    }
        -:  242:
    #####:  243:    end = *p + len;
        -:  244:
    #####:  245:    if( ( ret = mbedtls_asn1_get_int( p, end, ver ) ) != 0 )
    #####:  246:        return( MBEDTLS_ERR_X509_INVALID_VERSION + ret );
        -:  247:
    #####:  248:    if( *p != end )
    #####:  249:        return( MBEDTLS_ERR_X509_INVALID_VERSION +
        -:  250:                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
        -:  251:
    #####:  252:    return( 0 );
        -:  253:}
        -:  254:
        -:  255:/*
        -:  256: *  Validity ::= SEQUENCE {
        -:  257: *       notBefore      Time,
        -:  258: *       notAfter       Time }
        -:  259: */
    #####:  260:static int x509_get_dates( unsigned char **p,
        -:  261:                           const unsigned char *end,
        -:  262:                           mbedtls_x509_time *from,
        -:  263:                           mbedtls_x509_time *to )
        -:  264:{
        -:  265:    int ret;
        -:  266:    size_t len;
        -:  267:
    #####:  268:    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
        -:  269:            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
    #####:  270:        return( MBEDTLS_ERR_X509_INVALID_DATE + ret );
        -:  271:
    #####:  272:    end = *p + len;
        -:  273:
    #####:  274:    if( ( ret = mbedtls_x509_get_time( p, end, from ) ) != 0 )
    #####:  275:        return( ret );
        -:  276:
    #####:  277:    if( ( ret = mbedtls_x509_get_time( p, end, to ) ) != 0 )
    #####:  278:        return( ret );
        -:  279:
    #####:  280:    if( *p != end )
    #####:  281:        return( MBEDTLS_ERR_X509_INVALID_DATE +
        -:  282:                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
        -:  283:
    #####:  284:    return( 0 );
        -:  285:}
        -:  286:
        -:  287:/*
        -:  288: * X.509 v2/v3 unique identifier (not parsed)
        -:  289: */
    #####:  290:static int x509_get_uid( unsigned char **p,
        -:  291:                         const unsigned char *end,
        -:  292:                         mbedtls_x509_buf *uid, int n )
        -:  293:{
        -:  294:    int ret;
        -:  295:
    #####:  296:    if( *p == end )
    #####:  297:        return( 0 );
        -:  298:
    #####:  299:    uid->tag = **p;
        -:  300:
    #####:  301:    if( ( ret = mbedtls_asn1_get_tag( p, end, &uid->len,
        -:  302:            MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | n ) ) != 0 )
        -:  303:    {
    #####:  304:        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
    #####:  305:            return( 0 );
        -:  306:
    #####:  307:        return( ret );
        -:  308:    }
        -:  309:
    #####:  310:    uid->p = *p;
    #####:  311:    *p += uid->len;
        -:  312:
    #####:  313:    return( 0 );
        -:  314:}
        -:  315:
    #####:  316:static int x509_get_basic_constraints( unsigned char **p,
        -:  317:                                       const unsigned char *end,
        -:  318:                                       int *ca_istrue,
        -:  319:                                       int *max_pathlen )
        -:  320:{
        -:  321:    int ret;
        -:  322:    size_t len;
        -:  323:
        -:  324:    /*
        -:  325:     * BasicConstraints ::= SEQUENCE {
        -:  326:     *      cA                      BOOLEAN DEFAULT FALSE,
        -:  327:     *      pathLenConstraint       INTEGER (0..MAX) OPTIONAL }
        -:  328:     */
    #####:  329:    *ca_istrue = 0; /* DEFAULT FALSE */
    #####:  330:    *max_pathlen = 0; /* endless */
        -:  331:
    #####:  332:    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
        -:  333:            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
    #####:  334:        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
        -:  335:
    #####:  336:    if( *p == end )
    #####:  337:        return( 0 );
        -:  338:
    #####:  339:    if( ( ret = mbedtls_asn1_get_bool( p, end, ca_istrue ) ) != 0 )
        -:  340:    {
    #####:  341:        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
    #####:  342:            ret = mbedtls_asn1_get_int( p, end, ca_istrue );
        -:  343:
    #####:  344:        if( ret != 0 )
    #####:  345:            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
        -:  346:
    #####:  347:        if( *ca_istrue != 0 )
    #####:  348:            *ca_istrue = 1;
        -:  349:    }
        -:  350:
    #####:  351:    if( *p == end )
    #####:  352:        return( 0 );
        -:  353:
    #####:  354:    if( ( ret = mbedtls_asn1_get_int( p, end, max_pathlen ) ) != 0 )
    #####:  355:        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
        -:  356:
    #####:  357:    if( *p != end )
    #####:  358:        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
        -:  359:                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
        -:  360:
    #####:  361:    (*max_pathlen)++;
        -:  362:
    #####:  363:    return( 0 );
        -:  364:}
        -:  365:
    #####:  366:static int x509_get_ns_cert_type( unsigned char **p,
        -:  367:                                       const unsigned char *end,
        -:  368:                                       unsigned char *ns_cert_type)
        -:  369:{
        -:  370:    int ret;
    #####:  371:    mbedtls_x509_bitstring bs = { 0, 0, NULL };
        -:  372:
    #####:  373:    if( ( ret = mbedtls_asn1_get_bitstring( p, end, &bs ) ) != 0 )
    #####:  374:        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
        -:  375:
    #####:  376:    if( bs.len != 1 )
    #####:  377:        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
        -:  378:                MBEDTLS_ERR_ASN1_INVALID_LENGTH );
        -:  379:
        -:  380:    /* Get actual bitstring */
    #####:  381:    *ns_cert_type = *bs.p;
    #####:  382:    return( 0 );
        -:  383:}
        -:  384:
    #####:  385:static int x509_get_key_usage( unsigned char **p,
        -:  386:                               const unsigned char *end,
        -:  387:                               unsigned int *key_usage)
        -:  388:{
        -:  389:    int ret;
        -:  390:    size_t i;
    #####:  391:    mbedtls_x509_bitstring bs = { 0, 0, NULL };
        -:  392:
    #####:  393:    if( ( ret = mbedtls_asn1_get_bitstring( p, end, &bs ) ) != 0 )
    #####:  394:        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
        -:  395:
    #####:  396:    if( bs.len < 1 )
    #####:  397:        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
        -:  398:                MBEDTLS_ERR_ASN1_INVALID_LENGTH );
        -:  399:
        -:  400:    /* Get actual bitstring */
    #####:  401:    *key_usage = 0;
    #####:  402:    for( i = 0; i < bs.len && i < sizeof( unsigned int ); i++ )
        -:  403:    {
    #####:  404:        *key_usage |= (unsigned int) bs.p[i] << (8*i);
        -:  405:    }
        -:  406:
    #####:  407:    return( 0 );
        -:  408:}
        -:  409:
        -:  410:/*
        -:  411: * ExtKeyUsageSyntax ::= SEQUENCE SIZE (1..MAX) OF KeyPurposeId
        -:  412: *
        -:  413: * KeyPurposeId ::= OBJECT IDENTIFIER
        -:  414: */
    #####:  415:static int x509_get_ext_key_usage( unsigned char **p,
        -:  416:                               const unsigned char *end,
        -:  417:                               mbedtls_x509_sequence *ext_key_usage)
        -:  418:{
        -:  419:    int ret;
        -:  420:
    #####:  421:    if( ( ret = mbedtls_asn1_get_sequence_of( p, end, ext_key_usage, MBEDTLS_ASN1_OID ) ) != 0 )
    #####:  422:        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
        -:  423:
        -:  424:    /* Sequence length must be >= 1 */
    #####:  425:    if( ext_key_usage->buf.p == NULL )
    #####:  426:        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
        -:  427:                MBEDTLS_ERR_ASN1_INVALID_LENGTH );
        -:  428:
    #####:  429:    return( 0 );
        -:  430:}
        -:  431:
        -:  432:/*
        -:  433: * SubjectAltName ::= GeneralNames
        -:  434: *
        -:  435: * GeneralNames ::= SEQUENCE SIZE (1..MAX) OF GeneralName
        -:  436: *
        -:  437: * GeneralName ::= CHOICE {
        -:  438: *      otherName                       [0]     OtherName,
        -:  439: *      rfc822Name                      [1]     IA5String,
        -:  440: *      dNSName                         [2]     IA5String,
        -:  441: *      x400Address                     [3]     ORAddress,
        -:  442: *      directoryName                   [4]     Name,
        -:  443: *      ediPartyName                    [5]     EDIPartyName,
        -:  444: *      uniformResourceIdentifier       [6]     IA5String,
        -:  445: *      iPAddress                       [7]     OCTET STRING,
        -:  446: *      registeredID                    [8]     OBJECT IDENTIFIER }
        -:  447: *
        -:  448: * OtherName ::= SEQUENCE {
        -:  449: *      type-id    OBJECT IDENTIFIER,
        -:  450: *      value      [0] EXPLICIT ANY DEFINED BY type-id }
        -:  451: *
        -:  452: * EDIPartyName ::= SEQUENCE {
        -:  453: *      nameAssigner            [0]     DirectoryString OPTIONAL,
        -:  454: *      partyName               [1]     DirectoryString }
        -:  455: *
        -:  456: * NOTE: we only parse and use dNSName at this point.
        -:  457: */
    #####:  458:static int x509_get_subject_alt_name( unsigned char **p,
        -:  459:                                      const unsigned char *end,
        -:  460:                                      mbedtls_x509_sequence *subject_alt_name )
        -:  461:{
        -:  462:    int ret;
        -:  463:    size_t len, tag_len;
        -:  464:    mbedtls_asn1_buf *buf;
        -:  465:    unsigned char tag;
    #####:  466:    mbedtls_asn1_sequence *cur = subject_alt_name;
        -:  467:
        -:  468:    /* Get main sequence tag */
    #####:  469:    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
        -:  470:            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
    #####:  471:        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
        -:  472:
    #####:  473:    if( *p + len != end )
    #####:  474:        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
        -:  475:                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
        -:  476:
    #####:  477:    while( *p < end )
        -:  478:    {
    #####:  479:        if( ( end - *p ) < 1 )
    #####:  480:            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
        -:  481:                    MBEDTLS_ERR_ASN1_OUT_OF_DATA );
        -:  482:
    #####:  483:        tag = **p;
    #####:  484:        (*p)++;
    #####:  485:        if( ( ret = mbedtls_asn1_get_len( p, end, &tag_len ) ) != 0 )
    #####:  486:            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
        -:  487:
    #####:  488:        if( ( tag & MBEDTLS_ASN1_TAG_CLASS_MASK ) !=
        -:  489:                MBEDTLS_ASN1_CONTEXT_SPECIFIC )
        -:  490:        {
    #####:  491:            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
        -:  492:                    MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );
        -:  493:        }
        -:  494:
        -:  495:        /* Skip everything but DNS name */
    #####:  496:        if( tag != ( MBEDTLS_ASN1_CONTEXT_SPECIFIC | 2 ) )
        -:  497:        {
    #####:  498:            *p += tag_len;
    #####:  499:            continue;
        -:  500:        }
        -:  501:
        -:  502:        /* Allocate and assign next pointer */
    #####:  503:        if( cur->buf.p != NULL )
        -:  504:        {
    #####:  505:            if( cur->next != NULL )
    #####:  506:                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS );
        -:  507:
    #####:  508:            cur->next = mbedtls_calloc( 1, sizeof( mbedtls_asn1_sequence ) );
        -:  509:
    #####:  510:            if( cur->next == NULL )
    #####:  511:                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
        -:  512:                        MBEDTLS_ERR_ASN1_ALLOC_FAILED );
        -:  513:
    #####:  514:            cur = cur->next;
        -:  515:        }
        -:  516:
    #####:  517:        buf = &(cur->buf);
    #####:  518:        buf->tag = tag;
    #####:  519:        buf->p = *p;
    #####:  520:        buf->len = tag_len;
    #####:  521:        *p += buf->len;
        -:  522:    }
        -:  523:
        -:  524:    /* Set final sequence entry's next pointer to NULL */
    #####:  525:    cur->next = NULL;
        -:  526:
    #####:  527:    if( *p != end )
    #####:  528:        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
        -:  529:                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
        -:  530:
    #####:  531:    return( 0 );
        -:  532:}
        -:  533:
        -:  534:/*
        -:  535: * X.509 v3 extensions
        -:  536: *
        -:  537: */
    #####:  538:static int x509_get_crt_ext( unsigned char **p,
        -:  539:                             const unsigned char *end,
        -:  540:                             mbedtls_x509_crt *crt )
        -:  541:{
        -:  542:    int ret;
        -:  543:    size_t len;
        -:  544:    unsigned char *end_ext_data, *end_ext_octet;
        -:  545:
    #####:  546:    if( ( ret = mbedtls_x509_get_ext( p, end, &crt->v3_ext, 3 ) ) != 0 )
        -:  547:    {
    #####:  548:        if( ret == MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
    #####:  549:            return( 0 );
        -:  550:
    #####:  551:        return( ret );
        -:  552:    }
        -:  553:
    #####:  554:    while( *p < end )
        -:  555:    {
        -:  556:        /*
        -:  557:         * Extension  ::=  SEQUENCE  {
        -:  558:         *      extnID      OBJECT IDENTIFIER,
        -:  559:         *      critical    BOOLEAN DEFAULT FALSE,
        -:  560:         *      extnValue   OCTET STRING  }
        -:  561:         */
    #####:  562:        mbedtls_x509_buf extn_oid = {0, 0, NULL};
    #####:  563:        int is_critical = 0; /* DEFAULT FALSE */
    #####:  564:        int ext_type = 0;
        -:  565:
    #####:  566:        if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
        -:  567:                MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
    #####:  568:            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
        -:  569:
    #####:  570:        end_ext_data = *p + len;
        -:  571:
        -:  572:        /* Get extension ID */
    #####:  573:        extn_oid.tag = **p;
        -:  574:
    #####:  575:        if( ( ret = mbedtls_asn1_get_tag( p, end, &extn_oid.len, MBEDTLS_ASN1_OID ) ) != 0 )
    #####:  576:            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
        -:  577:
    #####:  578:        extn_oid.p = *p;
    #####:  579:        *p += extn_oid.len;
        -:  580:
    #####:  581:        if( ( end - *p ) < 1 )
    #####:  582:            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
        -:  583:                    MBEDTLS_ERR_ASN1_OUT_OF_DATA );
        -:  584:
        -:  585:        /* Get optional critical */
    #####:  586:        if( ( ret = mbedtls_asn1_get_bool( p, end_ext_data, &is_critical ) ) != 0 &&
        -:  587:            ( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG ) )
    #####:  588:            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
        -:  589:
        -:  590:        /* Data should be octet string type */
    #####:  591:        if( ( ret = mbedtls_asn1_get_tag( p, end_ext_data, &len,
        -:  592:                MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
    #####:  593:            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS + ret );
        -:  594:
    #####:  595:        end_ext_octet = *p + len;
        -:  596:
    #####:  597:        if( end_ext_octet != end_ext_data )
    #####:  598:            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
        -:  599:                    MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
        -:  600:
        -:  601:        /*
        -:  602:         * Detect supported extensions
        -:  603:         */
    #####:  604:        ret = mbedtls_oid_get_x509_ext_type( &extn_oid, &ext_type );
        -:  605:
    #####:  606:        if( ret != 0 )
        -:  607:        {
        -:  608:            /* No parser found, skip extension */
    #####:  609:            *p = end_ext_octet;
        -:  610:
        -:  611:#if !defined(MBEDTLS_X509_ALLOW_UNSUPPORTED_CRITICAL_EXTENSION)
    #####:  612:            if( is_critical )
        -:  613:            {
        -:  614:                /* Data is marked as critical: fail */
    #####:  615:                return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
        -:  616:                        MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );
        -:  617:            }
        -:  618:#endif
    #####:  619:            continue;
        -:  620:        }
        -:  621:
        -:  622:        /* Forbid repeated extensions */
    #####:  623:        if( ( crt->ext_types & ext_type ) != 0 )
    #####:  624:            return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS );
        -:  625:
    #####:  626:        crt->ext_types |= ext_type;
        -:  627:
    #####:  628:        switch( ext_type )
        -:  629:        {
    #####:  630:        case MBEDTLS_X509_EXT_BASIC_CONSTRAINTS:
        -:  631:            /* Parse basic constraints */
    #####:  632:            if( ( ret = x509_get_basic_constraints( p, end_ext_octet,
        -:  633:                    &crt->ca_istrue, &crt->max_pathlen ) ) != 0 )
    #####:  634:                return( ret );
    #####:  635:            break;
        -:  636:
    #####:  637:        case MBEDTLS_X509_EXT_KEY_USAGE:
        -:  638:            /* Parse key usage */
    #####:  639:            if( ( ret = x509_get_key_usage( p, end_ext_octet,
        -:  640:                    &crt->key_usage ) ) != 0 )
    #####:  641:                return( ret );
    #####:  642:            break;
        -:  643:
    #####:  644:        case MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE:
        -:  645:            /* Parse extended key usage */
    #####:  646:            if( ( ret = x509_get_ext_key_usage( p, end_ext_octet,
        -:  647:                    &crt->ext_key_usage ) ) != 0 )
    #####:  648:                return( ret );
    #####:  649:            break;
        -:  650:
    #####:  651:        case MBEDTLS_X509_EXT_SUBJECT_ALT_NAME:
        -:  652:            /* Parse subject alt name */
    #####:  653:            if( ( ret = x509_get_subject_alt_name( p, end_ext_octet,
        -:  654:                    &crt->subject_alt_names ) ) != 0 )
    #####:  655:                return( ret );
    #####:  656:            break;
        -:  657:
    #####:  658:        case MBEDTLS_X509_EXT_NS_CERT_TYPE:
        -:  659:            /* Parse netscape certificate type */
    #####:  660:            if( ( ret = x509_get_ns_cert_type( p, end_ext_octet,
        -:  661:                    &crt->ns_cert_type ) ) != 0 )
    #####:  662:                return( ret );
    #####:  663:            break;
        -:  664:
    #####:  665:        default:
    #####:  666:            return( MBEDTLS_ERR_X509_FEATURE_UNAVAILABLE );
        -:  667:        }
        -:  668:    }
        -:  669:
    #####:  670:    if( *p != end )
    #####:  671:        return( MBEDTLS_ERR_X509_INVALID_EXTENSIONS +
        -:  672:                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
        -:  673:
    #####:  674:    return( 0 );
        -:  675:}
        -:  676:
        -:  677:/*
        -:  678: * Parse and fill a single X.509 certificate in DER format
        -:  679: */
    #####:  680:static int x509_crt_parse_der_core( mbedtls_x509_crt *crt, const unsigned char *buf,
        -:  681:                                    size_t buflen )
        -:  682:{
        -:  683:    int ret;
        -:  684:    size_t len;
        -:  685:    unsigned char *p, *end, *crt_end;
        -:  686:    mbedtls_x509_buf sig_params1, sig_params2, sig_oid2;
        -:  687:
    #####:  688:    memset( &sig_params1, 0, sizeof( mbedtls_x509_buf ) );
    #####:  689:    memset( &sig_params2, 0, sizeof( mbedtls_x509_buf ) );
    #####:  690:    memset( &sig_oid2, 0, sizeof( mbedtls_x509_buf ) );
        -:  691:
        -:  692:    /*
        -:  693:     * Check for valid input
        -:  694:     */
    #####:  695:    if( crt == NULL || buf == NULL )
    #####:  696:        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
        -:  697:
        -:  698:    // Use the original buffer until we figure out actual length
    #####:  699:    p = (unsigned char*) buf;
    #####:  700:    len = buflen;
    #####:  701:    end = p + len;
        -:  702:
        -:  703:    /*
        -:  704:     * Certificate  ::=  SEQUENCE  {
        -:  705:     *      tbsCertificate       TBSCertificate,
        -:  706:     *      signatureAlgorithm   AlgorithmIdentifier,
        -:  707:     *      signatureValue       BIT STRING  }
        -:  708:     */
    #####:  709:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
        -:  710:            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
        -:  711:    {
    #####:  712:        mbedtls_x509_crt_free( crt );
    #####:  713:        return( MBEDTLS_ERR_X509_INVALID_FORMAT );
        -:  714:    }
        -:  715:
    #####:  716:    if( len > (size_t) ( end - p ) )
        -:  717:    {
    #####:  718:        mbedtls_x509_crt_free( crt );
    #####:  719:        return( MBEDTLS_ERR_X509_INVALID_FORMAT +
        -:  720:                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
        -:  721:    }
    #####:  722:    crt_end = p + len;
        -:  723:
        -:  724:    // Create and populate a new buffer for the raw field
    #####:  725:    crt->raw.len = crt_end - buf;
    #####:  726:    crt->raw.p = p = mbedtls_calloc( 1, crt->raw.len );
    #####:  727:    if( p == NULL )
    #####:  728:        return( MBEDTLS_ERR_X509_ALLOC_FAILED );
        -:  729:
    #####:  730:    memcpy( p, buf, crt->raw.len );
        -:  731:
        -:  732:    // Direct pointers to the new buffer
    #####:  733:    p += crt->raw.len - len;
    #####:  734:    end = crt_end = p + len;
        -:  735:
        -:  736:    /*
        -:  737:     * TBSCertificate  ::=  SEQUENCE  {
        -:  738:     */
    #####:  739:    crt->tbs.p = p;
        -:  740:
    #####:  741:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
        -:  742:            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
        -:  743:    {
    #####:  744:        mbedtls_x509_crt_free( crt );
    #####:  745:        return( MBEDTLS_ERR_X509_INVALID_FORMAT + ret );
        -:  746:    }
        -:  747:
    #####:  748:    end = p + len;
    #####:  749:    crt->tbs.len = end - crt->tbs.p;
        -:  750:
        -:  751:    /*
        -:  752:     * Version  ::=  INTEGER  {  v1(0), v2(1), v3(2)  }
        -:  753:     *
        -:  754:     * CertificateSerialNumber  ::=  INTEGER
        -:  755:     *
        -:  756:     * signature            AlgorithmIdentifier
        -:  757:     */
    #####:  758:    if( ( ret = x509_get_version(  &p, end, &crt->version  ) ) != 0 ||
    #####:  759:        ( ret = mbedtls_x509_get_serial(   &p, end, &crt->serial   ) ) != 0 ||
    #####:  760:        ( ret = mbedtls_x509_get_alg(      &p, end, &crt->sig_oid,
        -:  761:                                            &sig_params1 ) ) != 0 )
        -:  762:    {
    #####:  763:        mbedtls_x509_crt_free( crt );
    #####:  764:        return( ret );
        -:  765:    }
        -:  766:
    #####:  767:    if( crt->version < 0 || crt->version > 2 )
        -:  768:    {
    #####:  769:        mbedtls_x509_crt_free( crt );
    #####:  770:        return( MBEDTLS_ERR_X509_UNKNOWN_VERSION );
        -:  771:    }
        -:  772:
    #####:  773:    crt->version++;
        -:  774:
    #####:  775:    if( ( ret = mbedtls_x509_get_sig_alg( &crt->sig_oid, &sig_params1,
        -:  776:                                  &crt->sig_md, &crt->sig_pk,
        -:  777:                                  &crt->sig_opts ) ) != 0 )
        -:  778:    {
    #####:  779:        mbedtls_x509_crt_free( crt );
    #####:  780:        return( ret );
        -:  781:    }
        -:  782:
        -:  783:    /*
        -:  784:     * issuer               Name
        -:  785:     */
    #####:  786:    crt->issuer_raw.p = p;
        -:  787:
    #####:  788:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
        -:  789:            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
        -:  790:    {
    #####:  791:        mbedtls_x509_crt_free( crt );
    #####:  792:        return( MBEDTLS_ERR_X509_INVALID_FORMAT + ret );
        -:  793:    }
        -:  794:
    #####:  795:    if( ( ret = mbedtls_x509_get_name( &p, p + len, &crt->issuer ) ) != 0 )
        -:  796:    {
    #####:  797:        mbedtls_x509_crt_free( crt );
    #####:  798:        return( ret );
        -:  799:    }
        -:  800:
    #####:  801:    crt->issuer_raw.len = p - crt->issuer_raw.p;
        -:  802:
        -:  803:    /*
        -:  804:     * Validity ::= SEQUENCE {
        -:  805:     *      notBefore      Time,
        -:  806:     *      notAfter       Time }
        -:  807:     *
        -:  808:     */
    #####:  809:    if( ( ret = x509_get_dates( &p, end, &crt->valid_from,
        -:  810:                                         &crt->valid_to ) ) != 0 )
        -:  811:    {
    #####:  812:        mbedtls_x509_crt_free( crt );
    #####:  813:        return( ret );
        -:  814:    }
        -:  815:
        -:  816:    /*
        -:  817:     * subject              Name
        -:  818:     */
    #####:  819:    crt->subject_raw.p = p;
        -:  820:
    #####:  821:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
        -:  822:            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
        -:  823:    {
    #####:  824:        mbedtls_x509_crt_free( crt );
    #####:  825:        return( MBEDTLS_ERR_X509_INVALID_FORMAT + ret );
        -:  826:    }
        -:  827:
    #####:  828:    if( len && ( ret = mbedtls_x509_get_name( &p, p + len, &crt->subject ) ) != 0 )
        -:  829:    {
    #####:  830:        mbedtls_x509_crt_free( crt );
    #####:  831:        return( ret );
        -:  832:    }
        -:  833:
    #####:  834:    crt->subject_raw.len = p - crt->subject_raw.p;
        -:  835:
        -:  836:    /*
        -:  837:     * SubjectPublicKeyInfo
        -:  838:     */
    #####:  839:    if( ( ret = mbedtls_pk_parse_subpubkey( &p, end, &crt->pk ) ) != 0 )
        -:  840:    {
    #####:  841:        mbedtls_x509_crt_free( crt );
    #####:  842:        return( ret );
        -:  843:    }
        -:  844:
        -:  845:    /*
        -:  846:     *  issuerUniqueID  [1]  IMPLICIT UniqueIdentifier OPTIONAL,
        -:  847:     *                       -- If present, version shall be v2 or v3
        -:  848:     *  subjectUniqueID [2]  IMPLICIT UniqueIdentifier OPTIONAL,
        -:  849:     *                       -- If present, version shall be v2 or v3
        -:  850:     *  extensions      [3]  EXPLICIT Extensions OPTIONAL
        -:  851:     *                       -- If present, version shall be v3
        -:  852:     */
    #####:  853:    if( crt->version == 2 || crt->version == 3 )
        -:  854:    {
    #####:  855:        ret = x509_get_uid( &p, end, &crt->issuer_id,  1 );
    #####:  856:        if( ret != 0 )
        -:  857:        {
    #####:  858:            mbedtls_x509_crt_free( crt );
    #####:  859:            return( ret );
        -:  860:        }
        -:  861:    }
        -:  862:
    #####:  863:    if( crt->version == 2 || crt->version == 3 )
        -:  864:    {
    #####:  865:        ret = x509_get_uid( &p, end, &crt->subject_id,  2 );
    #####:  866:        if( ret != 0 )
        -:  867:        {
    #####:  868:            mbedtls_x509_crt_free( crt );
    #####:  869:            return( ret );
        -:  870:        }
        -:  871:    }
        -:  872:
        -:  873:#if !defined(MBEDTLS_X509_ALLOW_EXTENSIONS_NON_V3)
    #####:  874:    if( crt->version == 3 )
        -:  875:#endif
        -:  876:    {
    #####:  877:        ret = x509_get_crt_ext( &p, end, crt );
    #####:  878:        if( ret != 0 )
        -:  879:        {
    #####:  880:            mbedtls_x509_crt_free( crt );
    #####:  881:            return( ret );
        -:  882:        }
        -:  883:    }
        -:  884:
    #####:  885:    if( p != end )
        -:  886:    {
    #####:  887:        mbedtls_x509_crt_free( crt );
    #####:  888:        return( MBEDTLS_ERR_X509_INVALID_FORMAT +
        -:  889:                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
        -:  890:    }
        -:  891:
    #####:  892:    end = crt_end;
        -:  893:
        -:  894:    /*
        -:  895:     *  }
        -:  896:     *  -- end of TBSCertificate
        -:  897:     *
        -:  898:     *  signatureAlgorithm   AlgorithmIdentifier,
        -:  899:     *  signatureValue       BIT STRING
        -:  900:     */
    #####:  901:    if( ( ret = mbedtls_x509_get_alg( &p, end, &sig_oid2, &sig_params2 ) ) != 0 )
        -:  902:    {
    #####:  903:        mbedtls_x509_crt_free( crt );
    #####:  904:        return( ret );
        -:  905:    }
        -:  906:
    #####:  907:    if( crt->sig_oid.len != sig_oid2.len ||
    #####:  908:        memcmp( crt->sig_oid.p, sig_oid2.p, crt->sig_oid.len ) != 0 ||
    #####:  909:        sig_params1.len != sig_params2.len ||
    #####:  910:        ( sig_params1.len != 0 &&
    #####:  911:          memcmp( sig_params1.p, sig_params2.p, sig_params1.len ) != 0 ) )
        -:  912:    {
    #####:  913:        mbedtls_x509_crt_free( crt );
    #####:  914:        return( MBEDTLS_ERR_X509_SIG_MISMATCH );
        -:  915:    }
        -:  916:
    #####:  917:    if( ( ret = mbedtls_x509_get_sig( &p, end, &crt->sig ) ) != 0 )
        -:  918:    {
    #####:  919:        mbedtls_x509_crt_free( crt );
    #####:  920:        return( ret );
        -:  921:    }
        -:  922:
    #####:  923:    if( p != end )
        -:  924:    {
    #####:  925:        mbedtls_x509_crt_free( crt );
    #####:  926:        return( MBEDTLS_ERR_X509_INVALID_FORMAT +
        -:  927:                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
        -:  928:    }
        -:  929:
    #####:  930:    return( 0 );
        -:  931:}
        -:  932:
        -:  933:/*
        -:  934: * Parse one X.509 certificate in DER format from a buffer and add them to a
        -:  935: * chained list
        -:  936: */
    #####:  937:int mbedtls_x509_crt_parse_der( mbedtls_x509_crt *chain, const unsigned char *buf,
        -:  938:                        size_t buflen )
        -:  939:{
        -:  940:    int ret;
    #####:  941:    mbedtls_x509_crt *crt = chain, *prev = NULL;
        -:  942:
        -:  943:    /*
        -:  944:     * Check for valid input
        -:  945:     */
    #####:  946:    if( crt == NULL || buf == NULL )
    #####:  947:        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
        -:  948:
    #####:  949:    while( crt->version != 0 && crt->next != NULL )
        -:  950:    {
    #####:  951:        prev = crt;
    #####:  952:        crt = crt->next;
        -:  953:    }
        -:  954:
        -:  955:    /*
        -:  956:     * Add new certificate on the end of the chain if needed.
        -:  957:     */
    #####:  958:    if( crt->version != 0 && crt->next == NULL )
        -:  959:    {
    #####:  960:        crt->next = mbedtls_calloc( 1, sizeof( mbedtls_x509_crt ) );
        -:  961:
    #####:  962:        if( crt->next == NULL )
    #####:  963:            return( MBEDTLS_ERR_X509_ALLOC_FAILED );
        -:  964:
    #####:  965:        prev = crt;
    #####:  966:        mbedtls_x509_crt_init( crt->next );
    #####:  967:        crt = crt->next;
        -:  968:    }
        -:  969:
    #####:  970:    if( ( ret = x509_crt_parse_der_core( crt, buf, buflen ) ) != 0 )
        -:  971:    {
    #####:  972:        if( prev )
    #####:  973:            prev->next = NULL;
        -:  974:
    #####:  975:        if( crt != chain )
    #####:  976:            mbedtls_free( crt );
        -:  977:
    #####:  978:        return( ret );
        -:  979:    }
        -:  980:
    #####:  981:    return( 0 );
        -:  982:}
        -:  983:
        -:  984:/*
        -:  985: * Parse one or more PEM certificates from a buffer and add them to the chained
        -:  986: * list
        -:  987: */
    #####:  988:int mbedtls_x509_crt_parse( mbedtls_x509_crt *chain, const unsigned char *buf, size_t buflen )
        -:  989:{
        -:  990:#if defined(MBEDTLS_PEM_PARSE_C)
        -:  991:    int success = 0, first_error = 0, total_failed = 0;
        -:  992:    int buf_format = MBEDTLS_X509_FORMAT_DER;
        -:  993:#endif
        -:  994:
        -:  995:    /*
        -:  996:     * Check for valid input
        -:  997:     */
    #####:  998:    if( chain == NULL || buf == NULL )
    #####:  999:        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
        -: 1000:
        -: 1001:    /*
        -: 1002:     * Determine buffer content. Buffer contains either one DER certificate or
        -: 1003:     * one or more PEM certificates.
        -: 1004:     */
        -: 1005:#if defined(MBEDTLS_PEM_PARSE_C)
        -: 1006:    if( buflen != 0 && buf[buflen - 1] == '\0' &&
        -: 1007:        strstr( (const char *) buf, "-----BEGIN CERTIFICATE-----" ) != NULL )
        -: 1008:    {
        -: 1009:        buf_format = MBEDTLS_X509_FORMAT_PEM;
        -: 1010:    }
        -: 1011:
        -: 1012:    if( buf_format == MBEDTLS_X509_FORMAT_DER )
        -: 1013:        return mbedtls_x509_crt_parse_der( chain, buf, buflen );
        -: 1014:#else
    #####: 1015:    return mbedtls_x509_crt_parse_der( chain, buf, buflen );
        -: 1016:#endif
        -: 1017:
        -: 1018:#if defined(MBEDTLS_PEM_PARSE_C)
        -: 1019:    if( buf_format == MBEDTLS_X509_FORMAT_PEM )
        -: 1020:    {
        -: 1021:        int ret;
        -: 1022:        mbedtls_pem_context pem;
        -: 1023:
        -: 1024:        /* 1 rather than 0 since the terminating NULL byte is counted in */
        -: 1025:        while( buflen > 1 )
        -: 1026:        {
        -: 1027:            size_t use_len;
        -: 1028:            mbedtls_pem_init( &pem );
        -: 1029:
        -: 1030:            /* If we get there, we know the string is null-terminated */
        -: 1031:            ret = mbedtls_pem_read_buffer( &pem,
        -: 1032:                           "-----BEGIN CERTIFICATE-----",
        -: 1033:                           "-----END CERTIFICATE-----",
        -: 1034:                           buf, NULL, 0, &use_len );
        -: 1035:
        -: 1036:            if( ret == 0 )
        -: 1037:            {
        -: 1038:                /*
        -: 1039:                 * Was PEM encoded
        -: 1040:                 */
        -: 1041:                buflen -= use_len;
        -: 1042:                buf += use_len;
        -: 1043:            }
        -: 1044:            else if( ret == MBEDTLS_ERR_PEM_BAD_INPUT_DATA )
        -: 1045:            {
        -: 1046:                return( ret );
        -: 1047:            }
        -: 1048:            else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
        -: 1049:            {
        -: 1050:                mbedtls_pem_free( &pem );
        -: 1051:
        -: 1052:                /*
        -: 1053:                 * PEM header and footer were found
        -: 1054:                 */
        -: 1055:                buflen -= use_len;
        -: 1056:                buf += use_len;
        -: 1057:
        -: 1058:                if( first_error == 0 )
        -: 1059:                    first_error = ret;
        -: 1060:
        -: 1061:                total_failed++;
        -: 1062:                continue;
        -: 1063:            }
        -: 1064:            else
        -: 1065:                break;
        -: 1066:
        -: 1067:            ret = mbedtls_x509_crt_parse_der( chain, pem.buf, pem.buflen );
        -: 1068:
        -: 1069:            mbedtls_pem_free( &pem );
        -: 1070:
        -: 1071:            if( ret != 0 )
        -: 1072:            {
        -: 1073:                /*
        -: 1074:                 * Quit parsing on a memory error
        -: 1075:                 */
        -: 1076:                if( ret == MBEDTLS_ERR_X509_ALLOC_FAILED )
        -: 1077:                    return( ret );
        -: 1078:
        -: 1079:                if( first_error == 0 )
        -: 1080:                    first_error = ret;
        -: 1081:
        -: 1082:                total_failed++;
        -: 1083:                continue;
        -: 1084:            }
        -: 1085:
        -: 1086:            success = 1;
        -: 1087:        }
        -: 1088:    }
        -: 1089:
        -: 1090:    if( success )
        -: 1091:        return( total_failed );
        -: 1092:    else if( first_error )
        -: 1093:        return( first_error );
        -: 1094:    else
        -: 1095:        return( MBEDTLS_ERR_X509_CERT_UNKNOWN_FORMAT );
        -: 1096:#endif /* MBEDTLS_PEM_PARSE_C */
        -: 1097:}
        -: 1098:
        -: 1099:#if defined(MBEDTLS_FS_IO)
        -: 1100:/*
        -: 1101: * Load one or more certificates and add them to the chained list
        -: 1102: */
        -: 1103:int mbedtls_x509_crt_parse_file( mbedtls_x509_crt *chain, const char *path )
        -: 1104:{
        -: 1105:    int ret;
        -: 1106:    size_t n;
        -: 1107:    unsigned char *buf;
        -: 1108:
        -: 1109:    if( ( ret = mbedtls_pk_load_file( path, &buf, &n ) ) != 0 )
        -: 1110:        return( ret );
        -: 1111:
        -: 1112:    ret = mbedtls_x509_crt_parse( chain, buf, n );
        -: 1113:
        -: 1114:    mbedtls_platform_zeroize( buf, n );
        -: 1115:    mbedtls_free( buf );
        -: 1116:
        -: 1117:    return( ret );
        -: 1118:}
        -: 1119:
        -: 1120:int mbedtls_x509_crt_parse_path( mbedtls_x509_crt *chain, const char *path )
        -: 1121:{
        -: 1122:    int ret = 0;
        -: 1123:#if defined(_WIN32) && !defined(EFIX64) && !defined(EFI32)
        -: 1124:    int w_ret;
        -: 1125:    WCHAR szDir[MAX_PATH];
        -: 1126:    char filename[MAX_PATH];
        -: 1127:    char *p;
        -: 1128:    size_t len = strlen( path );
        -: 1129:
        -: 1130:    WIN32_FIND_DATAW file_data;
        -: 1131:    HANDLE hFind;
        -: 1132:
        -: 1133:    if( len > MAX_PATH - 3 )
        -: 1134:        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
        -: 1135:
        -: 1136:    memset( szDir, 0, sizeof(szDir) );
        -: 1137:    memset( filename, 0, MAX_PATH );
        -: 1138:    memcpy( filename, path, len );
        -: 1139:    filename[len++] = '\\';
        -: 1140:    p = filename + len;
        -: 1141:    filename[len++] = '*';
        -: 1142:
        -: 1143:    w_ret = MultiByteToWideChar( CP_ACP, 0, filename, (int)len, szDir,
        -: 1144:                                 MAX_PATH - 3 );
        -: 1145:    if( w_ret == 0 )
        -: 1146:        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
        -: 1147:
        -: 1148:    hFind = FindFirstFileW( szDir, &file_data );
        -: 1149:    if( hFind == INVALID_HANDLE_VALUE )
        -: 1150:        return( MBEDTLS_ERR_X509_FILE_IO_ERROR );
        -: 1151:
        -: 1152:    len = MAX_PATH - len;
        -: 1153:    do
        -: 1154:    {
        -: 1155:        memset( p, 0, len );
        -: 1156:
        -: 1157:        if( file_data.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
        -: 1158:            continue;
        -: 1159:
        -: 1160:        w_ret = WideCharToMultiByte( CP_ACP, 0, file_data.cFileName,
        -: 1161:                                     lstrlenW( file_data.cFileName ),
        -: 1162:                                     p, (int) len - 1,
        -: 1163:                                     NULL, NULL );
        -: 1164:        if( w_ret == 0 )
        -: 1165:        {
        -: 1166:            ret = MBEDTLS_ERR_X509_FILE_IO_ERROR;
        -: 1167:            goto cleanup;
        -: 1168:        }
        -: 1169:
        -: 1170:        w_ret = mbedtls_x509_crt_parse_file( chain, filename );
        -: 1171:        if( w_ret < 0 )
        -: 1172:            ret++;
        -: 1173:        else
        -: 1174:            ret += w_ret;
        -: 1175:    }
        -: 1176:    while( FindNextFileW( hFind, &file_data ) != 0 );
        -: 1177:
        -: 1178:    if( GetLastError() != ERROR_NO_MORE_FILES )
        -: 1179:        ret = MBEDTLS_ERR_X509_FILE_IO_ERROR;
        -: 1180:
        -: 1181:cleanup:
        -: 1182:    FindClose( hFind );
        -: 1183:#else /* _WIN32 */
        -: 1184:    int t_ret;
        -: 1185:    int snp_ret;
        -: 1186:    struct stat sb;
        -: 1187:    struct dirent *entry;
        -: 1188:    char entry_name[MBEDTLS_X509_MAX_FILE_PATH_LEN];
        -: 1189:    DIR *dir = opendir( path );
        -: 1190:
        -: 1191:    if( dir == NULL )
        -: 1192:        return( MBEDTLS_ERR_X509_FILE_IO_ERROR );
        -: 1193:
        -: 1194:#if defined(MBEDTLS_THREADING_C)
        -: 1195:    if( ( ret = mbedtls_mutex_lock( &mbedtls_threading_readdir_mutex ) ) != 0 )
        -: 1196:    {
        -: 1197:        closedir( dir );
        -: 1198:        return( ret );
        -: 1199:    }
        -: 1200:#endif /* MBEDTLS_THREADING_C */
        -: 1201:
        -: 1202:    while( ( entry = readdir( dir ) ) != NULL )
        -: 1203:    {
        -: 1204:        snp_ret = mbedtls_snprintf( entry_name, sizeof entry_name,
        -: 1205:                                    "%s/%s", path, entry->d_name );
        -: 1206:
        -: 1207:        if( snp_ret < 0 || (size_t)snp_ret >= sizeof entry_name )
        -: 1208:        {
        -: 1209:            ret = MBEDTLS_ERR_X509_BUFFER_TOO_SMALL;
        -: 1210:            goto cleanup;
        -: 1211:        }
        -: 1212:        else if( stat( entry_name, &sb ) == -1 )
        -: 1213:        {
        -: 1214:            ret = MBEDTLS_ERR_X509_FILE_IO_ERROR;
        -: 1215:            goto cleanup;
        -: 1216:        }
        -: 1217:
        -: 1218:        if( !S_ISREG( sb.st_mode ) )
        -: 1219:            continue;
        -: 1220:
        -: 1221:        // Ignore parse errors
        -: 1222:        //
        -: 1223:        t_ret = mbedtls_x509_crt_parse_file( chain, entry_name );
        -: 1224:        if( t_ret < 0 )
        -: 1225:            ret++;
        -: 1226:        else
        -: 1227:            ret += t_ret;
        -: 1228:    }
        -: 1229:
        -: 1230:cleanup:
        -: 1231:    closedir( dir );
        -: 1232:
        -: 1233:#if defined(MBEDTLS_THREADING_C)
        -: 1234:    if( mbedtls_mutex_unlock( &mbedtls_threading_readdir_mutex ) != 0 )
        -: 1235:        ret = MBEDTLS_ERR_THREADING_MUTEX_ERROR;
        -: 1236:#endif /* MBEDTLS_THREADING_C */
        -: 1237:
        -: 1238:#endif /* _WIN32 */
        -: 1239:
        -: 1240:    return( ret );
        -: 1241:}
        -: 1242:#endif /* MBEDTLS_FS_IO */
        -: 1243:
    #####: 1244:static int x509_info_subject_alt_name( char **buf, size_t *size,
        -: 1245:                                       const mbedtls_x509_sequence *subject_alt_name )
        -: 1246:{
        -: 1247:    size_t i;
    #####: 1248:    size_t n = *size;
    #####: 1249:    char *p = *buf;
    #####: 1250:    const mbedtls_x509_sequence *cur = subject_alt_name;
    #####: 1251:    const char *sep = "";
    #####: 1252:    size_t sep_len = 0;
        -: 1253:
    #####: 1254:    while( cur != NULL )
        -: 1255:    {
    #####: 1256:        if( cur->buf.len + sep_len >= n )
        -: 1257:        {
    #####: 1258:            *p = '\0';
    #####: 1259:            return( MBEDTLS_ERR_X509_BUFFER_TOO_SMALL );
        -: 1260:        }
        -: 1261:
    #####: 1262:        n -= cur->buf.len + sep_len;
    #####: 1263:        for( i = 0; i < sep_len; i++ )
    #####: 1264:            *p++ = sep[i];
    #####: 1265:        for( i = 0; i < cur->buf.len; i++ )
    #####: 1266:            *p++ = cur->buf.p[i];
        -: 1267:
    #####: 1268:        sep = ", ";
    #####: 1269:        sep_len = 2;
        -: 1270:
    #####: 1271:        cur = cur->next;
        -: 1272:    }
        -: 1273:
    #####: 1274:    *p = '\0';
        -: 1275:
    #####: 1276:    *size = n;
    #####: 1277:    *buf = p;
        -: 1278:
    #####: 1279:    return( 0 );
        -: 1280:}
        -: 1281:
        -: 1282:#define PRINT_ITEM(i)                           \
        -: 1283:    {                                           \
        -: 1284:        ret = mbedtls_snprintf( p, n, "%s" i, sep );    \
        -: 1285:        MBEDTLS_X509_SAFE_SNPRINTF;                        \
        -: 1286:        sep = ", ";                             \
        -: 1287:    }
        -: 1288:
        -: 1289:#define CERT_TYPE(type,name)                    \
        -: 1290:    if( ns_cert_type & type )                   \
        -: 1291:        PRINT_ITEM( name );
        -: 1292:
    #####: 1293:static int x509_info_cert_type( char **buf, size_t *size,
        -: 1294:                                unsigned char ns_cert_type )
        -: 1295:{
        -: 1296:    int ret;
    #####: 1297:    size_t n = *size;
    #####: 1298:    char *p = *buf;
    #####: 1299:    const char *sep = "";
        -: 1300:
    #####: 1301:    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_SSL_CLIENT,         "SSL Client" );
    #####: 1302:    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_SSL_SERVER,         "SSL Server" );
    #####: 1303:    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_EMAIL,              "Email" );
    #####: 1304:    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING,     "Object Signing" );
    #####: 1305:    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_RESERVED,           "Reserved" );
    #####: 1306:    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_SSL_CA,             "SSL CA" );
    #####: 1307:    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_EMAIL_CA,           "Email CA" );
    #####: 1308:    CERT_TYPE( MBEDTLS_X509_NS_CERT_TYPE_OBJECT_SIGNING_CA,  "Object Signing CA" );
        -: 1309:
    #####: 1310:    *size = n;
    #####: 1311:    *buf = p;
        -: 1312:
    #####: 1313:    return( 0 );
        -: 1314:}
        -: 1315:
        -: 1316:#define KEY_USAGE(code,name)    \
        -: 1317:    if( key_usage & code )      \
        -: 1318:        PRINT_ITEM( name );
        -: 1319:
    #####: 1320:static int x509_info_key_usage( char **buf, size_t *size,
        -: 1321:                                unsigned int key_usage )
        -: 1322:{
        -: 1323:    int ret;
    #####: 1324:    size_t n = *size;
    #####: 1325:    char *p = *buf;
    #####: 1326:    const char *sep = "";
        -: 1327:
    #####: 1328:    KEY_USAGE( MBEDTLS_X509_KU_DIGITAL_SIGNATURE,    "Digital Signature" );
    #####: 1329:    KEY_USAGE( MBEDTLS_X509_KU_NON_REPUDIATION,      "Non Repudiation" );
    #####: 1330:    KEY_USAGE( MBEDTLS_X509_KU_KEY_ENCIPHERMENT,     "Key Encipherment" );
    #####: 1331:    KEY_USAGE( MBEDTLS_X509_KU_DATA_ENCIPHERMENT,    "Data Encipherment" );
    #####: 1332:    KEY_USAGE( MBEDTLS_X509_KU_KEY_AGREEMENT,        "Key Agreement" );
    #####: 1333:    KEY_USAGE( MBEDTLS_X509_KU_KEY_CERT_SIGN,        "Key Cert Sign" );
    #####: 1334:    KEY_USAGE( MBEDTLS_X509_KU_CRL_SIGN,             "CRL Sign" );
    #####: 1335:    KEY_USAGE( MBEDTLS_X509_KU_ENCIPHER_ONLY,        "Encipher Only" );
    #####: 1336:    KEY_USAGE( MBEDTLS_X509_KU_DECIPHER_ONLY,        "Decipher Only" );
        -: 1337:
    #####: 1338:    *size = n;
    #####: 1339:    *buf = p;
        -: 1340:
    #####: 1341:    return( 0 );
        -: 1342:}
        -: 1343:
    #####: 1344:static int x509_info_ext_key_usage( char **buf, size_t *size,
        -: 1345:                                    const mbedtls_x509_sequence *extended_key_usage )
        -: 1346:{
        -: 1347:    int ret;
        -: 1348:    const char *desc;
    #####: 1349:    size_t n = *size;
    #####: 1350:    char *p = *buf;
    #####: 1351:    const mbedtls_x509_sequence *cur = extended_key_usage;
    #####: 1352:    const char *sep = "";
        -: 1353:
    #####: 1354:    while( cur != NULL )
        -: 1355:    {
    #####: 1356:        if( mbedtls_oid_get_extended_key_usage( &cur->buf, &desc ) != 0 )
    #####: 1357:            desc = "???";
        -: 1358:
    #####: 1359:        ret = mbedtls_snprintf( p, n, "%s%s", sep, desc );
    #####: 1360:        MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1361:
    #####: 1362:        sep = ", ";
        -: 1363:
    #####: 1364:        cur = cur->next;
        -: 1365:    }
        -: 1366:
    #####: 1367:    *size = n;
    #####: 1368:    *buf = p;
        -: 1369:
    #####: 1370:    return( 0 );
        -: 1371:}
        -: 1372:
        -: 1373:/*
        -: 1374: * Return an informational string about the certificate.
        -: 1375: */
        -: 1376:#define BEFORE_COLON    18
        -: 1377:#define BC              "18"
    #####: 1378:int mbedtls_x509_crt_info( char *buf, size_t size, const char *prefix,
        -: 1379:                   const mbedtls_x509_crt *crt )
        -: 1380:{
        -: 1381:    int ret;
        -: 1382:    size_t n;
        -: 1383:    char *p;
        -: 1384:    char key_size_str[BEFORE_COLON];
        -: 1385:
    #####: 1386:    p = buf;
    #####: 1387:    n = size;
        -: 1388:
    #####: 1389:    if( NULL == crt )
        -: 1390:    {
    #####: 1391:        ret = mbedtls_snprintf( p, n, "\nCertificate is uninitialised!\n" );
    #####: 1392:        MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1393:
    #####: 1394:        return( (int) ( size - n ) );
        -: 1395:    }
        -: 1396:
    #####: 1397:    ret = mbedtls_snprintf( p, n, "%scert. version     : %d\n",
        -: 1398:                               prefix, crt->version );
    #####: 1399:    MBEDTLS_X509_SAFE_SNPRINTF;
    #####: 1400:    ret = mbedtls_snprintf( p, n, "%sserial number     : ",
        -: 1401:                               prefix );
    #####: 1402:    MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1403:
    #####: 1404:    ret = mbedtls_x509_serial_gets( p, n, &crt->serial );
    #####: 1405:    MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1406:
    #####: 1407:    ret = mbedtls_snprintf( p, n, "\n%sissuer name       : ", prefix );
    #####: 1408:    MBEDTLS_X509_SAFE_SNPRINTF;
    #####: 1409:    ret = mbedtls_x509_dn_gets( p, n, &crt->issuer  );
    #####: 1410:    MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1411:
    #####: 1412:    ret = mbedtls_snprintf( p, n, "\n%ssubject name      : ", prefix );
    #####: 1413:    MBEDTLS_X509_SAFE_SNPRINTF;
    #####: 1414:    ret = mbedtls_x509_dn_gets( p, n, &crt->subject );
    #####: 1415:    MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1416:
    #####: 1417:    ret = mbedtls_snprintf( p, n, "\n%sissued  on        : " \
        -: 1418:                   "%04d-%02d-%02d %02d:%02d:%02d", prefix,
        -: 1419:                   crt->valid_from.year, crt->valid_from.mon,
        -: 1420:                   crt->valid_from.day,  crt->valid_from.hour,
        -: 1421:                   crt->valid_from.min,  crt->valid_from.sec );
    #####: 1422:    MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1423:
    #####: 1424:    ret = mbedtls_snprintf( p, n, "\n%sexpires on        : " \
        -: 1425:                   "%04d-%02d-%02d %02d:%02d:%02d", prefix,
        -: 1426:                   crt->valid_to.year, crt->valid_to.mon,
        -: 1427:                   crt->valid_to.day,  crt->valid_to.hour,
        -: 1428:                   crt->valid_to.min,  crt->valid_to.sec );
    #####: 1429:    MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1430:
    #####: 1431:    ret = mbedtls_snprintf( p, n, "\n%ssigned using      : ", prefix );
    #####: 1432:    MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1433:
    #####: 1434:    ret = mbedtls_x509_sig_alg_gets( p, n, &crt->sig_oid, crt->sig_pk,
    #####: 1435:                             crt->sig_md, crt->sig_opts );
    #####: 1436:    MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1437:
        -: 1438:    /* Key size */
    #####: 1439:    if( ( ret = mbedtls_x509_key_size_helper( key_size_str, BEFORE_COLON,
        -: 1440:                                      mbedtls_pk_get_name( &crt->pk ) ) ) != 0 )
        -: 1441:    {
    #####: 1442:        return( ret );
        -: 1443:    }
        -: 1444:
    #####: 1445:    ret = mbedtls_snprintf( p, n, "\n%s%-" BC "s: %d bits", prefix, key_size_str,
    #####: 1446:                          (int) mbedtls_pk_get_bitlen( &crt->pk ) );
    #####: 1447:    MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1448:
        -: 1449:    /*
        -: 1450:     * Optional extensions
        -: 1451:     */
        -: 1452:
    #####: 1453:    if( crt->ext_types & MBEDTLS_X509_EXT_BASIC_CONSTRAINTS )
        -: 1454:    {
    #####: 1455:        ret = mbedtls_snprintf( p, n, "\n%sbasic constraints : CA=%s", prefix,
    #####: 1456:                        crt->ca_istrue ? "true" : "false" );
    #####: 1457:        MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1458:
    #####: 1459:        if( crt->max_pathlen > 0 )
        -: 1460:        {
    #####: 1461:            ret = mbedtls_snprintf( p, n, ", max_pathlen=%d", crt->max_pathlen - 1 );
    #####: 1462:            MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1463:        }
        -: 1464:    }
        -: 1465:
    #####: 1466:    if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
        -: 1467:    {
    #####: 1468:        ret = mbedtls_snprintf( p, n, "\n%ssubject alt name  : ", prefix );
    #####: 1469:        MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1470:
    #####: 1471:        if( ( ret = x509_info_subject_alt_name( &p, &n,
        -: 1472:                                            &crt->subject_alt_names ) ) != 0 )
    #####: 1473:            return( ret );
        -: 1474:    }
        -: 1475:
    #####: 1476:    if( crt->ext_types & MBEDTLS_X509_EXT_NS_CERT_TYPE )
        -: 1477:    {
    #####: 1478:        ret = mbedtls_snprintf( p, n, "\n%scert. type        : ", prefix );
    #####: 1479:        MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1480:
    #####: 1481:        if( ( ret = x509_info_cert_type( &p, &n, crt->ns_cert_type ) ) != 0 )
    #####: 1482:            return( ret );
        -: 1483:    }
        -: 1484:
    #####: 1485:    if( crt->ext_types & MBEDTLS_X509_EXT_KEY_USAGE )
        -: 1486:    {
    #####: 1487:        ret = mbedtls_snprintf( p, n, "\n%skey usage         : ", prefix );
    #####: 1488:        MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1489:
    #####: 1490:        if( ( ret = x509_info_key_usage( &p, &n, crt->key_usage ) ) != 0 )
    #####: 1491:            return( ret );
        -: 1492:    }
        -: 1493:
    #####: 1494:    if( crt->ext_types & MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE )
        -: 1495:    {
    #####: 1496:        ret = mbedtls_snprintf( p, n, "\n%sext key usage     : ", prefix );
    #####: 1497:        MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1498:
    #####: 1499:        if( ( ret = x509_info_ext_key_usage( &p, &n,
        -: 1500:                                             &crt->ext_key_usage ) ) != 0 )
    #####: 1501:            return( ret );
        -: 1502:    }
        -: 1503:
    #####: 1504:    ret = mbedtls_snprintf( p, n, "\n" );
    #####: 1505:    MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1506:
    #####: 1507:    return( (int) ( size - n ) );
        -: 1508:}
        -: 1509:
        -: 1510:struct x509_crt_verify_string {
        -: 1511:    int code;
        -: 1512:    const char *string;
        -: 1513:};
        -: 1514:
        -: 1515:static const struct x509_crt_verify_string x509_crt_verify_strings[] = {
        -: 1516:    { MBEDTLS_X509_BADCERT_EXPIRED,       "The certificate validity has expired" },
        -: 1517:    { MBEDTLS_X509_BADCERT_REVOKED,       "The certificate has been revoked (is on a CRL)" },
        -: 1518:    { MBEDTLS_X509_BADCERT_CN_MISMATCH,   "The certificate Common Name (CN) does not match with the expected CN" },
        -: 1519:    { MBEDTLS_X509_BADCERT_NOT_TRUSTED,   "The certificate is not correctly signed by the trusted CA" },
        -: 1520:    { MBEDTLS_X509_BADCRL_NOT_TRUSTED,    "The CRL is not correctly signed by the trusted CA" },
        -: 1521:    { MBEDTLS_X509_BADCRL_EXPIRED,        "The CRL is expired" },
        -: 1522:    { MBEDTLS_X509_BADCERT_MISSING,       "Certificate was missing" },
        -: 1523:    { MBEDTLS_X509_BADCERT_SKIP_VERIFY,   "Certificate verification was skipped" },
        -: 1524:    { MBEDTLS_X509_BADCERT_OTHER,         "Other reason (can be used by verify callback)" },
        -: 1525:    { MBEDTLS_X509_BADCERT_FUTURE,        "The certificate validity starts in the future" },
        -: 1526:    { MBEDTLS_X509_BADCRL_FUTURE,         "The CRL is from the future" },
        -: 1527:    { MBEDTLS_X509_BADCERT_KEY_USAGE,     "Usage does not match the keyUsage extension" },
        -: 1528:    { MBEDTLS_X509_BADCERT_EXT_KEY_USAGE, "Usage does not match the extendedKeyUsage extension" },
        -: 1529:    { MBEDTLS_X509_BADCERT_NS_CERT_TYPE,  "Usage does not match the nsCertType extension" },
        -: 1530:    { MBEDTLS_X509_BADCERT_BAD_MD,        "The certificate is signed with an unacceptable hash." },
        -: 1531:    { MBEDTLS_X509_BADCERT_BAD_PK,        "The certificate is signed with an unacceptable PK alg (eg RSA vs ECDSA)." },
        -: 1532:    { MBEDTLS_X509_BADCERT_BAD_KEY,       "The certificate is signed with an unacceptable key (eg bad curve, RSA too short)." },
        -: 1533:    { MBEDTLS_X509_BADCRL_BAD_MD,         "The CRL is signed with an unacceptable hash." },
        -: 1534:    { MBEDTLS_X509_BADCRL_BAD_PK,         "The CRL is signed with an unacceptable PK alg (eg RSA vs ECDSA)." },
        -: 1535:    { MBEDTLS_X509_BADCRL_BAD_KEY,        "The CRL is signed with an unacceptable key (eg bad curve, RSA too short)." },
        -: 1536:    { 0, NULL }
        -: 1537:};
        -: 1538:
    #####: 1539:int mbedtls_x509_crt_verify_info( char *buf, size_t size, const char *prefix,
        -: 1540:                          uint32_t flags )
        -: 1541:{
        -: 1542:    int ret;
        -: 1543:    const struct x509_crt_verify_string *cur;
    #####: 1544:    char *p = buf;
    #####: 1545:    size_t n = size;
        -: 1546:
    #####: 1547:    for( cur = x509_crt_verify_strings; cur->string != NULL ; cur++ )
        -: 1548:    {
    #####: 1549:        if( ( flags & cur->code ) == 0 )
    #####: 1550:            continue;
        -: 1551:
    #####: 1552:        ret = mbedtls_snprintf( p, n, "%s%s\n", prefix, cur->string );
    #####: 1553:        MBEDTLS_X509_SAFE_SNPRINTF;
    #####: 1554:        flags ^= cur->code;
        -: 1555:    }
        -: 1556:
    #####: 1557:    if( flags != 0 )
        -: 1558:    {
    #####: 1559:        ret = mbedtls_snprintf( p, n, "%sUnknown reason "
        -: 1560:                                       "(this should not happen)\n", prefix );
    #####: 1561:        MBEDTLS_X509_SAFE_SNPRINTF;
        -: 1562:    }
        -: 1563:
    #####: 1564:    return( (int) ( size - n ) );
        -: 1565:}
        -: 1566:
        -: 1567:#if defined(MBEDTLS_X509_CHECK_KEY_USAGE)
        -: 1568:int mbedtls_x509_crt_check_key_usage( const mbedtls_x509_crt *crt,
        -: 1569:                                      unsigned int usage )
        -: 1570:{
        -: 1571:    unsigned int usage_must, usage_may;
        -: 1572:    unsigned int may_mask = MBEDTLS_X509_KU_ENCIPHER_ONLY
        -: 1573:                          | MBEDTLS_X509_KU_DECIPHER_ONLY;
        -: 1574:
        -: 1575:    if( ( crt->ext_types & MBEDTLS_X509_EXT_KEY_USAGE ) == 0 )
        -: 1576:        return( 0 );
        -: 1577:
        -: 1578:    usage_must = usage & ~may_mask;
        -: 1579:
        -: 1580:    if( ( ( crt->key_usage & ~may_mask ) & usage_must ) != usage_must )
        -: 1581:        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
        -: 1582:
        -: 1583:    usage_may = usage & may_mask;
        -: 1584:
        -: 1585:    if( ( ( crt->key_usage & may_mask ) | usage_may ) != usage_may )
        -: 1586:        return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
        -: 1587:
        -: 1588:    return( 0 );
        -: 1589:}
        -: 1590:#endif
        -: 1591:
        -: 1592:#if defined(MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE)
        -: 1593:int mbedtls_x509_crt_check_extended_key_usage( const mbedtls_x509_crt *crt,
        -: 1594:                                       const char *usage_oid,
        -: 1595:                                       size_t usage_len )
        -: 1596:{
        -: 1597:    const mbedtls_x509_sequence *cur;
        -: 1598:
        -: 1599:    /* Extension is not mandatory, absent means no restriction */
        -: 1600:    if( ( crt->ext_types & MBEDTLS_X509_EXT_EXTENDED_KEY_USAGE ) == 0 )
        -: 1601:        return( 0 );
        -: 1602:
        -: 1603:    /*
        -: 1604:     * Look for the requested usage (or wildcard ANY) in our list
        -: 1605:     */
        -: 1606:    for( cur = &crt->ext_key_usage; cur != NULL; cur = cur->next )
        -: 1607:    {
        -: 1608:        const mbedtls_x509_buf *cur_oid = &cur->buf;
        -: 1609:
        -: 1610:        if( cur_oid->len == usage_len &&
        -: 1611:            memcmp( cur_oid->p, usage_oid, usage_len ) == 0 )
        -: 1612:        {
        -: 1613:            return( 0 );
        -: 1614:        }
        -: 1615:
        -: 1616:        if( MBEDTLS_OID_CMP( MBEDTLS_OID_ANY_EXTENDED_KEY_USAGE, cur_oid ) == 0 )
        -: 1617:            return( 0 );
        -: 1618:    }
        -: 1619:
        -: 1620:    return( MBEDTLS_ERR_X509_BAD_INPUT_DATA );
        -: 1621:}
        -: 1622:#endif /* MBEDTLS_X509_CHECK_EXTENDED_KEY_USAGE */
        -: 1623:
        -: 1624:#if defined(MBEDTLS_X509_CRL_PARSE_C)
        -: 1625:/*
        -: 1626: * Return 1 if the certificate is revoked, or 0 otherwise.
        -: 1627: */
        -: 1628:int mbedtls_x509_crt_is_revoked( const mbedtls_x509_crt *crt, const mbedtls_x509_crl *crl )
        -: 1629:{
        -: 1630:    const mbedtls_x509_crl_entry *cur = &crl->entry;
        -: 1631:
        -: 1632:    while( cur != NULL && cur->serial.len != 0 )
        -: 1633:    {
        -: 1634:        if( crt->serial.len == cur->serial.len &&
        -: 1635:            memcmp( crt->serial.p, cur->serial.p, crt->serial.len ) == 0 )
        -: 1636:        {
        -: 1637:            if( mbedtls_x509_time_is_past( &cur->revocation_date ) )
        -: 1638:                return( 1 );
        -: 1639:        }
        -: 1640:
        -: 1641:        cur = cur->next;
        -: 1642:    }
        -: 1643:
        -: 1644:    return( 0 );
        -: 1645:}
        -: 1646:
        -: 1647:/*
        -: 1648: * Check that the given certificate is not revoked according to the CRL.
        -: 1649: * Skip validation if no CRL for the given CA is present.
        -: 1650: */
        -: 1651:static int x509_crt_verifycrl( mbedtls_x509_crt *crt, mbedtls_x509_crt *ca,
        -: 1652:                               mbedtls_x509_crl *crl_list,
        -: 1653:                               const mbedtls_x509_crt_profile *profile )
        -: 1654:{
        -: 1655:    int flags = 0;
        -: 1656:    unsigned char hash[MBEDTLS_MD_MAX_SIZE];
        -: 1657:    const mbedtls_md_info_t *md_info;
        -: 1658:
        -: 1659:    if( ca == NULL )
        -: 1660:        return( flags );
        -: 1661:
        -: 1662:    while( crl_list != NULL )
        -: 1663:    {
        -: 1664:        if( crl_list->version == 0 ||
        -: 1665:            crl_list->issuer_raw.len != ca->subject_raw.len ||
        -: 1666:            memcmp( crl_list->issuer_raw.p, ca->subject_raw.p,
        -: 1667:                    crl_list->issuer_raw.len ) != 0 )
        -: 1668:        {
        -: 1669:            crl_list = crl_list->next;
        -: 1670:            continue;
        -: 1671:        }
        -: 1672:
        -: 1673:        /*
        -: 1674:         * Check if the CA is configured to sign CRLs
        -: 1675:         */
        -: 1676:#if defined(MBEDTLS_X509_CHECK_KEY_USAGE)
        -: 1677:        if( mbedtls_x509_crt_check_key_usage( ca, MBEDTLS_X509_KU_CRL_SIGN ) != 0 )
        -: 1678:        {
        -: 1679:            flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;
        -: 1680:            break;
        -: 1681:        }
        -: 1682:#endif
        -: 1683:
        -: 1684:        /*
        -: 1685:         * Check if CRL is correctly signed by the trusted CA
        -: 1686:         */
        -: 1687:        if( x509_profile_check_md_alg( profile, crl_list->sig_md ) != 0 )
        -: 1688:            flags |= MBEDTLS_X509_BADCRL_BAD_MD;
        -: 1689:
        -: 1690:        if( x509_profile_check_pk_alg( profile, crl_list->sig_pk ) != 0 )
        -: 1691:            flags |= MBEDTLS_X509_BADCRL_BAD_PK;
        -: 1692:
        -: 1693:        md_info = mbedtls_md_info_from_type( crl_list->sig_md );
        -: 1694:        if( mbedtls_md( md_info, crl_list->tbs.p, crl_list->tbs.len, hash ) != 0 )
        -: 1695:        {
        -: 1696:            /* Note: this can't happen except after an internal error */
        -: 1697:            flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;
        -: 1698:            break;
        -: 1699:        }
        -: 1700:
        -: 1701:        if( x509_profile_check_key( profile, &ca->pk ) != 0 )
        -: 1702:            flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
        -: 1703:
        -: 1704:        if( mbedtls_pk_verify_ext( crl_list->sig_pk, crl_list->sig_opts, &ca->pk,
        -: 1705:                           crl_list->sig_md, hash, mbedtls_md_get_size( md_info ),
        -: 1706:                           crl_list->sig.p, crl_list->sig.len ) != 0 )
        -: 1707:        {
        -: 1708:            flags |= MBEDTLS_X509_BADCRL_NOT_TRUSTED;
        -: 1709:            break;
        -: 1710:        }
        -: 1711:
        -: 1712:        /*
        -: 1713:         * Check for validity of CRL (Do not drop out)
        -: 1714:         */
        -: 1715:        if( mbedtls_x509_time_is_past( &crl_list->next_update ) )
        -: 1716:            flags |= MBEDTLS_X509_BADCRL_EXPIRED;
        -: 1717:
        -: 1718:        if( mbedtls_x509_time_is_future( &crl_list->this_update ) )
        -: 1719:            flags |= MBEDTLS_X509_BADCRL_FUTURE;
        -: 1720:
        -: 1721:        /*
        -: 1722:         * Check if certificate is revoked
        -: 1723:         */
        -: 1724:        if( mbedtls_x509_crt_is_revoked( crt, crl_list ) )
        -: 1725:        {
        -: 1726:            flags |= MBEDTLS_X509_BADCERT_REVOKED;
        -: 1727:            break;
        -: 1728:        }
        -: 1729:
        -: 1730:        crl_list = crl_list->next;
        -: 1731:    }
        -: 1732:
        -: 1733:    return( flags );
        -: 1734:}
        -: 1735:#endif /* MBEDTLS_X509_CRL_PARSE_C */
        -: 1736:
        -: 1737:/*
        -: 1738: * Like memcmp, but case-insensitive and always returns -1 if different
        -: 1739: */
    #####: 1740:static int x509_memcasecmp( const void *s1, const void *s2, size_t len )
        -: 1741:{
        -: 1742:    size_t i;
        -: 1743:    unsigned char diff;
    #####: 1744:    const unsigned char *n1 = s1, *n2 = s2;
        -: 1745:
    #####: 1746:    for( i = 0; i < len; i++ )
        -: 1747:    {
    #####: 1748:        diff = n1[i] ^ n2[i];
        -: 1749:
    #####: 1750:        if( diff == 0 )
    #####: 1751:            continue;
        -: 1752:
    #####: 1753:        if( diff == 32 &&
    #####: 1754:            ( ( n1[i] >= 'a' && n1[i] <= 'z' ) ||
    #####: 1755:              ( n1[i] >= 'A' && n1[i] <= 'Z' ) ) )
        -: 1756:        {
    #####: 1757:            continue;
        -: 1758:        }
        -: 1759:
    #####: 1760:        return( -1 );
        -: 1761:    }
        -: 1762:
    #####: 1763:    return( 0 );
        -: 1764:}
        -: 1765:
        -: 1766:/*
        -: 1767: * Return 0 if name matches wildcard, -1 otherwise
        -: 1768: */
    #####: 1769:static int x509_check_wildcard( const char *cn, const mbedtls_x509_buf *name )
        -: 1770:{
        -: 1771:    size_t i;
    #####: 1772:    size_t cn_idx = 0, cn_len = strlen( cn );
        -: 1773:
        -: 1774:    /* We can't have a match if there is no wildcard to match */
    #####: 1775:    if( name->len < 3 || name->p[0] != '*' || name->p[1] != '.' )
    #####: 1776:        return( -1 );
        -: 1777:
    #####: 1778:    for( i = 0; i < cn_len; ++i )
        -: 1779:    {
    #####: 1780:        if( cn[i] == '.' )
        -: 1781:        {
    #####: 1782:            cn_idx = i;
    #####: 1783:            break;
        -: 1784:        }
        -: 1785:    }
        -: 1786:
    #####: 1787:    if( cn_idx == 0 )
    #####: 1788:        return( -1 );
        -: 1789:
    #####: 1790:    if( cn_len - cn_idx == name->len - 1 &&
    #####: 1791:        x509_memcasecmp( name->p + 1, cn + cn_idx, name->len - 1 ) == 0 )
        -: 1792:    {
    #####: 1793:        return( 0 );
        -: 1794:    }
        -: 1795:
    #####: 1796:    return( -1 );
        -: 1797:}
        -: 1798:
        -: 1799:/*
        -: 1800: * Compare two X.509 strings, case-insensitive, and allowing for some encoding
        -: 1801: * variations (but not all).
        -: 1802: *
        -: 1803: * Return 0 if equal, -1 otherwise.
        -: 1804: */
    #####: 1805:static int x509_string_cmp( const mbedtls_x509_buf *a, const mbedtls_x509_buf *b )
        -: 1806:{
    #####: 1807:    if( a->tag == b->tag &&
    #####: 1808:        a->len == b->len &&
    #####: 1809:        memcmp( a->p, b->p, b->len ) == 0 )
        -: 1810:    {
    #####: 1811:        return( 0 );
        -: 1812:    }
        -: 1813:
    #####: 1814:    if( ( a->tag == MBEDTLS_ASN1_UTF8_STRING || a->tag == MBEDTLS_ASN1_PRINTABLE_STRING ) &&
    #####: 1815:        ( b->tag == MBEDTLS_ASN1_UTF8_STRING || b->tag == MBEDTLS_ASN1_PRINTABLE_STRING ) &&
    #####: 1816:        a->len == b->len &&
    #####: 1817:        x509_memcasecmp( a->p, b->p, b->len ) == 0 )
        -: 1818:    {
    #####: 1819:        return( 0 );
        -: 1820:    }
        -: 1821:
    #####: 1822:    return( -1 );
        -: 1823:}
        -: 1824:
        -: 1825:/*
        -: 1826: * Compare two X.509 Names (aka rdnSequence).
        -: 1827: *
        -: 1828: * See RFC 5280 section 7.1, though we don't implement the whole algorithm:
        -: 1829: * we sometimes return unequal when the full algorithm would return equal,
        -: 1830: * but never the other way. (In particular, we don't do Unicode normalisation
        -: 1831: * or space folding.)
        -: 1832: *
        -: 1833: * Return 0 if equal, -1 otherwise.
        -: 1834: */
    #####: 1835:static int x509_name_cmp( const mbedtls_x509_name *a, const mbedtls_x509_name *b )
        -: 1836:{
        -: 1837:    /* Avoid recursion, it might not be optimised by the compiler */
    #####: 1838:    while( a != NULL || b != NULL )
        -: 1839:    {
    #####: 1840:        if( a == NULL || b == NULL )
    #####: 1841:            return( -1 );
        -: 1842:
        -: 1843:        /* type */
    #####: 1844:        if( a->oid.tag != b->oid.tag ||
    #####: 1845:            a->oid.len != b->oid.len ||
    #####: 1846:            memcmp( a->oid.p, b->oid.p, b->oid.len ) != 0 )
        -: 1847:        {
    #####: 1848:            return( -1 );
        -: 1849:        }
        -: 1850:
        -: 1851:        /* value */
    #####: 1852:        if( x509_string_cmp( &a->val, &b->val ) != 0 )
    #####: 1853:            return( -1 );
        -: 1854:
        -: 1855:        /* structure of the list of sets */
    #####: 1856:        if( a->next_merged != b->next_merged )
    #####: 1857:            return( -1 );
        -: 1858:
    #####: 1859:        a = a->next;
    #####: 1860:        b = b->next;
        -: 1861:    }
        -: 1862:
        -: 1863:    /* a == NULL == b */
    #####: 1864:    return( 0 );
        -: 1865:}
        -: 1866:
        -: 1867:/*
        -: 1868: * Check the signature of a certificate by its parent
        -: 1869: */
    #####: 1870:static int x509_crt_check_signature( const mbedtls_x509_crt *child,
        -: 1871:                                     mbedtls_x509_crt *parent )
        -: 1872:{
        -: 1873:    const mbedtls_md_info_t *md_info;
        -: 1874:    unsigned char hash[MBEDTLS_MD_MAX_SIZE];
        -: 1875:
    #####: 1876:    md_info = mbedtls_md_info_from_type( child->sig_md );
    #####: 1877:    if( mbedtls_md( md_info, child->tbs.p, child->tbs.len, hash ) != 0 )
        -: 1878:    {
        -: 1879:        /* Note: this can't happen except after an internal error */
    #####: 1880:        return( -1 );
        -: 1881:    }
        -: 1882:
    #####: 1883:    if( mbedtls_pk_verify_ext( child->sig_pk, child->sig_opts, &parent->pk,
    #####: 1884:                child->sig_md, hash, mbedtls_md_get_size( md_info ),
    #####: 1885:                child->sig.p, child->sig.len ) != 0 )
        -: 1886:    {
    #####: 1887:        return( -1 );
        -: 1888:    }
        -: 1889:
    #####: 1890:    return( 0 );
        -: 1891:}
        -: 1892:
        -: 1893:/*
        -: 1894: * Check if 'parent' is a suitable parent (signing CA) for 'child'.
        -: 1895: * Return 0 if yes, -1 if not.
        -: 1896: *
        -: 1897: * top means parent is a locally-trusted certificate
        -: 1898: */
    #####: 1899:static int x509_crt_check_parent( const mbedtls_x509_crt *child,
        -: 1900:                                  const mbedtls_x509_crt *parent,
        -: 1901:                                  int top )
        -: 1902:{
        -: 1903:    int need_ca_bit;
        -: 1904:
        -: 1905:    /* Parent must be the issuer */
    #####: 1906:    if( x509_name_cmp( &child->issuer, &parent->subject ) != 0 )
    #####: 1907:        return( -1 );
        -: 1908:
        -: 1909:    /* Parent must have the basicConstraints CA bit set as a general rule */
    #####: 1910:    need_ca_bit = 1;
        -: 1911:
        -: 1912:    /* Exception: v1/v2 certificates that are locally trusted. */
    #####: 1913:    if( top && parent->version < 3 )
    #####: 1914:        need_ca_bit = 0;
        -: 1915:
    #####: 1916:    if( need_ca_bit && ! parent->ca_istrue )
    #####: 1917:        return( -1 );
        -: 1918:
        -: 1919:#if defined(MBEDTLS_X509_CHECK_KEY_USAGE)
        -: 1920:    if( need_ca_bit &&
        -: 1921:        mbedtls_x509_crt_check_key_usage( parent, MBEDTLS_X509_KU_KEY_CERT_SIGN ) != 0 )
        -: 1922:    {
        -: 1923:        return( -1 );
        -: 1924:    }
        -: 1925:#endif
        -: 1926:
    #####: 1927:    return( 0 );
        -: 1928:}
        -: 1929:
        -: 1930:/*
        -: 1931: * Find a suitable parent for child in candidates, or return NULL.
        -: 1932: *
        -: 1933: * Here suitable is defined as:
        -: 1934: *  1. subject name matches child's issuer
        -: 1935: *  2. if necessary, the CA bit is set and key usage allows signing certs
        -: 1936: *  3. for trusted roots, the signature is correct
        -: 1937: *  4. pathlen constraints are satisfied
        -: 1938: *
        -: 1939: * If there's a suitable candidate which is also time-valid, return the first
        -: 1940: * such. Otherwise, return the first suitable candidate (or NULL if there is
        -: 1941: * none).
        -: 1942: *
        -: 1943: * The rationale for this rule is that someone could have a list of trusted
        -: 1944: * roots with two versions on the same root with different validity periods.
        -: 1945: * (At least one user reported having such a list and wanted it to just work.)
        -: 1946: * The reason we don't just require time-validity is that generally there is
        -: 1947: * only one version, and if it's expired we want the flags to state that
        -: 1948: * rather than NOT_TRUSTED, as would be the case if we required it here.
        -: 1949: *
        -: 1950: * The rationale for rule 3 (signature for trusted roots) is that users might
        -: 1951: * have two versions of the same CA with different keys in their list, and the
        -: 1952: * way we select the correct one is by checking the signature (as we don't
        -: 1953: * rely on key identifier extensions). (This is one way users might choose to
        -: 1954: * handle key rollover, another relies on self-issued certs, see [SIRO].)
        -: 1955: *
        -: 1956: * Arguments:
        -: 1957: *  - [in] child: certificate for which we're looking for a parent
        -: 1958: *  - [in] candidates: chained list of potential parents
        -: 1959: *  - [in] top: 1 if candidates consists of trusted roots, ie we're at the top
        -: 1960: *         of the chain, 0 otherwise
        -: 1961: *  - [in] path_cnt: number of intermediates seen so far
        -: 1962: *  - [in] self_cnt: number of self-signed intermediates seen so far
        -: 1963: *         (will never be greater than path_cnt)
        -: 1964: *
        -: 1965: * Return value:
        -: 1966: *  - the first suitable parent found (see above regarding time-validity)
        -: 1967: *  - NULL if no suitable parent was found
        -: 1968: */
    #####: 1969:static mbedtls_x509_crt *x509_crt_find_parent_in( mbedtls_x509_crt *child,
        -: 1970:                                                  mbedtls_x509_crt *candidates,
        -: 1971:                                                  int top,
        -: 1972:                                                  size_t path_cnt,
        -: 1973:                                                  size_t self_cnt )
        -: 1974:{
    #####: 1975:    mbedtls_x509_crt *parent, *badtime_parent = NULL;
        -: 1976:
    #####: 1977:    for( parent = candidates; parent != NULL; parent = parent->next )
        -: 1978:    {
        -: 1979:        /* basic parenting skills (name, CA bit, key usage) */
    #####: 1980:        if( x509_crt_check_parent( child, parent, top ) != 0 )
    #####: 1981:            continue;
        -: 1982:
        -: 1983:        /* +1 because stored max_pathlen is 1 higher that the actual value */
    #####: 1984:        if( parent->max_pathlen > 0 &&
    #####: 1985:            (size_t) parent->max_pathlen < 1 + path_cnt - self_cnt )
        -: 1986:        {
    #####: 1987:            continue;
        -: 1988:        }
        -: 1989:
        -: 1990:        /* Signature */
    #####: 1991:        if( top && x509_crt_check_signature( child, parent ) != 0 )
        -: 1992:        {
    #####: 1993:            continue;
        -: 1994:        }
        -: 1995:
        -: 1996:        /* optional time check */
    #####: 1997:        if( mbedtls_x509_time_is_past( &parent->valid_to ) ||
    #####: 1998:            mbedtls_x509_time_is_future( &parent->valid_from ) )
        -: 1999:        {
    #####: 2000:            if( badtime_parent == NULL )
    #####: 2001:                badtime_parent = parent;
        -: 2002:
    #####: 2003:            continue;
        -: 2004:        }
        -: 2005:
    #####: 2006:        break;
        -: 2007:    }
        -: 2008:
    #####: 2009:    if( parent == NULL )
    #####: 2010:        parent = badtime_parent;
        -: 2011:
    #####: 2012:    return( parent );
        -: 2013:}
        -: 2014:
        -: 2015:/*
        -: 2016: * Find a parent in trusted CAs or the provided chain, or return NULL.
        -: 2017: *
        -: 2018: * Searches in trusted CAs first, and return the first suitable parent found
        -: 2019: * (see find_parent_in() for definition of suitable).
        -: 2020: *
        -: 2021: * Arguments:
        -: 2022: *  - [in] child: certificate for which we're looking for a parent, followed
        -: 2023: *         by a chain of possible intermediates
        -: 2024: *  - [in] trust_ca: locally trusted CAs
        -: 2025: *  - [out] 1 if parent was found in trust_ca, 0 if found in provided chain
        -: 2026: *  - [in] path_cnt: number of intermediates seen so far
        -: 2027: *  - [in] self_cnt: number of self-signed intermediates seen so far
        -: 2028: *         (will always be no greater than path_cnt)
        -: 2029: *
        -: 2030: * Return value:
        -: 2031: *  - the first suitable parent found (see find_parent_in() for "suitable")
        -: 2032: *  - NULL if no suitable parent was found
        -: 2033: */
    #####: 2034:static mbedtls_x509_crt *x509_crt_find_parent( mbedtls_x509_crt *child,
        -: 2035:                                               mbedtls_x509_crt *trust_ca,
        -: 2036:                                               int *parent_is_trusted,
        -: 2037:                                               size_t path_cnt,
        -: 2038:                                               size_t self_cnt )
        -: 2039:{
        -: 2040:    mbedtls_x509_crt *parent;
        -: 2041:
        -: 2042:    /* Look for a parent in trusted CAs */
    #####: 2043:    *parent_is_trusted = 1;
    #####: 2044:    parent = x509_crt_find_parent_in( child, trust_ca, 1, path_cnt, self_cnt );
        -: 2045:
    #####: 2046:    if( parent != NULL )
    #####: 2047:        return( parent );
        -: 2048:
        -: 2049:    /* Look for a parent upwards the chain */
    #####: 2050:    *parent_is_trusted = 0;
    #####: 2051:    return( x509_crt_find_parent_in( child, child->next, 0, path_cnt, self_cnt ) );
        -: 2052:}
        -: 2053:
        -: 2054:/*
        -: 2055: * Check if an end-entity certificate is locally trusted
        -: 2056: *
        -: 2057: * Currently we require such certificates to be self-signed (actually only
        -: 2058: * check for self-issued as self-signatures are not checked)
        -: 2059: */
    #####: 2060:static int x509_crt_check_ee_locally_trusted(
        -: 2061:                    mbedtls_x509_crt *crt,
        -: 2062:                    mbedtls_x509_crt *trust_ca )
        -: 2063:{
        -: 2064:    mbedtls_x509_crt *cur;
        -: 2065:
        -: 2066:    /* must be self-issued */
    #####: 2067:    if( x509_name_cmp( &crt->issuer, &crt->subject ) != 0 )
    #####: 2068:        return( -1 );
        -: 2069:
        -: 2070:    /* look for an exact match with trusted cert */
    #####: 2071:    for( cur = trust_ca; cur != NULL; cur = cur->next )
        -: 2072:    {
    #####: 2073:        if( crt->raw.len == cur->raw.len &&
    #####: 2074:            memcmp( crt->raw.p, cur->raw.p, crt->raw.len ) == 0 )
        -: 2075:        {
    #####: 2076:            return( 0 );
        -: 2077:        }
        -: 2078:    }
        -: 2079:
        -: 2080:    /* too bad */
    #####: 2081:    return( -1 );
        -: 2082:}
        -: 2083:
        -: 2084:/*
        -: 2085: * Build and verify a certificate chain
        -: 2086: *
        -: 2087: * Given a peer-provided list of certificates EE, C1, ..., Cn and
        -: 2088: * a list of trusted certs R1, ... Rp, try to build and verify a chain
        -: 2089: *      EE, Ci1, ... Ciq [, Rj]
        -: 2090: * such that every cert in the chain is a child of the next one,
        -: 2091: * jumping to a trusted root as early as possible.
        -: 2092: *
        -: 2093: * Verify that chain and return it with flags for all issues found.
        -: 2094: *
        -: 2095: * Special cases:
        -: 2096: * - EE == Rj -> return a one-element list containing it
        -: 2097: * - EE, Ci1, ..., Ciq cannot be continued with a trusted root
        -: 2098: *   -> return that chain with NOT_TRUSTED set on Ciq
        -: 2099: *
        -: 2100: * Arguments:
        -: 2101: *  - [in] crt: the cert list EE, C1, ..., Cn
        -: 2102: *  - [in] trust_ca: the trusted list R1, ..., Rp
        -: 2103: *  - [in] ca_crl, profile: as in verify_with_profile()
        -: 2104: *  - [out] ver_chain, chain_len: the built and verified chain
        -: 2105: *
        -: 2106: * Return value:
        -: 2107: *  - non-zero if the chain could not be fully built and examined
        -: 2108: *  - 0 is the chain was successfully built and examined,
        -: 2109: *      even if it was found to be invalid
        -: 2110: */
    #####: 2111:static int x509_crt_verify_chain(
        -: 2112:                mbedtls_x509_crt *crt,
        -: 2113:                mbedtls_x509_crt *trust_ca,
        -: 2114:                mbedtls_x509_crl *ca_crl,
        -: 2115:                const mbedtls_x509_crt_profile *profile,
        -: 2116:                x509_crt_verify_chain_item ver_chain[X509_MAX_VERIFY_CHAIN_SIZE],
        -: 2117:                size_t *chain_len )
        -: 2118:{
        -: 2119:    uint32_t *flags;
        -: 2120:    mbedtls_x509_crt *child;
        -: 2121:    mbedtls_x509_crt *parent;
    #####: 2122:    int parent_is_trusted = 0;
    #####: 2123:    int child_is_trusted = 0;
    #####: 2124:    size_t self_cnt = 0;
        -: 2125:
    #####: 2126:    child = crt;
    #####: 2127:    *chain_len = 0;
        -: 2128:
        -: 2129:    while( 1 ) {
        -: 2130:        /* Add certificate to the verification chain */
    #####: 2131:        ver_chain[*chain_len].crt = child;
    #####: 2132:        flags = &ver_chain[*chain_len].flags;
    #####: 2133:        ++*chain_len;
        -: 2134:
        -: 2135:        /* Check time-validity (all certificates) */
    #####: 2136:        if( mbedtls_x509_time_is_past( &child->valid_to ) )
    #####: 2137:            *flags |= MBEDTLS_X509_BADCERT_EXPIRED;
        -: 2138:
    #####: 2139:        if( mbedtls_x509_time_is_future( &child->valid_from ) )
    #####: 2140:            *flags |= MBEDTLS_X509_BADCERT_FUTURE;
        -: 2141:
        -: 2142:        /* Stop here for trusted roots (but not for trusted EE certs) */
    #####: 2143:        if( child_is_trusted )
    #####: 2144:            return( 0 );
        -: 2145:
        -: 2146:        /* Check signature algorithm: MD & PK algs */
    #####: 2147:        if( x509_profile_check_md_alg( profile, child->sig_md ) != 0 )
    #####: 2148:            *flags |= MBEDTLS_X509_BADCERT_BAD_MD;
        -: 2149:
    #####: 2150:        if( x509_profile_check_pk_alg( profile, child->sig_pk ) != 0 )
    #####: 2151:            *flags |= MBEDTLS_X509_BADCERT_BAD_PK;
        -: 2152:
        -: 2153:        /* Special case: EE certs that are locally trusted */
    #####: 2154:        if( *chain_len == 1 &&
    #####: 2155:            x509_crt_check_ee_locally_trusted( child, trust_ca ) == 0 )
        -: 2156:        {
    #####: 2157:            return( 0 );
        -: 2158:        }
        -: 2159:
        -: 2160:        /* Look for a parent in trusted CAs or up the chain */
    #####: 2161:        parent = x509_crt_find_parent( child, trust_ca, &parent_is_trusted,
    #####: 2162:                                       *chain_len - 1, self_cnt );
        -: 2163:
        -: 2164:        /* No parent? We're done here */
    #####: 2165:        if( parent == NULL )
        -: 2166:        {
    #####: 2167:            *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
    #####: 2168:            return( 0 );
        -: 2169:        }
        -: 2170:
        -: 2171:        /* Count intermediate self-issued (not necessarily self-signed) certs.
        -: 2172:         * These can occur with some strategies for key rollover, see [SIRO],
        -: 2173:         * and should be excluded from max_pathlen checks. */
    #####: 2174:        if( *chain_len != 1 &&
    #####: 2175:            x509_name_cmp( &child->issuer, &child->subject ) == 0 )
        -: 2176:        {
    #####: 2177:            self_cnt++;
        -: 2178:        }
        -: 2179:
        -: 2180:        /* path_cnt is 0 for the first intermediate CA,
        -: 2181:         * and if parent is trusted it's not an intermediate CA */
    #####: 2182:        if( ! parent_is_trusted &&
    #####: 2183:            *chain_len > MBEDTLS_X509_MAX_INTERMEDIATE_CA )
        -: 2184:        {
        -: 2185:            /* return immediately to avoid overflow the chain array */
    #####: 2186:            return( MBEDTLS_ERR_X509_FATAL_ERROR );
        -: 2187:        }
        -: 2188:
        -: 2189:        /* if parent is trusted, the signature was checked by find_parent() */
    #####: 2190:        if( ! parent_is_trusted && x509_crt_check_signature( child, parent ) != 0 )
    #####: 2191:            *flags |= MBEDTLS_X509_BADCERT_NOT_TRUSTED;
        -: 2192:
        -: 2193:        /* check size of signing key */
    #####: 2194:        if( x509_profile_check_key( profile, &parent->pk ) != 0 )
    #####: 2195:            *flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
        -: 2196:
        -: 2197:#if defined(MBEDTLS_X509_CRL_PARSE_C)
        -: 2198:        /* Check trusted CA's CRL for the given crt */
        -: 2199:        *flags |= x509_crt_verifycrl( child, parent, ca_crl, profile );
        -: 2200:#else
        -: 2201:        (void) ca_crl;
        -: 2202:#endif
        -: 2203:
        -: 2204:        /* prepare for next iteration */
    #####: 2205:        child = parent;
    #####: 2206:        parent = NULL;
    #####: 2207:        child_is_trusted = parent_is_trusted;
        -: 2208:    }
        -: 2209:}
        -: 2210:
        -: 2211:/*
        -: 2212: * Check for CN match
        -: 2213: */
    #####: 2214:static int x509_crt_check_cn( const mbedtls_x509_buf *name,
        -: 2215:                              const char *cn, size_t cn_len )
        -: 2216:{
        -: 2217:    /* try exact match */
    #####: 2218:    if( name->len == cn_len &&
    #####: 2219:        x509_memcasecmp( cn, name->p, cn_len ) == 0 )
        -: 2220:    {
    #####: 2221:        return( 0 );
        -: 2222:    }
        -: 2223:
        -: 2224:    /* try wildcard match */
    #####: 2225:    if( x509_check_wildcard( cn, name ) == 0 )
        -: 2226:    {
    #####: 2227:        return( 0 );
        -: 2228:    }
        -: 2229:
    #####: 2230:    return( -1 );
        -: 2231:}
        -: 2232:
        -: 2233:/*
        -: 2234: * Verify the requested CN - only call this if cn is not NULL!
        -: 2235: */
    #####: 2236:static void x509_crt_verify_name( const mbedtls_x509_crt *crt,
        -: 2237:                                  const char *cn,
        -: 2238:                                  uint32_t *flags )
        -: 2239:{
        -: 2240:    const mbedtls_x509_name *name;
        -: 2241:    const mbedtls_x509_sequence *cur;
    #####: 2242:    size_t cn_len = strlen( cn );
        -: 2243:
    #####: 2244:    if( crt->ext_types & MBEDTLS_X509_EXT_SUBJECT_ALT_NAME )
        -: 2245:    {
    #####: 2246:        for( cur = &crt->subject_alt_names; cur != NULL; cur = cur->next )
        -: 2247:        {
    #####: 2248:            if( x509_crt_check_cn( &cur->buf, cn, cn_len ) == 0 )
    #####: 2249:                break;
        -: 2250:        }
        -: 2251:
    #####: 2252:        if( cur == NULL )
    #####: 2253:            *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        -: 2254:    }
        -: 2255:    else
        -: 2256:    {
    #####: 2257:        for( name = &crt->subject; name != NULL; name = name->next )
        -: 2258:        {
    #####: 2259:            if( MBEDTLS_OID_CMP( MBEDTLS_OID_AT_CN, &name->oid ) == 0 &&
    #####: 2260:                x509_crt_check_cn( &name->val, cn, cn_len ) == 0 )
        -: 2261:            {
    #####: 2262:                break;
        -: 2263:            }
        -: 2264:        }
        -: 2265:
    #####: 2266:        if( name == NULL )
    #####: 2267:            *flags |= MBEDTLS_X509_BADCERT_CN_MISMATCH;
        -: 2268:    }
    #####: 2269:}
        -: 2270:
        -: 2271:/*
        -: 2272: * Merge the flags for all certs in the chain, after calling callback
        -: 2273: */
    #####: 2274:static int x509_crt_merge_flags_with_cb(
        -: 2275:           uint32_t *flags,
        -: 2276:           x509_crt_verify_chain_item ver_chain[X509_MAX_VERIFY_CHAIN_SIZE],
        -: 2277:           size_t chain_len,
        -: 2278:           int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
        -: 2279:           void *p_vrfy )
        -: 2280:{
        -: 2281:    int ret;
        -: 2282:    size_t i;
        -: 2283:    uint32_t cur_flags;
        -: 2284:
    #####: 2285:    for( i = chain_len; i != 0; --i )
        -: 2286:    {
    #####: 2287:        cur_flags = ver_chain[i-1].flags;
        -: 2288:
    #####: 2289:        if( NULL != f_vrfy )
    #####: 2290:            if( ( ret = f_vrfy( p_vrfy, ver_chain[i-1].crt, (int) i-1, &cur_flags ) ) != 0 )
    #####: 2291:                return( ret );
        -: 2292:
    #####: 2293:        *flags |= cur_flags;
        -: 2294:    }
        -: 2295:
    #####: 2296:    return( 0 );
        -: 2297:}
        -: 2298:
        -: 2299:/*
        -: 2300: * Verify the certificate validity
        -: 2301: */
    #####: 2302:int mbedtls_x509_crt_verify( mbedtls_x509_crt *crt,
        -: 2303:                     mbedtls_x509_crt *trust_ca,
        -: 2304:                     mbedtls_x509_crl *ca_crl,
        -: 2305:                     const char *cn, uint32_t *flags,
        -: 2306:                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
        -: 2307:                     void *p_vrfy )
        -: 2308:{
    #####: 2309:    return( mbedtls_x509_crt_verify_with_profile( crt, trust_ca, ca_crl,
        -: 2310:                &mbedtls_x509_crt_profile_default, cn, flags, f_vrfy, p_vrfy ) );
        -: 2311:}
        -: 2312:
        -: 2313:/*
        -: 2314: * Verify the certificate validity, with profile
        -: 2315: *
        -: 2316: * This function:
        -: 2317: *  - checks the requested CN (if any)
        -: 2318: *  - checks the type and size of the EE cert's key,
        -: 2319: *    as that isn't done as part of chain building/verification currently
        -: 2320: *  - builds and verifies the chain
        -: 2321: *  - then calls the callback and merges the flags
        -: 2322: */
    #####: 2323:int mbedtls_x509_crt_verify_with_profile( mbedtls_x509_crt *crt,
        -: 2324:                     mbedtls_x509_crt *trust_ca,
        -: 2325:                     mbedtls_x509_crl *ca_crl,
        -: 2326:                     const mbedtls_x509_crt_profile *profile,
        -: 2327:                     const char *cn, uint32_t *flags,
        -: 2328:                     int (*f_vrfy)(void *, mbedtls_x509_crt *, int, uint32_t *),
        -: 2329:                     void *p_vrfy )
        -: 2330:{
        -: 2331:    int ret;
        -: 2332:    mbedtls_pk_type_t pk_type;
        -: 2333:    x509_crt_verify_chain_item ver_chain[X509_MAX_VERIFY_CHAIN_SIZE];
        -: 2334:    size_t chain_len;
    #####: 2335:    uint32_t *ee_flags = &ver_chain[0].flags;
        -: 2336:
    #####: 2337:    *flags = 0;
    #####: 2338:    memset( ver_chain, 0, sizeof( ver_chain ) );
    #####: 2339:    chain_len = 0;
        -: 2340:
    #####: 2341:    if( profile == NULL )
        -: 2342:    {
    #####: 2343:        ret = MBEDTLS_ERR_X509_BAD_INPUT_DATA;
    #####: 2344:        goto exit;
        -: 2345:    }
        -: 2346:
        -: 2347:    /* check name if requested */
    #####: 2348:    if( cn != NULL )
    #####: 2349:        x509_crt_verify_name( crt, cn, ee_flags );
        -: 2350:
        -: 2351:    /* Check the type and size of the key */
    #####: 2352:    pk_type = mbedtls_pk_get_type( &crt->pk );
        -: 2353:
    #####: 2354:    if( x509_profile_check_pk_alg( profile, pk_type ) != 0 )
    #####: 2355:        *ee_flags |= MBEDTLS_X509_BADCERT_BAD_PK;
        -: 2356:
    #####: 2357:    if( x509_profile_check_key( profile, &crt->pk ) != 0 )
    #####: 2358:        *ee_flags |= MBEDTLS_X509_BADCERT_BAD_KEY;
        -: 2359:
        -: 2360:    /* Check the chain */
    #####: 2361:    ret = x509_crt_verify_chain( crt, trust_ca, ca_crl, profile,
        -: 2362:                                 ver_chain, &chain_len );
    #####: 2363:    if( ret != 0 )
    #####: 2364:        goto exit;
        -: 2365:
        -: 2366:    /* Build final flags, calling callback on the way if any */
    #####: 2367:    ret = x509_crt_merge_flags_with_cb( flags,
        -: 2368:                                        ver_chain, chain_len, f_vrfy, p_vrfy );
        -: 2369:
    #####: 2370:exit:
        -: 2371:    /* prevent misuse of the vrfy callback - VERIFY_FAILED would be ignored by
        -: 2372:     * the SSL module for authmode optional, but non-zero return from the
        -: 2373:     * callback means a fatal error so it shouldn't be ignored */
    #####: 2374:    if( ret == MBEDTLS_ERR_X509_CERT_VERIFY_FAILED )
    #####: 2375:        ret = MBEDTLS_ERR_X509_FATAL_ERROR;
        -: 2376:
    #####: 2377:    if( ret != 0 )
        -: 2378:    {
    #####: 2379:        *flags = (uint32_t) -1;
    #####: 2380:        return( ret );
        -: 2381:    }
        -: 2382:
    #####: 2383:    if( *flags != 0 )
    #####: 2384:        return( MBEDTLS_ERR_X509_CERT_VERIFY_FAILED );
        -: 2385:
    #####: 2386:    return( 0 );
        -: 2387:}
        -: 2388:
        -: 2389:/*
        -: 2390: * Initialize a certificate chain
        -: 2391: */
    #####: 2392:void mbedtls_x509_crt_init( mbedtls_x509_crt *crt )
        -: 2393:{
    #####: 2394:    memset( crt, 0, sizeof(mbedtls_x509_crt) );
    #####: 2395:}
        -: 2396:
        -: 2397:/*
        -: 2398: * Unallocate all certificate data
        -: 2399: */
    #####: 2400:void mbedtls_x509_crt_free( mbedtls_x509_crt *crt )
        -: 2401:{
    #####: 2402:    mbedtls_x509_crt *cert_cur = crt;
        -: 2403:    mbedtls_x509_crt *cert_prv;
        -: 2404:    mbedtls_x509_name *name_cur;
        -: 2405:    mbedtls_x509_name *name_prv;
        -: 2406:    mbedtls_x509_sequence *seq_cur;
        -: 2407:    mbedtls_x509_sequence *seq_prv;
        -: 2408:
    #####: 2409:    if( crt == NULL )
    #####: 2410:        return;
        -: 2411:
        -: 2412:    do
        -: 2413:    {
    #####: 2414:        mbedtls_pk_free( &cert_cur->pk );
        -: 2415:
        -: 2416:#if defined(MBEDTLS_X509_RSASSA_PSS_SUPPORT)
        -: 2417:        mbedtls_free( cert_cur->sig_opts );
        -: 2418:#endif
        -: 2419:
    #####: 2420:        name_cur = cert_cur->issuer.next;
    #####: 2421:        while( name_cur != NULL )
        -: 2422:        {
    #####: 2423:            name_prv = name_cur;
    #####: 2424:            name_cur = name_cur->next;
    #####: 2425:            mbedtls_platform_zeroize( name_prv, sizeof( mbedtls_x509_name ) );
    #####: 2426:            mbedtls_free( name_prv );
        -: 2427:        }
        -: 2428:
    #####: 2429:        name_cur = cert_cur->subject.next;
    #####: 2430:        while( name_cur != NULL )
        -: 2431:        {
    #####: 2432:            name_prv = name_cur;
    #####: 2433:            name_cur = name_cur->next;
    #####: 2434:            mbedtls_platform_zeroize( name_prv, sizeof( mbedtls_x509_name ) );
    #####: 2435:            mbedtls_free( name_prv );
        -: 2436:        }
        -: 2437:
    #####: 2438:        seq_cur = cert_cur->ext_key_usage.next;
    #####: 2439:        while( seq_cur != NULL )
        -: 2440:        {
    #####: 2441:            seq_prv = seq_cur;
    #####: 2442:            seq_cur = seq_cur->next;
    #####: 2443:            mbedtls_platform_zeroize( seq_prv,
        -: 2444:                                      sizeof( mbedtls_x509_sequence ) );
    #####: 2445:            mbedtls_free( seq_prv );
        -: 2446:        }
        -: 2447:
    #####: 2448:        seq_cur = cert_cur->subject_alt_names.next;
    #####: 2449:        while( seq_cur != NULL )
        -: 2450:        {
    #####: 2451:            seq_prv = seq_cur;
    #####: 2452:            seq_cur = seq_cur->next;
    #####: 2453:            mbedtls_platform_zeroize( seq_prv,
        -: 2454:                                      sizeof( mbedtls_x509_sequence ) );
    #####: 2455:            mbedtls_free( seq_prv );
        -: 2456:        }
        -: 2457:
    #####: 2458:        if( cert_cur->raw.p != NULL )
        -: 2459:        {
    #####: 2460:            mbedtls_platform_zeroize( cert_cur->raw.p, cert_cur->raw.len );
    #####: 2461:            mbedtls_free( cert_cur->raw.p );
        -: 2462:        }
        -: 2463:
    #####: 2464:        cert_cur = cert_cur->next;
        -: 2465:    }
    #####: 2466:    while( cert_cur != NULL );
        -: 2467:
    #####: 2468:    cert_cur = crt;
        -: 2469:    do
        -: 2470:    {
    #####: 2471:        cert_prv = cert_cur;
    #####: 2472:        cert_cur = cert_cur->next;
        -: 2473:
    #####: 2474:        mbedtls_platform_zeroize( cert_prv, sizeof( mbedtls_x509_crt ) );
    #####: 2475:        if( cert_prv != crt )
    #####: 2476:            mbedtls_free( cert_prv );
        -: 2477:    }
    #####: 2478:    while( cert_cur != NULL );
        -: 2479:}
        -: 2480:
        -: 2481:#endif /* MBEDTLS_X509_CRT_PARSE_C */
