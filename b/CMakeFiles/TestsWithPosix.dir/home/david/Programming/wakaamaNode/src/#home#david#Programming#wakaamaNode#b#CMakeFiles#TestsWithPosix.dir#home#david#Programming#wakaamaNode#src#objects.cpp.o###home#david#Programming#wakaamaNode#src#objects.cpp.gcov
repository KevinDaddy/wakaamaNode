        -:    0:Source:/home/david/Programming/wakaamaNode/src/objects.cpp
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/objects.cpp.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:#include "lwm2m/objects.h"
        -:    2:#include <cstring>
        -:    3:
        -:    4:// Test offset_of
        -:    5:struct TestA {
        -:    6:    int a;
        -:    7:};
        -:    8:struct TestB : public TestA {
        -:    9:    int b;
        -:   10:};
        -:   11:static_assert(offset_of(&TestB::b)==sizeof(int),"offset_of doesn't work");
        -:   12:
        -:   13:
    #####:   14:int lwm2m_object_prepare_full_response(lwm2m_data_t ** dataArrayP, Lwm2mObjectBaseVoid* metaP)
        -:   15:{
    #####:   16:    *dataArrayP = lwm2m_data_new(metaP->resources_len());
    #####:   17:    if (*dataArrayP == nullptr) return -1;
    #####:   18:    int readable = 0;
    #####:   19:    for(unsigned i=0;i<metaP->resources_len();++i)
        -:   20:    {
    #####:   21:        lwm2m_object_res_item_t* resP = metaP->resource(i);
    #####:   22:        if (!(resP->access & O_RES_R))
    #####:   23:            continue;
    #####:   24:        lwm2m_data_t* dataP = &(*dataArrayP)[readable];
    #####:   25:        dataP->id = resP->ressource_id;
    #####:   26:        ++readable;
        -:   27:    }
    #####:   28:    return readable;
        -:   29:}
        -:   30:
    #####:   31:uint8_t lwm2m_object_assign_single_value(lwm2m_data_t* destination, lwm2m_object_res_item_t* resP, Lwm2mObjectInstance* instanceP)
        -:   32:{
    #####:   33:    lwm2m_object_util_type_t res_type = (lwm2m_object_util_type_t)resP->type;
        -:   34:
    #####:   35:    void* memberP = (void*)((char*)instanceP + resP->struct_member_offset);
        -:   36:
        -:   37:    /// Support for function results as value ///
    #####:   38:    if ((resP->access & O_RES_E) == O_RES_E)
        -:   39:    {
    #####:   40:        if ((resP->access & O_RES_RW)==O_RES_RW){
    #####:   41:            IndirectReadWrite<void*> *cbStr =(IndirectReadWrite<void*>*) memberP;
        -:   42:            // We do not know the result type of f() yet and use a generic "void*"
    #####:   43:            void* fdata = cbStr->read(instanceP);
        -:   44:            // Make memberP point to the address of fData.
        -:   45:            // The dereferenced memberP will contain the real data.
    #####:   46:            memberP = &fdata;
    #####:   47:        } else if ((resP->access & O_RES_R)==O_RES_R){
        -:   48:            // The following is equal to this: readFunc f = (readFunc)(*(void**)memberP);
        -:   49:            // But the -pedantic switch forces us to use this union construct.
        -:   50:            union FunUnion{IndirectRead<void*> to; void *from;};
    #####:   51:            IndirectRead<void*> f = ((FunUnion*)memberP)->to;
        -:   52:            // We do not know the result type of f() yet and use a generic "void*"
    #####:   53:            void* fdata = f(instanceP);
        -:   54:            // Make memberP point to the address of fData.
        -:   55:            // The dereferenced memberP will contain the real data.
    #####:   56:            memberP = &fdata;
        -:   57:        } else
    #####:   58:            return COAP_405_METHOD_NOT_ALLOWED;
        -:   59:    }
        -:   60:    ///////////////////////////////////////////////////////////////////////
        -:   61:
    #####:   62:    switch (res_type)
        -:   63:    {
    #####:   64:    case O_RES_STRING:
    #####:   65:        lwm2m_data_encode_string(*((char**)memberP), destination);
    #####:   66:        return COAP_205_CONTENT;
    #####:   67:    case O_RES_STRING_PREALLOC: {
    #####:   68:        OpaqueType_t* o = (OpaqueType_t*)memberP;
    #####:   69:        lwm2m_data_encode_string((char*)o->data, destination);
    #####:   70:        return COAP_205_CONTENT;
        -:   71:    }
    #####:   72:    case O_RES_OPAQUE_INDIRECT: {
    #####:   73:        OpaqueIndirect* o = (OpaqueIndirect*)memberP;
    #####:   74:        lwm2m_data_encode_opaque(o->data,o->used_len, destination);
    #####:   75:        return COAP_205_CONTENT;
        -:   76:    }
    #####:   77:    case O_RES_OPAQUE_PREALLOC: {
    #####:   78:        OpaqueType_t* o = (OpaqueType_t*)memberP;
    #####:   79:        lwm2m_data_encode_opaque(o->data,o->used_len, destination);
    #####:   80:        return COAP_205_CONTENT;
        -:   81:    }
    #####:   82:    case O_RES_BOOL:
    #####:   83:        lwm2m_data_encode_bool(*((bool*)memberP), destination);
    #####:   84:        return COAP_205_CONTENT;
    #####:   85:    case O_RES_DOUBLE:
    #####:   86:        lwm2m_data_encode_float(*((double*)memberP), destination);
    #####:   87:        return COAP_205_CONTENT;
    #####:   88:    case O_RES_INT8:
        -:   89:    case O_RES_UINT8:
    #####:   90:        lwm2m_data_encode_int(*((int8_t*)memberP), destination);
    #####:   91:        return COAP_205_CONTENT;
    #####:   92:    case O_RES_INT16:
        -:   93:    case O_RES_UINT16:
    #####:   94:        lwm2m_data_encode_int(*((int16_t*)memberP), destination);
    #####:   95:        return COAP_205_CONTENT;
    #####:   96:    case O_RES_INT32:
        -:   97:    case O_RES_UINT32:
    #####:   98:        lwm2m_data_encode_int(*((int32_t*)memberP), destination);
    #####:   99:        return COAP_205_CONTENT;
    #####:  100:    case O_RES_INT64:
    #####:  101:        lwm2m_data_encode_int(*((int64_t*)memberP), destination);
    #####:  102:        return COAP_205_CONTENT;
    #####:  103:    case O_RES_EXEC:
    #####:  104:        break;
        -:  105:    }
        -:  106:
    #####:  107:    return COAP_404_NOT_FOUND;
        -:  108:}
        -:  109:
    #####:  110:uint8_t prv_read(uint16_t instanceId,
        -:  111:                        int * numDataP,
        -:  112:                        lwm2m_data_t ** dataArrayP,
        -:  113:                        lwm2m_object_t * objectP,
        -:  114:                        lwm2m_context_t* context)
        -:  115:{
    #####:  116:    Lwm2mObjectInstance* instanceP = (Lwm2mObjectInstance *)lwm2m_list_find(objectP->instanceList, instanceId);
    #####:  117:    if (NULL == instanceP) return COAP_404_NOT_FOUND;
        -:  118:
    #####:  119:    Lwm2mObjectBaseVoid* metaP = Lwm2mObjectBaseVoid::getBase(objectP);
    #####:  120:    if (!metaP) return COAP_500_INTERNAL_SERVER_ERROR;
        -:  121:
    #####:  122:    if (*numDataP == 0)
    #####:  123:        *numDataP = lwm2m_object_prepare_full_response(dataArrayP, metaP);
        -:  124:
    #####:  125:    if (*numDataP < 0)
    #####:  126:        return COAP_500_INTERNAL_SERVER_ERROR;
        -:  127:
    #####:  128:    for (int i = 0 ; i < *numDataP ; i++)
        -:  129:    {
    #####:  130:        lwm2m_data_t* dataP = &(*dataArrayP)[i];
    #####:  131:        unsigned res_id = dataP->id;
    #####:  132:        lwm2m_object_res_item_t* resP = metaP->find_ressource(res_id);
    #####:  133:        if (!resP)
    #####:  134:            return COAP_404_NOT_FOUND;
        -:  135:
    #####:  136:        if (!(resP->access & O_RES_R) || resP->struct_member_offset==0)
    #####:  137:            return COAP_405_METHOD_NOT_ALLOWED;
        -:  138:
    #####:  139:        lwm2m_object_assign_single_value(dataP, resP, instanceP);
        -:  140:    }
        -:  141:
    #####:  142:    return COAP_205_CONTENT;
        -:  143:}
        -:  144:
        -:  145:/// Write value to function or to object instance member ///
        -:  146:template<class T>
    #####:  147:static uint8_t writeToMemberOrToMethod(Lwm2mObjectInstance* instanceP, uint8_t access, void* memberP, T value, int len) {
    #####:  148:    if ((access & O_RES_E) == O_RES_E)
        -:  149:    {
    #####:  150:        if ((access & O_RES_RW)==O_RES_RW){
    #####:  151:            IndirectReadWrite<T> *cbStr =reinterpret_cast<IndirectReadWrite<T>*>(memberP);
    #####:  152:            DynArray<T> d(value,len);
    #####:  153:            cbStr->write(instanceP,d);
    #####:  154:        } else if ((access & O_RES_W)==O_RES_W){
    #####:  155:            IndirectWrite<T> f = *reinterpret_cast<IndirectWrite<T>*>(memberP);
    #####:  156:            DynArray<T> d(value,len);
    #####:  157:            f(instanceP,d);
        -:  158:        } else
    #####:  159:            return COAP_405_METHOD_NOT_ALLOWED;
        -:  160:    } else {
    #####:  161:        *((T*)memberP) = (T)value;
        -:  162:    }
    #####:  163:    return COAP_204_CHANGED;
        -:  164:}
------------------
_Z23writeToMemberOrToMethodIPKcEhP19Lwm2mObjectInstancehPvT_i:
    #####:  147:static uint8_t writeToMemberOrToMethod(Lwm2mObjectInstance* instanceP, uint8_t access, void* memberP, T value, int len) {
    #####:  148:    if ((access & O_RES_E) == O_RES_E)
        -:  149:    {
    #####:  150:        if ((access & O_RES_RW)==O_RES_RW){
    #####:  151:            IndirectReadWrite<T> *cbStr =reinterpret_cast<IndirectReadWrite<T>*>(memberP);
    #####:  152:            DynArray<T> d(value,len);
    #####:  153:            cbStr->write(instanceP,d);
    #####:  154:        } else if ((access & O_RES_W)==O_RES_W){
    #####:  155:            IndirectWrite<T> f = *reinterpret_cast<IndirectWrite<T>*>(memberP);
    #####:  156:            DynArray<T> d(value,len);
    #####:  157:            f(instanceP,d);
        -:  158:        } else
    #####:  159:            return COAP_405_METHOD_NOT_ALLOWED;
        -:  160:    } else {
    #####:  161:        *((T*)memberP) = (T)value;
        -:  162:    }
    #####:  163:    return COAP_204_CHANGED;
        -:  164:}
------------------
_Z23writeToMemberOrToMethodIlEhP19Lwm2mObjectInstancehPvT_i:
    #####:  147:static uint8_t writeToMemberOrToMethod(Lwm2mObjectInstance* instanceP, uint8_t access, void* memberP, T value, int len) {
    #####:  148:    if ((access & O_RES_E) == O_RES_E)
        -:  149:    {
    #####:  150:        if ((access & O_RES_RW)==O_RES_RW){
    #####:  151:            IndirectReadWrite<T> *cbStr =reinterpret_cast<IndirectReadWrite<T>*>(memberP);
    #####:  152:            DynArray<T> d(value,len);
    #####:  153:            cbStr->write(instanceP,d);
    #####:  154:        } else if ((access & O_RES_W)==O_RES_W){
    #####:  155:            IndirectWrite<T> f = *reinterpret_cast<IndirectWrite<T>*>(memberP);
    #####:  156:            DynArray<T> d(value,len);
    #####:  157:            f(instanceP,d);
        -:  158:        } else
    #####:  159:            return COAP_405_METHOD_NOT_ALLOWED;
        -:  160:    } else {
    #####:  161:        *((T*)memberP) = (T)value;
        -:  162:    }
    #####:  163:    return COAP_204_CHANGED;
        -:  164:}
------------------
_Z23writeToMemberOrToMethodIjEhP19Lwm2mObjectInstancehPvT_i:
    #####:  147:static uint8_t writeToMemberOrToMethod(Lwm2mObjectInstance* instanceP, uint8_t access, void* memberP, T value, int len) {
    #####:  148:    if ((access & O_RES_E) == O_RES_E)
        -:  149:    {
    #####:  150:        if ((access & O_RES_RW)==O_RES_RW){
    #####:  151:            IndirectReadWrite<T> *cbStr =reinterpret_cast<IndirectReadWrite<T>*>(memberP);
    #####:  152:            DynArray<T> d(value,len);
    #####:  153:            cbStr->write(instanceP,d);
    #####:  154:        } else if ((access & O_RES_W)==O_RES_W){
    #####:  155:            IndirectWrite<T> f = *reinterpret_cast<IndirectWrite<T>*>(memberP);
    #####:  156:            DynArray<T> d(value,len);
    #####:  157:            f(instanceP,d);
        -:  158:        } else
    #####:  159:            return COAP_405_METHOD_NOT_ALLOWED;
        -:  160:    } else {
    #####:  161:        *((T*)memberP) = (T)value;
        -:  162:    }
    #####:  163:    return COAP_204_CHANGED;
        -:  164:}
------------------
_Z23writeToMemberOrToMethodIiEhP19Lwm2mObjectInstancehPvT_i:
    #####:  147:static uint8_t writeToMemberOrToMethod(Lwm2mObjectInstance* instanceP, uint8_t access, void* memberP, T value, int len) {
    #####:  148:    if ((access & O_RES_E) == O_RES_E)
        -:  149:    {
    #####:  150:        if ((access & O_RES_RW)==O_RES_RW){
    #####:  151:            IndirectReadWrite<T> *cbStr =reinterpret_cast<IndirectReadWrite<T>*>(memberP);
    #####:  152:            DynArray<T> d(value,len);
    #####:  153:            cbStr->write(instanceP,d);
    #####:  154:        } else if ((access & O_RES_W)==O_RES_W){
    #####:  155:            IndirectWrite<T> f = *reinterpret_cast<IndirectWrite<T>*>(memberP);
    #####:  156:            DynArray<T> d(value,len);
    #####:  157:            f(instanceP,d);
        -:  158:        } else
    #####:  159:            return COAP_405_METHOD_NOT_ALLOWED;
        -:  160:    } else {
    #####:  161:        *((T*)memberP) = (T)value;
        -:  162:    }
    #####:  163:    return COAP_204_CHANGED;
        -:  164:}
------------------
_Z23writeToMemberOrToMethodItEhP19Lwm2mObjectInstancehPvT_i:
    #####:  147:static uint8_t writeToMemberOrToMethod(Lwm2mObjectInstance* instanceP, uint8_t access, void* memberP, T value, int len) {
    #####:  148:    if ((access & O_RES_E) == O_RES_E)
        -:  149:    {
    #####:  150:        if ((access & O_RES_RW)==O_RES_RW){
    #####:  151:            IndirectReadWrite<T> *cbStr =reinterpret_cast<IndirectReadWrite<T>*>(memberP);
    #####:  152:            DynArray<T> d(value,len);
    #####:  153:            cbStr->write(instanceP,d);
    #####:  154:        } else if ((access & O_RES_W)==O_RES_W){
    #####:  155:            IndirectWrite<T> f = *reinterpret_cast<IndirectWrite<T>*>(memberP);
    #####:  156:            DynArray<T> d(value,len);
    #####:  157:            f(instanceP,d);
        -:  158:        } else
    #####:  159:            return COAP_405_METHOD_NOT_ALLOWED;
        -:  160:    } else {
    #####:  161:        *((T*)memberP) = (T)value;
        -:  162:    }
    #####:  163:    return COAP_204_CHANGED;
        -:  164:}
------------------
_Z23writeToMemberOrToMethodIsEhP19Lwm2mObjectInstancehPvT_i:
    #####:  147:static uint8_t writeToMemberOrToMethod(Lwm2mObjectInstance* instanceP, uint8_t access, void* memberP, T value, int len) {
    #####:  148:    if ((access & O_RES_E) == O_RES_E)
        -:  149:    {
    #####:  150:        if ((access & O_RES_RW)==O_RES_RW){
    #####:  151:            IndirectReadWrite<T> *cbStr =reinterpret_cast<IndirectReadWrite<T>*>(memberP);
    #####:  152:            DynArray<T> d(value,len);
    #####:  153:            cbStr->write(instanceP,d);
    #####:  154:        } else if ((access & O_RES_W)==O_RES_W){
    #####:  155:            IndirectWrite<T> f = *reinterpret_cast<IndirectWrite<T>*>(memberP);
    #####:  156:            DynArray<T> d(value,len);
    #####:  157:            f(instanceP,d);
        -:  158:        } else
    #####:  159:            return COAP_405_METHOD_NOT_ALLOWED;
        -:  160:    } else {
    #####:  161:        *((T*)memberP) = (T)value;
        -:  162:    }
    #####:  163:    return COAP_204_CHANGED;
        -:  164:}
------------------
_Z23writeToMemberOrToMethodIhEhP19Lwm2mObjectInstancehPvT_i:
    #####:  147:static uint8_t writeToMemberOrToMethod(Lwm2mObjectInstance* instanceP, uint8_t access, void* memberP, T value, int len) {
    #####:  148:    if ((access & O_RES_E) == O_RES_E)
        -:  149:    {
    #####:  150:        if ((access & O_RES_RW)==O_RES_RW){
    #####:  151:            IndirectReadWrite<T> *cbStr =reinterpret_cast<IndirectReadWrite<T>*>(memberP);
    #####:  152:            DynArray<T> d(value,len);
    #####:  153:            cbStr->write(instanceP,d);
    #####:  154:        } else if ((access & O_RES_W)==O_RES_W){
    #####:  155:            IndirectWrite<T> f = *reinterpret_cast<IndirectWrite<T>*>(memberP);
    #####:  156:            DynArray<T> d(value,len);
    #####:  157:            f(instanceP,d);
        -:  158:        } else
    #####:  159:            return COAP_405_METHOD_NOT_ALLOWED;
        -:  160:    } else {
    #####:  161:        *((T*)memberP) = (T)value;
        -:  162:    }
    #####:  163:    return COAP_204_CHANGED;
        -:  164:}
------------------
_Z23writeToMemberOrToMethodIaEhP19Lwm2mObjectInstancehPvT_i:
    #####:  147:static uint8_t writeToMemberOrToMethod(Lwm2mObjectInstance* instanceP, uint8_t access, void* memberP, T value, int len) {
    #####:  148:    if ((access & O_RES_E) == O_RES_E)
        -:  149:    {
    #####:  150:        if ((access & O_RES_RW)==O_RES_RW){
    #####:  151:            IndirectReadWrite<T> *cbStr =reinterpret_cast<IndirectReadWrite<T>*>(memberP);
    #####:  152:            DynArray<T> d(value,len);
    #####:  153:            cbStr->write(instanceP,d);
    #####:  154:        } else if ((access & O_RES_W)==O_RES_W){
    #####:  155:            IndirectWrite<T> f = *reinterpret_cast<IndirectWrite<T>*>(memberP);
    #####:  156:            DynArray<T> d(value,len);
    #####:  157:            f(instanceP,d);
        -:  158:        } else
    #####:  159:            return COAP_405_METHOD_NOT_ALLOWED;
        -:  160:    } else {
    #####:  161:        *((T*)memberP) = (T)value;
        -:  162:    }
    #####:  163:    return COAP_204_CHANGED;
        -:  164:}
------------------
_Z23writeToMemberOrToMethodIdEhP19Lwm2mObjectInstancehPvT_i:
    #####:  147:static uint8_t writeToMemberOrToMethod(Lwm2mObjectInstance* instanceP, uint8_t access, void* memberP, T value, int len) {
    #####:  148:    if ((access & O_RES_E) == O_RES_E)
        -:  149:    {
    #####:  150:        if ((access & O_RES_RW)==O_RES_RW){
    #####:  151:            IndirectReadWrite<T> *cbStr =reinterpret_cast<IndirectReadWrite<T>*>(memberP);
    #####:  152:            DynArray<T> d(value,len);
    #####:  153:            cbStr->write(instanceP,d);
    #####:  154:        } else if ((access & O_RES_W)==O_RES_W){
    #####:  155:            IndirectWrite<T> f = *reinterpret_cast<IndirectWrite<T>*>(memberP);
    #####:  156:            DynArray<T> d(value,len);
    #####:  157:            f(instanceP,d);
        -:  158:        } else
    #####:  159:            return COAP_405_METHOD_NOT_ALLOWED;
        -:  160:    } else {
    #####:  161:        *((T*)memberP) = (T)value;
        -:  162:    }
    #####:  163:    return COAP_204_CHANGED;
        -:  164:}
------------------
_Z23writeToMemberOrToMethodIbEhP19Lwm2mObjectInstancehPvT_i:
    #####:  147:static uint8_t writeToMemberOrToMethod(Lwm2mObjectInstance* instanceP, uint8_t access, void* memberP, T value, int len) {
    #####:  148:    if ((access & O_RES_E) == O_RES_E)
        -:  149:    {
    #####:  150:        if ((access & O_RES_RW)==O_RES_RW){
    #####:  151:            IndirectReadWrite<T> *cbStr =reinterpret_cast<IndirectReadWrite<T>*>(memberP);
    #####:  152:            DynArray<T> d(value,len);
    #####:  153:            cbStr->write(instanceP,d);
    #####:  154:        } else if ((access & O_RES_W)==O_RES_W){
    #####:  155:            IndirectWrite<T> f = *reinterpret_cast<IndirectWrite<T>*>(memberP);
    #####:  156:            DynArray<T> d(value,len);
    #####:  157:            f(instanceP,d);
        -:  158:        } else
    #####:  159:            return COAP_405_METHOD_NOT_ALLOWED;
        -:  160:    } else {
    #####:  161:        *((T*)memberP) = (T)value;
        -:  162:    }
    #####:  163:    return COAP_204_CHANGED;
        -:  164:}
------------------
        -:  165:
    #####:  166:uint8_t prv_write(uint16_t instanceId,
        -:  167:                 int numData,
        -:  168:                 lwm2m_data_t * dataArray,
        -:  169:                 lwm2m_object_t * objectP,
        -:  170:                 lwm2m_context_t* context)
        -:  171:{
    #####:  172:    Lwm2mObjectInstance* instanceP = (Lwm2mObjectInstance *)lwm2m_list_find(objectP->instanceList, instanceId);
    #####:  173:    if (nullptr == instanceP) return COAP_404_NOT_FOUND;
        -:  174:
    #####:  175:    Lwm2mObjectBaseVoid* metaP = Lwm2mObjectBaseVoid::getBase(objectP);
        -:  176:
        -:  177:    // For the verify/write callback to be able to deny a change, we hand over a copy
        -:  178:    // of the instance data. The copy is just thrown away if the change is denied.
        -:  179:    uint8_t copy_of_entry[300];
    #####:  180:    if (metaP->sizes.object_instance>300) return COAP_412_PRECONDITION_FAILED;
        -:  181:
    #####:  182:    for (int i = 0 ; i < numData ; ++i)
        -:  183:    {
    #####:  184:        unsigned res_id = dataArray[i].id;
        -:  185:
    #####:  186:        lwm2m_object_res_item_t* resP = metaP->find_ressource(res_id);
    #####:  187:        if (!resP)
    #####:  188:            return COAP_404_NOT_FOUND;
        -:  189:
        -:  190:        // Check for write access and if offset is set
    #####:  191:        if (!(resP->access & O_RES_W))
    #####:  192:            return COAP_405_METHOD_NOT_ALLOWED;
        -:  193:
        -:  194:        // Extract ressource type and member pointer from meta object
    #####:  195:        lwm2m_object_util_type_t res_type = (lwm2m_object_util_type_t)resP->type;
        -:  196:
        -:  197:        // For the verify/write callback to be able to deny a change, we hand over a copy
        -:  198:        // of the instance data. The copy is just thrown away if the change is denied.
    #####:  199:        memcpy(copy_of_entry, instanceP, metaP->sizes.object_instance);
    #####:  200:        void* memberP = (void*)((char*)copy_of_entry + resP->struct_member_offset);
        -:  201:
        -:  202:        union {
        -:  203:            bool b;
        -:  204:            int64_t i;
        -:  205:            double d;
        -:  206:            char* c;
        -:  207:        } temp;
        -:  208:
        -:  209:        // The CPP-API does not reallocate memory.
        -:  210:        // If there's not enough space, a COAP_413_ENTITY_TOO_LARGE error code is returned.
        -:  211:
    #####:  212:        switch (res_type)
        -:  213:        {
    #####:  214:        case O_RES_OPAQUE_INDIRECT: {
        -:  215:            // We do not apply data directly to the instance object. To make this work for
        -:  216:            // O_RES_OPAQUE_INDIRECT, we let the data pointer point
        -:  217:            // to the receive buffer temporary and copy the data in a post-processing step after
        -:  218:            // the verify/write callback accepted the change.
    #####:  219:            OpaqueIndirect* o = (OpaqueIndirect*)memberP;
    #####:  220:            if (o->reserved_len < dataArray[i].value.asBuffer.length)
    #####:  221:                return COAP_413_ENTITY_TOO_LARGE;
    #####:  222:            temp.c = (char*)o->data; // backup orginal pointer for post-processing
    #####:  223:            o->used_len = dataArray[i].value.asBuffer.length;
    #####:  224:            o->data = dataArray[i].value.asBuffer.buffer;
    #####:  225:            break;
        -:  226:        }
    #####:  227:        case O_RES_OPAQUE_PREALLOC:
        -:  228:        case O_RES_STRING_PREALLOC: {
    #####:  229:            OpaqueType_t* o = (OpaqueType_t*)memberP;
    #####:  230:            if (o->reserved_len < dataArray[i].value.asBuffer.length)
    #####:  231:                return COAP_413_ENTITY_TOO_LARGE;
    #####:  232:            o->used_len = dataArray[i].value.asBuffer.length;
    #####:  233:            memcpy(o->data, (char*)dataArray[i].value.asBuffer.buffer, o->used_len);
    #####:  234:            break;
        -:  235:        }
    #####:  236:        case O_RES_BOOL:
    #####:  237:            if (1 != lwm2m_data_decode_bool(&dataArray[i], &temp.b))
    #####:  238:                return COAP_400_BAD_REQUEST;
    #####:  239:            writeToMemberOrToMethod(instanceP, resP->access,memberP,temp.b,sizeof(temp.b));
    #####:  240:            break;
    #####:  241:        case O_RES_DOUBLE:
    #####:  242:            if (1 != lwm2m_data_decode_float(&dataArray[i], &temp.d))
    #####:  243:                return COAP_400_BAD_REQUEST;
    #####:  244:            writeToMemberOrToMethod(instanceP, resP->access,memberP,temp.d,sizeof(temp.d));
    #####:  245:            break;
    #####:  246:        case O_RES_INT8:
    #####:  247:            if (1 != lwm2m_data_decode_int(&dataArray[i], &temp.i) || temp.i < INT8_MIN || temp.i > INT8_MAX)
    #####:  248:                return COAP_400_BAD_REQUEST;
    #####:  249:            writeToMemberOrToMethod<int8_t>(instanceP, resP->access,memberP, temp.i,sizeof(temp.i));
    #####:  250:            break;
    #####:  251:        case O_RES_UINT8:
    #####:  252:            if (1 != lwm2m_data_decode_int(&dataArray[i], &temp.i) || temp.i < 0 || temp.i > UINT8_MAX)
    #####:  253:                return COAP_400_BAD_REQUEST;
    #####:  254:            writeToMemberOrToMethod<uint8_t>(instanceP, resP->access,memberP,temp.i,sizeof(temp.i));
    #####:  255:            break;
    #####:  256:        case O_RES_INT16:
    #####:  257:            if (1 != lwm2m_data_decode_int(&dataArray[i], &temp.i) || temp.i < INT16_MIN || temp.i > INT16_MAX)
    #####:  258:                return COAP_400_BAD_REQUEST;
    #####:  259:            writeToMemberOrToMethod<int16_t>(instanceP, resP->access,memberP,temp.i,sizeof(temp.i));
    #####:  260:            break;
    #####:  261:        case O_RES_UINT16:
    #####:  262:            if (1 != lwm2m_data_decode_int(&dataArray[i], &temp.i) || temp.i < 0 || temp.i > UINT16_MAX)
    #####:  263:                return COAP_400_BAD_REQUEST;
    #####:  264:            writeToMemberOrToMethod<uint16_t>(instanceP, resP->access,memberP,temp.i,sizeof(temp.i));
    #####:  265:            break;
    #####:  266:        case O_RES_INT32:
    #####:  267:            if (1 != lwm2m_data_decode_int(&dataArray[i], &temp.i) || temp.i < INT32_MIN || temp.i > INT32_MAX)
    #####:  268:                return COAP_400_BAD_REQUEST;
    #####:  269:            writeToMemberOrToMethod<int32_t>(instanceP, resP->access,memberP,temp.i,sizeof(temp.i));
    #####:  270:            break;
    #####:  271:        case O_RES_UINT32:
    #####:  272:            if (1 != lwm2m_data_decode_int(&dataArray[i], &temp.i) || temp.i < 0 || temp.i > UINT32_MAX)
    #####:  273:                return COAP_400_BAD_REQUEST;
    #####:  274:            writeToMemberOrToMethod<uint32_t>(instanceP, resP->access,memberP,temp.i,sizeof(temp.i));
    #####:  275:            break;
    #####:  276:        case O_RES_INT64:
    #####:  277:            if (1 != lwm2m_data_decode_int(&dataArray[i], &temp.i))
    #####:  278:                return COAP_400_BAD_REQUEST;
    #####:  279:            writeToMemberOrToMethod<int64_t>(instanceP, resP->access,memberP,temp.i,sizeof(temp.i));
    #####:  280:            break;
    #####:  281:        case O_RES_STRING:
    #####:  282:            if (!(resP->access & O_RES_E))
    #####:  283:                return COAP_400_BAD_REQUEST;
        -:  284:            else {
    #####:  285:                temp.c = (char*)dataArray[i].value.asBuffer.buffer;
    #####:  286:                writeToMemberOrToMethod<const char*>(instanceP, resP->access,memberP,temp.c,dataArray[i].value.asBuffer.length);
    #####:  287:                break;
        -:  288:            }
    #####:  289:        default:
    #####:  290:            return COAP_500_INTERNAL_SERVER_ERROR;
        -:  291:        }
        -:  292:
    #####:  293:        if (metaP->verifyWrite((Lwm2mObjectInstance*)copy_of_entry, res_id)) {
        -:  294:            // The O_RES_OPAQUE_INDIRECT needs some special handling:
    #####:  295:            if (res_type == O_RES_OPAQUE_INDIRECT) {
    #####:  296:                OpaqueIndirect* o = (OpaqueIndirect*)memberP;
        -:  297:                // Restore the pointer to the original memory area
    #####:  298:                o->data = (uint8_t*)temp.c;
        -:  299:                // Copy the receive buffer to the destination memory address
    #####:  300:                memcpy(o->data, (char*)dataArray[i].value.asBuffer.buffer, o->used_len);
        -:  301:            }
        -:  302:            // The verify method is either not set or accepted the input. Copy the altered
        -:  303:            // instance data back to the original instance.
    #####:  304:            memcpy(instanceP, copy_of_entry, metaP->sizes.object_instance);
        -:  305:        } else {
    #####:  306:            return COAP_400_BAD_REQUEST;
        -:  307:        }
        -:  308:
    #####:  309:        lwm2m_resource_changed_event(objectP->objID, instanceId, resP->ressource_id);
        -:  310:    }
        -:  311:
    #####:  312:    return COAP_204_CHANGED;
        -:  313:}
        -:  314:
        -:  315:
    #####:  316:uint8_t prv_execute(uint16_t instanceId,
        -:  317:                    uint16_t res_id,
        -:  318:                    lwm2m_context_t* context,
        -:  319:                    lwm2m_object_t * objectP)
        -:  320:{
    #####:  321:    Lwm2mObjectBaseVoid* metaP = Lwm2mObjectBaseVoid::getBase(objectP);
        -:  322:
    #####:  323:    Lwm2mObjectInstance* instanceP = (Lwm2mObjectInstance *)lwm2m_list_find(objectP->instanceList, instanceId);
    #####:  324:    if (nullptr == instanceP) return COAP_404_NOT_FOUND;
        -:  325:
    #####:  326:    lwm2m_object_res_item_t* resP = metaP->find_ressource(res_id);
    #####:  327:    if (!resP)
    #####:  328:        return COAP_404_NOT_FOUND;
        -:  329:
    #####:  330:    if (resP->access != O_RES_E)
    #####:  331:        return COAP_405_METHOD_NOT_ALLOWED;
        -:  332:
    #####:  333:    void* memberP = (void*)((char*)instanceP + resP->struct_member_offset);
        -:  334:    // The following is equal to this: execFunc f = (execFunc)(*(void**)memberP);
        -:  335:    // But the -pedantic switch forces us to use this union construct.
        -:  336:    union FunUnion{Executable to; void *from;};
    #####:  337:    Executable f = ((FunUnion*)memberP)->to;
    #####:  338:    if (f)
    #####:  339:        f(instanceP, context);
    #####:  340:    return COAP_204_CHANGED;
        -:  341:}
        -:  342:
        -:  343:
    #####:  344:uint8_t prv_discover(uint16_t instanceId,
        -:  345:                            int * numDataP,
        -:  346:                            lwm2m_data_t ** dataArrayP,
        -:  347:                            lwm2m_object_t * objectP)
        -:  348:{
    #####:  349:    Lwm2mObjectBaseVoid* metaP = Lwm2mObjectBaseVoid::getBase(objectP);
    #####:  350:    if (!metaP) return COAP_500_INTERNAL_SERVER_ERROR;
        -:  351:
    #####:  352:    lwm2m_list_t* instanceP = (lwm2m_list_t *)lwm2m_list_find(objectP->instanceList, instanceId);
    #####:  353:    if (nullptr == instanceP) return COAP_404_NOT_FOUND;
        -:  354:
        -:  355:    // is the server asking for the full object ?
    #####:  356:    if (*numDataP == 0)
        -:  357:    {
    #####:  358:        const unsigned resources_len = metaP->resources_len();
    #####:  359:        *dataArrayP = lwm2m_data_new((int)resources_len);
    #####:  360:        if (*dataArrayP == nullptr)
    #####:  361:            return COAP_500_INTERNAL_SERVER_ERROR;
    #####:  362:        int readable = 0;
    #####:  363:        for(unsigned i=0;i<resources_len;++i)
        -:  364:        {
    #####:  365:            lwm2m_object_res_item_t* resP = metaP->resource(i);
    #####:  366:            if (!(resP->access & (O_RES_RW|O_RES_E)))
    #####:  367:                continue;
    #####:  368:            lwm2m_data_t* dataP = &(*dataArrayP)[readable];
    #####:  369:            dataP->id = resP->ressource_id;
    #####:  370:            ++readable;
        -:  371:        }
    #####:  372:        *numDataP = readable;
    #####:  373:        return COAP_205_CONTENT;
        -:  374:    }
        -:  375:
    #####:  376:    for (int i = 0; i < *numDataP; ++i)
        -:  377:    {
    #####:  378:        lwm2m_data_t* dataP = &(*dataArrayP)[i];
    #####:  379:        if (dataP->id >= metaP->resources_len()) {
    #####:  380:            return COAP_404_NOT_FOUND;
        -:  381:        }
        -:  382:    }
    #####:  383:    return COAP_205_CONTENT;
        -:  384:}
        -:  385:
    #####:  386:uint8_t prv_delete(uint16_t id, lwm2m_object_t * objectP)
        -:  387:{
    #####:  388:    Lwm2mObjectBaseVoid* metaP = Lwm2mObjectBaseVoid::getBase(objectP);
    #####:  389:    if (!metaP) return COAP_500_INTERNAL_SERVER_ERROR;
        -:  390:
        -:  391:    lwm2m_list_t * targetP;
    #####:  392:    objectP->instanceList = lwm2m_list_remove(objectP->instanceList, id, (lwm2m_list_t **)&targetP);
    #####:  393:    if (NULL == targetP) return COAP_404_NOT_FOUND;
        -:  394:
    #####:  395:    metaP->deleteInstance(static_cast<Lwm2mObjectInstance*>(targetP));
        -:  396:
    #####:  397:    return COAP_202_DELETED;
        -:  398:}
        -:  399:
    #####:  400:uint8_t prv_create(uint16_t instanceId,
        -:  401:                          int numData,
        -:  402:                          lwm2m_data_t * dataArray,
        -:  403:                          lwm2m_object_t * objectP,
        -:  404:                          lwm2m_context_t * contextP)
        -:  405:{
    #####:  406:    Lwm2mObjectBaseVoid* metaP = Lwm2mObjectBaseVoid::getBase(objectP);
    #####:  407:    if (!metaP) return COAP_500_INTERNAL_SERVER_ERROR;
        -:  408:
    #####:  409:    Lwm2mObjectInstance* instanceP = metaP->createInstance(instanceId);
    #####:  410:    if (nullptr == instanceP)
    #####:  411:        return COAP_500_INTERNAL_SERVER_ERROR;
        -:  412:
    #####:  413:    instanceP->id = instanceId;
    #####:  414:    objectP->instanceList = LWM2M_LIST_ADD(objectP->instanceList, instanceP);
        -:  415:
    #####:  416:    uint8_t result = prv_write(instanceId, numData, dataArray, objectP,NULL);
        -:  417:
    #####:  418:    if (result != COAP_204_CHANGED)
        -:  419:    {
    #####:  420:        (void)prv_delete(instanceId, objectP);
        -:  421:    }
        -:  422:    else
        -:  423:    {
    #####:  424:        result = COAP_201_CREATED;
        -:  425:    }
        -:  426:
    #####:  427:    return result;
        -:  428:}
