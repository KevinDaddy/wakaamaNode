        -:    0:Source:/home/david/Programming/wakaamaNode/src/network/network_posix.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/network/network_posix.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*******************************************************************************
        -:    2: * Copyright (c) 2017-2018  David Graeff <david.graeff@web.de>
        -:    3: *
        -:    4: * Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    5: * of this software and associated documentation files (the "Software"), to deal
        -:    6: * in the Software without restriction, including without limitation the rights
        -:    7: * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:    8: * copies of the Software, and to permit persons to whom the Software is
        -:    9: * furnished to do so, subject to the following conditions:
        -:   10: *
        -:   11: * The above copyright notice and this permission notice shall be included in
        -:   12: * all copies or substantial portions of the Software.
        -:   13: */
        -:   14:#include "network_common.h"
        -:   15:
        -:   16:typedef int make_iso_compilers_happy; // if not POSIX_NETWORK
        -:   17:
        -:   18:#ifdef POSIX_NETWORK
        -:   19:
        -:   20:#include "lwm2m/network.h"
        -:   21:#include "lwm2m/c_connect.h"
        -:   22:#include "lwm2m/debug.h"
        -:   23:#include "../internal.h"
        -:   24:#include <stdio.h>
        -:   25:#include <errno.h>
        -:   26:#include <stdlib.h>
        -:   27:#include <string.h>
        -:   28:
        -:   29:#ifdef _WIN32
        -:   30:    #include "wepoll/wepoll.h"
        -:   31:    #define WIN32_LEAN_AND_MEAN
        -:   32:    #include <Windows.h>
        -:   33:    #include <Winsock2.h>
        -:   34:    #include <ws2tcpip.h>
        -:   35:    #define LOG_ERR 3
        -:   36:    typedef uint16_t in_port_t;
        -:   37:    #define close(s) closesocket(s)
        -:   38:#else
        -:   39:    #include <sys/epoll.h>
        -:   40:    #include <unistd.h>
        -:   41:    #include <netinet/in.h>
        -:   42:    #include <arpa/inet.h>
        -:   43:    #include <sys/types.h>
        -:   44:    #include <sys/socket.h>
        -:   45:    #include <sys/select.h>
        -:   46:    #include <netdb.h>
        -:   47:#endif
        -:   48:
    #####:   49:inline void internal_closeSocket(network_t* network, unsigned socket_handle) {
    #####:   50:    close(network->socket_handle[socket_handle].data.fd);
    #####:   51:}
        -:   52:
    #####:   53:void internal_network_close(network_t* network){
    #####:   54:    if (network->epfd)
    #####:   55:        close(network->epfd);
    #####:   56:}
        -:   57:
    #####:   58:uint8_t internal_init_sockets(lwm2m_context_t * contextP, network_t* network, uint16_t localPort) {
        -:   59:    (void)contextP;
        -:   60:    #ifdef _WIN32
        -:   61:    struct WSAData d;
        -:   62:    if (WSAStartup(MAKEWORD(2, 2), &d) != 0) {
        -:   63:        return -1;
        -:   64:    }
        -:   65:    #endif
        -:   66:
    #####:   67:    int s = -1;
        -:   68:    struct addrinfo hints;
        -:   69:    struct addrinfo *res;
        -:   70:    struct addrinfo *p;
        -:   71:
    #####:   72:    memset(&hints, 0, sizeof(struct addrinfo));
    #####:   73:    hints.ai_family = AF_UNSPEC; /* Allow IPv4 or IPv6 */
    #####:   74:    hints.ai_socktype = SOCK_DGRAM;
    #####:   75:    hints.ai_flags = AI_PASSIVE;
    #####:   76:    hints.ai_protocol = 0; // any protocol
    #####:   77:    hints.ai_canonname = NULL;
    #####:   78:    hints.ai_addr = NULL;
    #####:   79:    hints.ai_next = NULL;
        -:   80:
        -:   81:
        -:   82:    int r;
    #####:   83:    if (localPort) {
        -:   84:        // Server
    #####:   85:        network->type = NET_SERVER_PROCESS;
        -:   86:        char port[7];
    #####:   87:        snprintf(port, 7, "%d", localPort);
    #####:   88:        r = getaddrinfo(NULL, port, &hints, &res);
        -:   89:    } else {
        -:   90:        // client
    #####:   91:        network->type = NET_CLIENT_PROCESS;
    #####:   92:        r = getaddrinfo(NULL, "12873", &hints, &res);
        -:   93:    }
        -:   94:
    #####:   95:    if (0 != r || res == NULL)
    #####:   96:        return 0;
        -:   97:
    #####:   98:    network->open_listen_sockets = 0;
    #####:   99:    for(p = res ; p != NULL && s == -1 ; p = p->ai_next)
    #####:  100:        ++network->open_listen_sockets;
        -:  101:
    #####:  102:    network->epfd = epoll_create(MAX_SOCKETS);
        -:  103:
    #####:  104:    network->open_listen_sockets = 0;
    #####:  105:    for(p = res ; p != NULL; p = p->ai_next)
        -:  106:    {
    #####:  107:        int handle = socket(p->ai_family, p->ai_socktype, p->ai_protocol);
    #####:  108:        if (handle >= 0)
        -:  109:        {
    #####:  110:            if (-1 == bind(handle, p->ai_addr, p->ai_addrlen))
        -:  111:            {
    #####:  112:                close(handle);
        -:  113:            } else
        -:  114:            {
    #####:  115:                struct epoll_event *ev= &network->socket_handle[network->open_listen_sockets];
    #####:  116:                ev->events=EPOLLIN | EPOLLPRI | EPOLLONESHOT;
    #####:  117:                ev->data.fd=handle;
    #####:  118:                errno=0;
    #####:  119:                epoll_ctl(network->epfd, EPOLL_CTL_ADD, ev->data.fd, ev);
    #####:  120:                assert (errno==0);
        -:  121:
    #####:  122:                ++network->open_listen_sockets;
        -:  123:                // Don't use more sockets than we have size in our array
    #####:  124:                if ((unsigned long)network->open_listen_sockets > sizeof(network->socket_handle)/sizeof(int))
    #####:  125:                    break;
        -:  126:            }
        -:  127:        }
        -:  128:    }
        -:  129:
    #####:  130:    freeaddrinfo(res);
        -:  131:
    #####:  132:    return (uint8_t)network->open_listen_sockets;
        -:  133:}
        -:  134:
        -:  135:
    #####:  136:intptr_t lwm2m_network_native_sock(lwm2m_context_t * contextP, unsigned sock_no) {
    #####:  137:    network_t* network = (network_t*)contextP->userData;
    #####:  138:    if (!network) return -1;
    #####:  139:    return (intptr_t)network->socket_handle[sock_no].data.fd;
        -:  140:}
        -:  141:
        -:  142:#ifdef LWM2M_NETWORK_LOGGING
    #####:  143:void connection_log_io(connection_t* connection, int length, bool sending)
        -:  144:{
    #####:  145:    const struct sockaddr_storage addr = connection->addr.addr;
    #####:  146:    const network_process_type_t isServer = connection->network->type;
        -:  147:
        -:  148:    char s[INET6_ADDRSTRLEN];
    #####:  149:    in_port_t port=0;
        -:  150:
    #####:  151:    s[0] = 0;
        -:  152:
    #####:  153:    if (AF_INET == addr.ss_family)
        -:  154:    {
    #####:  155:        struct sockaddr_in *saddr = (struct sockaddr_in *)&addr;
    #####:  156:        inet_ntop(saddr->sin_family, &saddr->sin_addr, s, INET_ADDRSTRLEN);
    #####:  157:        port = ntohs(saddr->sin_port);
        -:  158:    }
    #####:  159:    else if (AF_INET6 == addr.ss_family)
        -:  160:    {
    #####:  161:        struct sockaddr_in6 *saddr = (struct sockaddr_in6 *)&addr;
    #####:  162:        inet_ntop(saddr->sin6_family, &saddr->sin6_addr, s, INET6_ADDRSTRLEN);
    #####:  163:        port = ntohs(saddr->sin6_port);
        -:  164:    }
        -:  165:
        -:  166:#ifdef LWM2M_WITH_DTLS
    #####:  167:    const int ssl_handshake = connection->ssl.state;
        -:  168:#else
        -:  169:    const int ssl_handshake = 0;
        -:  170:#endif
        -:  171:
    #####:  172:    if (sending)
    #####:  173:        network_log_info("Sending %d bytes to [%s]:%hu (server: %i, dtls handshake: %i )\r\n",
        -:  174:                (int)length, s, port, isServer, ssl_handshake);
        -:  175:    else
    #####:  176:        network_log_info("Receiving %d bytes from [%s]:%hu (server: %i, dtls handshake: %i)\r\n",
        -:  177:                (int)length, s, port, isServer, ssl_handshake);
        -:  178:
        -:  179:    //output_buffer(stderr, buffer, length, 0);
    #####:  180:}
        -:  181:#endif
        -:  182:
    #####:  183:bool lwm2m_network_process(lwm2m_context_t * contextP, struct timeval *timeoutInSec) {
    #####:  184:    network_t* network = (network_t*)contextP->userData;
    #####:  185:    for (unsigned c = 0; c < network->open_listen_sockets; ++c) {
        -:  186:        uint8_t buffer[MAX_PACKET_SIZE];
    #####:  187:        size_t numBytes = MAX_PACKET_SIZE;
    #####:  188:        struct sockaddr_storage addr={0};
    #####:  189:        socklen_t addrLen = sizeof(addr);
        -:  190:        
    #####:  191:        ssize_t r = recvfrom(network->socket_handle[c].data.fd, buffer, numBytes,
        -:  192:                         MSG_PEEK|MSG_DONTWAIT, (struct sockaddr *)&addr, &addrLen);
        -:  193:
    #####:  194:        if (r < 0)
        -:  195:        {
    #####:  196:            if (errno!=EAGAIN)
    #####:  197:                network_log_error("Error in recvfrom(): %d %s\r\n", errno, strerror(errno));
    #####:  198:            errno=0;
    #####:  199:            continue;
    #####:  200:        } else if (r == 0)
    #####:  201:            continue; // no new data
        -:  202:
        -:  203:        // Find connection with given address (or create it in server mode)
        -:  204:        addr_t t;
    #####:  205:        t.addr = addr;
    #####:  206:        connection_t * connection = internal_connection_find(network, t);
    #####:  207:        if (!connection) continue;
    #####:  208:        connection->sock = &network->socket_handle[c];
    #####:  209:        connection->addr = t;
        -:  210:
        -:  211:        //connection_log_io(connection,r,false);
    #####:  212:        internal_network_read(contextP, buffer, numBytes, connection);
        -:  213:    }
    #####:  214:    internal_check_timer(contextP, timeoutInSec);
    #####:  215:    return network->open_listen_sockets >= 1;
        -:  216:}
        -:  217:
        -:  218:#define IPADDRSIZE(connP) (connP->addr.addr.ss_family==AF_INET?sizeof(struct sockaddr_in):sizeof(struct sockaddr_in6))
        -:  219:#define IPADDR(connP) (struct sockaddr *)&(connP->addr.addr)
        -:  220:
    #####:  221:int mbedtls_net_send(void *ctx, const unsigned char *buffer, size_t length) {
    #####:  222:    connection_t * connection = (connection_t*)ctx;
    #####:  223:    ssize_t nbSent = 0;
    #####:  224:    size_t offset = 0;
    #####:  225:    while (offset != length)
        -:  226:    {
    #####:  227:        nbSent = sendto(connection->sock->data.fd, buffer + offset, length - offset, MSG_DONTWAIT,
    #####:  228:                        IPADDR(connection), IPADDRSIZE(connection));
        -:  229:
    #####:  230:        connection_log_io(connection, (int)length, true);
    #####:  231:        if (nbSent == -1)
    #####:  232:            break;
    #####:  233:        offset += (size_t)nbSent;
        -:  234:    }
    #####:  235:    if (nbSent>=0) return (int)nbSent;
    #####:  236:    if (errno==EAGAIN||errno==EWOULDBLOCK){
    #####:  237:        errno=0;
        -:  238:        #ifdef LWM2M_WITH_DTLS
    #####:  239:        return MBEDTLS_ERR_SSL_WANT_WRITE;
        -:  240:        #else
        -:  241:        return 0;
        -:  242:        #endif
        -:  243:    }
    #####:  244:    network_log_error( "#> failed sending %lu bytes\r\n", length);
        -:  245:    #ifdef LWM2M_WITH_DTLS
    #####:  246:    return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
        -:  247:    #else
        -:  248:    return COAP_500_INTERNAL_SERVER_ERROR;
        -:  249:    #endif
        -:  250:}
        -:  251:
    #####:  252:int mbedtls_net_recv( void *ctx, unsigned char *buf, size_t len ) {
    #####:  253:    connection_t * connection = (connection_t*)ctx;
        -:  254:    struct sockaddr_storage addr;
    #####:  255:    socklen_t addrLen = sizeof(addr);
        -:  256:
    #####:  257:    errno=0;
    #####:  258:    ssize_t r = recvfrom(connection->sock->data.fd, buf, len, MSG_DONTWAIT, (struct sockaddr *)&addr, &addrLen);
    #####:  259:    if (r>=0) {
    #####:  260:        connection_log_io(connection, (int)r, false);
    #####:  261:        epoll_ctl(connection->network->epfd, EPOLL_CTL_MOD, connection->sock->data.fd, connection->sock);
    #####:  262:        assert (errno==0);
    #####:  263:        return (int)r;
        -:  264:    }
    #####:  265:    if (errno==EAGAIN||errno==EWOULDBLOCK){
    #####:  266:        errno=0;
        -:  267:        #ifdef LWM2M_WITH_DTLS
    #####:  268:        return MBEDTLS_ERR_SSL_WANT_READ;
        -:  269:        #else
        -:  270:        return 0;
        -:  271:        #endif
        -:  272:    }
    #####:  273:    network_log_error("recvfrom failed %i", (int)errno);
    #####:  274:    assert (errno!=2); // The device should not be closed without any reason
    #####:  275:    errno=0;
        -:  276:    #ifdef LWM2M_WITH_DTLS
    #####:  277:    return MBEDTLS_ERR_SSL_INTERNAL_ERROR;
        -:  278:    #else
        -:  279:    return COAP_500_INTERNAL_SERVER_ERROR;
        -:  280:    #endif
        -:  281:}
        -:  282:
    #####:  283:sock_t* test_and_return_working_socket_handle(network_t* network,
        -:  284:                                          char * host,
        -:  285:                                          uint16_t port,
        -:  286:                                          struct sockaddr_storage* destip) {
        -:  287:
        -:  288:    struct addrinfo hints;
    #####:  289:    struct addrinfo *servinfo = NULL;
        -:  290:    struct addrinfo *p;
        -:  291:
    #####:  292:    memset(&hints, 0, sizeof(hints));
    #####:  293:    hints.ai_family = AF_UNSPEC;
    #####:  294:    hints.ai_socktype = SOCK_DGRAM;
    #####:  295:    hints.ai_flags = AI_NUMERICSERV|AI_ADDRCONFIG;
        -:  296:
        -:  297:    char portStr[7];
    #####:  298:    snprintf(portStr, 7, "%d", port);
    #####:  299:    if (0 != getaddrinfo(host, portStr, &hints, &servinfo) || servinfo == NULL)
    #####:  300:        return NULL;
        -:  301:
        -:  302:    // we test the various addresses with the sockets we know
    #####:  303:    for(p = servinfo ; p != NULL; p = p->ai_next)
        -:  304:    {
    #####:  305:        for (unsigned sock_no = 0; sock_no < network->open_listen_sockets; ++sock_no)
        -:  306:        {
    #####:  307:            int handle = network->socket_handle[sock_no].data.fd;
    #####:  308:            memcpy(destip, p->ai_addr, p->ai_addrlen);
        -:  309:            // We test if the given socket is able to connect to the ip address
    #####:  310:            if (-1 != connect(handle, p->ai_addr, p->ai_addrlen))
        -:  311:            {
        -:  312:                // "Connection" possible. If you use connect on a udp socket, that
        -:  313:                // socket will only receive from the given address. To make the socket
        -:  314:                // listen to any address again, call connect with sa_family == AF_UNSPEC.
        -:  315:                struct sockaddr any_addr;
    #####:  316:                any_addr.sa_family = AF_UNSPEC;
    #####:  317:                connect(handle,&any_addr,sizeof(any_addr));
        -:  318:
    #####:  319:                freeaddrinfo(servinfo);
    #####:  320:                return &network->socket_handle[sock_no];
        -:  321:            }
        -:  322:        }
        -:  323:    }
        -:  324:
    #####:  325:    if (NULL != servinfo) {
    #####:  326:        freeaddrinfo(servinfo);
        -:  327:    }
    #####:  328:    return NULL;
        -:  329:}
        -:  330:
    #####:  331:connection_t * internal_connection_create(network_t* network,
        -:  332:                                 char * host,
        -:  333:                                 uint16_t port)
        -:  334:{
    #####:  335:    if (!network->open_listen_sockets)
    #####:  336:        return NULL;
        -:  337:
    #####:  338:    connection_t * connection = NULL;
    #####:  339:    struct sockaddr_storage destip={0};
    #####:  340:    sock_t* s = test_and_return_working_socket_handle(network, host, port, &destip);
    #####:  341:    if (s != NULL) {
    #####:  342:        connection = (connection_t *)lwm2m_malloc(sizeof(connection_t));
    #####:  343:        if (connection != NULL) {
    #####:  344:            memset(connection, 0, sizeof(connection_t));
    #####:  345:            connection->sock = s;
    #####:  346:            connection->addr.addr = destip;
    #####:  347:            connection->next = (struct _connection_t *)network->connection_list;
        -:  348:        }
        -:  349:    }
        -:  350:
    #####:  351:    return connection;
        -:  352:}
        -:  353:
    #####:  354:int lwm2m_block_wait(lwm2m_context_t * contextP, struct timeval next_event) {
    #####:  355:    network_t* network = (network_t*)contextP->userData;
        -:  356:
        -:  357:    struct epoll_event rev;
    #####:  358:    const int timeout = (int)next_event.tv_sec*1000+(int)next_event.tv_usec/1000;
        -:  359:
    #####:  360:    errno=0;
    #####:  361:    int nfds = epoll_wait(network->epfd, &rev, 1, timeout);
        -:  362:
    #####:  363:    if (nfds < 0 && errno != EINTR) {
    #####:  364:        fprintf(stderr, "Error in epoll_wait(): %d %s\r\n", errno, strerror(errno));
    #####:  365:        return -1;
        -:  366:    }
        -:  367:
    #####:  368:    return rev.data.fd;
        -:  369:}
        -:  370:
        -:  371:
        -:  372://///// Compare IP addresses on POSIX systems
        -:  373:
        -:  374:#define SOCK_ADDR_PTR(ptr)	((struct sockaddr *)(ptr))
        -:  375:#define SOCK_ADDR_FAMILY(ptr)	SOCK_ADDR_PTR(ptr)->sa_family
        -:  376:
        -:  377:#define SOCK_ADDR_IN_PTR(sa)	((struct sockaddr_in *)(sa))
        -:  378:#define SOCK_ADDR_IN_ADDR(sa)	SOCK_ADDR_IN_PTR(sa)->sin_addr
        -:  379:
        -:  380:#define SOCK_ADDR_LEN(sa) \
        -:  381:   (SOCK_ADDR_PTR(sa)->sa_family == AF_INET6 ? \
        -:  382:    sizeof(struct sockaddr_in6) : sizeof(struct sockaddr_in))
        -:  383:
        -:  384:#define SOCK_ADDR_IN6_PTR(sa)	((struct sockaddr_in6 *)(sa))
        -:  385:#define SOCK_ADDR_IN6_ADDR(sa)	SOCK_ADDR_IN6_PTR(sa)->sin6_addr
        -:  386:
        -:  387:#define SOCK_ADDR_EQ_ADDR(sa, sb) \
        -:  388:   ((SOCK_ADDR_FAMILY(sa) == AF_INET && SOCK_ADDR_FAMILY(sb) == AF_INET \
        -:  389:     && SOCK_ADDR_IN_ADDR(sa).s_addr == SOCK_ADDR_IN_ADDR(sb).s_addr) \
        -:  390:    || (SOCK_ADDR_FAMILY(sa) == AF_INET6 && SOCK_ADDR_FAMILY(sb) == AF_INET6 \
        -:  391:        && memcmp((char *) &(SOCK_ADDR_IN6_ADDR(sa)), \
        -:  392:                  (char *) &(SOCK_ADDR_IN6_ADDR(sb)), \
        -:  393:                  sizeof(SOCK_ADDR_IN6_ADDR(sa))) == 0))
        -:  394:
    #####:  395:inline bool ip_equal(addr_t a, addr_t b) {
    #####:  396:    const struct sockaddr * sa = (struct sockaddr*)&a.addr;
    #####:  397:    const struct sockaddr * sb = (struct sockaddr*)&b.addr;
    #####:  398:    if (sa->sa_family != sb->sa_family) return false;
        -:  399:
    #####:  400:    if (sa->sa_family == AF_INET) {
    #####:  401:        return 0==(SOCK_ADDR_IN_ADDR(sa).s_addr - SOCK_ADDR_IN_ADDR(sb).s_addr);
    #####:  402:    } else if (sa->sa_family == AF_INET6) {
    #####:  403:        return (0==memcmp((char *) &(SOCK_ADDR_IN6_ADDR(sa)),
    #####:  404:               (char *) &(SOCK_ADDR_IN6_ADDR(sb)),
        -:  405:               sizeof(SOCK_ADDR_IN6_ADDR(sa))));
        -:  406:    } else {
    #####:  407:        return false;
        -:  408:    }
        -:  409:}
        -:  410:
        -:  411:#endif
