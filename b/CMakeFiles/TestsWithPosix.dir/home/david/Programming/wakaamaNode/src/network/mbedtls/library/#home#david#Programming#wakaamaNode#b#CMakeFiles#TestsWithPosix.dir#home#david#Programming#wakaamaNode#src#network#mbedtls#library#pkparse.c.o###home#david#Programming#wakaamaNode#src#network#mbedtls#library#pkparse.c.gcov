        -:    0:Source:/home/david/Programming/wakaamaNode/src/network/mbedtls/library/pkparse.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/network/mbedtls/library/pkparse.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*
        -:    2: *  Public Key layer for parsing key files and structures
        -:    3: *
        -:    4: *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
        -:    5: *  SPDX-License-Identifier: Apache-2.0
        -:    6: *
        -:    7: *  Licensed under the Apache License, Version 2.0 (the "License"); you may
        -:    8: *  not use this file except in compliance with the License.
        -:    9: *  You may obtain a copy of the License at
        -:   10: *
        -:   11: *  http://www.apache.org/licenses/LICENSE-2.0
        -:   12: *
        -:   13: *  Unless required by applicable law or agreed to in writing, software
        -:   14: *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
        -:   15: *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   16: *  See the License for the specific language governing permissions and
        -:   17: *  limitations under the License.
        -:   18: *
        -:   19: *  This file is part of mbed TLS (https://tls.mbed.org)
        -:   20: */
        -:   21:
        -:   22:#if !defined(MBEDTLS_CONFIG_FILE)
        -:   23:#include "mbedtls/config.h"
        -:   24:#else
        -:   25:#include MBEDTLS_CONFIG_FILE
        -:   26:#endif
        -:   27:
        -:   28:#if defined(MBEDTLS_PK_PARSE_C)
        -:   29:
        -:   30:#include "mbedtls/pk.h"
        -:   31:#include "mbedtls/asn1.h"
        -:   32:#include "mbedtls/oid.h"
        -:   33:#include "mbedtls/platform_util.h"
        -:   34:
        -:   35:#include <string.h>
        -:   36:
        -:   37:#if defined(MBEDTLS_RSA_C)
        -:   38:#include "mbedtls/rsa.h"
        -:   39:#endif
        -:   40:#if defined(MBEDTLS_ECP_C)
        -:   41:#include "mbedtls/ecp.h"
        -:   42:#endif
        -:   43:#if defined(MBEDTLS_ECDSA_C)
        -:   44:#include "mbedtls/ecdsa.h"
        -:   45:#endif
        -:   46:#if defined(MBEDTLS_PEM_PARSE_C)
        -:   47:#include "mbedtls/pem.h"
        -:   48:#endif
        -:   49:#if defined(MBEDTLS_PKCS5_C)
        -:   50:#include "mbedtls/pkcs5.h"
        -:   51:#endif
        -:   52:#if defined(MBEDTLS_PKCS12_C)
        -:   53:#include "mbedtls/pkcs12.h"
        -:   54:#endif
        -:   55:
        -:   56:#if defined(MBEDTLS_PLATFORM_C)
        -:   57:#include "mbedtls/platform.h"
        -:   58:#else
        -:   59:#include <stdlib.h>
        -:   60:#define mbedtls_calloc    calloc
        -:   61:#define mbedtls_free       free
        -:   62:#endif
        -:   63:
        -:   64:#if defined(MBEDTLS_FS_IO)
        -:   65:/*
        -:   66: * Load all data from a file into a given buffer.
        -:   67: *
        -:   68: * The file is expected to contain either PEM or DER encoded data.
        -:   69: * A terminating null byte is always appended. It is included in the announced
        -:   70: * length only if the data looks like it is PEM encoded.
        -:   71: */
        -:   72:int mbedtls_pk_load_file( const char *path, unsigned char **buf, size_t *n )
        -:   73:{
        -:   74:    FILE *f;
        -:   75:    long size;
        -:   76:
        -:   77:    if( ( f = fopen( path, "rb" ) ) == NULL )
        -:   78:        return( MBEDTLS_ERR_PK_FILE_IO_ERROR );
        -:   79:
        -:   80:    fseek( f, 0, SEEK_END );
        -:   81:    if( ( size = ftell( f ) ) == -1 )
        -:   82:    {
        -:   83:        fclose( f );
        -:   84:        return( MBEDTLS_ERR_PK_FILE_IO_ERROR );
        -:   85:    }
        -:   86:    fseek( f, 0, SEEK_SET );
        -:   87:
        -:   88:    *n = (size_t) size;
        -:   89:
        -:   90:    if( *n + 1 == 0 ||
        -:   91:        ( *buf = mbedtls_calloc( 1, *n + 1 ) ) == NULL )
        -:   92:    {
        -:   93:        fclose( f );
        -:   94:        return( MBEDTLS_ERR_PK_ALLOC_FAILED );
        -:   95:    }
        -:   96:
        -:   97:    if( fread( *buf, 1, *n, f ) != *n )
        -:   98:    {
        -:   99:        fclose( f );
        -:  100:
        -:  101:        mbedtls_platform_zeroize( *buf, *n );
        -:  102:        mbedtls_free( *buf );
        -:  103:
        -:  104:        return( MBEDTLS_ERR_PK_FILE_IO_ERROR );
        -:  105:    }
        -:  106:
        -:  107:    fclose( f );
        -:  108:
        -:  109:    (*buf)[*n] = '\0';
        -:  110:
        -:  111:    if( strstr( (const char *) *buf, "-----BEGIN " ) != NULL )
        -:  112:        ++*n;
        -:  113:
        -:  114:    return( 0 );
        -:  115:}
        -:  116:
        -:  117:/*
        -:  118: * Load and parse a private key
        -:  119: */
        -:  120:int mbedtls_pk_parse_keyfile( mbedtls_pk_context *ctx,
        -:  121:                      const char *path, const char *pwd )
        -:  122:{
        -:  123:    int ret;
        -:  124:    size_t n;
        -:  125:    unsigned char *buf;
        -:  126:
        -:  127:    if( ( ret = mbedtls_pk_load_file( path, &buf, &n ) ) != 0 )
        -:  128:        return( ret );
        -:  129:
        -:  130:    if( pwd == NULL )
        -:  131:        ret = mbedtls_pk_parse_key( ctx, buf, n, NULL, 0 );
        -:  132:    else
        -:  133:        ret = mbedtls_pk_parse_key( ctx, buf, n,
        -:  134:                (const unsigned char *) pwd, strlen( pwd ) );
        -:  135:
        -:  136:    mbedtls_platform_zeroize( buf, n );
        -:  137:    mbedtls_free( buf );
        -:  138:
        -:  139:    return( ret );
        -:  140:}
        -:  141:
        -:  142:/*
        -:  143: * Load and parse a public key
        -:  144: */
        -:  145:int mbedtls_pk_parse_public_keyfile( mbedtls_pk_context *ctx, const char *path )
        -:  146:{
        -:  147:    int ret;
        -:  148:    size_t n;
        -:  149:    unsigned char *buf;
        -:  150:
        -:  151:    if( ( ret = mbedtls_pk_load_file( path, &buf, &n ) ) != 0 )
        -:  152:        return( ret );
        -:  153:
        -:  154:    ret = mbedtls_pk_parse_public_key( ctx, buf, n );
        -:  155:
        -:  156:    mbedtls_platform_zeroize( buf, n );
        -:  157:    mbedtls_free( buf );
        -:  158:
        -:  159:    return( ret );
        -:  160:}
        -:  161:#endif /* MBEDTLS_FS_IO */
        -:  162:
        -:  163:#if defined(MBEDTLS_ECP_C)
        -:  164:/* Minimally parse an ECParameters buffer to and mbedtls_asn1_buf
        -:  165: *
        -:  166: * ECParameters ::= CHOICE {
        -:  167: *   namedCurve         OBJECT IDENTIFIER
        -:  168: *   specifiedCurve     SpecifiedECDomain -- = SEQUENCE { ... }
        -:  169: *   -- implicitCurve   NULL
        -:  170: * }
        -:  171: */
        -:  172:static int pk_get_ecparams( unsigned char **p, const unsigned char *end,
        -:  173:                            mbedtls_asn1_buf *params )
        -:  174:{
        -:  175:    int ret;
        -:  176:
        -:  177:    if ( end - *p < 1 )
        -:  178:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
        -:  179:                MBEDTLS_ERR_ASN1_OUT_OF_DATA );
        -:  180:
        -:  181:    /* Tag may be either OID or SEQUENCE */
        -:  182:    params->tag = **p;
        -:  183:    if( params->tag != MBEDTLS_ASN1_OID
        -:  184:#if defined(MBEDTLS_PK_PARSE_EC_EXTENDED)
        -:  185:            && params->tag != ( MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE )
        -:  186:#endif
        -:  187:            )
        -:  188:    {
        -:  189:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
        -:  190:                MBEDTLS_ERR_ASN1_UNEXPECTED_TAG );
        -:  191:    }
        -:  192:
        -:  193:    if( ( ret = mbedtls_asn1_get_tag( p, end, &params->len, params->tag ) ) != 0 )
        -:  194:    {
        -:  195:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  196:    }
        -:  197:
        -:  198:    params->p = *p;
        -:  199:    *p += params->len;
        -:  200:
        -:  201:    if( *p != end )
        -:  202:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
        -:  203:                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
        -:  204:
        -:  205:    return( 0 );
        -:  206:}
        -:  207:
        -:  208:#if defined(MBEDTLS_PK_PARSE_EC_EXTENDED)
        -:  209:/*
        -:  210: * Parse a SpecifiedECDomain (SEC 1 C.2) and (mostly) fill the group with it.
        -:  211: * WARNING: the resulting group should only be used with
        -:  212: * pk_group_id_from_specified(), since its base point may not be set correctly
        -:  213: * if it was encoded compressed.
        -:  214: *
        -:  215: *  SpecifiedECDomain ::= SEQUENCE {
        -:  216: *      version SpecifiedECDomainVersion(ecdpVer1 | ecdpVer2 | ecdpVer3, ...),
        -:  217: *      fieldID FieldID {{FieldTypes}},
        -:  218: *      curve Curve,
        -:  219: *      base ECPoint,
        -:  220: *      order INTEGER,
        -:  221: *      cofactor INTEGER OPTIONAL,
        -:  222: *      hash HashAlgorithm OPTIONAL,
        -:  223: *      ...
        -:  224: *  }
        -:  225: *
        -:  226: * We only support prime-field as field type, and ignore hash and cofactor.
        -:  227: */
        -:  228:static int pk_group_from_specified( const mbedtls_asn1_buf *params, mbedtls_ecp_group *grp )
        -:  229:{
        -:  230:    int ret;
        -:  231:    unsigned char *p = params->p;
        -:  232:    const unsigned char * const end = params->p + params->len;
        -:  233:    const unsigned char *end_field, *end_curve;
        -:  234:    size_t len;
        -:  235:    int ver;
        -:  236:
        -:  237:    /* SpecifiedECDomainVersion ::= INTEGER { 1, 2, 3 } */
        -:  238:    if( ( ret = mbedtls_asn1_get_int( &p, end, &ver ) ) != 0 )
        -:  239:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  240:
        -:  241:    if( ver < 1 || ver > 3 )
        -:  242:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
        -:  243:
        -:  244:    /*
        -:  245:     * FieldID { FIELD-ID:IOSet } ::= SEQUENCE { -- Finite field
        -:  246:     *       fieldType FIELD-ID.&id({IOSet}),
        -:  247:     *       parameters FIELD-ID.&Type({IOSet}{@fieldType})
        -:  248:     * }
        -:  249:     */
        -:  250:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
        -:  251:            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
        -:  252:        return( ret );
        -:  253:
        -:  254:    end_field = p + len;
        -:  255:
        -:  256:    /*
        -:  257:     * FIELD-ID ::= TYPE-IDENTIFIER
        -:  258:     * FieldTypes FIELD-ID ::= {
        -:  259:     *       { Prime-p IDENTIFIED BY prime-field } |
        -:  260:     *       { Characteristic-two IDENTIFIED BY characteristic-two-field }
        -:  261:     * }
        -:  262:     * prime-field OBJECT IDENTIFIER ::= { id-fieldType 1 }
        -:  263:     */
        -:  264:    if( ( ret = mbedtls_asn1_get_tag( &p, end_field, &len, MBEDTLS_ASN1_OID ) ) != 0 )
        -:  265:        return( ret );
        -:  266:
        -:  267:    if( len != MBEDTLS_OID_SIZE( MBEDTLS_OID_ANSI_X9_62_PRIME_FIELD ) ||
        -:  268:        memcmp( p, MBEDTLS_OID_ANSI_X9_62_PRIME_FIELD, len ) != 0 )
        -:  269:    {
        -:  270:        return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );
        -:  271:    }
        -:  272:
        -:  273:    p += len;
        -:  274:
        -:  275:    /* Prime-p ::= INTEGER -- Field of size p. */
        -:  276:    if( ( ret = mbedtls_asn1_get_mpi( &p, end_field, &grp->P ) ) != 0 )
        -:  277:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  278:
        -:  279:    grp->pbits = mbedtls_mpi_bitlen( &grp->P );
        -:  280:
        -:  281:    if( p != end_field )
        -:  282:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
        -:  283:                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
        -:  284:
        -:  285:    /*
        -:  286:     * Curve ::= SEQUENCE {
        -:  287:     *       a FieldElement,
        -:  288:     *       b FieldElement,
        -:  289:     *       seed BIT STRING OPTIONAL
        -:  290:     *       -- Shall be present if used in SpecifiedECDomain
        -:  291:     *       -- with version equal to ecdpVer2 or ecdpVer3
        -:  292:     * }
        -:  293:     */
        -:  294:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
        -:  295:            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
        -:  296:        return( ret );
        -:  297:
        -:  298:    end_curve = p + len;
        -:  299:
        -:  300:    /*
        -:  301:     * FieldElement ::= OCTET STRING
        -:  302:     * containing an integer in the case of a prime field
        -:  303:     */
        -:  304:    if( ( ret = mbedtls_asn1_get_tag( &p, end_curve, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 ||
        -:  305:        ( ret = mbedtls_mpi_read_binary( &grp->A, p, len ) ) != 0 )
        -:  306:    {
        -:  307:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  308:    }
        -:  309:
        -:  310:    p += len;
        -:  311:
        -:  312:    if( ( ret = mbedtls_asn1_get_tag( &p, end_curve, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 ||
        -:  313:        ( ret = mbedtls_mpi_read_binary( &grp->B, p, len ) ) != 0 )
        -:  314:    {
        -:  315:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  316:    }
        -:  317:
        -:  318:    p += len;
        -:  319:
        -:  320:    /* Ignore seed BIT STRING OPTIONAL */
        -:  321:    if( ( ret = mbedtls_asn1_get_tag( &p, end_curve, &len, MBEDTLS_ASN1_BIT_STRING ) ) == 0 )
        -:  322:        p += len;
        -:  323:
        -:  324:    if( p != end_curve )
        -:  325:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
        -:  326:                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
        -:  327:
        -:  328:    /*
        -:  329:     * ECPoint ::= OCTET STRING
        -:  330:     */
        -:  331:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
        -:  332:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  333:
        -:  334:    if( ( ret = mbedtls_ecp_point_read_binary( grp, &grp->G,
        -:  335:                                      ( const unsigned char *) p, len ) ) != 0 )
        -:  336:    {
        -:  337:        /*
        -:  338:         * If we can't read the point because it's compressed, cheat by
        -:  339:         * reading only the X coordinate and the parity bit of Y.
        -:  340:         */
        -:  341:        if( ret != MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE ||
        -:  342:            ( p[0] != 0x02 && p[0] != 0x03 ) ||
        -:  343:            len != mbedtls_mpi_size( &grp->P ) + 1 ||
        -:  344:            mbedtls_mpi_read_binary( &grp->G.X, p + 1, len - 1 ) != 0 ||
        -:  345:            mbedtls_mpi_lset( &grp->G.Y, p[0] - 2 ) != 0 ||
        -:  346:            mbedtls_mpi_lset( &grp->G.Z, 1 ) != 0 )
        -:  347:        {
        -:  348:            return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
        -:  349:        }
        -:  350:    }
        -:  351:
        -:  352:    p += len;
        -:  353:
        -:  354:    /*
        -:  355:     * order INTEGER
        -:  356:     */
        -:  357:    if( ( ret = mbedtls_asn1_get_mpi( &p, end, &grp->N ) ) != 0 )
        -:  358:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  359:
        -:  360:    grp->nbits = mbedtls_mpi_bitlen( &grp->N );
        -:  361:
        -:  362:    /*
        -:  363:     * Allow optional elements by purposefully not enforcing p == end here.
        -:  364:     */
        -:  365:
        -:  366:    return( 0 );
        -:  367:}
        -:  368:
        -:  369:/*
        -:  370: * Find the group id associated with an (almost filled) group as generated by
        -:  371: * pk_group_from_specified(), or return an error if unknown.
        -:  372: */
        -:  373:static int pk_group_id_from_group( const mbedtls_ecp_group *grp, mbedtls_ecp_group_id *grp_id )
        -:  374:{
        -:  375:    int ret = 0;
        -:  376:    mbedtls_ecp_group ref;
        -:  377:    const mbedtls_ecp_group_id *id;
        -:  378:
        -:  379:    mbedtls_ecp_group_init( &ref );
        -:  380:
        -:  381:    for( id = mbedtls_ecp_grp_id_list(); *id != MBEDTLS_ECP_DP_NONE; id++ )
        -:  382:    {
        -:  383:        /* Load the group associated to that id */
        -:  384:        mbedtls_ecp_group_free( &ref );
        -:  385:        MBEDTLS_MPI_CHK( mbedtls_ecp_group_load( &ref, *id ) );
        -:  386:
        -:  387:        /* Compare to the group we were given, starting with easy tests */
        -:  388:        if( grp->pbits == ref.pbits && grp->nbits == ref.nbits &&
        -:  389:            mbedtls_mpi_cmp_mpi( &grp->P, &ref.P ) == 0 &&
        -:  390:            mbedtls_mpi_cmp_mpi( &grp->A, &ref.A ) == 0 &&
        -:  391:            mbedtls_mpi_cmp_mpi( &grp->B, &ref.B ) == 0 &&
        -:  392:            mbedtls_mpi_cmp_mpi( &grp->N, &ref.N ) == 0 &&
        -:  393:            mbedtls_mpi_cmp_mpi( &grp->G.X, &ref.G.X ) == 0 &&
        -:  394:            mbedtls_mpi_cmp_mpi( &grp->G.Z, &ref.G.Z ) == 0 &&
        -:  395:            /* For Y we may only know the parity bit, so compare only that */
        -:  396:            mbedtls_mpi_get_bit( &grp->G.Y, 0 ) == mbedtls_mpi_get_bit( &ref.G.Y, 0 ) )
        -:  397:        {
        -:  398:            break;
        -:  399:        }
        -:  400:
        -:  401:    }
        -:  402:
        -:  403:cleanup:
        -:  404:    mbedtls_ecp_group_free( &ref );
        -:  405:
        -:  406:    *grp_id = *id;
        -:  407:
        -:  408:    if( ret == 0 && *id == MBEDTLS_ECP_DP_NONE )
        -:  409:        ret = MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE;
        -:  410:
        -:  411:    return( ret );
        -:  412:}
        -:  413:
        -:  414:/*
        -:  415: * Parse a SpecifiedECDomain (SEC 1 C.2) and find the associated group ID
        -:  416: */
        -:  417:static int pk_group_id_from_specified( const mbedtls_asn1_buf *params,
        -:  418:                                       mbedtls_ecp_group_id *grp_id )
        -:  419:{
        -:  420:    int ret;
        -:  421:    mbedtls_ecp_group grp;
        -:  422:
        -:  423:    mbedtls_ecp_group_init( &grp );
        -:  424:
        -:  425:    if( ( ret = pk_group_from_specified( params, &grp ) ) != 0 )
        -:  426:        goto cleanup;
        -:  427:
        -:  428:    ret = pk_group_id_from_group( &grp, grp_id );
        -:  429:
        -:  430:cleanup:
        -:  431:    mbedtls_ecp_group_free( &grp );
        -:  432:
        -:  433:    return( ret );
        -:  434:}
        -:  435:#endif /* MBEDTLS_PK_PARSE_EC_EXTENDED */
        -:  436:
        -:  437:/*
        -:  438: * Use EC parameters to initialise an EC group
        -:  439: *
        -:  440: * ECParameters ::= CHOICE {
        -:  441: *   namedCurve         OBJECT IDENTIFIER
        -:  442: *   specifiedCurve     SpecifiedECDomain -- = SEQUENCE { ... }
        -:  443: *   -- implicitCurve   NULL
        -:  444: */
        -:  445:static int pk_use_ecparams( const mbedtls_asn1_buf *params, mbedtls_ecp_group *grp )
        -:  446:{
        -:  447:    int ret;
        -:  448:    mbedtls_ecp_group_id grp_id;
        -:  449:
        -:  450:    if( params->tag == MBEDTLS_ASN1_OID )
        -:  451:    {
        -:  452:        if( mbedtls_oid_get_ec_grp( params, &grp_id ) != 0 )
        -:  453:            return( MBEDTLS_ERR_PK_UNKNOWN_NAMED_CURVE );
        -:  454:    }
        -:  455:    else
        -:  456:    {
        -:  457:#if defined(MBEDTLS_PK_PARSE_EC_EXTENDED)
        -:  458:        if( ( ret = pk_group_id_from_specified( params, &grp_id ) ) != 0 )
        -:  459:            return( ret );
        -:  460:#else
        -:  461:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
        -:  462:#endif
        -:  463:    }
        -:  464:
        -:  465:    /*
        -:  466:     * grp may already be initilialized; if so, make sure IDs match
        -:  467:     */
        -:  468:    if( grp->id != MBEDTLS_ECP_DP_NONE && grp->id != grp_id )
        -:  469:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
        -:  470:
        -:  471:    if( ( ret = mbedtls_ecp_group_load( grp, grp_id ) ) != 0 )
        -:  472:        return( ret );
        -:  473:
        -:  474:    return( 0 );
        -:  475:}
        -:  476:
        -:  477:/*
        -:  478: * EC public key is an EC point
        -:  479: *
        -:  480: * The caller is responsible for clearing the structure upon failure if
        -:  481: * desired. Take care to pass along the possible ECP_FEATURE_UNAVAILABLE
        -:  482: * return code of mbedtls_ecp_point_read_binary() and leave p in a usable state.
        -:  483: */
        -:  484:static int pk_get_ecpubkey( unsigned char **p, const unsigned char *end,
        -:  485:                            mbedtls_ecp_keypair *key )
        -:  486:{
        -:  487:    int ret;
        -:  488:
        -:  489:    if( ( ret = mbedtls_ecp_point_read_binary( &key->grp, &key->Q,
        -:  490:                    (const unsigned char *) *p, end - *p ) ) == 0 )
        -:  491:    {
        -:  492:        ret = mbedtls_ecp_check_pubkey( &key->grp, &key->Q );
        -:  493:    }
        -:  494:
        -:  495:    /*
        -:  496:     * We know mbedtls_ecp_point_read_binary consumed all bytes or failed
        -:  497:     */
        -:  498:    *p = (unsigned char *) end;
        -:  499:
        -:  500:    return( ret );
        -:  501:}
        -:  502:#endif /* MBEDTLS_ECP_C */
        -:  503:
        -:  504:#if defined(MBEDTLS_RSA_C)
        -:  505:/*
        -:  506: *  RSAPublicKey ::= SEQUENCE {
        -:  507: *      modulus           INTEGER,  -- n
        -:  508: *      publicExponent    INTEGER   -- e
        -:  509: *  }
        -:  510: */
    #####:  511:static int pk_get_rsapubkey( unsigned char **p,
        -:  512:                             const unsigned char *end,
        -:  513:                             mbedtls_rsa_context *rsa )
        -:  514:{
        -:  515:    int ret;
        -:  516:    size_t len;
        -:  517:
    #####:  518:    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
        -:  519:            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
    #####:  520:        return( MBEDTLS_ERR_PK_INVALID_PUBKEY + ret );
        -:  521:
    #####:  522:    if( *p + len != end )
    #####:  523:        return( MBEDTLS_ERR_PK_INVALID_PUBKEY +
        -:  524:                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
        -:  525:
        -:  526:    /* Import N */
    #####:  527:    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
    #####:  528:        return( MBEDTLS_ERR_PK_INVALID_PUBKEY + ret );
        -:  529:
    #####:  530:    if( ( ret = mbedtls_rsa_import_raw( rsa, *p, len, NULL, 0, NULL, 0,
        -:  531:                                        NULL, 0, NULL, 0 ) ) != 0 )
    #####:  532:        return( MBEDTLS_ERR_PK_INVALID_PUBKEY );
        -:  533:
    #####:  534:    *p += len;
        -:  535:
        -:  536:    /* Import E */
    #####:  537:    if( ( ret = mbedtls_asn1_get_tag( p, end, &len, MBEDTLS_ASN1_INTEGER ) ) != 0 )
    #####:  538:        return( MBEDTLS_ERR_PK_INVALID_PUBKEY + ret );
        -:  539:
    #####:  540:    if( ( ret = mbedtls_rsa_import_raw( rsa, NULL, 0, NULL, 0, NULL, 0,
        -:  541:                                        NULL, 0, *p, len ) ) != 0 )
    #####:  542:        return( MBEDTLS_ERR_PK_INVALID_PUBKEY );
        -:  543:
    #####:  544:    *p += len;
        -:  545:
    #####:  546:    if( mbedtls_rsa_complete( rsa ) != 0 ||
    #####:  547:        mbedtls_rsa_check_pubkey( rsa ) != 0 )
        -:  548:    {
    #####:  549:        return( MBEDTLS_ERR_PK_INVALID_PUBKEY );
        -:  550:    }
        -:  551:
    #####:  552:    if( *p != end )
    #####:  553:        return( MBEDTLS_ERR_PK_INVALID_PUBKEY +
        -:  554:                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
        -:  555:
    #####:  556:    return( 0 );
        -:  557:}
        -:  558:#endif /* MBEDTLS_RSA_C */
        -:  559:
        -:  560:/* Get a PK algorithm identifier
        -:  561: *
        -:  562: *  AlgorithmIdentifier  ::=  SEQUENCE  {
        -:  563: *       algorithm               OBJECT IDENTIFIER,
        -:  564: *       parameters              ANY DEFINED BY algorithm OPTIONAL  }
        -:  565: */
    #####:  566:static int pk_get_pk_alg( unsigned char **p,
        -:  567:                          const unsigned char *end,
        -:  568:                          mbedtls_pk_type_t *pk_alg, mbedtls_asn1_buf *params )
        -:  569:{
        -:  570:    int ret;
        -:  571:    mbedtls_asn1_buf alg_oid;
        -:  572:
    #####:  573:    memset( params, 0, sizeof(mbedtls_asn1_buf) );
        -:  574:
    #####:  575:    if( ( ret = mbedtls_asn1_get_alg( p, end, &alg_oid, params ) ) != 0 )
    #####:  576:        return( MBEDTLS_ERR_PK_INVALID_ALG + ret );
        -:  577:
    #####:  578:    if( mbedtls_oid_get_pk_alg( &alg_oid, pk_alg ) != 0 )
    #####:  579:        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
        -:  580:
        -:  581:    /*
        -:  582:     * No parameters with RSA (only for EC)
        -:  583:     */
    #####:  584:    if( *pk_alg == MBEDTLS_PK_RSA &&
    #####:  585:            ( ( params->tag != MBEDTLS_ASN1_NULL && params->tag != 0 ) ||
    #####:  586:                params->len != 0 ) )
        -:  587:    {
    #####:  588:        return( MBEDTLS_ERR_PK_INVALID_ALG );
        -:  589:    }
        -:  590:
    #####:  591:    return( 0 );
        -:  592:}
        -:  593:
        -:  594:/*
        -:  595: *  SubjectPublicKeyInfo  ::=  SEQUENCE  {
        -:  596: *       algorithm            AlgorithmIdentifier,
        -:  597: *       subjectPublicKey     BIT STRING }
        -:  598: */
    #####:  599:int mbedtls_pk_parse_subpubkey( unsigned char **p, const unsigned char *end,
        -:  600:                        mbedtls_pk_context *pk )
        -:  601:{
        -:  602:    int ret;
        -:  603:    size_t len;
        -:  604:    mbedtls_asn1_buf alg_params;
    #####:  605:    mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
        -:  606:    const mbedtls_pk_info_t *pk_info;
        -:  607:
    #####:  608:    if( ( ret = mbedtls_asn1_get_tag( p, end, &len,
        -:  609:                    MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
        -:  610:    {
    #####:  611:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  612:    }
        -:  613:
    #####:  614:    end = *p + len;
        -:  615:
    #####:  616:    if( ( ret = pk_get_pk_alg( p, end, &pk_alg, &alg_params ) ) != 0 )
    #####:  617:        return( ret );
        -:  618:
    #####:  619:    if( ( ret = mbedtls_asn1_get_bitstring_null( p, end, &len ) ) != 0 )
    #####:  620:        return( MBEDTLS_ERR_PK_INVALID_PUBKEY + ret );
        -:  621:
    #####:  622:    if( *p + len != end )
    #####:  623:        return( MBEDTLS_ERR_PK_INVALID_PUBKEY +
        -:  624:                MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
        -:  625:
    #####:  626:    if( ( pk_info = mbedtls_pk_info_from_type( pk_alg ) ) == NULL )
    #####:  627:        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
        -:  628:
    #####:  629:    if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 )
    #####:  630:        return( ret );
        -:  631:
        -:  632:#if defined(MBEDTLS_RSA_C)
    #####:  633:    if( pk_alg == MBEDTLS_PK_RSA )
        -:  634:    {
    #####:  635:        ret = pk_get_rsapubkey( p, end, mbedtls_pk_rsa( *pk ) );
        -:  636:    } else
        -:  637:#endif /* MBEDTLS_RSA_C */
        -:  638:#if defined(MBEDTLS_ECP_C)
        -:  639:    if( pk_alg == MBEDTLS_PK_ECKEY_DH || pk_alg == MBEDTLS_PK_ECKEY )
        -:  640:    {
        -:  641:        ret = pk_use_ecparams( &alg_params, &mbedtls_pk_ec( *pk )->grp );
        -:  642:        if( ret == 0 )
        -:  643:            ret = pk_get_ecpubkey( p, end, mbedtls_pk_ec( *pk ) );
        -:  644:    } else
        -:  645:#endif /* MBEDTLS_ECP_C */
    #####:  646:        ret = MBEDTLS_ERR_PK_UNKNOWN_PK_ALG;
        -:  647:
    #####:  648:    if( ret == 0 && *p != end )
    #####:  649:        ret = MBEDTLS_ERR_PK_INVALID_PUBKEY
        -:  650:              MBEDTLS_ERR_ASN1_LENGTH_MISMATCH;
        -:  651:
    #####:  652:    if( ret != 0 )
    #####:  653:        mbedtls_pk_free( pk );
        -:  654:
    #####:  655:    return( ret );
        -:  656:}
        -:  657:
        -:  658:#if defined(MBEDTLS_RSA_C)
        -:  659:/*
        -:  660: * Parse a PKCS#1 encoded private RSA key
        -:  661: */
    #####:  662:static int pk_parse_key_pkcs1_der( mbedtls_rsa_context *rsa,
        -:  663:                                   const unsigned char *key,
        -:  664:                                   size_t keylen )
        -:  665:{
        -:  666:    int ret, version;
        -:  667:    size_t len;
        -:  668:    unsigned char *p, *end;
        -:  669:
        -:  670:    mbedtls_mpi T;
    #####:  671:    mbedtls_mpi_init( &T );
        -:  672:
    #####:  673:    p = (unsigned char *) key;
    #####:  674:    end = p + keylen;
        -:  675:
        -:  676:    /*
        -:  677:     * This function parses the RSAPrivateKey (PKCS#1)
        -:  678:     *
        -:  679:     *  RSAPrivateKey ::= SEQUENCE {
        -:  680:     *      version           Version,
        -:  681:     *      modulus           INTEGER,  -- n
        -:  682:     *      publicExponent    INTEGER,  -- e
        -:  683:     *      privateExponent   INTEGER,  -- d
        -:  684:     *      prime1            INTEGER,  -- p
        -:  685:     *      prime2            INTEGER,  -- q
        -:  686:     *      exponent1         INTEGER,  -- d mod (p-1)
        -:  687:     *      exponent2         INTEGER,  -- d mod (q-1)
        -:  688:     *      coefficient       INTEGER,  -- (inverse of q) mod p
        -:  689:     *      otherPrimeInfos   OtherPrimeInfos OPTIONAL
        -:  690:     *  }
        -:  691:     */
    #####:  692:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
        -:  693:            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
        -:  694:    {
    #####:  695:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  696:    }
        -:  697:
    #####:  698:    end = p + len;
        -:  699:
    #####:  700:    if( ( ret = mbedtls_asn1_get_int( &p, end, &version ) ) != 0 )
        -:  701:    {
    #####:  702:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  703:    }
        -:  704:
    #####:  705:    if( version != 0 )
        -:  706:    {
    #####:  707:        return( MBEDTLS_ERR_PK_KEY_INVALID_VERSION );
        -:  708:    }
        -:  709:
        -:  710:    /* Import N */
    #####:  711:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    #####:  712:                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||
    #####:  713:        ( ret = mbedtls_rsa_import_raw( rsa, p, len, NULL, 0, NULL, 0,
        -:  714:                                        NULL, 0, NULL, 0 ) ) != 0 )
    #####:  715:        goto cleanup;
    #####:  716:    p += len;
        -:  717:
        -:  718:    /* Import E */
    #####:  719:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    #####:  720:                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||
    #####:  721:        ( ret = mbedtls_rsa_import_raw( rsa, NULL, 0, NULL, 0, NULL, 0,
        -:  722:                                        NULL, 0, p, len ) ) != 0 )
    #####:  723:        goto cleanup;
    #####:  724:    p += len;
        -:  725:
        -:  726:    /* Import D */
    #####:  727:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    #####:  728:                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||
    #####:  729:        ( ret = mbedtls_rsa_import_raw( rsa, NULL, 0, NULL, 0, NULL, 0,
        -:  730:                                        p, len, NULL, 0 ) ) != 0 )
    #####:  731:        goto cleanup;
    #####:  732:    p += len;
        -:  733:
        -:  734:    /* Import P */
    #####:  735:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    #####:  736:                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||
    #####:  737:        ( ret = mbedtls_rsa_import_raw( rsa, NULL, 0, p, len, NULL, 0,
        -:  738:                                        NULL, 0, NULL, 0 ) ) != 0 )
    #####:  739:        goto cleanup;
    #####:  740:    p += len;
        -:  741:
        -:  742:    /* Import Q */
    #####:  743:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
    #####:  744:                                      MBEDTLS_ASN1_INTEGER ) ) != 0 ||
    #####:  745:        ( ret = mbedtls_rsa_import_raw( rsa, NULL, 0, NULL, 0, p, len,
        -:  746:                                        NULL, 0, NULL, 0 ) ) != 0 )
    #####:  747:        goto cleanup;
    #####:  748:    p += len;
        -:  749:
        -:  750:    /* Complete the RSA private key */
    #####:  751:    if( ( ret = mbedtls_rsa_complete( rsa ) ) != 0 )
    #####:  752:        goto cleanup;
        -:  753:
        -:  754:    /* Check optional parameters */
    #####:  755:    if( ( ret = mbedtls_asn1_get_mpi( &p, end, &T ) ) != 0 ||
    #####:  756:        ( ret = mbedtls_asn1_get_mpi( &p, end, &T ) ) != 0 ||
    #####:  757:        ( ret = mbedtls_asn1_get_mpi( &p, end, &T ) ) != 0 )
    #####:  758:        goto cleanup;
        -:  759:
    #####:  760:    if( p != end )
        -:  761:    {
    #####:  762:        ret = MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
        -:  763:              MBEDTLS_ERR_ASN1_LENGTH_MISMATCH ;
        -:  764:    }
        -:  765:
    #####:  766:cleanup:
        -:  767:
    #####:  768:    mbedtls_mpi_free( &T );
        -:  769:
    #####:  770:    if( ret != 0 )
        -:  771:    {
        -:  772:        /* Wrap error code if it's coming from a lower level */
    #####:  773:        if( ( ret & 0xff80 ) == 0 )
    #####:  774:            ret = MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret;
        -:  775:        else
    #####:  776:            ret = MBEDTLS_ERR_PK_KEY_INVALID_FORMAT;
        -:  777:
    #####:  778:        mbedtls_rsa_free( rsa );
        -:  779:    }
        -:  780:
    #####:  781:    return( ret );
        -:  782:}
        -:  783:#endif /* MBEDTLS_RSA_C */
        -:  784:
        -:  785:#if defined(MBEDTLS_ECP_C)
        -:  786:/*
        -:  787: * Parse a SEC1 encoded private EC key
        -:  788: */
        -:  789:static int pk_parse_key_sec1_der( mbedtls_ecp_keypair *eck,
        -:  790:                                  const unsigned char *key,
        -:  791:                                  size_t keylen )
        -:  792:{
        -:  793:    int ret;
        -:  794:    int version, pubkey_done;
        -:  795:    size_t len;
        -:  796:    mbedtls_asn1_buf params;
        -:  797:    unsigned char *p = (unsigned char *) key;
        -:  798:    unsigned char *end = p + keylen;
        -:  799:    unsigned char *end2;
        -:  800:
        -:  801:    /*
        -:  802:     * RFC 5915, or SEC1 Appendix C.4
        -:  803:     *
        -:  804:     * ECPrivateKey ::= SEQUENCE {
        -:  805:     *      version        INTEGER { ecPrivkeyVer1(1) } (ecPrivkeyVer1),
        -:  806:     *      privateKey     OCTET STRING,
        -:  807:     *      parameters [0] ECParameters {{ NamedCurve }} OPTIONAL,
        -:  808:     *      publicKey  [1] BIT STRING OPTIONAL
        -:  809:     *    }
        -:  810:     */
        -:  811:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
        -:  812:            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
        -:  813:    {
        -:  814:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  815:    }
        -:  816:
        -:  817:    end = p + len;
        -:  818:
        -:  819:    if( ( ret = mbedtls_asn1_get_int( &p, end, &version ) ) != 0 )
        -:  820:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  821:
        -:  822:    if( version != 1 )
        -:  823:        return( MBEDTLS_ERR_PK_KEY_INVALID_VERSION );
        -:  824:
        -:  825:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
        -:  826:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  827:
        -:  828:    if( ( ret = mbedtls_mpi_read_binary( &eck->d, p, len ) ) != 0 )
        -:  829:    {
        -:  830:        mbedtls_ecp_keypair_free( eck );
        -:  831:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  832:    }
        -:  833:
        -:  834:    p += len;
        -:  835:
        -:  836:    pubkey_done = 0;
        -:  837:    if( p != end )
        -:  838:    {
        -:  839:        /*
        -:  840:         * Is 'parameters' present?
        -:  841:         */
        -:  842:        if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
        -:  843:                        MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 0 ) ) == 0 )
        -:  844:        {
        -:  845:            if( ( ret = pk_get_ecparams( &p, p + len, &params) ) != 0 ||
        -:  846:                ( ret = pk_use_ecparams( &params, &eck->grp )  ) != 0 )
        -:  847:            {
        -:  848:                mbedtls_ecp_keypair_free( eck );
        -:  849:                return( ret );
        -:  850:            }
        -:  851:        }
        -:  852:        else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
        -:  853:        {
        -:  854:            mbedtls_ecp_keypair_free( eck );
        -:  855:            return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  856:        }
        -:  857:    }
        -:  858:
        -:  859:    if( p != end )
        -:  860:    {
        -:  861:        /*
        -:  862:         * Is 'publickey' present? If not, or if we can't read it (eg because it
        -:  863:         * is compressed), create it from the private key.
        -:  864:         */
        -:  865:        if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
        -:  866:                        MBEDTLS_ASN1_CONTEXT_SPECIFIC | MBEDTLS_ASN1_CONSTRUCTED | 1 ) ) == 0 )
        -:  867:        {
        -:  868:            end2 = p + len;
        -:  869:
        -:  870:            if( ( ret = mbedtls_asn1_get_bitstring_null( &p, end2, &len ) ) != 0 )
        -:  871:                return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  872:
        -:  873:            if( p + len != end2 )
        -:  874:                return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
        -:  875:                        MBEDTLS_ERR_ASN1_LENGTH_MISMATCH );
        -:  876:
        -:  877:            if( ( ret = pk_get_ecpubkey( &p, end2, eck ) ) == 0 )
        -:  878:                pubkey_done = 1;
        -:  879:            else
        -:  880:            {
        -:  881:                /*
        -:  882:                 * The only acceptable failure mode of pk_get_ecpubkey() above
        -:  883:                 * is if the point format is not recognized.
        -:  884:                 */
        -:  885:                if( ret != MBEDTLS_ERR_ECP_FEATURE_UNAVAILABLE )
        -:  886:                    return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
        -:  887:            }
        -:  888:        }
        -:  889:        else if( ret != MBEDTLS_ERR_ASN1_UNEXPECTED_TAG )
        -:  890:        {
        -:  891:            mbedtls_ecp_keypair_free( eck );
        -:  892:            return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  893:        }
        -:  894:    }
        -:  895:
        -:  896:    if( ! pubkey_done &&
        -:  897:        ( ret = mbedtls_ecp_mul( &eck->grp, &eck->Q, &eck->d, &eck->grp.G,
        -:  898:                                                      NULL, NULL ) ) != 0 )
        -:  899:    {
        -:  900:        mbedtls_ecp_keypair_free( eck );
        -:  901:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  902:    }
        -:  903:
        -:  904:    if( ( ret = mbedtls_ecp_check_privkey( &eck->grp, &eck->d ) ) != 0 )
        -:  905:    {
        -:  906:        mbedtls_ecp_keypair_free( eck );
        -:  907:        return( ret );
        -:  908:    }
        -:  909:
        -:  910:    return( 0 );
        -:  911:}
        -:  912:#endif /* MBEDTLS_ECP_C */
        -:  913:
        -:  914:/*
        -:  915: * Parse an unencrypted PKCS#8 encoded private key
        -:  916: *
        -:  917: * Notes:
        -:  918: *
        -:  919: * - This function does not own the key buffer. It is the
        -:  920: *   responsibility of the caller to take care of zeroizing
        -:  921: *   and freeing it after use.
        -:  922: *
        -:  923: * - The function is responsible for freeing the provided
        -:  924: *   PK context on failure.
        -:  925: *
        -:  926: */
    #####:  927:static int pk_parse_key_pkcs8_unencrypted_der(
        -:  928:                                    mbedtls_pk_context *pk,
        -:  929:                                    const unsigned char* key,
        -:  930:                                    size_t keylen )
        -:  931:{
        -:  932:    int ret, version;
        -:  933:    size_t len;
        -:  934:    mbedtls_asn1_buf params;
    #####:  935:    unsigned char *p = (unsigned char *) key;
    #####:  936:    unsigned char *end = p + keylen;
    #####:  937:    mbedtls_pk_type_t pk_alg = MBEDTLS_PK_NONE;
        -:  938:    const mbedtls_pk_info_t *pk_info;
        -:  939:
        -:  940:    /*
        -:  941:     * This function parses the PrivateKeyInfo object (PKCS#8 v1.2 = RFC 5208)
        -:  942:     *
        -:  943:     *    PrivateKeyInfo ::= SEQUENCE {
        -:  944:     *      version                   Version,
        -:  945:     *      privateKeyAlgorithm       PrivateKeyAlgorithmIdentifier,
        -:  946:     *      privateKey                PrivateKey,
        -:  947:     *      attributes           [0]  IMPLICIT Attributes OPTIONAL }
        -:  948:     *
        -:  949:     *    Version ::= INTEGER
        -:  950:     *    PrivateKeyAlgorithmIdentifier ::= AlgorithmIdentifier
        -:  951:     *    PrivateKey ::= OCTET STRING
        -:  952:     *
        -:  953:     *  The PrivateKey OCTET STRING is a SEC1 ECPrivateKey
        -:  954:     */
        -:  955:
    #####:  956:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
        -:  957:            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
        -:  958:    {
    #####:  959:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  960:    }
        -:  961:
    #####:  962:    end = p + len;
        -:  963:
    #####:  964:    if( ( ret = mbedtls_asn1_get_int( &p, end, &version ) ) != 0 )
    #####:  965:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  966:
    #####:  967:    if( version != 0 )
    #####:  968:        return( MBEDTLS_ERR_PK_KEY_INVALID_VERSION + ret );
        -:  969:
    #####:  970:    if( ( ret = pk_get_pk_alg( &p, end, &pk_alg, &params ) ) != 0 )
    #####:  971:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  972:
    #####:  973:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
    #####:  974:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -:  975:
    #####:  976:    if( len < 1 )
    #####:  977:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT +
        -:  978:                MBEDTLS_ERR_ASN1_OUT_OF_DATA );
        -:  979:
    #####:  980:    if( ( pk_info = mbedtls_pk_info_from_type( pk_alg ) ) == NULL )
    #####:  981:        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
        -:  982:
    #####:  983:    if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 )
    #####:  984:        return( ret );
        -:  985:
        -:  986:#if defined(MBEDTLS_RSA_C)
    #####:  987:    if( pk_alg == MBEDTLS_PK_RSA )
        -:  988:    {
    #####:  989:        if( ( ret = pk_parse_key_pkcs1_der( mbedtls_pk_rsa( *pk ), p, len ) ) != 0 )
        -:  990:        {
    #####:  991:            mbedtls_pk_free( pk );
    #####:  992:            return( ret );
        -:  993:        }
        -:  994:    } else
        -:  995:#endif /* MBEDTLS_RSA_C */
        -:  996:#if defined(MBEDTLS_ECP_C)
        -:  997:    if( pk_alg == MBEDTLS_PK_ECKEY || pk_alg == MBEDTLS_PK_ECKEY_DH )
        -:  998:    {
        -:  999:        if( ( ret = pk_use_ecparams( &params, &mbedtls_pk_ec( *pk )->grp ) ) != 0 ||
        -: 1000:            ( ret = pk_parse_key_sec1_der( mbedtls_pk_ec( *pk ), p, len )  ) != 0 )
        -: 1001:        {
        -: 1002:            mbedtls_pk_free( pk );
        -: 1003:            return( ret );
        -: 1004:        }
        -: 1005:    } else
        -: 1006:#endif /* MBEDTLS_ECP_C */
    #####: 1007:        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
        -: 1008:
    #####: 1009:    return( 0 );
        -: 1010:}
        -: 1011:
        -: 1012:/*
        -: 1013: * Parse an encrypted PKCS#8 encoded private key
        -: 1014: *
        -: 1015: * To save space, the decryption happens in-place on the given key buffer.
        -: 1016: * Also, while this function may modify the keybuffer, it doesn't own it,
        -: 1017: * and instead it is the responsibility of the caller to zeroize and properly
        -: 1018: * free it after use.
        -: 1019: *
        -: 1020: */
        -: 1021:#if defined(MBEDTLS_PKCS12_C) || defined(MBEDTLS_PKCS5_C)
        -: 1022:static int pk_parse_key_pkcs8_encrypted_der(
        -: 1023:                                    mbedtls_pk_context *pk,
        -: 1024:                                    unsigned char *key, size_t keylen,
        -: 1025:                                    const unsigned char *pwd, size_t pwdlen )
        -: 1026:{
        -: 1027:    int ret, decrypted = 0;
        -: 1028:    size_t len;
        -: 1029:    unsigned char *buf;
        -: 1030:    unsigned char *p, *end;
        -: 1031:    mbedtls_asn1_buf pbe_alg_oid, pbe_params;
        -: 1032:#if defined(MBEDTLS_PKCS12_C)
        -: 1033:    mbedtls_cipher_type_t cipher_alg;
        -: 1034:    mbedtls_md_type_t md_alg;
        -: 1035:#endif
        -: 1036:
        -: 1037:    p = key;
        -: 1038:    end = p + keylen;
        -: 1039:
        -: 1040:    if( pwdlen == 0 )
        -: 1041:        return( MBEDTLS_ERR_PK_PASSWORD_REQUIRED );
        -: 1042:
        -: 1043:    /*
        -: 1044:     * This function parses the EncryptedPrivateKeyInfo object (PKCS#8)
        -: 1045:     *
        -: 1046:     *  EncryptedPrivateKeyInfo ::= SEQUENCE {
        -: 1047:     *    encryptionAlgorithm  EncryptionAlgorithmIdentifier,
        -: 1048:     *    encryptedData        EncryptedData
        -: 1049:     *  }
        -: 1050:     *
        -: 1051:     *  EncryptionAlgorithmIdentifier ::= AlgorithmIdentifier
        -: 1052:     *
        -: 1053:     *  EncryptedData ::= OCTET STRING
        -: 1054:     *
        -: 1055:     *  The EncryptedData OCTET STRING is a PKCS#8 PrivateKeyInfo
        -: 1056:     *
        -: 1057:     */
        -: 1058:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,
        -: 1059:            MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )
        -: 1060:    {
        -: 1061:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -: 1062:    }
        -: 1063:
        -: 1064:    end = p + len;
        -: 1065:
        -: 1066:    if( ( ret = mbedtls_asn1_get_alg( &p, end, &pbe_alg_oid, &pbe_params ) ) != 0 )
        -: 1067:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -: 1068:
        -: 1069:    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len, MBEDTLS_ASN1_OCTET_STRING ) ) != 0 )
        -: 1070:        return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT + ret );
        -: 1071:
        -: 1072:    buf = p;
        -: 1073:
        -: 1074:    /*
        -: 1075:     * Decrypt EncryptedData with appropriate PBE
        -: 1076:     */
        -: 1077:#if defined(MBEDTLS_PKCS12_C)
        -: 1078:    if( mbedtls_oid_get_pkcs12_pbe_alg( &pbe_alg_oid, &md_alg, &cipher_alg ) == 0 )
        -: 1079:    {
        -: 1080:        if( ( ret = mbedtls_pkcs12_pbe( &pbe_params, MBEDTLS_PKCS12_PBE_DECRYPT,
        -: 1081:                                cipher_alg, md_alg,
        -: 1082:                                pwd, pwdlen, p, len, buf ) ) != 0 )
        -: 1083:        {
        -: 1084:            if( ret == MBEDTLS_ERR_PKCS12_PASSWORD_MISMATCH )
        -: 1085:                return( MBEDTLS_ERR_PK_PASSWORD_MISMATCH );
        -: 1086:
        -: 1087:            return( ret );
        -: 1088:        }
        -: 1089:
        -: 1090:        decrypted = 1;
        -: 1091:    }
        -: 1092:    else if( MBEDTLS_OID_CMP( MBEDTLS_OID_PKCS12_PBE_SHA1_RC4_128, &pbe_alg_oid ) == 0 )
        -: 1093:    {
        -: 1094:        if( ( ret = mbedtls_pkcs12_pbe_sha1_rc4_128( &pbe_params,
        -: 1095:                                             MBEDTLS_PKCS12_PBE_DECRYPT,
        -: 1096:                                             pwd, pwdlen,
        -: 1097:                                             p, len, buf ) ) != 0 )
        -: 1098:        {
        -: 1099:            return( ret );
        -: 1100:        }
        -: 1101:
        -: 1102:        // Best guess for password mismatch when using RC4. If first tag is
        -: 1103:        // not MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE
        -: 1104:        //
        -: 1105:        if( *buf != ( MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) )
        -: 1106:            return( MBEDTLS_ERR_PK_PASSWORD_MISMATCH );
        -: 1107:
        -: 1108:        decrypted = 1;
        -: 1109:    }
        -: 1110:    else
        -: 1111:#endif /* MBEDTLS_PKCS12_C */
        -: 1112:#if defined(MBEDTLS_PKCS5_C)
        -: 1113:    if( MBEDTLS_OID_CMP( MBEDTLS_OID_PKCS5_PBES2, &pbe_alg_oid ) == 0 )
        -: 1114:    {
        -: 1115:        if( ( ret = mbedtls_pkcs5_pbes2( &pbe_params, MBEDTLS_PKCS5_DECRYPT, pwd, pwdlen,
        -: 1116:                                  p, len, buf ) ) != 0 )
        -: 1117:        {
        -: 1118:            if( ret == MBEDTLS_ERR_PKCS5_PASSWORD_MISMATCH )
        -: 1119:                return( MBEDTLS_ERR_PK_PASSWORD_MISMATCH );
        -: 1120:
        -: 1121:            return( ret );
        -: 1122:        }
        -: 1123:
        -: 1124:        decrypted = 1;
        -: 1125:    }
        -: 1126:    else
        -: 1127:#endif /* MBEDTLS_PKCS5_C */
        -: 1128:    {
        -: 1129:        ((void) pwd);
        -: 1130:    }
        -: 1131:
        -: 1132:    if( decrypted == 0 )
        -: 1133:        return( MBEDTLS_ERR_PK_FEATURE_UNAVAILABLE );
        -: 1134:
        -: 1135:    return( pk_parse_key_pkcs8_unencrypted_der( pk, buf, len ) );
        -: 1136:}
        -: 1137:#endif /* MBEDTLS_PKCS12_C || MBEDTLS_PKCS5_C */
        -: 1138:
        -: 1139:/*
        -: 1140: * Parse a private key
        -: 1141: */
    #####: 1142:int mbedtls_pk_parse_key( mbedtls_pk_context *pk,
        -: 1143:                  const unsigned char *key, size_t keylen,
        -: 1144:                  const unsigned char *pwd, size_t pwdlen )
        -: 1145:{
        -: 1146:    int ret;
        -: 1147:    const mbedtls_pk_info_t *pk_info;
        -: 1148:
        -: 1149:#if defined(MBEDTLS_PEM_PARSE_C)
        -: 1150:    size_t len;
        -: 1151:    mbedtls_pem_context pem;
        -: 1152:
        -: 1153:    mbedtls_pem_init( &pem );
        -: 1154:
        -: 1155:#if defined(MBEDTLS_RSA_C)
        -: 1156:    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */
        -: 1157:    if( keylen == 0 || key[keylen - 1] != '\0' )
        -: 1158:        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;
        -: 1159:    else
        -: 1160:        ret = mbedtls_pem_read_buffer( &pem,
        -: 1161:                               "-----BEGIN RSA PRIVATE KEY-----",
        -: 1162:                               "-----END RSA PRIVATE KEY-----",
        -: 1163:                               key, pwd, pwdlen, &len );
        -: 1164:
        -: 1165:    if( ret == 0 )
        -: 1166:    {
        -: 1167:        pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA );
        -: 1168:        if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 ||
        -: 1169:            ( ret = pk_parse_key_pkcs1_der( mbedtls_pk_rsa( *pk ),
        -: 1170:                                            pem.buf, pem.buflen ) ) != 0 )
        -: 1171:        {
        -: 1172:            mbedtls_pk_free( pk );
        -: 1173:        }
        -: 1174:
        -: 1175:        mbedtls_pem_free( &pem );
        -: 1176:        return( ret );
        -: 1177:    }
        -: 1178:    else if( ret == MBEDTLS_ERR_PEM_PASSWORD_MISMATCH )
        -: 1179:        return( MBEDTLS_ERR_PK_PASSWORD_MISMATCH );
        -: 1180:    else if( ret == MBEDTLS_ERR_PEM_PASSWORD_REQUIRED )
        -: 1181:        return( MBEDTLS_ERR_PK_PASSWORD_REQUIRED );
        -: 1182:    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
        -: 1183:        return( ret );
        -: 1184:#endif /* MBEDTLS_RSA_C */
        -: 1185:
        -: 1186:#if defined(MBEDTLS_ECP_C)
        -: 1187:    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */
        -: 1188:    if( keylen == 0 || key[keylen - 1] != '\0' )
        -: 1189:        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;
        -: 1190:    else
        -: 1191:        ret = mbedtls_pem_read_buffer( &pem,
        -: 1192:                               "-----BEGIN EC PRIVATE KEY-----",
        -: 1193:                               "-----END EC PRIVATE KEY-----",
        -: 1194:                               key, pwd, pwdlen, &len );
        -: 1195:    if( ret == 0 )
        -: 1196:    {
        -: 1197:        pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_ECKEY );
        -: 1198:
        -: 1199:        if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 ||
        -: 1200:            ( ret = pk_parse_key_sec1_der( mbedtls_pk_ec( *pk ),
        -: 1201:                                           pem.buf, pem.buflen ) ) != 0 )
        -: 1202:        {
        -: 1203:            mbedtls_pk_free( pk );
        -: 1204:        }
        -: 1205:
        -: 1206:        mbedtls_pem_free( &pem );
        -: 1207:        return( ret );
        -: 1208:    }
        -: 1209:    else if( ret == MBEDTLS_ERR_PEM_PASSWORD_MISMATCH )
        -: 1210:        return( MBEDTLS_ERR_PK_PASSWORD_MISMATCH );
        -: 1211:    else if( ret == MBEDTLS_ERR_PEM_PASSWORD_REQUIRED )
        -: 1212:        return( MBEDTLS_ERR_PK_PASSWORD_REQUIRED );
        -: 1213:    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
        -: 1214:        return( ret );
        -: 1215:#endif /* MBEDTLS_ECP_C */
        -: 1216:
        -: 1217:    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */
        -: 1218:    if( keylen == 0 || key[keylen - 1] != '\0' )
        -: 1219:        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;
        -: 1220:    else
        -: 1221:        ret = mbedtls_pem_read_buffer( &pem,
        -: 1222:                               "-----BEGIN PRIVATE KEY-----",
        -: 1223:                               "-----END PRIVATE KEY-----",
        -: 1224:                               key, NULL, 0, &len );
        -: 1225:    if( ret == 0 )
        -: 1226:    {
        -: 1227:        if( ( ret = pk_parse_key_pkcs8_unencrypted_der( pk,
        -: 1228:                                                pem.buf, pem.buflen ) ) != 0 )
        -: 1229:        {
        -: 1230:            mbedtls_pk_free( pk );
        -: 1231:        }
        -: 1232:
        -: 1233:        mbedtls_pem_free( &pem );
        -: 1234:        return( ret );
        -: 1235:    }
        -: 1236:    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
        -: 1237:        return( ret );
        -: 1238:
        -: 1239:#if defined(MBEDTLS_PKCS12_C) || defined(MBEDTLS_PKCS5_C)
        -: 1240:    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */
        -: 1241:    if( keylen == 0 || key[keylen - 1] != '\0' )
        -: 1242:        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;
        -: 1243:    else
        -: 1244:        ret = mbedtls_pem_read_buffer( &pem,
        -: 1245:                               "-----BEGIN ENCRYPTED PRIVATE KEY-----",
        -: 1246:                               "-----END ENCRYPTED PRIVATE KEY-----",
        -: 1247:                               key, NULL, 0, &len );
        -: 1248:    if( ret == 0 )
        -: 1249:    {
        -: 1250:        if( ( ret = pk_parse_key_pkcs8_encrypted_der( pk,
        -: 1251:                                                      pem.buf, pem.buflen,
        -: 1252:                                                      pwd, pwdlen ) ) != 0 )
        -: 1253:        {
        -: 1254:            mbedtls_pk_free( pk );
        -: 1255:        }
        -: 1256:
        -: 1257:        mbedtls_pem_free( &pem );
        -: 1258:        return( ret );
        -: 1259:    }
        -: 1260:    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
        -: 1261:        return( ret );
        -: 1262:#endif /* MBEDTLS_PKCS12_C || MBEDTLS_PKCS5_C */
        -: 1263:#else
        -: 1264:    ((void) ret);
        -: 1265:    ((void) pwd);
        -: 1266:    ((void) pwdlen);
        -: 1267:#endif /* MBEDTLS_PEM_PARSE_C */
        -: 1268:
        -: 1269:    /*
        -: 1270:     * At this point we only know it's not a PEM formatted key. Could be any
        -: 1271:     * of the known DER encoded private key formats
        -: 1272:     *
        -: 1273:     * We try the different DER format parsers to see if one passes without
        -: 1274:     * error
        -: 1275:     */
        -: 1276:#if defined(MBEDTLS_PKCS12_C) || defined(MBEDTLS_PKCS5_C)
        -: 1277:    {
        -: 1278:        unsigned char *key_copy;
        -: 1279:
        -: 1280:        if( keylen == 0 )
        -: 1281:            return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
        -: 1282:
        -: 1283:        if( ( key_copy = mbedtls_calloc( 1, keylen ) ) == NULL )
        -: 1284:            return( MBEDTLS_ERR_PK_ALLOC_FAILED );
        -: 1285:
        -: 1286:        memcpy( key_copy, key, keylen );
        -: 1287:
        -: 1288:        ret = pk_parse_key_pkcs8_encrypted_der( pk, key_copy, keylen,
        -: 1289:                                                pwd, pwdlen );
        -: 1290:
        -: 1291:        mbedtls_platform_zeroize( key_copy, keylen );
        -: 1292:        mbedtls_free( key_copy );
        -: 1293:    }
        -: 1294:
        -: 1295:    if( ret == 0 )
        -: 1296:        return( 0 );
        -: 1297:
        -: 1298:    mbedtls_pk_free( pk );
        -: 1299:
        -: 1300:    if( ret == MBEDTLS_ERR_PK_PASSWORD_MISMATCH )
        -: 1301:    {
        -: 1302:        return( ret );
        -: 1303:    }
        -: 1304:#endif /* MBEDTLS_PKCS12_C || MBEDTLS_PKCS5_C */
        -: 1305:
    #####: 1306:    if( ( ret = pk_parse_key_pkcs8_unencrypted_der( pk, key, keylen ) ) == 0 )
    #####: 1307:        return( 0 );
        -: 1308:
    #####: 1309:    mbedtls_pk_free( pk );
        -: 1310:
        -: 1311:#if defined(MBEDTLS_RSA_C)
        -: 1312:
    #####: 1313:    pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA );
    #####: 1314:    if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 ||
    #####: 1315:        ( ret = pk_parse_key_pkcs1_der( mbedtls_pk_rsa( *pk ),
        -: 1316:                                        key, keylen ) ) != 0 )
        -: 1317:    {
    #####: 1318:        mbedtls_pk_free( pk );
        -: 1319:    }
        -: 1320:    else
        -: 1321:    {
    #####: 1322:        return( 0 );
        -: 1323:    }
        -: 1324:
        -: 1325:#endif /* MBEDTLS_RSA_C */
        -: 1326:
        -: 1327:#if defined(MBEDTLS_ECP_C)
        -: 1328:
        -: 1329:    pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_ECKEY );
        -: 1330:    if( ( ret = mbedtls_pk_setup( pk, pk_info ) ) != 0 ||
        -: 1331:        ( ret = pk_parse_key_sec1_der( mbedtls_pk_ec( *pk ),
        -: 1332:                                       key, keylen ) ) != 0 )
        -: 1333:    {
        -: 1334:        mbedtls_pk_free( pk );
        -: 1335:    }
        -: 1336:    else
        -: 1337:    {
        -: 1338:        return( 0 );
        -: 1339:    }
        -: 1340:
        -: 1341:#endif /* MBEDTLS_ECP_C */
        -: 1342:
    #####: 1343:    return( MBEDTLS_ERR_PK_KEY_INVALID_FORMAT );
        -: 1344:}
        -: 1345:
        -: 1346:/*
        -: 1347: * Parse a public key
        -: 1348: */
    #####: 1349:int mbedtls_pk_parse_public_key( mbedtls_pk_context *ctx,
        -: 1350:                         const unsigned char *key, size_t keylen )
        -: 1351:{
        -: 1352:    int ret;
        -: 1353:    unsigned char *p;
        -: 1354:#if defined(MBEDTLS_RSA_C)
        -: 1355:    const mbedtls_pk_info_t *pk_info;
        -: 1356:#endif
        -: 1357:#if defined(MBEDTLS_PEM_PARSE_C)
        -: 1358:    size_t len;
        -: 1359:    mbedtls_pem_context pem;
        -: 1360:
        -: 1361:    mbedtls_pem_init( &pem );
        -: 1362:#if defined(MBEDTLS_RSA_C)
        -: 1363:    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */
        -: 1364:    if( keylen == 0 || key[keylen - 1] != '\0' )
        -: 1365:        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;
        -: 1366:    else
        -: 1367:        ret = mbedtls_pem_read_buffer( &pem,
        -: 1368:                               "-----BEGIN RSA PUBLIC KEY-----",
        -: 1369:                               "-----END RSA PUBLIC KEY-----",
        -: 1370:                               key, NULL, 0, &len );
        -: 1371:
        -: 1372:    if( ret == 0 )
        -: 1373:    {
        -: 1374:        p = pem.buf;
        -: 1375:        if( ( pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA ) ) == NULL )
        -: 1376:            return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
        -: 1377:
        -: 1378:        if( ( ret = mbedtls_pk_setup( ctx, pk_info ) ) != 0 )
        -: 1379:            return( ret );
        -: 1380:
        -: 1381:        if ( ( ret = pk_get_rsapubkey( &p, p + pem.buflen, mbedtls_pk_rsa( *ctx ) ) ) != 0 )
        -: 1382:            mbedtls_pk_free( ctx );
        -: 1383:
        -: 1384:        mbedtls_pem_free( &pem );
        -: 1385:        return( ret );
        -: 1386:    }
        -: 1387:    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
        -: 1388:    {
        -: 1389:        mbedtls_pem_free( &pem );
        -: 1390:        return( ret );
        -: 1391:    }
        -: 1392:#endif /* MBEDTLS_RSA_C */
        -: 1393:
        -: 1394:    /* Avoid calling mbedtls_pem_read_buffer() on non-null-terminated string */
        -: 1395:    if( keylen == 0 || key[keylen - 1] != '\0' )
        -: 1396:        ret = MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT;
        -: 1397:    else
        -: 1398:        ret = mbedtls_pem_read_buffer( &pem,
        -: 1399:                "-----BEGIN PUBLIC KEY-----",
        -: 1400:                "-----END PUBLIC KEY-----",
        -: 1401:                key, NULL, 0, &len );
        -: 1402:
        -: 1403:    if( ret == 0 )
        -: 1404:    {
        -: 1405:        /*
        -: 1406:         * Was PEM encoded
        -: 1407:         */
        -: 1408:        p = pem.buf;
        -: 1409:
        -: 1410:        ret = mbedtls_pk_parse_subpubkey( &p,  p + pem.buflen, ctx );
        -: 1411:        mbedtls_pem_free( &pem );
        -: 1412:        return( ret );
        -: 1413:    }
        -: 1414:    else if( ret != MBEDTLS_ERR_PEM_NO_HEADER_FOOTER_PRESENT )
        -: 1415:    {
        -: 1416:        mbedtls_pem_free( &pem );
        -: 1417:        return( ret );
        -: 1418:    }
        -: 1419:    mbedtls_pem_free( &pem );
        -: 1420:#endif /* MBEDTLS_PEM_PARSE_C */
        -: 1421:
        -: 1422:#if defined(MBEDTLS_RSA_C)
    #####: 1423:    if( ( pk_info = mbedtls_pk_info_from_type( MBEDTLS_PK_RSA ) ) == NULL )
    #####: 1424:        return( MBEDTLS_ERR_PK_UNKNOWN_PK_ALG );
        -: 1425:
    #####: 1426:    if( ( ret = mbedtls_pk_setup( ctx, pk_info ) ) != 0 )
    #####: 1427:        return( ret );
        -: 1428:
    #####: 1429:    p = (unsigned char *)key;
    #####: 1430:    ret = pk_get_rsapubkey( &p, p + keylen, mbedtls_pk_rsa( *ctx ) );
    #####: 1431:    if( ret == 0 )
        -: 1432:    {
    #####: 1433:        return( ret );
        -: 1434:    }
    #####: 1435:    mbedtls_pk_free( ctx );
    #####: 1436:    if( ret != ( MBEDTLS_ERR_PK_INVALID_PUBKEY + MBEDTLS_ERR_ASN1_UNEXPECTED_TAG ) )
        -: 1437:    {
    #####: 1438:        return( ret );
        -: 1439:    }
        -: 1440:#endif /* MBEDTLS_RSA_C */
    #####: 1441:    p = (unsigned char *) key;
        -: 1442:
    #####: 1443:    ret = mbedtls_pk_parse_subpubkey( &p, p + keylen, ctx );
        -: 1444:
    #####: 1445:    return( ret );
        -: 1446:}
        -: 1447:
        -: 1448:#endif /* MBEDTLS_PK_PARSE_C */
