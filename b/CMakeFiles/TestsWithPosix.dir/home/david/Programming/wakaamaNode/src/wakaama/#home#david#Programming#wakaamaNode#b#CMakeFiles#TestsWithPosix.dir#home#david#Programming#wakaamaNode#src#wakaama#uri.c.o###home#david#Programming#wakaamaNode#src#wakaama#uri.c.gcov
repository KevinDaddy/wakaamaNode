        -:    0:Source:/home/david/Programming/wakaamaNode/src/wakaama/uri.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/wakaama/uri.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*******************************************************************************
        -:    2: *
        -:    3: * Copyright (c) 2013, 2014 Intel Corporation and others.
        -:    4: * All rights reserved. This program and the accompanying materials
        -:    5: * are made available under the terms of the Eclipse Public License v1.0
        -:    6: * and Eclipse Distribution License v1.0 which accompany this distribution.
        -:    7: *
        -:    8: * The Eclipse Public License is available at
        -:    9: *    http://www.eclipse.org/legal/epl-v10.html
        -:   10: * The Eclipse Distribution License is available at
        -:   11: *    http://www.eclipse.org/org/documents/edl-v10.php.
        -:   12: *
        -:   13: * Contributors:
        -:   14: *    David Navarro, Intel Corporation - initial API and implementation
        -:   15: *    Fabien Fleutot - Please refer to git log
        -:   16: *    Toby Jaffey - Please refer to git log
        -:   17: *    Bosch Software Innovations GmbH - Please refer to git log
        -:   18: *    Pascal Rieux - Please refer to git log
        -:   19: *    
        -:   20: *******************************************************************************/
        -:   21:
        -:   22:/*
        -:   23: Copyright (c) 2013, 2014 Intel Corporation
        -:   24:
        -:   25: Redistribution and use in source and binary forms, with or without modification,
        -:   26: are permitted provided that the following conditions are met:
        -:   27:
        -:   28:     * Redistributions of source code must retain the above copyright notice,
        -:   29:       this list of conditions and the following disclaimer.
        -:   30:     * Redistributions in binary form must reproduce the above copyright notice,
        -:   31:       this list of conditions and the following disclaimer in the documentation
        -:   32:       and/or other materials provided with the distribution.
        -:   33:     * Neither the name of Intel Corporation nor the names of its contributors
        -:   34:       may be used to endorse or promote products derived from this software
        -:   35:       without specific prior written permission.
        -:   36:
        -:   37: THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   38: ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   39: WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
        -:   40: IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
        -:   41: INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
        -:   42: BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   43: DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
        -:   44: LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
        -:   45: OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
        -:   46: THE POSSIBILITY OF SUCH DAMAGE.
        -:   47:
        -:   48: David Navarro <david.navarro@intel.com>
        -:   49:
        -:   50:*/
        -:   51:
        -:   52:#include "internals.h"
        -:   53:#include <stdlib.h>
        -:   54:#include <string.h>
        -:   55:#include <ctype.h>
        -:   56:
    #####:   57:static int prv_parseNumber(uint8_t * uriString,
        -:   58:                            size_t uriLength,
        -:   59:                            size_t * headP)
        -:   60:{
    #####:   61:    int result = 0;
        -:   62:
    #####:   63:    if (uriString[*headP] == '/')
        -:   64:    {
        -:   65:        // empty Object Instance ID with resource ID is not allowed
    #####:   66:        return -1;
        -:   67:    }
    #####:   68:    while (*headP < uriLength && uriString[*headP] != '/')
        -:   69:    {
    #####:   70:        if ('0' <= uriString[*headP] && uriString[*headP] <= '9')
        -:   71:        {
    #####:   72:            result += uriString[*headP] - '0';
    #####:   73:            result *= 10;
        -:   74:        }
        -:   75:        else
        -:   76:        {
    #####:   77:            return -1;
        -:   78:        }
    #####:   79:        *headP += 1;
        -:   80:    }
        -:   81:
    #####:   82:    result /= 10;
    #####:   83:    return result;
        -:   84:}
        -:   85:
        -:   86:
    #####:   87:int uri_getNumber(uint8_t * uriString,
        -:   88:                   size_t uriLength)
        -:   89:{
    #####:   90:    size_t index = 0;
        -:   91:
    #####:   92:    return prv_parseNumber(uriString, uriLength, &index);
        -:   93:}
        -:   94:
        -:   95:
    #####:   96:lwm2m_uri_t * uri_decode(char * altPath,
        -:   97:                         multi_option_t *uriPath)
        -:   98:{
        -:   99:    lwm2m_uri_t * uriP;
        -:  100:    int readNum;
        -:  101:
        -:  102:    LOG_ARG("altPath: \"%s\"", altPath);
        -:  103:
    #####:  104:    uriP = (lwm2m_uri_t *)lwm2m_malloc(sizeof(lwm2m_uri_t));
    #####:  105:    if (NULL == uriP) return NULL;
        -:  106:
    #####:  107:    memset(uriP, 0, sizeof(lwm2m_uri_t));
        -:  108:
        -:  109:    // Read object ID
    #####:  110:    if (NULL != uriPath
    #####:  111:     && URI_REGISTRATION_SEGMENT_LEN == uriPath->len
    #####:  112:     && 0 == strncmp(URI_REGISTRATION_SEGMENT, (char *)uriPath->data, uriPath->len))
        -:  113:    {
    #####:  114:        uriP->flag |= LWM2M_URI_FLAG_REGISTRATION;
    #####:  115:        uriPath = uriPath->next;
    #####:  116:        if (uriPath == NULL) return uriP;
        -:  117:    }
    #####:  118:    else if (NULL != uriPath
    #####:  119:     && URI_BOOTSTRAP_SEGMENT_LEN == uriPath->len
    #####:  120:     && 0 == strncmp(URI_BOOTSTRAP_SEGMENT, (char *)uriPath->data, uriPath->len))
        -:  121:    {
    #####:  122:        uriP->flag |= LWM2M_URI_FLAG_BOOTSTRAP;
    #####:  123:        uriPath = uriPath->next;
    #####:  124:        if (uriPath != NULL) goto error;
    #####:  125:        return uriP;
        -:  126:    }
        -:  127:
    #####:  128:    if ((uriP->flag & LWM2M_URI_MASK_TYPE) != LWM2M_URI_FLAG_REGISTRATION)
        -:  129:    {
        -:  130:        // Read altPath if any
    #####:  131:        if (altPath != NULL)
        -:  132:        {
        -:  133:            int i;
    #####:  134:            if (NULL == uriPath)
        -:  135:            {
    #####:  136:                lwm2m_free(uriP);
    #####:  137:                return NULL;
        -:  138:            }
    #####:  139:            for (i = 0 ; i < uriPath->len ; i++)
        -:  140:            {
    #####:  141:                if (uriPath->data[i] != altPath[i+1])
        -:  142:                {
    #####:  143:                    lwm2m_free(uriP);
    #####:  144:                    return NULL;
        -:  145:                }
        -:  146:            }
    #####:  147:            uriPath = uriPath->next;
        -:  148:        }
    #####:  149:        if (NULL == uriPath || uriPath->len == 0)
        -:  150:        {
    #####:  151:            uriP->flag |= LWM2M_URI_FLAG_DELETE_ALL;
    #####:  152:            return uriP;
        -:  153:        }
        -:  154:    }
        -:  155:
    #####:  156:    readNum = uri_getNumber(uriPath->data, uriPath->len);
    #####:  157:    if (readNum < 0 || readNum > LWM2M_MAX_ID) goto error;
    #####:  158:    uriP->objectId = (uint16_t)readNum;
    #####:  159:    uriP->flag |= LWM2M_URI_FLAG_OBJECT_ID;
    #####:  160:    uriPath = uriPath->next;
        -:  161:
    #####:  162:    if ((uriP->flag & LWM2M_URI_MASK_TYPE) == LWM2M_URI_FLAG_REGISTRATION)
        -:  163:    {
    #####:  164:        if (uriPath != NULL) goto error;
    #####:  165:        return uriP;
        -:  166:    }
    #####:  167:    uriP->flag |= LWM2M_URI_FLAG_DM;
        -:  168:
    #####:  169:    if (uriPath == NULL) return uriP;
        -:  170:
        -:  171:    // Read object instance
    #####:  172:    if (uriPath->len != 0)
        -:  173:    {
    #####:  174:        readNum = uri_getNumber(uriPath->data, uriPath->len);
    #####:  175:        if (readNum < 0 || readNum >= LWM2M_MAX_ID) goto error;
    #####:  176:        uriP->instanceId = (uint16_t)readNum;
    #####:  177:        uriP->flag |= LWM2M_URI_FLAG_INSTANCE_ID;
        -:  178:    }
    #####:  179:    uriPath = uriPath->next;
        -:  180:
    #####:  181:    if (uriPath == NULL) return uriP;
        -:  182:
        -:  183:    // Read resource ID
    #####:  184:    if (uriPath->len != 0)
        -:  185:    {
        -:  186:        // resource ID without an instance ID is not allowed
    #####:  187:        if ((uriP->flag & LWM2M_URI_FLAG_INSTANCE_ID) == 0) goto error;
        -:  188:
    #####:  189:        readNum = uri_getNumber(uriPath->data, uriPath->len);
    #####:  190:        if (readNum < 0 || readNum > LWM2M_MAX_ID) goto error;
    #####:  191:        uriP->resourceId = (uint16_t)readNum;
    #####:  192:        uriP->flag |= LWM2M_URI_FLAG_RESOURCE_ID;
        -:  193:    }
        -:  194:
        -:  195:    // must be the last segment
    #####:  196:    if (NULL == uriPath->next)
        -:  197:    {
        -:  198:        LOG_URI(uriP);
    #####:  199:        return uriP;
        -:  200:    }
        -:  201:
    #####:  202:error:
        -:  203:    LOG("Exiting on error");
    #####:  204:    lwm2m_free(uriP);
    #####:  205:    return NULL;
        -:  206:}
        -:  207:
    #####:  208:int lwm2m_stringToUri(const char * buffer,
        -:  209:                      size_t buffer_len,
        -:  210:                      lwm2m_uri_t * uriP)
        -:  211:{
        -:  212:    size_t head;
        -:  213:    int readNum;
        -:  214:
        -:  215:    LOG_ARG("buffer_len: %u, buffer: \"%.*s\"", buffer_len, buffer_len, buffer);
        -:  216:
    #####:  217:    if (buffer == NULL || buffer_len == 0 || uriP == NULL) return 0;
        -:  218:
    #####:  219:    memset(uriP, 0, sizeof(lwm2m_uri_t));
        -:  220:
        -:  221:    // Skip any white space
    #####:  222:    head = 0;
    #####:  223:    while (head < buffer_len && isspace(buffer[head]&0xFF))
        -:  224:    {
    #####:  225:        head++;
        -:  226:    }
    #####:  227:    if (head == buffer_len) return 0;
        -:  228:
        -:  229:    // Check the URI start with a '/'
    #####:  230:    if (buffer[head] != '/') return 0;
    #####:  231:    head++;
    #####:  232:    if (head == buffer_len) return 0;
        -:  233:
        -:  234:    // Read object ID
    #####:  235:    readNum = prv_parseNumber((uint8_t *)buffer, buffer_len, &head);
    #####:  236:    if (readNum < 0 || readNum > LWM2M_MAX_ID) return 0;
    #####:  237:    uriP->objectId = (uint16_t)readNum;
    #####:  238:    uriP->flag |= LWM2M_URI_FLAG_OBJECT_ID;
        -:  239:
    #####:  240:    if (buffer[head] == '/') head += 1;
    #####:  241:    if (head >= buffer_len)
        -:  242:    {
        -:  243:        LOG_ARG("Parsed characters: %u", head);
        -:  244:        LOG_URI(uriP);
    #####:  245:        return head;
        -:  246:    }
        -:  247:
    #####:  248:    readNum = prv_parseNumber((uint8_t *)buffer, buffer_len, &head);
    #####:  249:    if (readNum < 0 || readNum >= LWM2M_MAX_ID) return 0;
    #####:  250:    uriP->instanceId = (uint16_t)readNum;
    #####:  251:    uriP->flag |= LWM2M_URI_FLAG_INSTANCE_ID;
        -:  252:
    #####:  253:    if (buffer[head] == '/') head += 1;
    #####:  254:    if (head >= buffer_len)
        -:  255:    {
        -:  256:        LOG_ARG("Parsed characters: %u", head);
        -:  257:        LOG_URI(uriP);
    #####:  258:        return head;
        -:  259:    }
        -:  260:
    #####:  261:    readNum = prv_parseNumber((uint8_t *)buffer, buffer_len, &head);
    #####:  262:    if (readNum < 0 || readNum >= LWM2M_MAX_ID) return 0;
    #####:  263:    uriP->resourceId = (uint16_t)readNum;
    #####:  264:    uriP->flag |= LWM2M_URI_FLAG_RESOURCE_ID;
        -:  265:
    #####:  266:    if (head != buffer_len) return 0;
        -:  267:
        -:  268:    LOG_ARG("Parsed characters: %u", head);
        -:  269:    LOG_URI(uriP);
        -:  270:
    #####:  271:    return head;
        -:  272:}
        -:  273:
    #####:  274:int uri_toString(lwm2m_uri_t * uriP,
        -:  275:                 uint8_t * buffer,
        -:  276:                 size_t bufferLen,
        -:  277:                 uri_depth_t * depthP)
        -:  278:{
        -:  279:    size_t head;
        -:  280:    int res;
        -:  281:
        -:  282:    LOG_ARG("bufferLen: %u", bufferLen);
        -:  283:    LOG_URI(uriP);
        -:  284:
    #####:  285:    buffer[0] = '/';
        -:  286:
    #####:  287:    if (uriP == NULL)
        -:  288:    {
    #####:  289:        if (depthP) *depthP = URI_DEPTH_OBJECT;
    #####:  290:        return 1;
        -:  291:    }
        -:  292:
    #####:  293:    head = 1;
        -:  294:
    #####:  295:    res = utils_intToText(uriP->objectId, buffer + head, bufferLen - head);
    #####:  296:    if (res <= 0) return -1;
    #####:  297:    head += res;
    #####:  298:    if (head >= bufferLen - 1) return -1;
    #####:  299:    if (depthP) *depthP = URI_DEPTH_OBJECT_INSTANCE;
        -:  300:
    #####:  301:    if (LWM2M_URI_IS_SET_INSTANCE(uriP))
        -:  302:    {
    #####:  303:        buffer[head] = '/';
    #####:  304:        head++;
    #####:  305:        res = utils_intToText(uriP->instanceId, buffer + head, bufferLen - head);
    #####:  306:        if (res <= 0) return -1;
    #####:  307:        head += res;
    #####:  308:        if (head >= bufferLen - 1) return -1;
    #####:  309:        if (depthP) *depthP = URI_DEPTH_RESOURCE;
    #####:  310:        if (LWM2M_URI_IS_SET_RESOURCE(uriP))
        -:  311:        {
    #####:  312:            buffer[head] = '/';
    #####:  313:            head++;
    #####:  314:            res = utils_intToText(uriP->resourceId, buffer + head, bufferLen - head);
    #####:  315:            if (res <= 0) return -1;
    #####:  316:            head += res;
    #####:  317:            if (head >= bufferLen - 1) return -1;
    #####:  318:            if (depthP) *depthP = URI_DEPTH_RESOURCE_INSTANCE;
        -:  319:        }
        -:  320:    }
        -:  321:
    #####:  322:    buffer[head] = '/';
    #####:  323:    head++;
        -:  324:
        -:  325:    LOG_ARG("length: %u, buffer: \"%.*s\"", head, head, buffer);
        -:  326:
    #####:  327:    return head;
        -:  328:}
