        -:    0:Source:/home/david/Programming/wakaamaNode/src/wakaama/liblwm2m.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/wakaama/liblwm2m.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*******************************************************************************
        -:    2: *
        -:    3: * Copyright (c) 2013, 2014 Intel Corporation and others.
        -:    4: * All rights reserved. This program and the accompanying materials
        -:    5: * are made available under the terms of the Eclipse Public License v1.0
        -:    6: * and Eclipse Distribution License v1.0 which accompany this distribution.
        -:    7: *
        -:    8: * The Eclipse Public License is available at
        -:    9: *    http://www.eclipse.org/legal/epl-v10.html
        -:   10: * The Eclipse Distribution License is available at
        -:   11: *    http://www.eclipse.org/org/documents/edl-v10.php.
        -:   12: *
        -:   13: * Contributors:
        -:   14: *    David Navarro, Intel Corporation - initial API and implementation
        -:   15: *    Fabien Fleutot - Please refer to git log
        -:   16: *    Simon Bernard - Please refer to git log
        -:   17: *    Toby Jaffey - Please refer to git log
        -:   18: *    Pascal Rieux - Please refer to git log
        -:   19: *    
        -:   20: *******************************************************************************/
        -:   21:
        -:   22:/*
        -:   23: Copyright (c) 2013, 2014 Intel Corporation
        -:   24:
        -:   25: Redistribution and use in source and binary forms, with or without modification,
        -:   26: are permitted provided that the following conditions are met:
        -:   27:
        -:   28:     * Redistributions of source code must retain the above copyright notice,
        -:   29:       this list of conditions and the following disclaimer.
        -:   30:     * Redistributions in binary form must reproduce the above copyright notice,
        -:   31:       this list of conditions and the following disclaimer in the documentation
        -:   32:       and/or other materials provided with the distribution.
        -:   33:     * Neither the name of Intel Corporation nor the names of its contributors
        -:   34:       may be used to endorse or promote products derived from this software
        -:   35:       without specific prior written permission.
        -:   36:
        -:   37: THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   38: ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   39: WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
        -:   40: IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
        -:   41: INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
        -:   42: BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   43: DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
        -:   44: LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
        -:   45: OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
        -:   46: THE POSSIBILITY OF SUCH DAMAGE.
        -:   47:
        -:   48: David Navarro <david.navarro@intel.com>
        -:   49:
        -:   50:*/
        -:   51:
        -:   52:#include "internals.h"
        -:   53:
        -:   54:#include <stdlib.h>
        -:   55:#include <string.h>
        -:   56:
        -:   57:#include <stdio.h>
        -:   58:
        -:   59:
    #####:   60:lwm2m_context_t * lwm2m_init(void * userData)
        -:   61:{
        -:   62:    lwm2m_context_t * contextP;
        -:   63:
        -:   64:    LOG("Entering");
    #####:   65:    contextP = (lwm2m_context_t *)lwm2m_malloc(sizeof(lwm2m_context_t));
    #####:   66:    if (NULL != contextP)
        -:   67:    {
    #####:   68:        memset(contextP, 0, sizeof(lwm2m_context_t));
    #####:   69:        contextP->userData = userData;
    #####:   70:        srand((int)lwm2m_gettime());
    #####:   71:        contextP->nextMID = rand();
        -:   72:    }
        -:   73:
    #####:   74:    return contextP;
        -:   75:}
        -:   76:
        -:   77:#ifdef LWM2M_CLIENT_MODE
    #####:   78:void lwm2m_deregister(lwm2m_context_t * context)
        -:   79:{
    #####:   80:    lwm2m_server_t * server = context->serverList;
        -:   81:
        -:   82:    LOG("Entering");
    #####:   83:    while (NULL != server)
        -:   84:    {
    #####:   85:        registration_deregister(context, server);
    #####:   86:        server = server->next;
        -:   87:    }
    #####:   88:}
        -:   89:
    #####:   90:static void prv_deleteServer(lwm2m_server_t * serverP, void *userData)
        -:   91:{
        -:   92:    // TODO parse transaction and observation to remove the ones related to this server
    #####:   93:    if (serverP->sessionH != NULL)
        -:   94:    {
    #####:   95:         lwm2m_close_connection(serverP->sessionH, userData);
        -:   96:    }
    #####:   97:    if (NULL != serverP->location)
        -:   98:    {
    #####:   99:        lwm2m_free(serverP->location);
        -:  100:    }
    #####:  101:    free_block1_buffer(serverP->block1Data);
    #####:  102:    lwm2m_free(serverP);
    #####:  103:}
        -:  104:
    #####:  105:static void prv_deleteServerList(lwm2m_context_t * context)
        -:  106:{
    #####:  107:    while (NULL != context->serverList)
        -:  108:    {
        -:  109:        lwm2m_server_t * server;
    #####:  110:        server = context->serverList;
    #####:  111:        context->serverList = server->next;
    #####:  112:        prv_deleteServer(server, context->userData);
        -:  113:    }
    #####:  114:}
        -:  115:
    #####:  116:static void prv_deleteBootstrapServer(lwm2m_server_t * serverP, void *userData)
        -:  117:{
        -:  118:    // TODO should we free location as in prv_deleteServer ?
        -:  119:    // TODO should we parse transaction and observation to remove the ones related to this server ?
    #####:  120:    if (serverP->sessionH != NULL)
        -:  121:    {
    #####:  122:         lwm2m_close_connection(serverP->sessionH, userData);
        -:  123:    }
    #####:  124:    free_block1_buffer(serverP->block1Data);
    #####:  125:    lwm2m_free(serverP);
    #####:  126:}
        -:  127:
    #####:  128:static void prv_deleteBootstrapServerList(lwm2m_context_t * context)
        -:  129:{
    #####:  130:    while (NULL != context->bootstrapServerList)
        -:  131:    {
        -:  132:        lwm2m_server_t * server;
    #####:  133:        server = context->bootstrapServerList;
    #####:  134:        context->bootstrapServerList = server->next;
    #####:  135:        prv_deleteBootstrapServer(server, context->userData);
        -:  136:    }
    #####:  137:}
        -:  138:
    #####:  139:static void prv_deleteObservedList(lwm2m_context_t * contextP)
        -:  140:{
    #####:  141:    while (NULL != contextP->observedList)
        -:  142:    {
        -:  143:        lwm2m_observed_t * targetP;
        -:  144:        lwm2m_watcher_t * watcherP;
        -:  145:
    #####:  146:        targetP = contextP->observedList;
    #####:  147:        contextP->observedList = contextP->observedList->next;
        -:  148:
    #####:  149:        for (watcherP = targetP->watcherList ; watcherP != NULL ; watcherP = watcherP->next)
        -:  150:        {
    #####:  151:            if (watcherP->parameters != NULL) lwm2m_free(watcherP->parameters);
        -:  152:        }
    #####:  153:        LWM2M_LIST_FREE(targetP->watcherList);
        -:  154:
    #####:  155:        lwm2m_free(targetP);
        -:  156:    }
    #####:  157:}
        -:  158:#endif
        -:  159:
    #####:  160:void prv_deleteTransactionList(lwm2m_context_t * context)
        -:  161:{
    #####:  162:    while (NULL != context->transactionList)
        -:  163:    {
        -:  164:        lwm2m_transaction_t * transaction;
        -:  165:
    #####:  166:        transaction = context->transactionList;
    #####:  167:        context->transactionList = context->transactionList->next;
    #####:  168:        transaction_free(transaction);
        -:  169:    }
    #####:  170:}
        -:  171:
    #####:  172:void lwm2m_close(lwm2m_context_t * contextP)
        -:  173:{
        -:  174:#ifdef LWM2M_CLIENT_MODE
        -:  175:
        -:  176:    LOG("Entering");
    #####:  177:    lwm2m_deregister(contextP);
    #####:  178:    prv_deleteServerList(contextP);
    #####:  179:    prv_deleteBootstrapServerList(contextP);
    #####:  180:    prv_deleteObservedList(contextP);
    #####:  181:    lwm2m_free(contextP->endpointName);
    #####:  182:    if (contextP->msisdn != NULL)
        -:  183:    {
    #####:  184:        lwm2m_free(contextP->msisdn);
        -:  185:    }
    #####:  186:    if (contextP->altPath != NULL)
        -:  187:    {
    #####:  188:        lwm2m_free(contextP->altPath);
        -:  189:    }
        -:  190:
        -:  191:#endif
        -:  192:
        -:  193:#ifdef LWM2M_SERVER_MODE
    #####:  194:    while (NULL != contextP->clientList)
        -:  195:    {
        -:  196:        lwm2m_client_t * clientP;
        -:  197:
    #####:  198:        clientP = contextP->clientList;
    #####:  199:        contextP->clientList = contextP->clientList->next;
        -:  200:
    #####:  201:        registration_freeClient(clientP);
        -:  202:    }
        -:  203:#endif
        -:  204:
    #####:  205:    prv_deleteTransactionList(contextP);
    #####:  206:}
        -:  207:
        -:  208:#ifdef LWM2M_CLIENT_MODE
    #####:  209:static int prv_refreshServerList(lwm2m_context_t * contextP)
        -:  210:{
        -:  211:    lwm2m_server_t * targetP;
        -:  212:    lwm2m_server_t * nextP;
        -:  213:
        -:  214:    // Remove all servers marked as dirty
    #####:  215:    targetP = contextP->bootstrapServerList;
    #####:  216:    contextP->bootstrapServerList = NULL;
    #####:  217:    while (targetP != NULL)
        -:  218:    {
    #####:  219:        nextP = targetP->next;
    #####:  220:        targetP->next = NULL;
    #####:  221:        if (!targetP->dirty)
        -:  222:        {
    #####:  223:            targetP->status = STATE_DEREGISTERED;
    #####:  224:            contextP->bootstrapServerList = (lwm2m_server_t *)LWM2M_LIST_ADD(contextP->bootstrapServerList, targetP);
        -:  225:        }
        -:  226:        else
        -:  227:        {
    #####:  228:            prv_deleteServer(targetP, contextP->userData);
        -:  229:        }
    #####:  230:        targetP = nextP;
        -:  231:    }
    #####:  232:    targetP = contextP->serverList;
    #####:  233:    contextP->serverList = NULL;
    #####:  234:    while (targetP != NULL)
        -:  235:    {
    #####:  236:        nextP = targetP->next;
    #####:  237:        targetP->next = NULL;
    #####:  238:        if (!targetP->dirty)
        -:  239:        {
        -:  240:            // TODO: Should we revert the status to STATE_DEREGISTERED ?
    #####:  241:            contextP->serverList = (lwm2m_server_t *)LWM2M_LIST_ADD(contextP->serverList, targetP);
        -:  242:        }
        -:  243:        else
        -:  244:        {
    #####:  245:            prv_deleteServer(targetP, contextP->userData);
        -:  246:        }
    #####:  247:        targetP = nextP;
        -:  248:    }
        -:  249:
    #####:  250:    return object_getServers(contextP, false);
        -:  251:}
        -:  252:
    #####:  253:int lwm2m_configure(lwm2m_context_t * contextP,
        -:  254:                    const char * endpointName,
        -:  255:                    const char * msisdn,
        -:  256:                    const char * altPath,
        -:  257:                    uint16_t numObject,
        -:  258:                    lwm2m_object_t * objectList[])
        -:  259:{
        -:  260:    int i;
        -:  261:    uint8_t found;
        -:  262:
        -:  263:    LOG_ARG("endpointName: \"%s\", msisdn: \"%s\", altPath: \"%s\", numObject: %d", endpointName, msisdn, altPath, numObject);
        -:  264:    // This API can be called only once for now
    #####:  265:    if (contextP->endpointName != NULL || contextP->objectList != NULL) return COAP_400_BAD_REQUEST;
        -:  266:
    #####:  267:    if (endpointName == NULL) return COAP_400_BAD_REQUEST;
    #####:  268:    if (numObject < 3) return COAP_400_BAD_REQUEST;
        -:  269:    // Check that mandatory objects are present
    #####:  270:    found = 0;
    #####:  271:    for (i = 0 ; i < numObject ; i++)
        -:  272:    {
    #####:  273:        if (objectList[i]->objID == LWM2M_SECURITY_OBJECT_ID) found |= 0x01;
    #####:  274:        if (objectList[i]->objID == LWM2M_SERVER_OBJECT_ID) found |= 0x02;
    #####:  275:        if (objectList[i]->objID == LWM2M_DEVICE_OBJECT_ID) found |= 0x04;
        -:  276:    }
    #####:  277:    if (found != 0x07) return COAP_400_BAD_REQUEST;
    #####:  278:    if (altPath != NULL)
        -:  279:    {
    #####:  280:        if (0 == utils_isAltPathValid(altPath))
        -:  281:        {
    #####:  282:            return COAP_400_BAD_REQUEST;
        -:  283:        }
    #####:  284:        if (altPath[1] == 0)
        -:  285:        {
    #####:  286:            altPath = NULL;
        -:  287:        }
        -:  288:    }
    #####:  289:    contextP->endpointName = lwm2m_strdup(endpointName);
    #####:  290:    if (contextP->endpointName == NULL)
        -:  291:    {
    #####:  292:        return COAP_500_INTERNAL_SERVER_ERROR;
        -:  293:    }
        -:  294:
    #####:  295:    if (msisdn != NULL)
        -:  296:    {
    #####:  297:        contextP->msisdn = lwm2m_strdup(msisdn);
    #####:  298:        if (contextP->msisdn == NULL)
        -:  299:        {
    #####:  300:            return COAP_500_INTERNAL_SERVER_ERROR;
        -:  301:        }
        -:  302:    }
        -:  303:
    #####:  304:    if (altPath != NULL)
        -:  305:    {
    #####:  306:        contextP->altPath = lwm2m_strdup(altPath);
    #####:  307:        if (contextP->altPath == NULL)
        -:  308:        {
    #####:  309:            return COAP_500_INTERNAL_SERVER_ERROR;
        -:  310:        }
        -:  311:    }
        -:  312:
    #####:  313:    for (i = 0; i < numObject; i++)
        -:  314:    {
    #####:  315:        objectList[i]->next = NULL;
    #####:  316:        contextP->objectList = (lwm2m_object_t *)LWM2M_LIST_ADD(contextP->objectList, objectList[i]);
        -:  317:    }
        -:  318:
    #####:  319:    return COAP_NO_ERROR;
        -:  320:}
        -:  321:
    #####:  322:int lwm2m_add_object(lwm2m_context_t * contextP,
        -:  323:                     lwm2m_object_t * objectP)
        -:  324:{
        -:  325:    lwm2m_object_t * targetP;
        -:  326:
        -:  327:    LOG_ARG("ID: %d", objectP->objID);
    #####:  328:    targetP = (lwm2m_object_t *)LWM2M_LIST_FIND(contextP->objectList, objectP->objID);
    #####:  329:    if (targetP != NULL) return COAP_406_NOT_ACCEPTABLE;
    #####:  330:    objectP->next = NULL;
        -:  331:
    #####:  332:    contextP->objectList = (lwm2m_object_t *)LWM2M_LIST_ADD(contextP->objectList, objectP);
        -:  333:
    #####:  334:    if (contextP->state == STATE_READY)
        -:  335:    {
    #####:  336:        return lwm2m_update_registration(contextP, 0, true);
        -:  337:    }
        -:  338:
    #####:  339:    return COAP_NO_ERROR;
        -:  340:}
        -:  341:
    #####:  342:int lwm2m_remove_object(lwm2m_context_t * contextP,
        -:  343:                        uint16_t id)
        -:  344:{
        -:  345:    lwm2m_object_t * targetP;
        -:  346:
        -:  347:    LOG_ARG("ID: %d", id);
    #####:  348:    contextP->objectList = (lwm2m_object_t *)LWM2M_LIST_RM(contextP->objectList, id, &targetP);
        -:  349:
    #####:  350:    if (targetP == NULL) return COAP_404_NOT_FOUND;
        -:  351:
    #####:  352:    if (contextP->state == STATE_READY)
        -:  353:    {
    #####:  354:        return lwm2m_update_registration(contextP, 0, true);
        -:  355:    }
        -:  356:
    #####:  357:    return 0;
        -:  358:}
        -:  359:
        -:  360:#endif
        -:  361:
        -:  362:
    #####:  363:int lwm2m_step(lwm2m_context_t * contextP,
        -:  364:               time_t * timeoutP)
        -:  365:{
        -:  366:    time_t tv_sec;
        -:  367:    int result;
        -:  368:
    #####:  369:    tv_sec = lwm2m_gettime();
    #####:  370:    if (tv_sec < 0) return COAP_500_INTERNAL_SERVER_ERROR;
        -:  371:
        -:  372:#ifdef LWM2M_CLIENT_MODE
        -:  373:
    #####:  374:next_step:
    #####:  375:    switch (contextP->state)
        -:  376:    {
    #####:  377:    case STATE_INITIAL:
    #####:  378:        if (0 != prv_refreshServerList(contextP)) return COAP_503_SERVICE_UNAVAILABLE;
    #####:  379:        if (contextP->serverList != NULL)
        -:  380:        {
    #####:  381:            contextP->state = STATE_REGISTER_REQUIRED;
        -:  382:        }
        -:  383:        else
        -:  384:        {
        -:  385:            // Bootstrapping
    #####:  386:            contextP->state = STATE_BOOTSTRAP_REQUIRED;
        -:  387:        }
    #####:  388:        goto next_step;
    #####:  389:    case STATE_BOOTSTRAP_REQUIRED:
        -:  390:#ifdef LWM2M_BOOTSTRAP
        -:  391:        if (contextP->bootstrapServerList != NULL)
        -:  392:        {
        -:  393:            bootstrap_start(contextP);
        -:  394:            contextP->state = STATE_BOOTSTRAPPING;
        -:  395:            bootstrap_step(contextP, tv_sec, timeoutP);
        -:  396:            break;
        -:  397:        }
        -:  398:        else
        -:  399:#endif
        -:  400:        {
    #####:  401:            return COAP_503_SERVICE_UNAVAILABLE;
        -:  402:        }
        -:  403:
        -:  404:#ifdef LWM2M_BOOTSTRAP
        -:  405:    case STATE_BOOTSTRAPPING:
        -:  406:        switch (bootstrap_getStatus(contextP))
        -:  407:        {
        -:  408:        case STATE_BS_FINISHED:
        -:  409:            contextP->state = STATE_INITIAL;
        -:  410:            goto next_step;
        -:  411:            break;
        -:  412:
        -:  413:        case STATE_BS_FAILED:
        -:  414:            return COAP_503_SERVICE_UNAVAILABLE;
        -:  415:
        -:  416:        default:
        -:  417:            // keep on waiting
        -:  418:            bootstrap_step(contextP, tv_sec, timeoutP);
        -:  419:            break;
        -:  420:        }
        -:  421:        break;
        -:  422:#endif
        -:  423:    // This is a two step phase. First a connection is established
        -:  424:    // then the lwm2m handshake starts.
    #####:  425:    case STATE_REGISTER_REQUIRED:
    #####:  426:        result = registration_init_connection(contextP);
    #####:  427:        contextP->state = STATE_REGISTER_REQUIRED2;
    #####:  428:        *timeoutP = 0;
    #####:  429:        break;
        -:  430:
    #####:  431:    case STATE_REGISTER_REQUIRED2:
    #####:  432:        result = registration_start(contextP);
    #####:  433:        if (COAP_NO_ERROR != result) return result;
    #####:  434:        contextP->state = STATE_REGISTERING;
    #####:  435:        break;
    #####:  436:    case STATE_REGISTERING:
        -:  437:    {
    #####:  438:        switch (registration_getStatus(contextP))
        -:  439:        {
    #####:  440:        case STATE_REGISTERED:
    #####:  441:            contextP->state = STATE_READY;
    #####:  442:            break;
        -:  443:
    #####:  444:        case STATE_REG_FAILED:
        -:  445:            // TODO avoid infinite loop by checking the bootstrap info is different
    #####:  446:            contextP->state = STATE_BOOTSTRAP_REQUIRED;
    #####:  447:            goto next_step;
        -:  448:            break;
        -:  449:
    #####:  450:        case STATE_REG_PENDING:
        -:  451:        default:
        -:  452:            // keep on waiting
    #####:  453:            break;
        -:  454:        }
        -:  455:    }
    #####:  456:    break;
        -:  457:
    #####:  458:    case STATE_READY:
    #####:  459:        if (registration_getStatus(contextP) == STATE_REG_FAILED)
        -:  460:        {
        -:  461:            // TODO avoid infinite loop by checking the bootstrap info is different
    #####:  462:            contextP->state = STATE_BOOTSTRAP_REQUIRED;
    #####:  463:            goto next_step;
        -:  464:            break;
        -:  465:        }
    #####:  466:        break;
        -:  467:
    #####:  468:    default:
        -:  469:        // do nothing
    #####:  470:        break;
        -:  471:    }
        -:  472:
    #####:  473:    observe_step(contextP, tv_sec, timeoutP);
        -:  474:#endif
        -:  475:
    #####:  476:    registration_step(contextP, tv_sec, timeoutP);
    #####:  477:    transaction_step(contextP, tv_sec, timeoutP);
        -:  478:
    #####:  479:    return 0;
        -:  480:}
