        -:    0:Source:/home/david/Programming/wakaamaNode/src/wakaama/management.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/wakaama/management.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*******************************************************************************
        -:    2: *
        -:    3: * Copyright (c) 2013, 2014 Intel Corporation and others.
        -:    4: * All rights reserved. This program and the accompanying materials
        -:    5: * are made available under the terms of the Eclipse Public License v1.0
        -:    6: * and Eclipse Distribution License v1.0 which accompany this distribution.
        -:    7: *
        -:    8: * The Eclipse Public License is available at
        -:    9: *    http://www.eclipse.org/legal/epl-v10.html
        -:   10: * The Eclipse Distribution License is available at
        -:   11: *    http://www.eclipse.org/org/documents/edl-v10.php.
        -:   12: *
        -:   13: * Contributors:
        -:   14: *    David Navarro, Intel Corporation - initial API and implementation
        -:   15: *    domedambrosio - Please refer to git log
        -:   16: *    Toby Jaffey - Please refer to git log
        -:   17: *    Bosch Software Innovations GmbH - Please refer to git log
        -:   18: *    Pascal Rieux - Please refer to git log
        -:   19: *    
        -:   20: *******************************************************************************/
        -:   21:/*
        -:   22: Copyright (c) 2013, 2014 Intel Corporation
        -:   23:
        -:   24: Redistribution and use in source and binary forms, with or without modification,
        -:   25: are permitted provided that the following conditions are met:
        -:   26:
        -:   27:     * Redistributions of source code must retain the above copyright notice,
        -:   28:       this list of conditions and the following disclaimer.
        -:   29:     * Redistributions in binary form must reproduce the above copyright notice,
        -:   30:       this list of conditions and the following disclaimer in the documentation
        -:   31:       and/or other materials provided with the distribution.
        -:   32:     * Neither the name of Intel Corporation nor the names of its contributors
        -:   33:       may be used to endorse or promote products derived from this software
        -:   34:       without specific prior written permission.
        -:   35:
        -:   36: THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
        -:   37: ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
        -:   38: WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
        -:   39: IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
        -:   40: INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
        -:   41: BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
        -:   42: DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
        -:   43: LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
        -:   44: OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
        -:   45: THE POSSIBILITY OF SUCH DAMAGE.
        -:   46:
        -:   47: David Navarro <david.navarro@intel.com>
        -:   48:
        -:   49:*/
        -:   50:
        -:   51:#include "internals.h"
        -:   52:#include <stdio.h>
        -:   53:
        -:   54:
        -:   55:#ifdef LWM2M_CLIENT_MODE
    #####:   56:static int prv_readAttributes(multi_option_t * query,
        -:   57:                              lwm2m_attributes_t * attrP)
        -:   58:{
        -:   59:    int64_t intValue;
        -:   60:    double floatValue;
        -:   61:
    #####:   62:    memset(attrP, 0, sizeof(lwm2m_attributes_t));
        -:   63:
    #####:   64:    while (query != NULL)
        -:   65:    {
    #####:   66:        if (lwm2m_strncmp((char *)query->data, ATTR_MIN_PERIOD_STR, ATTR_MIN_PERIOD_LEN) == 0)
        -:   67:        {
    #####:   68:            if (0 != ((attrP->toSet | attrP->toClear) & LWM2M_ATTR_FLAG_MIN_PERIOD)) return -1;
    #####:   69:            if (query->len == ATTR_MIN_PERIOD_LEN) return -1;
        -:   70:
    #####:   71:            if (1 != utils_textToInt(query->data + ATTR_MIN_PERIOD_LEN, query->len - ATTR_MIN_PERIOD_LEN, &intValue)) return -1;
    #####:   72:            if (intValue < 0) return -1;
        -:   73:
    #####:   74:            attrP->toSet |= LWM2M_ATTR_FLAG_MIN_PERIOD;
    #####:   75:            attrP->minPeriod = intValue;
        -:   76:        }
    #####:   77:        else if (lwm2m_strncmp((char *)query->data, ATTR_MIN_PERIOD_STR, ATTR_MIN_PERIOD_LEN - 1) == 0)
        -:   78:        {
    #####:   79:            if (0 != ((attrP->toSet | attrP->toClear) & LWM2M_ATTR_FLAG_MIN_PERIOD)) return -1;
    #####:   80:            if (query->len != ATTR_MIN_PERIOD_LEN - 1) return -1;
        -:   81:
    #####:   82:            attrP->toClear |= LWM2M_ATTR_FLAG_MIN_PERIOD;
        -:   83:        }
    #####:   84:        else if (lwm2m_strncmp((char *)query->data, ATTR_MAX_PERIOD_STR, ATTR_MAX_PERIOD_LEN) == 0)
        -:   85:        {
    #####:   86:            if (0 != ((attrP->toSet | attrP->toClear) & LWM2M_ATTR_FLAG_MAX_PERIOD)) return -1;
    #####:   87:            if (query->len == ATTR_MAX_PERIOD_LEN) return -1;
        -:   88:
    #####:   89:            if (1 != utils_textToInt(query->data + ATTR_MAX_PERIOD_LEN, query->len - ATTR_MAX_PERIOD_LEN, &intValue)) return -1;
    #####:   90:            if (intValue < 0) return -1;
        -:   91:
    #####:   92:            attrP->toSet |= LWM2M_ATTR_FLAG_MAX_PERIOD;
    #####:   93:            attrP->maxPeriod = intValue;
        -:   94:        }
    #####:   95:        else if (lwm2m_strncmp((char *)query->data, ATTR_MAX_PERIOD_STR, ATTR_MAX_PERIOD_LEN - 1) == 0)
        -:   96:        {
    #####:   97:            if (0 != ((attrP->toSet | attrP->toClear) & LWM2M_ATTR_FLAG_MAX_PERIOD)) return -1;
    #####:   98:            if (query->len != ATTR_MAX_PERIOD_LEN - 1) return -1;
        -:   99:
    #####:  100:            attrP->toClear |= LWM2M_ATTR_FLAG_MAX_PERIOD;
        -:  101:        }
    #####:  102:        else if (lwm2m_strncmp((char *)query->data, ATTR_GREATER_THAN_STR, ATTR_GREATER_THAN_LEN) == 0)
        -:  103:        {
    #####:  104:            if (0 != ((attrP->toSet | attrP->toClear) & LWM2M_ATTR_FLAG_GREATER_THAN)) return -1;
    #####:  105:            if (query->len == ATTR_GREATER_THAN_LEN) return -1;
        -:  106:
    #####:  107:            if (1 != utils_textToFloat(query->data + ATTR_GREATER_THAN_LEN, query->len - ATTR_GREATER_THAN_LEN, &floatValue)) return -1;
        -:  108:
    #####:  109:            attrP->toSet |= LWM2M_ATTR_FLAG_GREATER_THAN;
    #####:  110:            attrP->greaterThan = floatValue;
        -:  111:        }
    #####:  112:        else if (lwm2m_strncmp((char *)query->data, ATTR_GREATER_THAN_STR, ATTR_GREATER_THAN_LEN - 1) == 0)
        -:  113:        {
    #####:  114:            if (0 != ((attrP->toSet | attrP->toClear) & LWM2M_ATTR_FLAG_GREATER_THAN)) return -1;
    #####:  115:            if (query->len != ATTR_GREATER_THAN_LEN - 1) return -1;
        -:  116:
    #####:  117:            attrP->toClear |= LWM2M_ATTR_FLAG_GREATER_THAN;
        -:  118:        }
    #####:  119:        else if (lwm2m_strncmp((char *)query->data, ATTR_LESS_THAN_STR, ATTR_LESS_THAN_LEN) == 0)
        -:  120:        {
    #####:  121:            if (0 != ((attrP->toSet | attrP->toClear) & LWM2M_ATTR_FLAG_LESS_THAN)) return -1;
    #####:  122:            if (query->len == ATTR_LESS_THAN_LEN) return -1;
        -:  123:
    #####:  124:            if (1 != utils_textToFloat(query->data + ATTR_LESS_THAN_LEN, query->len - ATTR_LESS_THAN_LEN, &floatValue)) return -1;
        -:  125:
    #####:  126:            attrP->toSet |= LWM2M_ATTR_FLAG_LESS_THAN;
    #####:  127:            attrP->lessThan = floatValue;
        -:  128:        }
    #####:  129:        else if (lwm2m_strncmp((char *)query->data, ATTR_LESS_THAN_STR, ATTR_LESS_THAN_LEN - 1) == 0)
        -:  130:        {
    #####:  131:            if (0 != ((attrP->toSet | attrP->toClear) & LWM2M_ATTR_FLAG_LESS_THAN)) return -1;
    #####:  132:            if (query->len != ATTR_LESS_THAN_LEN - 1) return -1;
        -:  133:
    #####:  134:            attrP->toClear |= LWM2M_ATTR_FLAG_LESS_THAN;
        -:  135:        }
    #####:  136:        else if (lwm2m_strncmp((char *)query->data, ATTR_STEP_STR, ATTR_STEP_LEN) == 0)
        -:  137:        {
    #####:  138:            if (0 != ((attrP->toSet | attrP->toClear) & LWM2M_ATTR_FLAG_STEP)) return -1;
    #####:  139:            if (query->len == ATTR_STEP_LEN) return -1;
        -:  140:
    #####:  141:            if (1 != utils_textToFloat(query->data + ATTR_STEP_LEN, query->len - ATTR_STEP_LEN, &floatValue)) return -1;
    #####:  142:            if (floatValue < 0) return -1;
        -:  143:
    #####:  144:            attrP->toSet |= LWM2M_ATTR_FLAG_STEP;
    #####:  145:            attrP->step = floatValue;
        -:  146:        }
    #####:  147:        else if (lwm2m_strncmp((char *)query->data, ATTR_STEP_STR, ATTR_STEP_LEN - 1) == 0)
        -:  148:        {
    #####:  149:            if (0 != ((attrP->toSet | attrP->toClear) & LWM2M_ATTR_FLAG_STEP)) return -1;
    #####:  150:            if (query->len != ATTR_STEP_LEN - 1) return -1;
        -:  151:
    #####:  152:            attrP->toClear |= LWM2M_ATTR_FLAG_STEP;
        -:  153:        }
    #####:  154:        else return -1;
        -:  155:
    #####:  156:        query = query->next;
        -:  157:    }
        -:  158:
    #####:  159:    return 0;
        -:  160:}
        -:  161:
    #####:  162:uint8_t dm_handleRequest(lwm2m_context_t * contextP,
        -:  163:                         lwm2m_uri_t * uriP,
        -:  164:                         lwm2m_server_t * serverP,
        -:  165:                         coap_packet_t * message,
        -:  166:                         coap_packet_t * response)
        -:  167:{
        -:  168:    uint8_t result;
        -:  169:    lwm2m_media_type_t format;
        -:  170:
        -:  171:    LOG_ARG("Code: %02X, server status: %s", message->code, STR_STATUS(serverP->status));
        -:  172:    LOG_URI(uriP);
        -:  173:
    #####:  174:    if (IS_OPTION(message, COAP_OPTION_CONTENT_TYPE))
        -:  175:    {
    #####:  176:        format = utils_convertMediaType(message->content_type);
        -:  177:    }
        -:  178:    else
        -:  179:    {
    #####:  180:        format = LWM2M_CONTENT_TLV;
        -:  181:    }
        -:  182:
    #####:  183:    if (uriP->objectId == LWM2M_SECURITY_OBJECT_ID)
        -:  184:    {
    #####:  185:        return COAP_404_NOT_FOUND;
        -:  186:    }
        -:  187:
    #####:  188:    if (serverP->status != STATE_REGISTERED
    #####:  189:        && serverP->status != STATE_REG_UPDATE_NEEDED
    #####:  190:        && serverP->status != STATE_REG_FULL_UPDATE_NEEDED
    #####:  191:        && serverP->status != STATE_REG_UPDATE_PENDING)
        -:  192:    {
    #####:  193:        return COAP_IGNORE;
        -:  194:    }
        -:  195:
        -:  196:    // TODO: check ACL
        -:  197:
    #####:  198:    switch (message->code)
        -:  199:    {
    #####:  200:    case COAP_GET:
        -:  201:        {
    #####:  202:            uint8_t * buffer = NULL;
    #####:  203:            size_t length = 0;
        -:  204:            int res;
        -:  205:
    #####:  206:            if (IS_OPTION(message, COAP_OPTION_OBSERVE))
        -:  207:            {
    #####:  208:                lwm2m_data_t * dataP = NULL;
    #####:  209:                int size = 0;
        -:  210:
    #####:  211:                result = object_readData(contextP, uriP, &size, &dataP);
    #####:  212:                if (COAP_205_CONTENT == result)
        -:  213:                {
    #####:  214:                    result = observe_handleRequest(contextP, uriP, serverP, size, dataP, message, response);
    #####:  215:                    if (COAP_205_CONTENT == result)
        -:  216:                    {
    #####:  217:                        if (IS_OPTION(message, COAP_OPTION_ACCEPT))
        -:  218:                        {
    #####:  219:                            format = utils_convertMediaType(message->accept[0]);
        -:  220:                        }
        -:  221:                        else
        -:  222:                        {
    #####:  223:                            format = LWM2M_CONTENT_TLV;
        -:  224:                        }
        -:  225:
    #####:  226:                        res = lwm2m_data_serialize(uriP, size, dataP, &format, &buffer);
    #####:  227:                        if (res < 0)
        -:  228:                        {
    #####:  229:                            result = COAP_500_INTERNAL_SERVER_ERROR;
        -:  230:                        }
        -:  231:                        else
        -:  232:                        {
    #####:  233:                            length = (size_t)res;
        -:  234:                            LOG_ARG("Observe Request[/%d/%d/%d]: %.*s\n", uriP->objectId, uriP->instanceId, uriP->resourceId, length, buffer);
        -:  235:                        }
        -:  236:                    }
    #####:  237:                    lwm2m_data_free(size, dataP);
        -:  238:                }
        -:  239:            }
    #####:  240:            else if (IS_OPTION(message, COAP_OPTION_ACCEPT)
    #####:  241:                  && message->accept_num == 1
    #####:  242:                  && message->accept[0] == APPLICATION_LINK_FORMAT)
        -:  243:            {
    #####:  244:                format = LWM2M_CONTENT_LINK;
    #####:  245:                result = object_discover(contextP, uriP, serverP, &buffer, &length);
        -:  246:            }
        -:  247:            else
        -:  248:            {
    #####:  249:                if (IS_OPTION(message, COAP_OPTION_ACCEPT))
        -:  250:                {
    #####:  251:                    format = utils_convertMediaType(message->accept[0]);
        -:  252:                }
        -:  253:
    #####:  254:                result = object_read(contextP, uriP, &format, &buffer, &length);
        -:  255:            }
    #####:  256:            if (COAP_205_CONTENT == result)
        -:  257:            {
    #####:  258:                coap_set_header_content_type(response, format);
    #####:  259:                coap_set_payload(response, buffer, length);
        -:  260:                // lwm2m_handle_packet will free buffer
        -:  261:            }
        -:  262:            else
        -:  263:            {
    #####:  264:                lwm2m_free(buffer);
        -:  265:            }
        -:  266:        }
    #####:  267:        break;
        -:  268:
    #####:  269:    case COAP_POST:
        -:  270:        {
    #####:  271:            if (!LWM2M_URI_IS_SET_INSTANCE(uriP))
        -:  272:            {
    #####:  273:                result = object_create(contextP, uriP, format, message->payload, message->payload_len);
    #####:  274:                if (result == COAP_201_CREATED)
        -:  275:                {
        -:  276:                    //longest uri is /65535/65535 = 12 + 1 (null) chars
    #####:  277:                    char location_path[13] = "";
        -:  278:                    //instanceId expected
    #####:  279:                    if ((uriP->flag & LWM2M_URI_FLAG_INSTANCE_ID) == 0)
        -:  280:                    {
    #####:  281:                        result = COAP_500_INTERNAL_SERVER_ERROR;
    #####:  282:                        break;
        -:  283:                    }
        -:  284:
    #####:  285:                    if (sprintf(location_path, "/%d/%d", uriP->objectId, uriP->instanceId) < 0)
        -:  286:                    {
    #####:  287:                        result = COAP_500_INTERNAL_SERVER_ERROR;
    #####:  288:                        break;
        -:  289:                    }
    #####:  290:                    coap_set_header_location_path(response, location_path);
        -:  291:
    #####:  292:                    lwm2m_update_registration(contextP, 0, true);
        -:  293:                }
        -:  294:            }
    #####:  295:            else if (!LWM2M_URI_IS_SET_RESOURCE(uriP))
        -:  296:            {
    #####:  297:                result = object_write(contextP, uriP, format, message->payload, message->payload_len);
        -:  298:            }
        -:  299:            else
        -:  300:            {
    #####:  301:                result = object_execute(contextP, uriP, message->payload, message->payload_len);
        -:  302:            }
        -:  303:        }
    #####:  304:        break;
        -:  305:
    #####:  306:    case COAP_PUT:
        -:  307:        {
    #####:  308:            if (IS_OPTION(message, COAP_OPTION_URI_QUERY))
        -:  309:            {
        -:  310:                lwm2m_attributes_t attr;
        -:  311:
    #####:  312:                if (0 != prv_readAttributes(message->uri_query, &attr))
        -:  313:                {
    #####:  314:                    result = COAP_400_BAD_REQUEST;
        -:  315:                }
        -:  316:                else
        -:  317:                {
    #####:  318:                    result = observe_setParameters(contextP, uriP, serverP, &attr);
        -:  319:                }
        -:  320:            }
    #####:  321:            else if (LWM2M_URI_IS_SET_INSTANCE(uriP))
        -:  322:            {
    #####:  323:                result = object_write(contextP, uriP, format, message->payload, message->payload_len);
        -:  324:            }
        -:  325:            else
        -:  326:            {
    #####:  327:                result = COAP_400_BAD_REQUEST;
        -:  328:            }
        -:  329:        }
    #####:  330:        break;
        -:  331:
    #####:  332:    case COAP_DELETE:
        -:  333:        {
    #####:  334:            if (!LWM2M_URI_IS_SET_INSTANCE(uriP) || LWM2M_URI_IS_SET_RESOURCE(uriP))
        -:  335:            {
    #####:  336:                result = COAP_400_BAD_REQUEST;
        -:  337:            }
        -:  338:            else
        -:  339:            {
    #####:  340:                result = object_delete(contextP, uriP);
    #####:  341:                if (result == COAP_202_DELETED)
        -:  342:                {
    #####:  343:                    lwm2m_update_registration(contextP, 0, true);
        -:  344:                }
        -:  345:            }
        -:  346:        }
    #####:  347:        break;
        -:  348:
    #####:  349:    default:
    #####:  350:        result = COAP_400_BAD_REQUEST;
    #####:  351:        break;
        -:  352:    }
        -:  353:
    #####:  354:    return result;
        -:  355:}
        -:  356:
        -:  357:#endif
        -:  358:
        -:  359:#ifdef LWM2M_SERVER_MODE
        -:  360:
        -:  361:#define ID_AS_STRING_MAX_LEN 8
        -:  362:
    #####:  363:static void prv_resultCallback(lwm2m_transaction_t * transacP,
        -:  364:                               void * message)
        -:  365:{
    #####:  366:    dm_data_t * dataP = (dm_data_t *)transacP->userData;
        -:  367:
    #####:  368:    if (message == NULL)
        -:  369:    {
    #####:  370:        dataP->callback(dataP->clientID,
        -:  371:                        &dataP->uri,
        -:  372:                        COAP_503_SERVICE_UNAVAILABLE,
        -:  373:                        LWM2M_CONTENT_TEXT, NULL, 0,
        -:  374:                        dataP->userData);
        -:  375:    }
        -:  376:    else
        -:  377:    {
    #####:  378:        coap_packet_t * packet = (coap_packet_t *)message;
        -:  379:
        -:  380:        //if packet is a CREATE response and the instanceId was assigned by the client
    #####:  381:        if (packet->code == COAP_201_CREATED
    #####:  382:         && packet->location_path != NULL)
        -:  383:        {
    #####:  384:            char * locationString = NULL;
    #####:  385:            int result = 0;
        -:  386:            lwm2m_uri_t locationUri;
        -:  387:
    #####:  388:            locationString = coap_get_multi_option_as_string(packet->location_path);
    #####:  389:            if (locationString == NULL)
        -:  390:            {
        -:  391:                LOG("Error: coap_get_multi_option_as_string() failed for Location_path option in prv_resultCallback()");
    #####:  392:                return;
        -:  393:            }
        -:  394:
    #####:  395:            result = lwm2m_stringToUri(locationString, strlen(locationString), &locationUri);
    #####:  396:            if (result == 0)
        -:  397:            {
        -:  398:                LOG("Error: lwm2m_stringToUri() failed for Location_path option in prv_resultCallback()");
    #####:  399:                lwm2m_free(locationString);
    #####:  400:                return;
        -:  401:            }
        -:  402:
    #####:  403:            ((dm_data_t*)transacP->userData)->uri.instanceId = locationUri.instanceId;
    #####:  404:            ((dm_data_t*)transacP->userData)->uri.flag = locationUri.flag;
        -:  405:
    #####:  406:            lwm2m_free(locationString);
        -:  407:        }
        -:  408:
    #####:  409:        dataP->callback(dataP->clientID,
        -:  410:                        &dataP->uri,
    #####:  411:                        packet->code,
        -:  412:                        utils_convertMediaType(packet->content_type),
        -:  413:                        packet->payload,
    #####:  414:                        packet->payload_len,
        -:  415:                        dataP->userData);
        -:  416:    }
    #####:  417:    lwm2m_free(dataP);
        -:  418:}
        -:  419:
    #####:  420:static int prv_makeOperation(lwm2m_context_t * contextP,
        -:  421:                             uint16_t clientID,
        -:  422:                             lwm2m_uri_t * uriP,
        -:  423:                             coap_method_t method,
        -:  424:                             lwm2m_media_type_t format,
        -:  425:                             uint8_t * buffer,
        -:  426:                             int length,
        -:  427:                             lwm2m_result_callback_t callback,
        -:  428:                             void * userData)
        -:  429:{
        -:  430:    lwm2m_client_t * clientP;
        -:  431:    lwm2m_transaction_t * transaction;
        -:  432:    dm_data_t * dataP;
        -:  433:
    #####:  434:    clientP = (lwm2m_client_t *)lwm2m_list_find((lwm2m_list_t *)contextP->clientList, clientID);
    #####:  435:    if (clientP == NULL) return COAP_404_NOT_FOUND;
        -:  436:
    #####:  437:    transaction = transaction_new(clientP->sessionH, method, clientP->altPath, uriP, contextP->nextMID++, 4, NULL);
    #####:  438:    if (transaction == NULL) return COAP_500_INTERNAL_SERVER_ERROR;
        -:  439:
    #####:  440:    if (method == COAP_GET)
        -:  441:    {
    #####:  442:        coap_set_header_accept(transaction->message, format);
        -:  443:    }
    #####:  444:    else if (buffer != NULL)
        -:  445:    {
    #####:  446:        coap_set_header_content_type(transaction->message, format);
        -:  447:        // TODO: Take care of fragmentation
    #####:  448:        coap_set_payload(transaction->message, buffer, length);
        -:  449:    }
        -:  450:
    #####:  451:    if (callback != NULL)
        -:  452:    {
    #####:  453:        dataP = (dm_data_t *)lwm2m_malloc(sizeof(dm_data_t));
    #####:  454:        if (dataP == NULL)
        -:  455:        {
    #####:  456:            transaction_free(transaction);
    #####:  457:            return COAP_500_INTERNAL_SERVER_ERROR;
        -:  458:        }
    #####:  459:        memcpy(&dataP->uri, uriP, sizeof(lwm2m_uri_t));
    #####:  460:        dataP->clientID = clientP->internalID;
    #####:  461:        dataP->callback = callback;
    #####:  462:        dataP->userData = userData;
        -:  463:
    #####:  464:        transaction->callback = prv_resultCallback;
    #####:  465:        transaction->userData = (void *)dataP;
        -:  466:    }
        -:  467:
    #####:  468:    contextP->transactionList = (lwm2m_transaction_t *)LWM2M_LIST_ADD(contextP->transactionList, transaction);
        -:  469:
    #####:  470:    return transaction_send(contextP, transaction);
        -:  471:}
        -:  472:
    #####:  473:int lwm2m_dm_read(lwm2m_context_t * contextP,
        -:  474:                  uint16_t clientID,
        -:  475:                  lwm2m_uri_t * uriP,
        -:  476:                  lwm2m_result_callback_t callback,
        -:  477:                  void * userData)
        -:  478:{
        -:  479:    lwm2m_client_t * clientP;
        -:  480:    lwm2m_media_type_t format;
        -:  481:
        -:  482:    LOG_ARG("clientID: %d", clientID);
        -:  483:    LOG_URI(uriP);
        -:  484:
    #####:  485:    clientP = (lwm2m_client_t *)lwm2m_list_find((lwm2m_list_t *)contextP->clientList, clientID);
    #####:  486:    if (clientP == NULL) return COAP_404_NOT_FOUND;
        -:  487:
    #####:  488:    if (clientP->supportJSON == true)
        -:  489:    {
    #####:  490:        format = LWM2M_CONTENT_JSON;
        -:  491:    }
        -:  492:    else
        -:  493:    {
    #####:  494:        format = LWM2M_CONTENT_TLV;
        -:  495:    }
        -:  496:
    #####:  497:    return prv_makeOperation(contextP, clientID, uriP,
        -:  498:                             COAP_GET,
        -:  499:                             format,
        -:  500:                             NULL, 0,
        -:  501:                             callback, userData);
        -:  502:}
        -:  503:
    #####:  504:int lwm2m_dm_write(lwm2m_context_t * contextP,
        -:  505:                   uint16_t clientID,
        -:  506:                   lwm2m_uri_t * uriP,
        -:  507:                   lwm2m_media_type_t format,
        -:  508:                   uint8_t * buffer,
        -:  509:                   int length,
        -:  510:                   lwm2m_result_callback_t callback,
        -:  511:                   void * userData)
        -:  512:{
        -:  513:    LOG_ARG("clientID: %d, format: %s, length: %d", clientID, STR_MEDIA_TYPE(format), length);
        -:  514:    LOG_URI(uriP);
    #####:  515:    if (!LWM2M_URI_IS_SET_INSTANCE(uriP)
    #####:  516:     || length == 0)
        -:  517:    {
    #####:  518:        return COAP_400_BAD_REQUEST;
        -:  519:    }
        -:  520:
    #####:  521:    if (LWM2M_URI_IS_SET_RESOURCE(uriP))
        -:  522:    {
    #####:  523:        return prv_makeOperation(contextP, clientID, uriP,
        -:  524:                                  COAP_PUT,
        -:  525:                                  format, buffer, length,
        -:  526:                                  callback, userData);
        -:  527:    }
        -:  528:    else
        -:  529:    {
    #####:  530:        return prv_makeOperation(contextP, clientID, uriP,
        -:  531:                                  COAP_POST,
        -:  532:                                  format, buffer, length,
        -:  533:                                  callback, userData);
        -:  534:    }
        -:  535:}
        -:  536:
    #####:  537:int lwm2m_dm_execute(lwm2m_context_t * contextP,
        -:  538:                     uint16_t clientID,
        -:  539:                     lwm2m_uri_t * uriP,
        -:  540:                     lwm2m_media_type_t format,
        -:  541:                     uint8_t * buffer,
        -:  542:                     int length,
        -:  543:                     lwm2m_result_callback_t callback,
        -:  544:                     void * userData)
        -:  545:{
        -:  546:    LOG_ARG("clientID: %d, format: %s, length: %d", clientID, STR_MEDIA_TYPE(format), length);
        -:  547:    LOG_URI(uriP);
    #####:  548:    if (!LWM2M_URI_IS_SET_RESOURCE(uriP))
        -:  549:    {
    #####:  550:        return COAP_400_BAD_REQUEST;
        -:  551:    }
        -:  552:
    #####:  553:    return prv_makeOperation(contextP, clientID, uriP,
        -:  554:                              COAP_POST,
        -:  555:                              format, buffer, length,
        -:  556:                              callback, userData);
        -:  557:}
        -:  558:
    #####:  559:int lwm2m_dm_create(lwm2m_context_t * contextP,
        -:  560:                    uint16_t clientID,
        -:  561:                    lwm2m_uri_t * uriP,
        -:  562:                    lwm2m_media_type_t format,
        -:  563:                    uint8_t * buffer,
        -:  564:                    int length,
        -:  565:                    lwm2m_result_callback_t callback,
        -:  566:                    void * userData)
        -:  567:{
        -:  568:    LOG_ARG("clientID: %d, format: %s, length: %d", clientID, STR_MEDIA_TYPE(format), length);
        -:  569:    LOG_URI(uriP);
        -:  570:
    #####:  571:    if (LWM2M_URI_IS_SET_INSTANCE(uriP)
    #####:  572:     || length == 0)
        -:  573:    {
    #####:  574:        return COAP_400_BAD_REQUEST;
        -:  575:    }
        -:  576:
    #####:  577:    return prv_makeOperation(contextP, clientID, uriP,
        -:  578:                              COAP_POST,
        -:  579:                              format, buffer, length,
        -:  580:                              callback, userData);
        -:  581:}
        -:  582:
    #####:  583:int lwm2m_dm_delete(lwm2m_context_t * contextP,
        -:  584:                    uint16_t clientID,
        -:  585:                    lwm2m_uri_t * uriP,
        -:  586:                    lwm2m_result_callback_t callback,
        -:  587:                    void * userData)
        -:  588:{
        -:  589:    LOG_ARG("clientID: %d", clientID);
        -:  590:    LOG_URI(uriP);
    #####:  591:    if (!LWM2M_URI_IS_SET_INSTANCE(uriP)
    #####:  592:     || LWM2M_URI_IS_SET_RESOURCE(uriP))
        -:  593:    {
    #####:  594:        return COAP_400_BAD_REQUEST;
        -:  595:    }
        -:  596:
    #####:  597:    return prv_makeOperation(contextP, clientID, uriP,
        -:  598:                              COAP_DELETE,
        -:  599:                              LWM2M_CONTENT_TEXT, NULL, 0,
        -:  600:                              callback, userData);
        -:  601:}
        -:  602:
    #####:  603:int lwm2m_dm_write_attributes(lwm2m_context_t * contextP,
        -:  604:                              uint16_t clientID,
        -:  605:                              lwm2m_uri_t * uriP,
        -:  606:                              lwm2m_attributes_t * attrP,
        -:  607:                              lwm2m_result_callback_t callback,
        -:  608:                              void * userData)
        -:  609:{
        -:  610:#define _PRV_BUFFER_SIZE 32
        -:  611:    lwm2m_client_t * clientP;
        -:  612:    lwm2m_transaction_t * transaction;
        -:  613:    coap_packet_t * coap_pkt;
        -:  614:    uint8_t buffer[_PRV_BUFFER_SIZE];
        -:  615:    size_t length;
        -:  616:
        -:  617:    LOG_ARG("clientID: %d", clientID);
        -:  618:    LOG_URI(uriP);
    #####:  619:    if (attrP == NULL) return COAP_400_BAD_REQUEST;
        -:  620:
    #####:  621:    if (0 != (attrP->toSet & attrP->toClear)) return COAP_400_BAD_REQUEST;
    #####:  622:    if (0 != (attrP->toSet & ATTR_FLAG_NUMERIC) && !LWM2M_URI_IS_SET_RESOURCE(uriP)) return COAP_400_BAD_REQUEST;
    #####:  623:    if (ATTR_FLAG_NUMERIC == (attrP->toSet & ATTR_FLAG_NUMERIC)
    #####:  624:     && (attrP->lessThan + 2 * attrP->step >= attrP->greaterThan)) return COAP_400_BAD_REQUEST;
        -:  625:
    #####:  626:    clientP = (lwm2m_client_t *)lwm2m_list_find((lwm2m_list_t *)contextP->clientList, clientID);
    #####:  627:    if (clientP == NULL) return COAP_404_NOT_FOUND;
        -:  628:
    #####:  629:    transaction = transaction_new(clientP->sessionH, COAP_PUT, clientP->altPath, uriP, contextP->nextMID++, 4, NULL);
    #####:  630:    if (transaction == NULL) return COAP_500_INTERNAL_SERVER_ERROR;
        -:  631:
    #####:  632:    if (callback != NULL)
        -:  633:    {
        -:  634:        dm_data_t * dataP;
        -:  635:
    #####:  636:        dataP = (dm_data_t *)lwm2m_malloc(sizeof(dm_data_t));
    #####:  637:        if (dataP == NULL)
        -:  638:        {
    #####:  639:            transaction_free(transaction);
    #####:  640:            return COAP_500_INTERNAL_SERVER_ERROR;
        -:  641:        }
    #####:  642:        memcpy(&dataP->uri, uriP, sizeof(lwm2m_uri_t));
    #####:  643:        dataP->clientID = clientP->internalID;
    #####:  644:        dataP->callback = callback;
    #####:  645:        dataP->userData = userData;
        -:  646:
    #####:  647:        transaction->callback = prv_resultCallback;
    #####:  648:        transaction->userData = (void *)dataP;
        -:  649:    }
        -:  650:
    #####:  651:    coap_pkt = (coap_packet_t *)transaction->message;
    #####:  652:    free_multi_option(coap_pkt->uri_query);
    #####:  653:    if (attrP->toSet & LWM2M_ATTR_FLAG_MIN_PERIOD)
        -:  654:    {
    #####:  655:        memcpy(buffer, ATTR_MIN_PERIOD_STR, ATTR_MIN_PERIOD_LEN);
    #####:  656:        length = utils_intToText(attrP->minPeriod, buffer + ATTR_MIN_PERIOD_LEN, _PRV_BUFFER_SIZE - ATTR_MIN_PERIOD_LEN);
    #####:  657:        if (length == 0)
        -:  658:        {
    #####:  659:            transaction_free(transaction);
    #####:  660:            return COAP_500_INTERNAL_SERVER_ERROR;
        -:  661:        }
    #####:  662:        coap_add_multi_option(&(coap_pkt->uri_query), buffer, ATTR_MIN_PERIOD_LEN + length, 0);
    #####:  663:        SET_OPTION(coap_pkt, COAP_OPTION_URI_QUERY);
        -:  664:    }
    #####:  665:    if (attrP->toSet & LWM2M_ATTR_FLAG_MAX_PERIOD)
        -:  666:    {
    #####:  667:        memcpy(buffer, ATTR_MAX_PERIOD_STR, ATTR_MAX_PERIOD_LEN);
    #####:  668:        length = utils_intToText(attrP->maxPeriod, buffer + ATTR_MAX_PERIOD_LEN, _PRV_BUFFER_SIZE - ATTR_MAX_PERIOD_LEN);
    #####:  669:        if (length == 0)
        -:  670:        {
    #####:  671:            transaction_free(transaction);
    #####:  672:            return COAP_500_INTERNAL_SERVER_ERROR;
        -:  673:        }
    #####:  674:        coap_add_multi_option(&(coap_pkt->uri_query), buffer, ATTR_MAX_PERIOD_LEN + length, 0);
    #####:  675:        SET_OPTION(coap_pkt, COAP_OPTION_URI_QUERY);
        -:  676:    }
    #####:  677:    if (attrP->toSet & LWM2M_ATTR_FLAG_GREATER_THAN)
        -:  678:    {
    #####:  679:        memcpy(buffer, ATTR_GREATER_THAN_STR, ATTR_GREATER_THAN_LEN);
    #####:  680:        length = utils_floatToText(attrP->greaterThan, buffer + ATTR_GREATER_THAN_LEN, _PRV_BUFFER_SIZE - ATTR_GREATER_THAN_LEN);
    #####:  681:        if (length == 0)
        -:  682:        {
    #####:  683:            transaction_free(transaction);
    #####:  684:            return COAP_500_INTERNAL_SERVER_ERROR;
        -:  685:        }
    #####:  686:        coap_add_multi_option(&(coap_pkt->uri_query), buffer, ATTR_GREATER_THAN_LEN + length, 0);
    #####:  687:        SET_OPTION(coap_pkt, COAP_OPTION_URI_QUERY);
        -:  688:    }
    #####:  689:    if (attrP->toSet & LWM2M_ATTR_FLAG_LESS_THAN)
        -:  690:    {
    #####:  691:        memcpy(buffer, ATTR_LESS_THAN_STR, ATTR_LESS_THAN_LEN);
    #####:  692:        length = utils_floatToText(attrP->lessThan, buffer + ATTR_LESS_THAN_LEN, _PRV_BUFFER_SIZE - ATTR_LESS_THAN_LEN);
    #####:  693:        if (length == 0)
        -:  694:        {
    #####:  695:            transaction_free(transaction);
    #####:  696:            return COAP_500_INTERNAL_SERVER_ERROR;
        -:  697:        }
    #####:  698:        coap_add_multi_option(&(coap_pkt->uri_query), buffer, ATTR_LESS_THAN_LEN + length, 0);
    #####:  699:        SET_OPTION(coap_pkt, COAP_OPTION_URI_QUERY);
        -:  700:    }
    #####:  701:    if (attrP->toSet & LWM2M_ATTR_FLAG_STEP)
        -:  702:    {
    #####:  703:        memcpy(buffer, ATTR_STEP_STR, ATTR_STEP_LEN);
    #####:  704:        length = utils_floatToText(attrP->step, buffer + ATTR_STEP_LEN, _PRV_BUFFER_SIZE - ATTR_STEP_LEN);
    #####:  705:        if (length == 0)
        -:  706:        {
    #####:  707:            transaction_free(transaction);
    #####:  708:            return COAP_500_INTERNAL_SERVER_ERROR;
        -:  709:        }
    #####:  710:        coap_add_multi_option(&(coap_pkt->uri_query), buffer, ATTR_STEP_LEN + length, 0);
    #####:  711:        SET_OPTION(coap_pkt, COAP_OPTION_URI_QUERY);
        -:  712:    }
    #####:  713:    if (attrP->toClear & LWM2M_ATTR_FLAG_MIN_PERIOD)
        -:  714:    {
    #####:  715:        coap_add_multi_option(&(coap_pkt->uri_query), (uint8_t*)ATTR_MIN_PERIOD_STR, ATTR_MIN_PERIOD_LEN -1, 0);
    #####:  716:        SET_OPTION(coap_pkt, COAP_OPTION_URI_QUERY);
        -:  717:    }
    #####:  718:    if (attrP->toClear & LWM2M_ATTR_FLAG_MAX_PERIOD)
        -:  719:    {
    #####:  720:        coap_add_multi_option(&(coap_pkt->uri_query), (uint8_t*)ATTR_MAX_PERIOD_STR, ATTR_MAX_PERIOD_LEN - 1, 0);
    #####:  721:        SET_OPTION(coap_pkt, COAP_OPTION_URI_QUERY);
        -:  722:    }
    #####:  723:    if (attrP->toClear & LWM2M_ATTR_FLAG_GREATER_THAN)
        -:  724:    {
    #####:  725:        coap_add_multi_option(&(coap_pkt->uri_query), (uint8_t*)ATTR_GREATER_THAN_STR, ATTR_GREATER_THAN_LEN - 1, 0);
    #####:  726:        SET_OPTION(coap_pkt, COAP_OPTION_URI_QUERY);
        -:  727:    }
    #####:  728:    if (attrP->toClear & LWM2M_ATTR_FLAG_LESS_THAN)
        -:  729:    {
    #####:  730:        coap_add_multi_option(&(coap_pkt->uri_query), (uint8_t*)ATTR_LESS_THAN_STR, ATTR_LESS_THAN_LEN - 1, 0);
    #####:  731:        SET_OPTION(coap_pkt, COAP_OPTION_URI_QUERY);
        -:  732:    }
    #####:  733:    if (attrP->toClear & LWM2M_ATTR_FLAG_STEP)
        -:  734:    {
    #####:  735:        coap_add_multi_option(&(coap_pkt->uri_query), (uint8_t*)ATTR_STEP_STR, ATTR_STEP_LEN - 1, 0);
    #####:  736:        SET_OPTION(coap_pkt, COAP_OPTION_URI_QUERY);
        -:  737:    }
        -:  738:
    #####:  739:    contextP->transactionList = (lwm2m_transaction_t *)LWM2M_LIST_ADD(contextP->transactionList, transaction);
        -:  740:
    #####:  741:    return transaction_send(contextP, transaction);
        -:  742:}
        -:  743:
    #####:  744:int lwm2m_dm_discover(lwm2m_context_t * contextP,
        -:  745:                      uint16_t clientID,
        -:  746:                      lwm2m_uri_t * uriP,
        -:  747:                      lwm2m_result_callback_t callback,
        -:  748:                      void * userData)
        -:  749:{
        -:  750:    lwm2m_client_t * clientP;
        -:  751:    lwm2m_transaction_t * transaction;
        -:  752:    dm_data_t * dataP;
        -:  753:
        -:  754:    LOG_ARG("clientID: %d", clientID);
        -:  755:    LOG_URI(uriP);
    #####:  756:    clientP = (lwm2m_client_t *)lwm2m_list_find((lwm2m_list_t *)contextP->clientList, clientID);
    #####:  757:    if (clientP == NULL) return COAP_404_NOT_FOUND;
        -:  758:
    #####:  759:    transaction = transaction_new(clientP->sessionH, COAP_GET, clientP->altPath, uriP, contextP->nextMID++, 4, NULL);
    #####:  760:    if (transaction == NULL) return COAP_500_INTERNAL_SERVER_ERROR;
        -:  761:
    #####:  762:    coap_set_header_accept(transaction->message, LWM2M_CONTENT_LINK);
        -:  763:
    #####:  764:    if (callback != NULL)
        -:  765:    {
    #####:  766:        dataP = (dm_data_t *)lwm2m_malloc(sizeof(dm_data_t));
    #####:  767:        if (dataP == NULL)
        -:  768:        {
    #####:  769:            transaction_free(transaction);
    #####:  770:            return COAP_500_INTERNAL_SERVER_ERROR;
        -:  771:        }
    #####:  772:        memcpy(&dataP->uri, uriP, sizeof(lwm2m_uri_t));
    #####:  773:        dataP->clientID = clientP->internalID;
    #####:  774:        dataP->callback = callback;
    #####:  775:        dataP->userData = userData;
        -:  776:
    #####:  777:        transaction->callback = prv_resultCallback;
    #####:  778:        transaction->userData = (void *)dataP;
        -:  779:    }
        -:  780:
    #####:  781:    contextP->transactionList = (lwm2m_transaction_t *)LWM2M_LIST_ADD(contextP->transactionList, transaction);
        -:  782:
    #####:  783:    return transaction_send(contextP, transaction);
        -:  784:}
        -:  785:
        -:  786:#endif
