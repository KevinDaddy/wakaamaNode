        -:    0:Source:/home/david/Programming/wakaamaNode/src/c_objects.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/c_objects.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:#include "lwm2m/c_objects.h"
        -:    2:#include "wakaama/liblwm2m.h"
        -:    3:#include "wakaama/internals.h"
        -:    4:
        -:    5:#include <stdarg.h>
        -:    6:#include <string.h>
        -:    7:
        -:    8:// No-OP default implementation
    #####:    9:void __attribute__((weak)) lwm2m_resource_changed_event(uint16_t object_id, uint16_t object_instance_id, uint16_t resource_id) { }
        -:   10:
    #####:   11:static lwm2m_object_res_item_t* prv_find_ressource(lwm2m_object_meta_information_t* metaP, uint16_t id) {
    #####:   12:    for (int index = 0; index < metaP->ressources_len; index++) {
    #####:   13:        if (metaP->ressources[index].ressource_id == id) {
    #####:   14:            return &metaP->ressources[index];
        -:   15:        }
        -:   16:    }
        -:   17:
    #####:   18:    return NULL;
        -:   19:}
        -:   20:
    #####:   21:int lwm2m_object_prepare_full_response(lwm2m_data_t ** dataArrayP, lwm2m_object_meta_information_t* metaP)
        -:   22:{
    #####:   23:    *dataArrayP = lwm2m_data_new(metaP->ressources_len);
    #####:   24:    if (*dataArrayP == NULL) return -1;
    #####:   25:    int readable = 0;
    #####:   26:    for(unsigned i=0;i<metaP->ressources_len;++i)
        -:   27:    {
    #####:   28:        lwm2m_object_res_item_t* resP = &(metaP->ressources[i]);
    #####:   29:        if (!(resP->access & O_RES_R))
    #####:   30:            continue;
    #####:   31:        lwm2m_data_t* dataP = &(*dataArrayP)[readable];
    #####:   32:        dataP->id = resP->ressource_id;
    #####:   33:        ++readable;
        -:   34:    }
    #####:   35:    return readable;
        -:   36:}
        -:   37:
    #####:   38:uint8_t lwm2m_object_assign_single_value(lwm2m_data_t* destination,
        -:   39:                                         lwm2m_object_res_item_t* resP,
        -:   40:                                         void* instanceP,
        -:   41:                                         lwm2m_context_t* context)
        -:   42:{
    #####:   43:    lwm2m_object_util_type_t res_type = resP->type;
        -:   44:
    #####:   45:    void* memberP = (void*)((char*)instanceP + resP->struct_member_offset);
    #####:   46:    assert(memberP!=NULL);
        -:   47:
        -:   48:    /// Support for function results as value ///
    #####:   49:    if ((resP->access & O_RES_E)==O_RES_E)
        -:   50:    {
    #####:   51:        if ((resP->access & O_RES_RW)==O_RES_RW) {
        -:   52:            struct
        -:   53:            {
        -:   54:                void*(*read)(void);
        -:   55:                void(*write)(void*);
    #####:   56:            } *cbStr = memberP;
        -:   57:            // We do not know the result type of f() yet and use a generic "void*"
    #####:   58:            void* fdata = cbStr->read();
        -:   59:            // Make memberP point to the address of fData.
        -:   60:            // The dereferenced memberP will contain the real data.
    #####:   61:            memberP = &fdata;
    #####:   62:        }else if ((resP->access & O_RES_R)==O_RES_R){
        -:   63:            // The following is equal to this: readFunc f = (readFunc)(*(void**)memberP);
        -:   64:            // But the -pedantic switch forces us to use this union construct.
    #####:   65:            readFunc f = ((union {readFunc to; void *from;} *)memberP)->to;
        -:   66:            // We do not know the result type of f() yet and use a generic "void*"
    #####:   67:            void* fdata = f(context,instanceP);
        -:   68:            // Make memberP point to the address of fData.
        -:   69:            // The dereferenced memberP will contain the real data.
    #####:   70:            memberP = &fdata;
        -:   71:        } else
    #####:   72:            return COAP_405_METHOD_NOT_ALLOWED;
        -:   73:    }
        -:   74:    ///////////////////////////////////////////////////////////////////////
        -:   75:
    #####:   76:    switch (res_type)
        -:   77:    {
    #####:   78:    case O_RES_STRING:
    #####:   79:        lwm2m_data_encode_string(*((char**)memberP), destination);
    #####:   80:        return COAP_205_CONTENT;
    #####:   81:    case O_RES_STRING_PREALLOC: {
    #####:   82:        OpaqueType_t* o = (OpaqueType_t*)memberP;
    #####:   83:        lwm2m_data_encode_string((char*)o->data, destination);
    #####:   84:        return COAP_205_CONTENT;
        -:   85:    }
    #####:   86:    case O_RES_OPAQUE_INDIRECT: {
    #####:   87:        OpaqueIndirect* o = (OpaqueIndirect*)memberP;
    #####:   88:        lwm2m_data_encode_opaque(o->data,o->used_len, destination);
    #####:   89:        return COAP_205_CONTENT;
        -:   90:    }
    #####:   91:    case O_RES_OPAQUE_PREALLOC: {
    #####:   92:        OpaqueType_t* o = (OpaqueType_t*)memberP;
    #####:   93:        lwm2m_data_encode_opaque(o->data,o->used_len, destination);
    #####:   94:        return COAP_205_CONTENT;
        -:   95:    }
    #####:   96:    case O_RES_BOOL:
    #####:   97:        lwm2m_data_encode_bool(*((bool*)memberP), destination);
    #####:   98:        return COAP_205_CONTENT;
    #####:   99:    case O_RES_DOUBLE:
    #####:  100:        lwm2m_data_encode_float(*((double*)memberP), destination);
    #####:  101:        return COAP_205_CONTENT;
    #####:  102:    case O_RES_INT8:
        -:  103:    case O_RES_UINT8:
    #####:  104:        lwm2m_data_encode_int(*((int8_t*)memberP), destination);
    #####:  105:        return COAP_205_CONTENT;
    #####:  106:    case O_RES_INT16:
        -:  107:    case O_RES_UINT16:
    #####:  108:        lwm2m_data_encode_int(*((int16_t*)memberP), destination);
    #####:  109:        return COAP_205_CONTENT;
    #####:  110:    case O_RES_INT32:
        -:  111:    case O_RES_UINT32:
    #####:  112:        lwm2m_data_encode_int(*((int32_t*)memberP), destination);
    #####:  113:        return COAP_205_CONTENT;
    #####:  114:    case O_RES_INT64:
    #####:  115:        lwm2m_data_encode_int(*((int64_t*)memberP), destination);
    #####:  116:        return COAP_205_CONTENT;
    #####:  117:    case O_RES_EXEC:
    #####:  118:        break;
        -:  119:    }
        -:  120:
    #####:  121:    return COAP_404_NOT_FOUND;
        -:  122:}
        -:  123:
    #####:  124:static uint8_t prv_read(uint16_t instanceId,
        -:  125:                        int * numDataP,
        -:  126:                        lwm2m_data_t ** dataArrayP,
        -:  127:                        lwm2m_object_t * objectP,
        -:  128:                        lwm2m_context_t * contextP)
        -:  129:{
    #####:  130:    lwm2m_list_t* instanceP = (lwm2m_list_t *)lwm2m_list_find(objectP->instanceList, instanceId);
    #####:  131:    if (NULL == instanceP) return COAP_404_NOT_FOUND;
        -:  132:
        -:  133:    // The meta data pointer is not an official member of the lwm2m_object_t struct.
    #####:  134:    lwm2m_object_meta_information_t* metaP = (lwm2m_object_meta_information_t*)objectP;
        -:  135:
    #####:  136:    if (*numDataP == 0)
    #####:  137:        *numDataP = lwm2m_object_prepare_full_response(dataArrayP, metaP);
        -:  138:
    #####:  139:    if (*numDataP < 0)
    #####:  140:        return COAP_500_INTERNAL_SERVER_ERROR;
        -:  141:
    #####:  142:    for (int i = 0 ; i < *numDataP ; i++)
        -:  143:    {
    #####:  144:        lwm2m_data_t* dataP = &(*dataArrayP)[i];
    #####:  145:        uint16_t res_id = dataP->id;
    #####:  146:        lwm2m_object_res_item_t* resP = prv_find_ressource(metaP, res_id);
    #####:  147:        if (!resP)
    #####:  148:            return COAP_404_NOT_FOUND;
        -:  149:
    #####:  150:        if (!(resP->access & O_RES_R) || resP->struct_member_offset==0)
    #####:  151:            return COAP_405_METHOD_NOT_ALLOWED;
        -:  152:
    #####:  153:        lwm2m_object_assign_single_value(dataP, resP, instanceP,contextP);
        -:  154:    }
        -:  155:
    #####:  156:    return COAP_205_CONTENT;
        -:  157:}
        -:  158:
        -:  159:
    #####:  160:static uint8_t prv_write(uint16_t instanceId,
        -:  161:                         int numData,
        -:  162:                         lwm2m_data_t * dataArray,
        -:  163:                         lwm2m_object_t * objectP,
        -:  164:                         lwm2m_context_t * contextP)
    #####:  165:{
        -:  166:    (void)contextP;
    #####:  167:    lwm2m_list_t* instanceP = (lwm2m_list_t *)lwm2m_list_find(objectP->instanceList, instanceId);
    #####:  168:    if (NULL == instanceP) return COAP_404_NOT_FOUND;
        -:  169:
        -:  170:    // The meta data pointer is not an official member of the lwm2m_object_t struct.
    #####:  171:    lwm2m_object_meta_information_t* metaP = (lwm2m_object_meta_information_t*)objectP;
        -:  172:
        -:  173:    // For the verify/write callback to be able to deny a change, we hand over a copy
        -:  174:    // of the instance data. The copy is just thrown away if the change is denied.
    #####:  175:    uint8_t copy_of_entry[metaP->instance_object_size];
        -:  176:
    #####:  177:    for (unsigned i = 0 ; i < (unsigned)numData ; ++i)
        -:  178:    {
    #####:  179:        uint16_t res_id = dataArray[i].id;
        -:  180:
    #####:  181:        lwm2m_object_res_item_t* resP = prv_find_ressource(metaP, res_id);
    #####:  182:        if (!resP)
    #####:  183:            return COAP_404_NOT_FOUND;
        -:  184:
        -:  185:        // Check for write access and if offset is set
    #####:  186:        if (!(resP->access & O_RES_W) || resP->struct_member_offset==0)
    #####:  187:            return COAP_405_METHOD_NOT_ALLOWED;
        -:  188:
        -:  189:        // The C-API does not support write-back methods
    #####:  190:        if ((resP->access & O_RES_E) == O_RES_E)
    #####:  191:            return COAP_405_METHOD_NOT_ALLOWED;
        -:  192:
        -:  193:        // Extract ressource type and member pointer from meta object
    #####:  194:        lwm2m_object_util_type_t res_type = resP->type;
        -:  195:
        -:  196:        // For the verify/write callback to be able to deny a change, we hand over a copy
        -:  197:        // of the instance data. The copy is just thrown away if the change is denied.
    #####:  198:        memcpy(copy_of_entry, instanceP, metaP->instance_object_size);
    #####:  199:        void* memberP = (void*)((char*)copy_of_entry + resP->struct_member_offset);
        -:  200:
        -:  201:        union {
        -:  202:            bool b;
        -:  203:            int64_t i;
        -:  204:            double d;
        -:  205:            char* c;
        -:  206:        } temp;
        -:  207:
        -:  208:        // The C-API does not reallocate memory.
        -:  209:        // If there's not enough space, a COAP_413_ENTITY_TOO_LARGE error code is returned.
        -:  210:
    #####:  211:        switch (res_type)
        -:  212:        {
    #####:  213:        case O_RES_OPAQUE_INDIRECT: {
        -:  214:            // We do not apply data directly to the instance object. To make this work for
        -:  215:            // O_RES_OPAQUE_INDIRECT, we let the data pointer point
        -:  216:            // to the receive buffer temporary and copy the data in a post-processing step after
        -:  217:            // the verify/write callback accepted the change.
    #####:  218:            OpaqueIndirect* o = (OpaqueIndirect*)memberP;
    #####:  219:            if (o->reserved_len < dataArray[i].value.asBuffer.length)
    #####:  220:                return COAP_413_ENTITY_TOO_LARGE;
    #####:  221:            temp.c = (char*)o->data; // backup orginal pointer for post-processing
    #####:  222:            o->used_len = dataArray[i].value.asBuffer.length;
    #####:  223:            o->data = dataArray[i].value.asBuffer.buffer;
    #####:  224:            break;
        -:  225:        }
    #####:  226:        case O_RES_OPAQUE_PREALLOC:
        -:  227:        case O_RES_STRING_PREALLOC: {
    #####:  228:            OpaqueType_t* o = (OpaqueType_t*)memberP;
    #####:  229:            if (o->reserved_len < dataArray[i].value.asBuffer.length)
    #####:  230:                return COAP_413_ENTITY_TOO_LARGE;
    #####:  231:            o->used_len = dataArray[i].value.asBuffer.length;
    #####:  232:            memcpy(o->data, (char*)dataArray[i].value.asBuffer.buffer, o->used_len);
    #####:  233:            break;
        -:  234:        }
    #####:  235:        case O_RES_BOOL:
    #####:  236:            if (1 != lwm2m_data_decode_bool(&dataArray[i], &temp.b))
    #####:  237:                return COAP_400_BAD_REQUEST;
    #####:  238:            *((bool*)memberP) = (bool)temp.b;
    #####:  239:            break;
    #####:  240:        case O_RES_DOUBLE:
    #####:  241:            if (1 != lwm2m_data_decode_float(&dataArray[i], &temp.d))
    #####:  242:                return COAP_400_BAD_REQUEST;
    #####:  243:            *((double*)memberP) = temp.d;
    #####:  244:            break;
    #####:  245:        case O_RES_INT8:
    #####:  246:            if (1 != lwm2m_data_decode_int(&dataArray[i], &temp.i) || temp.i < INT8_MIN || temp.i > INT8_MAX)
    #####:  247:                return COAP_400_BAD_REQUEST;
    #####:  248:            *((int8_t*)memberP) = (int8_t)temp.i;
    #####:  249:            break;
    #####:  250:        case O_RES_UINT8:
    #####:  251:            if (1 != lwm2m_data_decode_int(&dataArray[i], &temp.i) || temp.i < 0 || temp.i > UINT8_MAX)
    #####:  252:                return COAP_400_BAD_REQUEST;
    #####:  253:            *((uint8_t*)memberP) = (uint8_t)temp.i;
    #####:  254:            break;
    #####:  255:        case O_RES_INT16:
    #####:  256:            if (1 != lwm2m_data_decode_int(&dataArray[i], &temp.i) || temp.i < INT16_MIN || temp.i > INT16_MAX)
    #####:  257:                return COAP_400_BAD_REQUEST;
    #####:  258:            *((int16_t*)memberP) = (int16_t)temp.i;
    #####:  259:            break;
    #####:  260:        case O_RES_UINT16:
    #####:  261:            if (1 != lwm2m_data_decode_int(&dataArray[i], &temp.i) || temp.i < 0 || temp.i > UINT16_MAX)
    #####:  262:                return COAP_400_BAD_REQUEST;
    #####:  263:            *((uint16_t*)memberP) = (uint16_t)temp.i;
    #####:  264:            break;
    #####:  265:        case O_RES_INT32:
    #####:  266:            if (1 != lwm2m_data_decode_int(&dataArray[i], &temp.i) || temp.i < INT32_MIN || temp.i > INT32_MAX)
    #####:  267:                return COAP_400_BAD_REQUEST;
    #####:  268:            *((int32_t*)memberP) = (int32_t)temp.i;
    #####:  269:            break;
    #####:  270:        case O_RES_UINT32:
    #####:  271:            if (1 != lwm2m_data_decode_int(&dataArray[i], &temp.i) || temp.i < 0 || temp.i > UINT32_MAX)
    #####:  272:                return COAP_400_BAD_REQUEST;
    #####:  273:            *((uint32_t*)memberP) = (uint32_t)temp.i;
    #####:  274:            break;
    #####:  275:        case O_RES_INT64:
    #####:  276:            if (1 != lwm2m_data_decode_int(&dataArray[i], &temp.i))
    #####:  277:                return COAP_400_BAD_REQUEST;
    #####:  278:            *((int64_t*)memberP) = (int64_t)temp.i;
    #####:  279:            break;
    #####:  280:        case O_RES_STRING:
    #####:  281:            return COAP_400_BAD_REQUEST;
    #####:  282:        default:
    #####:  283:            return COAP_500_INTERNAL_SERVER_ERROR;
        -:  284:        }
        -:  285:
    #####:  286:        if (!metaP->write_verify_cb || metaP->write_verify_cb((lwm2m_list_t*)copy_of_entry, res_id))
        -:  287:        {
        -:  288:            // The O_RES_OPAQUE_INDIRECT needs some special handling:
    #####:  289:            if (res_type == O_RES_OPAQUE_INDIRECT) {
    #####:  290:                OpaqueIndirect* o = (OpaqueIndirect*)memberP;
        -:  291:                // Restore the pointer to the original memory area
    #####:  292:                o->data = (uint8_t*)temp.c;
        -:  293:                // Copy the receive buffer to the destination memory address
    #####:  294:                memcpy(o->data, (char*)dataArray[i].value.asBuffer.buffer, o->used_len);
        -:  295:            }
        -:  296:            // The verify method is either not set or accepted the input. Copy the altered
        -:  297:            // instance data back to the original instance.
    #####:  298:            memcpy(instanceP, copy_of_entry, metaP->instance_object_size);
        -:  299:        } else {
    #####:  300:            return COAP_400_BAD_REQUEST;
        -:  301:        }
        -:  302:
    #####:  303:        lwm2m_resource_changed_event(objectP->objID, instanceId, resP->ressource_id);
        -:  304:    }
        -:  305:    
    #####:  306:    return COAP_204_CHANGED;
        -:  307:}
        -:  308:
    #####:  309:static uint8_t prv_execute(uint16_t instanceId,
        -:  310:                    uint16_t resourceId,
        -:  311:                    lwm2m_context_t * contextP,
        -:  312:                    lwm2m_object_t * objectP)
        -:  313:{
        -:  314:    // The meta data pointer is not an official member of the lwm2m_object_t struct.
    #####:  315:    lwm2m_object_meta_information_t* metaP = (lwm2m_object_meta_information_t*)objectP;
        -:  316:
    #####:  317:    lwm2m_list_t* instanceP = (lwm2m_list_t *)lwm2m_list_find(objectP->instanceList, instanceId);
    #####:  318:    if (NULL == instanceP) return COAP_404_NOT_FOUND;
        -:  319:
    #####:  320:    lwm2m_object_res_item_t* resP = prv_find_ressource(metaP, resourceId);
    #####:  321:    if (!resP)
    #####:  322:        return COAP_404_NOT_FOUND;
        -:  323:
    #####:  324:    if (resP->access != O_RES_E)
    #####:  325:        return COAP_405_METHOD_NOT_ALLOWED;
        -:  326:    
    #####:  327:    void* memberP = (void*)((char*)instanceP + resP->struct_member_offset);
        -:  328:    // The following is equal to this: execFunc f = (execFunc)(*(void**)memberP);
        -:  329:    // But the -pedantic switch forces us to use this union construct.
    #####:  330:    execFunc f = ((union {execFunc to; void *from;} *)memberP)->to;
    #####:  331:    if (f)
    #####:  332:        f(contextP, instanceP);
    #####:  333:    return COAP_204_CHANGED;
        -:  334:}
        -:  335:
        -:  336:
    #####:  337:static uint8_t prv_discover(uint16_t instanceId,
        -:  338:                            int * numDataP,
        -:  339:                            lwm2m_data_t ** dataArrayP,
        -:  340:                            lwm2m_object_t * objectP)
        -:  341:{
    #####:  342:    lwm2m_list_t* instanceP = (lwm2m_list_t *)lwm2m_list_find(objectP->instanceList, instanceId);
    #####:  343:    if (NULL == instanceP) return COAP_404_NOT_FOUND;
        -:  344:
        -:  345:    // The meta data pointer is not an official member of the lwm2m_object_t struct.
    #####:  346:    lwm2m_object_meta_information_t* metaP = (lwm2m_object_meta_information_t*)objectP;
        -:  347:
        -:  348:    // is the server asking for the full object ?
    #####:  349:    if (*numDataP == 0)
        -:  350:    {
    #####:  351:        *dataArrayP = lwm2m_data_new(metaP->ressources_len);
    #####:  352:        if (*dataArrayP == NULL)
    #####:  353:            return COAP_500_INTERNAL_SERVER_ERROR;
    #####:  354:        int readable = 0;
    #####:  355:        for(unsigned i=0;i<metaP->ressources_len;++i)
        -:  356:        {
    #####:  357:            lwm2m_object_res_item_t* resP = &metaP->ressources[i];
    #####:  358:            if (!(resP->access & (O_RES_RW|O_RES_E)))
    #####:  359:                continue;
    #####:  360:            lwm2m_data_t* dataP = &(*dataArrayP)[readable];
    #####:  361:            dataP->id = resP->ressource_id;
    #####:  362:            ++readable;
        -:  363:        }
    #####:  364:        *numDataP = readable;
    #####:  365:        return COAP_205_CONTENT;
        -:  366:    }
        -:  367:
    #####:  368:    for (unsigned i = 0; i < (unsigned)*numDataP; ++i)
        -:  369:    {
    #####:  370:        lwm2m_data_t* dataP = &(*dataArrayP)[i];
    #####:  371:        if (dataP->id >= metaP->ressources_len) {
    #####:  372:            return COAP_404_NOT_FOUND;
        -:  373:        }
        -:  374:    }
    #####:  375:    return COAP_205_CONTENT;
        -:  376:}
        -:  377:
        -:  378:
    #####:  379:static uint8_t prv_delete(uint16_t id,
        -:  380:                          lwm2m_object_t * objectP)
        -:  381:{
        -:  382:    lwm2m_list_t * targetP;
    #####:  383:    objectP->instanceList = lwm2m_list_remove(objectP->instanceList, id, (lwm2m_list_t **)&targetP);
    #####:  384:    if (NULL == targetP) return COAP_404_NOT_FOUND;
        -:  385:
    #####:  386:    lwm2m_free(targetP);
        -:  387:
    #####:  388:    return COAP_202_DELETED;
        -:  389:}
        -:  390:
    #####:  391:static uint8_t prv_create(uint16_t instanceId,
        -:  392:                          int numData,
        -:  393:                          lwm2m_data_t * dataArray,
        -:  394:                          lwm2m_object_t * objectP,
        -:  395:                          lwm2m_context_t * contextP)
        -:  396:{
        -:  397:    // The meta data pointer is not an official member of the lwm2m_object_t struct.
    #####:  398:    lwm2m_object_meta_information_t* metaP = (lwm2m_object_meta_information_t*)objectP;
        -:  399:
    #####:  400:    lwm2m_list_t* instanceP = (lwm2m_list_t *)lwm2m_malloc(metaP->instance_object_size);
    #####:  401:    if (NULL == instanceP)
    #####:  402:        return COAP_500_INTERNAL_SERVER_ERROR;
        -:  403:
    #####:  404:    memset(instanceP, 0, metaP->instance_object_size);
        -:  405:
    #####:  406:    instanceP->id = instanceId;
    #####:  407:    objectP->instanceList = LWM2M_LIST_ADD(objectP->instanceList, instanceP);
        -:  408:
    #####:  409:    uint8_t result = prv_write(instanceId, numData, dataArray, objectP,contextP);
        -:  410:
    #####:  411:    if (result != COAP_204_CHANGED)
        -:  412:    {
    #####:  413:        (void)prv_delete(instanceId, objectP);
        -:  414:    }
        -:  415:    else
        -:  416:    {
    #####:  417:        result = COAP_201_CREATED;
        -:  418:    }
        -:  419:
    #####:  420:    return result;
        -:  421:}
        -:  422:
    #####:  423:int lwm2m_add_initialize_object(lwm2m_context_t * contextP,
        -:  424:                                lwm2m_object_t* object,
        -:  425:                                bool allow_dynamic_instance_creation)
        -:  426:{
    #####:  427:    lwm2m_object_meta_information_t* m = (lwm2m_object_meta_information_t*)object;
    #####:  428:    m->obj.readFunc = prv_read;
    #####:  429:    m->obj.writeFunc = prv_write;
    #####:  430:    m->obj.discoverFunc = prv_discover;
    #####:  431:    m->obj.executeFunc = prv_execute;
        -:  432:
    #####:  433:    if (allow_dynamic_instance_creation)
        -:  434:    {
    #####:  435:        m->obj.createFunc = prv_create;
    #####:  436:        m->obj.deleteFunc = prv_delete;
        -:  437:    }
        -:  438:
    #####:  439:    if (object->objID>3)
    #####:  440:        return lwm2m_add_object(contextP,object);
        -:  441:    else
    #####:  442:        return COAP_NO_ERROR;
        -:  443:}
        -:  444:
    #####:  445:int lwm2m_object_instance_add(lwm2m_context_t * contextP, lwm2m_object_t* object, lwm2m_list_t* instance) {
    #####:  446:    if (!object_isInstanceNew(contextP, object->objID, instance->id)) return COAP_IGNORE;
    #####:  447:    object->instanceList = lwm2m_list_add(object->instanceList, instance);
        -:  448:
        -:  449:    // Update server registration if connected and object is known to wakaama
    #####:  450:    if (contextP->state == STATE_READY && LWM2M_LIST_FIND(contextP->objectList, object->objID) != NULL)
        -:  451:    {
    #####:  452:        return lwm2m_update_registration(contextP, 0, true);
        -:  453:    }
    #####:  454:    return COAP_NO_ERROR;
        -:  455:}
        -:  456:
    #####:  457:lwm2m_list_t* lwm2m_object_instance_remove(lwm2m_context_t * contextP, lwm2m_object_t* object, uint16_t instance_id) {
    #####:  458:    lwm2m_list_t* removed = NULL;
    #####:  459:    object->instanceList = lwm2m_list_remove(object->instanceList, instance_id, &removed);
        -:  460:
    #####:  461:    if (contextP->state == STATE_READY && LWM2M_LIST_FIND(contextP->objectList, object->objID) != NULL)
        -:  462:    {
    #####:  463:        lwm2m_update_registration(contextP, 0, true);
        -:  464:    }
    #####:  465:    return removed;
        -:  466:}
