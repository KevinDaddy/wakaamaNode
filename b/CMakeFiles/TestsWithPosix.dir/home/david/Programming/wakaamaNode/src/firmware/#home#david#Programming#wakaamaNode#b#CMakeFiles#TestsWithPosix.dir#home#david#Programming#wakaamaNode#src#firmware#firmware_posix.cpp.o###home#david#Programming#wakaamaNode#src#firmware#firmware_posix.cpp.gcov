        -:    0:Source:/home/david/Programming/wakaamaNode/src/firmware/firmware_posix.cpp
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/firmware/firmware_posix.cpp.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*******************************************************************************
        -:    2: * Copyright (c) 2017-2018  David Graeff <david.graeff@web.de>
        -:    3: *
        -:    4: * Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    5: * of this software and associated documentation files (the "Software"), to deal
        -:    6: * in the Software without restriction, including without limitation the rights
        -:    7: * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:    8: * copies of the Software, and to permit persons to whom the Software is
        -:    9: * furnished to do so, subject to the following conditions:
        -:   10: *
        -:   11: * The above copyright notice and this permission notice shall be included in
        -:   12: * all copies or substantial portions of the Software.
        -:   13: */
        -:   14:typedef int make_iso_compilers_happy; // if not LWIP
        -:   15:
        -:   16:#include "wakaama_config.h"
        -:   17:
        -:   18:#ifdef LWM2M_FIRMWARE_UPGRADES
        -:   19:#include "lwm2m/firmware.h"
        -:   20:#include "lwm2m/connect.h"
        -:   21:
        -:   22:#if (defined(_WIN32) || defined(__unix__))
        -:   23:#include <iostream>
        -:   24:#include <fstream>
        -:   25:using namespace std;
        -:   26:#endif
        -:   27:
        -:   28:#ifdef _WIN32
        -:   29:#include <windows.h>
        -:   30:
        -:   31:void startup(const char* lpApplicationName) {
        -:   32:   // additional information
        -:   33:   STARTUPINFO si;
        -:   34:   PROCESS_INFORMATION pi;
        -:   35:
        -:   36:   // set the size of the structures
        -:   37:   ZeroMemory( &si, sizeof(si) );
        -:   38:   si.cb = sizeof(si);
        -:   39:   ZeroMemory( &pi, sizeof(pi) );
        -:   40:
        -:   41:  // start the program up
        -:   42:  CreateProcess( lpApplicationName,   // the path
        -:   43:    (string(lpApplicationName)+" oldexe="+to_string(parent_pid)).c_str(),        // Command line
        -:   44:    NULL,           // Process handle not inheritable
        -:   45:    NULL,           // Thread handle not inheritable
        -:   46:    FALSE,          // Set handle inheritance to FALSE
        -:   47:    0,              // No creation flags
        -:   48:    NULL,           // Use parent's environment block
        -:   49:    NULL,           // Use parent's starting directory
        -:   50:    &si,            // Pointer to STARTUPINFO structure
        -:   51:    &pi             // Pointer to PROCESS_INFORMATION structure (removed extra parentheses)
        -:   52:    );
        -:   53:    // Close process and thread handles.
        -:   54:    CloseHandle( pi.hProcess );
        -:   55:    CloseHandle( pi.hThread );
        -:   56:}
        -:   57:#endif
        -:   58:
        -:   59:#if defined(__unix__)
        -:   60:
        -:   61:#include <sys/types.h>
        -:   62:#include <signal.h>
        -:   63:#include <unistd.h>
    #####:   64:void startup(const char* lpApplicationName) {
        -:   65:    pid_t parent_pid;
        -:   66:    pid_t child_pid;
        -:   67:    // so the child can send a signal to the parent if needed
    #####:   68:    parent_pid = getpid();
        -:   69:
    #####:   70:    child_pid = fork();
    #####:   71:    switch( child_pid )
        -:   72:    {
    #####:   73:      case -1:
    #####:   74:         perror( "[fork-exec-test] fork failed" );
    #####:   75:         exit( EXIT_FAILURE );
        -:   76:         break;
        -:   77:
    #####:   78:      case 0:
        -:   79:         // the program should receive its own command as argv[0]
    #####:   80:         execlp( lpApplicationName, string("oldexe="+to_string(parent_pid)).c_str(), NULL );
        -:   81:         // should't return
    #####:   82:         perror( "[fork-exec-test] exec failed" );
    #####:   83:         exit( EXIT_FAILURE );
        -:   84:         break;
        -:   85:
    #####:   86:      default:
        -:   87:         // no errors
    #####:   88:         break;
        -:   89:    }
    #####:   90:}
        -:   91:
        -:   92:#endif
        -:   93:
        -:   94:#if (defined(_WIN32) || defined(__unix__))
        -:   95:
    #####:   96:void FirmwareUpdate::process() {}
        -:   97:
    #####:   98:inline bool exists (const std::string& name) {
    #####:   99:    ifstream f(name.c_str());
    #####:  100:    return f.good();
        -:  101:}
        -:  102:
    #####:  103:void writeNewFirmware(Lwm2mObjectInstance* o, DynArray<uint8_t*>& firmware) {
    #####:  104:    FirmwareUpdate* fu = static_cast<FirmwareUpdate*>(o);
    #####:  105:    string newname = "new." + fu->executableFilename;
    #####:  106:    ofstream fout(newname, ofstream::trunc);
    #####:  107:    if (!fout.is_open()) {
    #####:  108:        cerr << "Cannot open file for writing " << newname << endl;
    #####:  109:        return;
        -:  110:    }
    #####:  111:    fout.write((const char*)firmware.data, firmware.len);
    #####:  112:    fout.close();
        -:  113:}
        -:  114:
    #####:  115:void executeFirmwareUpdate(Lwm2mObjectInstance* o, lwm2m_context_t* context) {
    #####:  116:    FirmwareUpdate* fu = static_cast<FirmwareUpdate*>(o);
        -:  117:
    #####:  118:    string newname = "new." + fu->executableFilename;
    #####:  119:    if (!exists(newname)) return;
        -:  120:
    #####:  121:    if (exists("old."+fu->executableFilename)) {
    #####:  122:        remove(("old."+fu->executableFilename).c_str());
        -:  123:    }
    #####:  124:    if (rename(fu->executableFilename.c_str(), ("old."+fu->executableFilename).c_str())) {
    #####:  125:        cerr << "Cannot move old executable " << fu->executableFilename << endl;
    #####:  126:        return;
        -:  127:    }
    #####:  128:    if (rename(newname.c_str(), fu->executableFilename.c_str())) {
    #####:  129:        cerr << "Cannot move " << newname << " to " << fu->executableFilename << endl;
    #####:  130:        return;
        -:  131:    }
        -:  132:
    #####:  133:    fu->UpdateResult=UPDATE_RESULT_STATE_SUCCESS;
    #####:  134:    fu->firmwareObject.resChanged(context,0,(uint16_t)KnownObjects::id5::RESID::UpdateResult);
        -:  135:
    #####:  136:    startup(fu->executableFilename.c_str());
    #####:  137:    sigset_t sigset{};
    #####:  138:    sigemptyset(&sigset);
    #####:  139:    sigaddset(&sigset,SIGKILL);
        -:  140:    siginfo_t info;
        -:  141:    timespec t;
    #####:  142:    t.tv_nsec=1000*500;
    #####:  143:    int s = sigtimedwait(&sigset,&info,&t);
    #####:  144:    if (s==SIGKILL){
    #####:  145:        cout << "Update completed"<<endl;
    #####:  146:        exit(0);
    #####:  147:    } else if (s==EINTR) {
    #####:  148:        cout << "Updated process didn't report back in time"<<endl;
        -:  149:    } else {
    #####:  150:        cerr << "Error with sigtimedwait " << info.si_errno<<endl;
        -:  151:    }
        -:  152:}
        -:  153:
    #####:  154:FirmwareUpdate::FirmwareUpdate(const char* app_version, lwm2m_update_protocol protocol) {
    #####:  155:    Package = writeNewFirmware;
    #####:  156:    Update = executeFirmwareUpdate;
    #####:  157:    FirmwareUpdateProtocolSupport = protocol;
    #####:  158:    FirmwareUpdateDeliveryMethod = UPDATE_DELIVERY_PUSHPULL;
    #####:  159:    PkgVersion.copy(app_version);
    #####:  160:    State = UPDATE_STATE_IDLE;
    #####:  161:    UpdateResult=UPDATE_RESULT_STATE_IDLE;
    #####:  162:}
        -:  163:
    #####:  164:void FirmwareUpdate::checkIsUpdated(int argc, char** argv) {
    #####:  165:   executableFilename = argv[0];
    #####:  166:   const size_t last_slash_idx = executableFilename.find_last_of("\\/");
    #####:  167:   if (std::string::npos != last_slash_idx)
    #####:  168:       executableFilename.erase(0, last_slash_idx + 1);
    #####:  169:   State=exists("new." + executableFilename) ? UPDATE_STATE_DOWNLOADED :UPDATE_STATE_IDLE;
    #####:  170:   PkgName.copy(argv[0]);
        -:  171:
    #####:  172:   int pid = -1;
    #####:  173:   for (int i=0;i<argc;++i){
    #####:  174:       auto arg = std::string(argv[i]);
    #####:  175:       if (arg.find("oldexe=")!=std::string::npos) {
    #####:  176:           arg = arg.substr(arg.find("="));
    #####:  177:           pid = std::stoi(arg);
    #####:  178:           break;
        -:  179:       }
        -:  180:   }
    #####:  181:   if (pid != -1) {
    #####:  182:        kill(pid, SIGKILL);
    #####:  183:        cout << "Wait for old executable to terminate: " << pid << endl;
    #####:  184:        usleep(200*1000);
        -:  185:   }
    #####:  186:}
        -:  187:#endif
        -:  188:
        -:  189:#endif
