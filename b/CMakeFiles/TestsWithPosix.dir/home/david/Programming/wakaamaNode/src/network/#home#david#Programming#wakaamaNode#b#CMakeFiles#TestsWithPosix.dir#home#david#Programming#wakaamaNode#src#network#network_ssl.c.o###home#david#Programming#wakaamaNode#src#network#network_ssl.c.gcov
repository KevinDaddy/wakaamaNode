        -:    0:Source:/home/david/Programming/wakaamaNode/src/network/network_ssl.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/network/network_ssl.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*******************************************************************************
        -:    2: * Copyright (c) 2017-2018  David Graeff <david.graeff@web.de>
        -:    3: *
        -:    4: * Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    5: * of this software and associated documentation files (the "Software"), to deal
        -:    6: * in the Software without restriction, including without limitation the rights
        -:    7: * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:    8: * copies of the Software, and to permit persons to whom the Software is
        -:    9: * furnished to do so, subject to the following conditions:
        -:   10: *
        -:   11: * The above copyright notice and this permission notice shall be included in
        -:   12: * all copies or substantial portions of the Software.
        -:   13: */
        -:   14:
        -:   15:#include "lwm2m/c_connect.h"
        -:   16:#include "lwm2m/network.h"
        -:   17:#include "lwm2m/debug.h"
        -:   18:#include "../internal.h"
        -:   19:#include "network_common.h"
        -:   20:#include <stdio.h>
        -:   21:#include <errno.h>
        -:   22:#include <stdlib.h>
        -:   23:#include <string.h>
        -:   24:
        -:   25:typedef int make_iso_compilers_happy; // if not LWM2M_WITH_DTLS
        -:   26:
        -:   27:#ifdef LWM2M_WITH_DTLS
        -:   28:
        -:   29:/**
        -:   30: * \brief          Set a pair of delays to watch
        -:   31: *                 (See \c mbedtls_timing_get_delay().)
        -:   32: *
        -:   33: * \param data     Pointer to timing data.
        -:   34: *                 Must point to a valid \c mbedtls_timing_delay_context struct.
        -:   35: * \param int_ms   First (intermediate) delay in milliseconds.
        -:   36: *                 The effect if int_ms > fin_ms is unspecified.
        -:   37: * \param fin_ms   Second (final) delay in milliseconds.
        -:   38: *                 Pass 0 to cancel the current delay.
        -:   39: *
        -:   40: * \note           To set a single delay, either use \c mbedtls_timing_set_timer
        -:   41: *                 directly or use this function with int_ms == fin_ms.
        -:   42: */
    #####:   43:static void set_delay( void *data, uint32_t int_ms, uint32_t fin_ms ) {
    #####:   44:    connection_t * connection = (connection_t *)data;
    #####:   45:    connection->tmr_intermediate_ms = int_ms;
    #####:   46:    connection->tmr_final_ms = fin_ms;
    #####:   47:    gettimeofday( &connection->tmr_current, NULL );
        -:   48:
    #####:   49:    if (!fin_ms) {
    #####:   50:        connection->network->cached_next_timer_connection = NULL;
    #####:   51:        return;
        -:   52:    }
        -:   53:
    #####:   54:    connection_t * next_timer_connection = connection->network->cached_next_timer_connection;
        -:   55:
        -:   56:    // cached_next_timer_connection always points to the next point in time of all connections
    #####:   57:    if (next_timer_connection) {
    #####:   58:        if (next_timer_connection == connection) return;
    #####:   59:        if (timercmp(&next_timer_connection->tmr_current,&connection->tmr_current,>)) {
    #####:   60:            connection->network->cached_next_timer_connection = connection;
        -:   61:        }
        -:   62:    } else
    #####:   63:        connection->network->cached_next_timer_connection = connection;
        -:   64:}
        -:   65:
        -:   66:/**
        -:   67: * \brief          Get the status of delays
        -:   68: *                 (Memory helper: number of delays passed.)
        -:   69: *
        -:   70: * \param data     Pointer to timing data
        -:   71: *                 Must point to a valid \c mbedtls_timing_delay_context struct.
        -:   72: *
        -:   73: * \return         -1 if cancelled (fin_ms = 0),
        -:   74: *                  0 if none of the delays are passed,
        -:   75: *                  1 if only the intermediate delay is passed,
        -:   76: *                  2 if the final delay is passed.
        -:   77: */
    #####:   78:static int get_delay( void *data ){
    #####:   79:    connection_t * connection = (connection_t *)data;
        -:   80:
        -:   81:    unsigned long elapsed_ms;
        -:   82:
    #####:   83:    if( connection->tmr_final_ms == 0 )
    #####:   84:        return( -1 );
        -:   85:
        -:   86:    struct timeval now;
    #####:   87:    gettimeofday( &now, NULL );
    #####:   88:    elapsed_ms = (unsigned long)( now.tv_sec  - connection->tmr_current.tv_sec  ) * 1000ul
    #####:   89:          + (unsigned long)( now.tv_usec - connection->tmr_current.tv_usec ) / 1000;
        -:   90:
    #####:   91:    if( elapsed_ms >= connection->tmr_final_ms )
    #####:   92:        return( 2 );
        -:   93:
    #####:   94:    if( elapsed_ms >= connection->tmr_intermediate_ms )
    #####:   95:        return( 1 );
        -:   96:
    #####:   97:    return( 0 );
        -:   98:}
        -:   99:
    #####:  100:static void my_debug( void *ctx, int level,
        -:  101:                      const char *file, int line, const char *str )
        -:  102:{
        -:  103:    (void) ctx;
        -:  104:    (void) level;
        -:  105:    (void) file;
        -:  106:    (void) line;
        -:  107:    (void) str;
    #####:  108:    network_log_error("%s:%04d: %s", file, line, str);
    #####:  109:}
        -:  110:
        -:  111:#ifdef LWM2M_SERVER_MODE
        -:  112:
    #####:  113:static int cb_check_psk(void *parameter, mbedtls_ssl_context *ssl, const unsigned char *psk_identity, size_t identity_len) {
    #####:  114:    network_t* network = (network_t*)parameter;
        -:  115:    (void)psk_identity;
        -:  116:    (void)identity_len;
    #####:  117:    return mbedtls_ssl_set_hs_psk(ssl,(const unsigned char*)network->secretKey,network->secretKeyLen);
        -:  118:}
        -:  119:
    #####:  120:int init_server_connection_ssl(connection_t* connection, network_t* network) {
        -:  121:    int ret;
    #####:  122:    mbedtls_ssl_init( &connection->ssl );
    #####:  123:    mbedtls_ssl_config_init( &connection->conf );
    #####:  124:    if( ( ret = mbedtls_ssl_config_defaults( &connection->conf,
        -:  125:                    MBEDTLS_SSL_IS_SERVER,
        -:  126:                    MBEDTLS_SSL_TRANSPORT_DATAGRAM,
        -:  127:                    MBEDTLS_SSL_PRESET_DEFAULT ) ) != 0 )
        -:  128:    {
    #####:  129:        network_log_error("mbedtls_ssl_config_defaults returned %d\r\n", ret);
        -:  130:    }
    #####:  131:    mbedtls_ssl_conf_authmode( &connection->conf, MBEDTLS_SSL_VERIFY_NONE );
    #####:  132:    mbedtls_ssl_conf_rng( &connection->conf, mbedtls_ctr_drbg_random, &network->ctr_drbg );
    #####:  133:    mbedtls_ssl_conf_dbg( &connection->conf, my_debug, stdout );
    #####:  134:    mbedtls_ssl_set_bio( &connection->ssl, connection,
        -:  135:                         mbedtls_net_send, mbedtls_net_recv, NULL );
    #####:  136:    mbedtls_ssl_conf_psk_cb(&connection->conf, cb_check_psk, network);
    #####:  137:    mbedtls_ssl_conf_dtls_cookies(&connection->conf,
        -:  138:                                  mbedtls_ssl_cookie_write,
        -:  139:                                  mbedtls_ssl_cookie_check,
    #####:  140:                                  &network->cookies);
    #####:  141:    mbedtls_ssl_set_timer_cb(&connection->ssl,connection,set_delay,get_delay);
    #####:  142:    if( ( ret = mbedtls_ssl_setup (&connection->ssl,&connection->conf ) ) != 0 ){
    #####:  143:        network_log_error("mbedtls_ssl_config_defaults returned %d\r\n", ret);
        -:  144:    }
    #####:  145:    if( ( ret = mbedtls_ssl_set_client_transport_id(&connection->ssl,(void*)&connection->addr,sizeof(addr_t) ) ) != 0 ){
    #####:  146:        network_log_error("mbedtls_ssl_config_defaults returned %d\r\n", ret);
        -:  147:    }
    #####:  148:    return 0;
        -:  149:}
        -:  150:
        -:  151:#endif
        -:  152:
    #####:  153:static int mbedtls_entropy_f_source(void *data, unsigned char *output, size_t len, size_t *olen) {
        -:  154:    (void)data;
    #####:  155:    while (len>sizeof(long)) {
    #####:  156:        int r = rand();
    #####:  157:        memcpy(output,(void*)&r,sizeof(r));
    #####:  158:        len -= sizeof(r);
    #####:  159:        *olen += sizeof(r);
        -:  160:    }
    #####:  161:    return 0;
        -:  162:}
        -:  163:
    #####:  164:bool internal_network_ssl_init(network_t* network) {
    #####:  165:    mbedtls_debug_set_threshold(1);
        -:  166:    // Always init all cryptographic functionality
        -:  167:    //mbedtls_x509_crt_init( &network->certs ); // Certificate chains for DTLS not yet supported
    #####:  168:    mbedtls_ctr_drbg_init( &network->ctr_drbg );
    #####:  169:    mbedtls_entropy_init( &network->entropy );
        -:  170:    static const unsigned char pers[] = "lwm2m_library";
    #####:  171:    mbedtls_entropy_add_source (&network->entropy,mbedtls_entropy_f_source,
        -:  172:                                NULL,0,MBEDTLS_ENTROPY_SOURCE_STRONG);
    #####:  173:    if(mbedtls_ctr_drbg_seed(&network->ctr_drbg, mbedtls_entropy_func,
    #####:  174:                             &network->entropy, pers, sizeof(pers)) != 0 ) {
    #####:  175:        network_log_error("mbedtls_ctr_drbg_seed failed\n" );
    #####:  176:        return false;
        -:  177:    }
        -:  178:    #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY) && defined(LWM2M_SERVER_MODE)
    #####:  179:    mbedtls_ssl_cookie_init(&network->cookies);
    #####:  180:    if (mbedtls_ssl_cookie_setup(&network->cookies,mbedtls_ctr_drbg_random, &network->ctr_drbg)!=0) {
    #####:  181:        network_log_error("mbedtls_ssl_cookie_setup failed\n" );
    #####:  182:        return false;
        -:  183:    }
        -:  184:    #endif
    #####:  185:    return true;
        -:  186:}
        -:  187:
    #####:  188:static inline void check_handshake_over(network_t* network,
        -:  189:                                        bool inHandshake,
        -:  190:                                        connection_t* connection ) {
        -:  191:    // If handshake is done after this received packet, compute global handshake flag
    #####:  192:    if (inHandshake && connection->ssl.state == MBEDTLS_SSL_HANDSHAKE_OVER) {
    #####:  193:        connection_t* c = network->connection_list;
        -:  194:        // Update network->inHandshake connection global flag.
        -:  195:        // While we are in a handshake, the lwm2m state machine is not called
    #####:  196:        bool inHandshake = false;
    #####:  197:        while (c) {
    #####:  198:            inHandshake |= c->dtls && c->ssl.state!=MBEDTLS_SSL_HANDSHAKE_OVER;
    #####:  199:            c = c->next;
        -:  200:        }
    #####:  201:        network->inHandshake = inHandshake;
        -:  202:    }
    #####:  203:}
        -:  204:
    #####:  205:void internal_check_timer(lwm2m_context_t *contextP, struct timeval* next_event) {
    #####:  206:    network_t* network = (network_t*)contextP->userData;
    #####:  207:    if (!network->cached_next_timer_connection) return;
        -:  208:
        -:  209:    struct timeval tmr_current;
    #####:  210:    gettimeofday( &tmr_current, NULL );
        -:  211:
        -:  212:    // cached_next_timer_connection always points to the next point in time of all connections
    #####:  213:    if (timercmp(&network->cached_next_timer_connection->tmr_current,&tmr_current,<)) {
    #####:  214:        network->cached_next_timer_connection = NULL;
        -:  215:        // check all connections
    #####:  216:        connection_t* c = network->connection_list;
    #####:  217:        while (c) {
    #####:  218:            if (get_delay(c)==2){
    #####:  219:                bool inHandshake = c->ssl.state != MBEDTLS_SSL_HANDSHAKE_OVER;
    #####:  220:                int r = mbedtls_ssl_handshake(&c->ssl);
    #####:  221:                check_handshake_over(network, inHandshake, c);
    #####:  222:                if (r<0){
    #####:  223:                    if (r==MBEDTLS_ERR_SSL_WANT_READ)
    #####:  224:                        return;
    #####:  225:                    network_log_error("mbedtls_ssl_handshake failed %i\r\n", r);
        -:  226:                }
        -:  227:            }
    #####:  228:            c = c->next;
        -:  229:        }
    #####:  230:    } else if (next_event) { // Adjust next_event
        -:  231:        struct timeval relative_next;
    #####:  232:        timersub(&tmr_current,&network->cached_next_timer_connection->tmr_current,&relative_next);
    #####:  233:        if (timercmp(&relative_next,next_event,<)) {
    #####:  234:            *next_event = relative_next;
        -:  235:        }
        -:  236:    }
        -:  237:}
        -:  238:
    #####:  239:connection_t * internal_configure_ssl(connection_t * connection,
        -:  240:                                             network_t* network,
        -:  241:                                             security_instance_t* secInst) {
    #####:  242:    if (connection->dtls) {
        -:  243:        int ret;
    #####:  244:        mbedtls_ssl_init( &connection->ssl );
    #####:  245:        mbedtls_ssl_config_init( &connection->conf );
    #####:  246:        if( ( ret = mbedtls_ssl_config_defaults( &connection->conf,
        -:  247:                        MBEDTLS_SSL_IS_CLIENT,
        -:  248:                        MBEDTLS_SSL_TRANSPORT_DATAGRAM,
        -:  249:                        MBEDTLS_SSL_PRESET_DEFAULT ) ) != 0 )
        -:  250:        {
    #####:  251:            network_log_error("mbedtls_ssl_config_defaults returned %d\r\n", ret);
    #####:  252:            lwm2m_free(connection);
    #####:  253:            return NULL;
        -:  254:        }
    #####:  255:        mbedtls_ssl_conf_psk(&connection->conf,
    #####:  256:                             ( const unsigned char*)secInst->secretKey,secInst->secretKeyLen,
    #####:  257:                            ( const unsigned char*) secInst->publicIdentity,secInst->publicIdLen);
    #####:  258:        mbedtls_ssl_conf_authmode( &connection->conf, MBEDTLS_SSL_VERIFY_NONE );
    #####:  259:        mbedtls_ssl_conf_rng( &connection->conf, mbedtls_ctr_drbg_random, &network->ctr_drbg );
    #####:  260:        mbedtls_ssl_conf_dbg( &connection->conf, my_debug, stdout );
        -:  261://            if( ( ret = mbedtls_ssl_set_hostname( &newConnP->ssl, "mbed TLS Server" ) ) != 0 ) {
        -:  262://                network_log_error(" failed\n  ! mbedtls_ssl_set_hostname returned %d\n\n", ret);
        -:  263://                lwm2m_free(newConnP);
        -:  264://                return NULL;
        -:  265://            }
    #####:  266:        mbedtls_ssl_set_bio( &connection->ssl, connection,
        -:  267:                             mbedtls_net_send, mbedtls_net_recv, NULL );
    #####:  268:        mbedtls_ssl_set_timer_cb(&connection->ssl,connection,set_delay,get_delay);
    #####:  269:        mbedtls_ssl_setup (&connection->ssl,&connection->conf );
        -:  270:
    #####:  271:        if( ( ret = mbedtls_ssl_handshake( &connection->ssl ) ) != 0 ) {
    #####:  272:            if (ret != MBEDTLS_ERR_SSL_WANT_READ && ret != MBEDTLS_ERR_SSL_WANT_WRITE){
    #####:  273:                network_log_error("mbedtls_ssl_handshake failed %x\n", -ret);
    #####:  274:                lwm2m_free(connection);
    #####:  275:                return NULL;
        -:  276:            }
        -:  277:        }
    #####:  278:        network->inHandshake = true;
        -:  279:    }
    #####:  280:    return connection;
        -:  281:}
        -:  282:
    #####:  283:inline bool internal_in_dtls_handshake(lwm2m_context_t *contextP){
    #####:  284:    network_t* network = (network_t*)contextP->userData;
    #####:  285:    return network->inHandshake;
        -:  286:}
        -:  287:
    #####:  288:void internal_close_connection_ssl(network_t* network, connection_t * t) {
    #####:  289:    if (network->cached_next_timer_connection == t)
    #####:  290:        network->cached_next_timer_connection = NULL;
    #####:  291:    if(t->dtls){
    #####:  292:        mbedtls_ssl_free( &t->ssl );
    #####:  293:        mbedtls_ssl_config_free( &t->conf );
        -:  294:    }
    #####:  295:}
        -:  296:
    #####:  297:void internal_network_close_ssl(network_t* network) {
    #####:  298:    mbedtls_ctr_drbg_free( &network->ctr_drbg );
    #####:  299:    mbedtls_entropy_free( &network->entropy );
        -:  300:    #if defined(LWM2M_SERVER_MODE)
        -:  301:        #if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
    #####:  302:            mbedtls_ssl_cookie_free ( &network->cookies );
        -:  303:        #endif
    #####:  304:        lwm2m_free(network->publicIdentity);
    #####:  305:        lwm2m_free(network->serverPublicKey);
    #####:  306:        lwm2m_free(network->secretKey);
        -:  307:    #endif
    #####:  308:}
        -:  309:
    #####:  310:void internal_network_read(lwm2m_context_t* contextP, void *dest, size_t len, connection_t *connection) {
        -:  311:    ssize_t r;
    #####:  312:    network_t* network = (network_t*)contextP->userData;
    #####:  313:    if (connection->dtls) {
    #####:  314:        bool inHandshake = connection->ssl.state != MBEDTLS_SSL_HANDSHAKE_OVER;
    #####:  315:        r = mbedtls_ssl_read(&connection->ssl, dest, (size_t)len);
    #####:  316:        check_handshake_over(network, inHandshake, connection);
    #####:  317:        if (r==MBEDTLS_ERR_SSL_WANT_READ)
    #####:  318:            return;
    #####:  319:        if (r<0){
        -:  320:            int ret;
    #####:  321:            if (network->type==NET_SERVER_PROCESS &&
        -:  322:                    r==MBEDTLS_ERR_SSL_CLIENT_RECONNECT){
    #####:  323:                if( ( ret = mbedtls_ssl_handshake(&connection->ssl) ) != 0 ){
    #####:  324:                    network_log_error("mbedtls_ssl_handshake returned %d\r\n", ret);
        -:  325:                }
    #####:  326:                return;
        -:  327:            }
        -:  328:
    #####:  329:            switch(r) {
    #####:  330:                case MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED:
    #####:  331:                    network_log_info("MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED!\n");
    #####:  332:                    if( ( ret = mbedtls_ssl_session_reset(&connection->ssl) ) != 0 ){
    #####:  333:                        network_log_error("mbedtls_ssl_session_reset returned %d\r\n", ret);
        -:  334:                    }
        -:  335:                    #ifdef LWM2M_SERVER_MODE
    #####:  336:                    if( network->type==NET_SERVER_PROCESS &&
    #####:  337:                            ( ret = mbedtls_ssl_set_client_transport_id(&connection->ssl,(void*)&connection->addr,sizeof(addr_t) ) ) != 0 ){
    #####:  338:                        network_log_error("mbedtls_ssl_config_defaults returned %d\r\n", ret);
        -:  339:                    }
        -:  340:                    #endif
    #####:  341:                    break;
    #####:  342:            case MBEDTLS_ERR_SSL_BAD_INPUT_DATA:
    #####:  343:                assert(1==0);
        -:  344:            default:
    #####:  345:                network_log_error("(ssl) receiving failed: %0x!\r\n", (int)-r);
    #####:  346:                internal_close_connection_ssl(network, connection);
        -:  347:            }
    #####:  348:            return;
        -:  349:        }
        -:  350:    } else {
    #####:  351:        r = mbedtls_net_recv(connection, dest, (size_t)len);
        -:  352:    }
    #####:  353:    lwm2m_handle_packet(contextP, dest, (int)r, connection);
        -:  354:}
        -:  355:
        -:  356:#endif
