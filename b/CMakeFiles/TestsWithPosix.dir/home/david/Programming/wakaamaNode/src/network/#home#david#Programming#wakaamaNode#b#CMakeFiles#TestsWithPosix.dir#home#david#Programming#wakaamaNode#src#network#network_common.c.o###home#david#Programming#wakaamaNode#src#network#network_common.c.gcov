        -:    0:Source:/home/david/Programming/wakaamaNode/src/network/network_common.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/network/network_common.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*******************************************************************************
        -:    2: * Copyright (c) 2017-2018  David Graeff <david.graeff@web.de>
        -:    3: *
        -:    4: * Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    5: * of this software and associated documentation files (the "Software"), to deal
        -:    6: * in the Software without restriction, including without limitation the rights
        -:    7: * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:    8: * copies of the Software, and to permit persons to whom the Software is
        -:    9: * furnished to do so, subject to the following conditions:
        -:   10: *
        -:   11: * The above copyright notice and this permission notice shall be included in
        -:   12: * all copies or substantial portions of the Software.
        -:   13: */
        -:   14:
        -:   15:#include "lwm2m/c_connect.h"
        -:   16:#include "lwm2m/network.h"
        -:   17:#include "lwm2m/debug.h"
        -:   18:#include "../internal.h"
        -:   19:#include "network_common.h"
        -:   20:#include <stdio.h>
        -:   21:#include <errno.h>
        -:   22:#include <stdlib.h>
        -:   23:#include <string.h>
        -:   24:#include <sys/time.h>
        -:   25:
    #####:   26:uint8_t decode_uri(char* uri, char** host, uint16_t* port)
        -:   27:{
    #####:   28:    uint8_t r=0;
        -:   29:    // parse uri in the form "coaps://[host]:[port]"
    #####:   30:    if (0 == strncmp(uri, "coaps://", sizeof("coaps://")-1))
        -:   31:    {
    #####:   32:        *host = uri+sizeof("coaps://")-1;
    #####:   33:        r=2;
        -:   34:    }
    #####:   35:    else if (0 == strncmp(uri, "coap://", sizeof("coap://")-1))
        -:   36:    {
    #####:   37:        *host = uri+sizeof("coap://")-1;
    #####:   38:        r=1;
        -:   39:    }
        -:   40:    else
        -:   41:    {
    #####:   42:        return r;
        -:   43:    }
    #####:   44:    char* afterHost = strrchr(*host, ':');
    #####:   45:    char* portStr = afterHost;
    #####:   46:    if (portStr == NULL) {
    #####:   47:        *port = r==1?LWM2M_DEFAULT_SERVER_PORT:LWM2M_DEFAULT_SECURE_SERVER_PORT;
    #####:   48:        afterHost = *host + strlen(*host);
        -:   49:    } else {
        -:   50:        // split strings, by making the colon a c-string terminator
    #####:   51:        *afterHost = 0;
    #####:   52:        *port = (uint16_t)atoi(portStr+1);
        -:   53:    }
        -:   54:
        -:   55:    // remove brackets if ipv6 addresses
    #####:   56:    if (*host[0] == '[')
        -:   57:    {
    #####:   58:        *host = *host + 1;
    #####:   59:        if (*(afterHost - 1) == ']')
        -:   60:        {
    #####:   61:            *(afterHost - 1) = 0;
        -:   62:        }
        -:   63:        else
    #####:   64:            return 0;
        -:   65:    }
    #####:   66:    return r;
        -:   67:}
        -:   68:
    #####:   69:bool lwm2m_session_is_equal(void * session1,
        -:   70:                            void * session2,
        -:   71:                            void * userData)
        -:   72:{
        -:   73:    (void)userData;
    #####:   74:    return (session1 == session2);
        -:   75:}
        -:   76:
        -:   77:#ifdef LWM2M_SERVER_MODE
        -:   78:
    #####:   79:static inline connection_t* internal_create_server_connection(network_t* network, addr_t addr) {
    #####:   80:    connection_t* connection = (connection_t *)lwm2m_malloc(sizeof(connection_t));
    #####:   81:    if (connection == NULL)
        -:   82:    {
    #####:   83:        network_log_error("memory alloc for new connection failed");
    #####:   84:        return NULL;
        -:   85:    }
    #####:   86:    memset(connection, 0, sizeof(connection_t));
    #####:   87:    connection->network = network;
    #####:   88:    connection->addr = addr;
        -:   89:
        -:   90:    #ifdef LWM2M_WITH_DTLS
    #####:   91:    connection->dtls = network->dtls;
    #####:   92:    if (connection->dtls) {
        -:   93:        int ret;
    #####:   94:        if ((ret = init_server_connection_ssl (connection,network))!=0){
    #####:   95:            lwm2m_free(connection);
    #####:   96:            return NULL;
        -:   97:        }
        -:   98:    }
        -:   99:    #endif
    #####:  100:    internal_network_add_conn(network, connection);
    #####:  101:    return connection;
        -:  102:}
        -:  103:#else
        -:  104:static inline connection_t* internal_create_server_connection(network_t* network, addr_t addr) {
        -:  105:    (void)network;
        -:  106:    (void)addr;
        -:  107:    return NULL;
        -:  108:}
        -:  109:#endif
        -:  110:
    #####:  111:connection_t * internal_connection_find(network_t * network, addr_t addr) {
    #####:  112:    connection_t * connP = (connection_t*)network->connection_list;
    #####:  113:    while (connP != NULL) {
    #####:  114:        if (ip_equal(connP->addr, addr))
    #####:  115:            return connP;
    #####:  116:        connP = (connection_t*)connP->next;
        -:  117:    }
    #####:  118:    if (connP == NULL && network->type == NET_SERVER_PROCESS) {
    #####:  119:        return internal_create_server_connection(network, addr);
        -:  120:    }
        -:  121:
    #####:  122:    return NULL;
        -:  123:}
        -:  124:
    #####:  125:inline void internal_network_add_conn(network_t* network, connection_t* conn) {
    #####:  126:    conn->next = (struct _connection_t *)network->connection_list;
    #####:  127:    network->connection_list = conn;
    #####:  128:}
        -:  129:
    #####:  130:uint8_t lwm2m_network_init(lwm2m_context_t * contextP, uint16_t localPort) {
        -:  131:    // The network can only be initialized once. We also need the userdata pointer
        -:  132:    // and therefore check if it is not used so far.
    #####:  133:    if (contextP->userData != NULL)
    #####:  134:        return 0;
        -:  135:
        -:  136:    // Allocate memory for the network structure
    #####:  137:    contextP->userData = lwm2m_malloc(sizeof(network_t));
    #####:  138:    if (contextP->userData == NULL)
    #####:  139:        return 0;
        -:  140:
    #####:  141:    network_t* network = (network_t*)contextP->userData;
    #####:  142:    memset(network, 0, sizeof(network_t));
        -:  143:
        -:  144:#ifdef LWM2M_WITH_DTLS
    #####:  145:    if (!internal_network_ssl_init(network)) return 0;
        -:  146:#endif
        -:  147:
    #####:  148:    uint8_t r = internal_init_sockets(contextP, network, localPort);
    #####:  149:    if (!r) {
    #####:  150:        contextP->userData = NULL;
    #####:  151:        lwm2m_free(network);
        -:  152:    }
    #####:  153:    return r;
        -:  154:}
        -:  155:
    #####:  156:void * lwm2m_connect_server(uint16_t secObjInstID, lwm2m_context_t * context) {
        -:  157:    char * host;
        -:  158:    uint16_t port;
        -:  159:    char uri[255];
        -:  160:
    #####:  161:    security_instance_t* secInst = lwm2m_get_security_object(context, secObjInstID);
    #####:  162:    if (!secInst) return NULL;
        -:  163:
    #####:  164:    secInst->securityMode = LWM2M_SECURITY_MODE_NONE;
        -:  165:
    #####:  166:    strncpy(uri, secInst->uri, sizeof (uri));
        -:  167:
    #####:  168:    network_log_info("Connecting to %s on %i\r\n", uri, secInst->shortID);
        -:  169:
    #####:  170:    uint8_t uri_result=decode_uri(uri, &host, &port);
    #####:  171:    if (uri_result==0){
    #####:  172:        network_log_error("Couldn't decode server uri %s.\r\n", uri);
    #####:  173:        return NULL;
        -:  174:    }
        -:  175:    #ifndef LWM2M_WITH_DTLS
        -:  176:    else if (uri_result==2){
        -:  177:        network_log_error("dtls not supported: %s.\r\n", uri);
        -:  178:        return NULL;
        -:  179:    }
        -:  180:    #else
    #####:  181:    if (uri_result==2){ // use dtls
    #####:  182:        if (secInst->securityMode==LWM2M_SECURITY_MODE_PRE_SHARED_KEY &&
    #####:  183:                (secInst->publicIdLen==0||secInst->secretKeyLen==0)){
    #####:  184:            network_log_error("dtls preshared key information missing: %s.\r\n", uri);
    #####:  185:            return NULL;
        -:  186:        }
        -:  187:    } else { // no enc
    #####:  188:        internal_erase_security_params(secInst);
        -:  189:    }
        -:  190:    #endif
        -:  191:
    #####:  192:    network_t* network = (network_t*)context->userData;
    #####:  193:    if (network->type==NET_SERVER_PROCESS){
    #####:  194:        network_log_error("lwm2m_connect_server not allowed on servers\n");
    #####:  195:        return NULL;
        -:  196:    }
    #####:  197:    connection_t * connection = internal_connection_create(network, host, port);
    #####:  198:    if (connection == NULL) {
    #####:  199:        network_log_error("Connection creation failed\n");
        -:  200:    }
        -:  201:    else {
    #####:  202:        connection->network = network;
    #####:  203:        connection->shortServerID = secInst->shortID;
    #####:  204:        internal_network_add_conn (network,connection);
        -:  205:        #ifdef LWM2M_WITH_DTLS
    #####:  206:        if (uri_result==2){
    #####:  207:            connection->dtls = true;
    #####:  208:            return internal_configure_ssl(connection,network,secInst);
        -:  209:        }
        -:  210:        #endif
        -:  211:    }
        -:  212:
    #####:  213:    return (void *)connection;
        -:  214:}
        -:  215:
    #####:  216:uint8_t lwm2m_buffer_send(void * sessionH,
        -:  217:                          uint8_t * buffer,
        -:  218:                          size_t length,
        -:  219:                          void * userdata)
        -:  220:{
        -:  221:    (void)userdata;
    #####:  222:    connection_t * connection = (connection_t*) sessionH;
        -:  223:
    #####:  224:    if (connection == NULL)
        -:  225:    {
    #####:  226:        network_log_error("failed sending %lu bytes, missing connection\r\n", (long unsigned)length);
    #####:  227:        return COAP_500_INTERNAL_SERVER_ERROR ;
        -:  228:    }
        -:  229:
        -:  230:    int r;
        -:  231:    #ifdef LWM2M_WITH_DTLS
    #####:  232:    if (connection->dtls) {
    #####:  233:        r = mbedtls_ssl_write(&connection->ssl, buffer, length);
    #####:  234:        if (r==MBEDTLS_ERR_SSL_WANT_WRITE) r = 0;
        -:  235:    } else {
    #####:  236:        r = mbedtls_net_send(connection, (const unsigned char*)buffer, length);
        -:  237:    }
        -:  238:    #else
        -:  239:    r = mbedtls_net_send(connection, (const unsigned char*)buffer, length);
        -:  240:    #endif
    #####:  241:    return r>=0 ? COAP_NO_ERROR : COAP_503_SERVICE_UNAVAILABLE;
        -:  242:}
        -:  243:
        -:  244:#ifndef LWM2M_WITH_DTLS
        -:  245:inline void internal_close_connection_ssl(network_t* network, connection_t * t) {}
        -:  246:inline void internal_network_close_ssl(network_t* network) {}
        -:  247:void internal_check_timer(lwm2m_context_t *contextP, struct timeval* next_event) {}
        -:  248:
        -:  249:void internal_network_read(lwm2m_context_t* contextP, void *dest, size_t len, connection_t *connection) {
        -:  250:    ssize_t r = mbedtls_net_recv(connection, dest, (size_t)len);
        -:  251:    if (r<0) {
        -:  252:        network_log_error("receiving failed: %i!\r\n", (int)r);
        -:  253:        return;
        -:  254:    }
        -:  255:    len = (size_t)r;
        -:  256:    lwm2m_handle_packet(contextP, dest, (int)len, connection);
        -:  257:}
        -:  258:
        -:  259:inline bool internal_in_dtls_handshake(lwm2m_context_t *contextP){
        -:  260:    return false;
        -:  261:}
        -:  262:
        -:  263:#endif
        -:  264:
    #####:  265:void lwm2m_close_connection(void * sessionH,
        -:  266:                            void * userData)
        -:  267:{
    #####:  268:    network_t* network = (network_t*)userData;
        -:  269:    // Protect us from being released multiple times
    #####:  270:    if (!network) return;
    #####:  271:    connection_t * t = network->connection_list;
        -:  272:
        -:  273:    // Remove connection from single linked list (search for entry if necessary)
    #####:  274:    if(t==sessionH)
    #####:  275:        network->connection_list=NULL;
    #####:  276:    else while (t) {
    #####:  277:        if (t->next == sessionH) {
        -:  278:            // Next extry would be the to-be-removed entry
    #####:  279:            t->next = ((connection_t*)sessionH)->next;
    #####:  280:            break;
        -:  281:        }
        -:  282:    }
    #####:  283:    internal_close_connection_ssl(network, ((connection_t*)sessionH));
    #####:  284:    lwm2m_free(sessionH);
        -:  285:}
        -:  286:
    #####:  287:void lwm2m_network_close(lwm2m_context_t * contextP) {
    #####:  288:    if (!contextP->userData) return;
        -:  289:
    #####:  290:    network_t* network = (network_t*)contextP->userData;
        -:  291:
        -:  292:    // Close all connections that are not already closed by lwm2m_close()
    #####:  293:    if ( network->connection_list) {
    #####:  294:        connection_t * t = network->connection_list;
    #####:  295:        while (t) {
    #####:  296:            connection_t*next = (connection_t*)t->next;
    #####:  297:            lwm2m_close_connection(t,network);
    #####:  298:            t = next;
        -:  299:        }
    #####:  300:        network->connection_list=NULL;
        -:  301:    }
        -:  302:
        -:  303:    // Close sockets
    #####:  304:    for (unsigned c = 0; c < network->open_listen_sockets; ++c)
    #####:  305:        internal_closeSocket(network, c);
    #####:  306:    network->open_listen_sockets = 0;
        -:  307:
    #####:  308:    internal_network_close_ssl(network);
        -:  309:
    #####:  310:    internal_network_close(network);
        -:  311:
    #####:  312:    lwm2m_free(network);
    #####:  313:    contextP->userData = NULL;
        -:  314:}
