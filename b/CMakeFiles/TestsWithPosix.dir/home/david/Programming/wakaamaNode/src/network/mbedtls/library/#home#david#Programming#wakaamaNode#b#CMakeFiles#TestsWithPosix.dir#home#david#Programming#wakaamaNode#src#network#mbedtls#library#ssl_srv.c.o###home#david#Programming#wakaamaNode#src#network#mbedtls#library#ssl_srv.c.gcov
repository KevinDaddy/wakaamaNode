        -:    0:Source:/home/david/Programming/wakaamaNode/src/network/mbedtls/library/ssl_srv.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/network/mbedtls/library/ssl_srv.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*
        -:    2: *  SSLv3/TLSv1 server-side functions
        -:    3: *
        -:    4: *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
        -:    5: *  SPDX-License-Identifier: Apache-2.0
        -:    6: *
        -:    7: *  Licensed under the Apache License, Version 2.0 (the "License"); you may
        -:    8: *  not use this file except in compliance with the License.
        -:    9: *  You may obtain a copy of the License at
        -:   10: *
        -:   11: *  http://www.apache.org/licenses/LICENSE-2.0
        -:   12: *
        -:   13: *  Unless required by applicable law or agreed to in writing, software
        -:   14: *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
        -:   15: *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   16: *  See the License for the specific language governing permissions and
        -:   17: *  limitations under the License.
        -:   18: *
        -:   19: *  This file is part of mbed TLS (https://tls.mbed.org)
        -:   20: */
        -:   21:
        -:   22:#if !defined(MBEDTLS_CONFIG_FILE)
        -:   23:#include "mbedtls/config.h"
        -:   24:#else
        -:   25:#include MBEDTLS_CONFIG_FILE
        -:   26:#endif
        -:   27:
        -:   28:#if defined(MBEDTLS_SSL_SRV_C)
        -:   29:
        -:   30:#if defined(MBEDTLS_PLATFORM_C)
        -:   31:#include "mbedtls/platform.h"
        -:   32:#else
        -:   33:#include <stdlib.h>
        -:   34:#define mbedtls_calloc    calloc
        -:   35:#define mbedtls_free      free
        -:   36:#endif
        -:   37:
        -:   38:#include "mbedtls/debug.h"
        -:   39:#include "mbedtls/ssl.h"
        -:   40:#include "mbedtls/ssl_internal.h"
        -:   41:#include "mbedtls/platform_util.h"
        -:   42:
        -:   43:#include <string.h>
        -:   44:
        -:   45:#if defined(MBEDTLS_ECP_C)
        -:   46:#include "mbedtls/ecp.h"
        -:   47:#endif
        -:   48:
        -:   49:#if defined(MBEDTLS_HAVE_TIME)
        -:   50:#include "mbedtls/platform_time.h"
        -:   51:#endif
        -:   52:
        -:   53:#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
    #####:   54:int mbedtls_ssl_set_client_transport_id( mbedtls_ssl_context *ssl,
        -:   55:                                 const unsigned char *info,
        -:   56:                                 size_t ilen )
        -:   57:{
    #####:   58:    if( ssl->conf->endpoint != MBEDTLS_SSL_IS_SERVER )
    #####:   59:        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
        -:   60:
    #####:   61:    mbedtls_free( ssl->cli_id );
        -:   62:
    #####:   63:    if( ( ssl->cli_id = mbedtls_calloc( 1, ilen ) ) == NULL )
    #####:   64:        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
        -:   65:
    #####:   66:    memcpy( ssl->cli_id, info, ilen );
    #####:   67:    ssl->cli_id_len = ilen;
        -:   68:
    #####:   69:    return( 0 );
        -:   70:}
        -:   71:
    #####:   72:void mbedtls_ssl_conf_dtls_cookies( mbedtls_ssl_config *conf,
        -:   73:                           mbedtls_ssl_cookie_write_t *f_cookie_write,
        -:   74:                           mbedtls_ssl_cookie_check_t *f_cookie_check,
        -:   75:                           void *p_cookie )
        -:   76:{
    #####:   77:    conf->f_cookie_write = f_cookie_write;
    #####:   78:    conf->f_cookie_check = f_cookie_check;
    #####:   79:    conf->p_cookie       = p_cookie;
    #####:   80:}
        -:   81:#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
        -:   82:
        -:   83:#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
    #####:   84:static int ssl_parse_servername_ext( mbedtls_ssl_context *ssl,
        -:   85:                                     const unsigned char *buf,
        -:   86:                                     size_t len )
        -:   87:{
        -:   88:    int ret;
        -:   89:    size_t servername_list_size, hostname_len;
        -:   90:    const unsigned char *p;
        -:   91:
    #####:   92:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "parse ServerName extension" ) );
        -:   93:
    #####:   94:    servername_list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );
    #####:   95:    if( servername_list_size + 2 != len )
        -:   96:    {
    #####:   97:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####:   98:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:   99:                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    #####:  100:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  101:    }
        -:  102:
    #####:  103:    p = buf + 2;
    #####:  104:    while( servername_list_size > 0 )
        -:  105:    {
    #####:  106:        hostname_len = ( ( p[1] << 8 ) | p[2] );
    #####:  107:        if( hostname_len + 3 > servername_list_size )
        -:  108:        {
    #####:  109:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####:  110:            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  111:                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    #####:  112:            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  113:        }
        -:  114:
    #####:  115:        if( p[0] == MBEDTLS_TLS_EXT_SERVERNAME_HOSTNAME )
        -:  116:        {
    #####:  117:            ret = ssl->conf->f_sni( ssl->conf->p_sni,
        -:  118:                                    ssl, p + 3, hostname_len );
    #####:  119:            if( ret != 0 )
        -:  120:            {
    #####:  121:                MBEDTLS_SSL_DEBUG_RET( 1, "ssl_sni_wrapper", ret );
    #####:  122:                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  123:                        MBEDTLS_SSL_ALERT_MSG_UNRECOGNIZED_NAME );
    #####:  124:                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  125:            }
    #####:  126:            return( 0 );
        -:  127:        }
        -:  128:
    #####:  129:        servername_list_size -= hostname_len + 3;
    #####:  130:        p += hostname_len + 3;
        -:  131:    }
        -:  132:
    #####:  133:    if( servername_list_size != 0 )
        -:  134:    {
    #####:  135:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####:  136:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  137:                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
    #####:  138:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  139:    }
        -:  140:
    #####:  141:    return( 0 );
        -:  142:}
        -:  143:#endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
        -:  144:
    #####:  145:static int ssl_parse_renegotiation_info( mbedtls_ssl_context *ssl,
        -:  146:                                         const unsigned char *buf,
        -:  147:                                         size_t len )
        -:  148:{
        -:  149:#if defined(MBEDTLS_SSL_RENEGOTIATION)
        -:  150:    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
        -:  151:    {
        -:  152:        /* Check verify-data in constant-time. The length OTOH is no secret */
        -:  153:        if( len    != 1 + ssl->verify_data_len ||
        -:  154:            buf[0] !=     ssl->verify_data_len ||
        -:  155:            mbedtls_ssl_safer_memcmp( buf + 1, ssl->peer_verify_data,
        -:  156:                          ssl->verify_data_len ) != 0 )
        -:  157:        {
        -:  158:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "non-matching renegotiation info" ) );
        -:  159:            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  160:                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
        -:  161:            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  162:        }
        -:  163:    }
        -:  164:    else
        -:  165:#endif /* MBEDTLS_SSL_RENEGOTIATION */
        -:  166:    {
    #####:  167:        if( len != 1 || buf[0] != 0x0 )
        -:  168:        {
    #####:  169:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "non-zero length renegotiation info" ) );
    #####:  170:            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  171:                                            MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
    #####:  172:            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  173:        }
        -:  174:
    #####:  175:        ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;
        -:  176:    }
        -:  177:
    #####:  178:    return( 0 );
        -:  179:}
        -:  180:
        -:  181:#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
        -:  182:    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
        -:  183:
        -:  184:/*
        -:  185: * Status of the implementation of signature-algorithms extension:
        -:  186: *
        -:  187: * Currently, we are only considering the signature-algorithm extension
        -:  188: * to pick a ciphersuite which allows us to send the ServerKeyExchange
        -:  189: * message with a signature-hash combination that the user allows.
        -:  190: *
        -:  191: * We do *not* check whether all certificates in our certificate
        -:  192: * chain are signed with an allowed signature-hash pair.
        -:  193: * This needs to be done at a later stage.
        -:  194: *
        -:  195: */
        -:  196:static int ssl_parse_signature_algorithms_ext( mbedtls_ssl_context *ssl,
        -:  197:                                               const unsigned char *buf,
        -:  198:                                               size_t len )
        -:  199:{
        -:  200:    size_t sig_alg_list_size;
        -:  201:
        -:  202:    const unsigned char *p;
        -:  203:    const unsigned char *end = buf + len;
        -:  204:
        -:  205:    mbedtls_md_type_t md_cur;
        -:  206:    mbedtls_pk_type_t sig_cur;
        -:  207:
        -:  208:    sig_alg_list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );
        -:  209:    if( sig_alg_list_size + 2 != len ||
        -:  210:        sig_alg_list_size % 2 != 0 )
        -:  211:    {
        -:  212:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
        -:  213:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  214:                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
        -:  215:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  216:    }
        -:  217:
        -:  218:    /* Currently we only guarantee signing the ServerKeyExchange message according
        -:  219:     * to the constraints specified in this extension (see above), so it suffices
        -:  220:     * to remember only one suitable hash for each possible signature algorithm.
        -:  221:     *
        -:  222:     * This will change when we also consider certificate signatures,
        -:  223:     * in which case we will need to remember the whole signature-hash
        -:  224:     * pair list from the extension.
        -:  225:     */
        -:  226:
        -:  227:    for( p = buf + 2; p < end; p += 2 )
        -:  228:    {
        -:  229:        /* Silently ignore unknown signature or hash algorithms. */
        -:  230:
        -:  231:        if( ( sig_cur = mbedtls_ssl_pk_alg_from_sig( p[1] ) ) == MBEDTLS_PK_NONE )
        -:  232:        {
        -:  233:            MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, signature_algorithm ext"
        -:  234:                                        " unknown sig alg encoding %d", p[1] ) );
        -:  235:            continue;
        -:  236:        }
        -:  237:
        -:  238:        /* Check if we support the hash the user proposes */
        -:  239:        md_cur = mbedtls_ssl_md_alg_from_hash( p[0] );
        -:  240:        if( md_cur == MBEDTLS_MD_NONE )
        -:  241:        {
        -:  242:            MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, signature_algorithm ext:"
        -:  243:                                        " unknown hash alg encoding %d", p[0] ) );
        -:  244:            continue;
        -:  245:        }
        -:  246:
        -:  247:        if( mbedtls_ssl_check_sig_hash( ssl, md_cur ) == 0 )
        -:  248:        {
        -:  249:            mbedtls_ssl_sig_hash_set_add( &ssl->handshake->hash_algs, sig_cur, md_cur );
        -:  250:            MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, signature_algorithm ext:"
        -:  251:                                        " match sig %d and hash %d",
        -:  252:                                        sig_cur, md_cur ) );
        -:  253:        }
        -:  254:        else
        -:  255:        {
        -:  256:            MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, signature_algorithm ext: "
        -:  257:                                        "hash alg %d not supported", md_cur ) );
        -:  258:        }
        -:  259:    }
        -:  260:
        -:  261:    return( 0 );
        -:  262:}
        -:  263:#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&
        -:  264:          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
        -:  265:
        -:  266:#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
        -:  267:    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
        -:  268:static int ssl_parse_supported_elliptic_curves( mbedtls_ssl_context *ssl,
        -:  269:                                                const unsigned char *buf,
        -:  270:                                                size_t len )
        -:  271:{
        -:  272:    size_t list_size, our_size;
        -:  273:    const unsigned char *p;
        -:  274:    const mbedtls_ecp_curve_info *curve_info, **curves;
        -:  275:
        -:  276:    list_size = ( ( buf[0] << 8 ) | ( buf[1] ) );
        -:  277:    if( list_size + 2 != len ||
        -:  278:        list_size % 2 != 0 )
        -:  279:    {
        -:  280:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
        -:  281:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  282:                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
        -:  283:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  284:    }
        -:  285:
        -:  286:    /* Should never happen unless client duplicates the extension */
        -:  287:    if( ssl->handshake->curves != NULL )
        -:  288:    {
        -:  289:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
        -:  290:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  291:                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
        -:  292:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  293:    }
        -:  294:
        -:  295:    /* Don't allow our peer to make us allocate too much memory,
        -:  296:     * and leave room for a final 0 */
        -:  297:    our_size = list_size / 2 + 1;
        -:  298:    if( our_size > MBEDTLS_ECP_DP_MAX )
        -:  299:        our_size = MBEDTLS_ECP_DP_MAX;
        -:  300:
        -:  301:    if( ( curves = mbedtls_calloc( our_size, sizeof( *curves ) ) ) == NULL )
        -:  302:    {
        -:  303:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  304:                                        MBEDTLS_SSL_ALERT_MSG_INTERNAL_ERROR );
        -:  305:        return( MBEDTLS_ERR_SSL_ALLOC_FAILED );
        -:  306:    }
        -:  307:
        -:  308:    ssl->handshake->curves = curves;
        -:  309:
        -:  310:    p = buf + 2;
        -:  311:    while( list_size > 0 && our_size > 1 )
        -:  312:    {
        -:  313:        curve_info = mbedtls_ecp_curve_info_from_tls_id( ( p[0] << 8 ) | p[1] );
        -:  314:
        -:  315:        if( curve_info != NULL )
        -:  316:        {
        -:  317:            *curves++ = curve_info;
        -:  318:            our_size--;
        -:  319:        }
        -:  320:
        -:  321:        list_size -= 2;
        -:  322:        p += 2;
        -:  323:    }
        -:  324:
        -:  325:    return( 0 );
        -:  326:}
        -:  327:
        -:  328:static int ssl_parse_supported_point_formats( mbedtls_ssl_context *ssl,
        -:  329:                                              const unsigned char *buf,
        -:  330:                                              size_t len )
        -:  331:{
        -:  332:    size_t list_size;
        -:  333:    const unsigned char *p;
        -:  334:
        -:  335:    list_size = buf[0];
        -:  336:    if( list_size + 1 != len )
        -:  337:    {
        -:  338:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
        -:  339:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  340:                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
        -:  341:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  342:    }
        -:  343:
        -:  344:    p = buf + 1;
        -:  345:    while( list_size > 0 )
        -:  346:    {
        -:  347:        if( p[0] == MBEDTLS_ECP_PF_UNCOMPRESSED ||
        -:  348:            p[0] == MBEDTLS_ECP_PF_COMPRESSED )
        -:  349:        {
        -:  350:#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C)
        -:  351:            ssl->handshake->ecdh_ctx.point_format = p[0];
        -:  352:#endif
        -:  353:#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
        -:  354:            ssl->handshake->ecjpake_ctx.point_format = p[0];
        -:  355:#endif
        -:  356:            MBEDTLS_SSL_DEBUG_MSG( 4, ( "point format selected: %d", p[0] ) );
        -:  357:            return( 0 );
        -:  358:        }
        -:  359:
        -:  360:        list_size--;
        -:  361:        p++;
        -:  362:    }
        -:  363:
        -:  364:    return( 0 );
        -:  365:}
        -:  366:#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C ||
        -:  367:          MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
        -:  368:
        -:  369:#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
        -:  370:static int ssl_parse_ecjpake_kkpp( mbedtls_ssl_context *ssl,
        -:  371:                                   const unsigned char *buf,
        -:  372:                                   size_t len )
        -:  373:{
        -:  374:    int ret;
        -:  375:
        -:  376:    if( mbedtls_ecjpake_check( &ssl->handshake->ecjpake_ctx ) != 0 )
        -:  377:    {
        -:  378:        MBEDTLS_SSL_DEBUG_MSG( 3, ( "skip ecjpake kkpp extension" ) );
        -:  379:        return( 0 );
        -:  380:    }
        -:  381:
        -:  382:    if( ( ret = mbedtls_ecjpake_read_round_one( &ssl->handshake->ecjpake_ctx,
        -:  383:                                                buf, len ) ) != 0 )
        -:  384:    {
        -:  385:        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecjpake_read_round_one", ret );
        -:  386:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  387:                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
        -:  388:        return( ret );
        -:  389:    }
        -:  390:
        -:  391:    /* Only mark the extension as OK when we're sure it is */
        -:  392:    ssl->handshake->cli_exts |= MBEDTLS_TLS_EXT_ECJPAKE_KKPP_OK;
        -:  393:
        -:  394:    return( 0 );
        -:  395:}
        -:  396:#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
        -:  397:
        -:  398:#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
        -:  399:static int ssl_parse_max_fragment_length_ext( mbedtls_ssl_context *ssl,
        -:  400:                                              const unsigned char *buf,
        -:  401:                                              size_t len )
        -:  402:{
        -:  403:    if( len != 1 || buf[0] >= MBEDTLS_SSL_MAX_FRAG_LEN_INVALID )
        -:  404:    {
        -:  405:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
        -:  406:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  407:                                        MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
        -:  408:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  409:    }
        -:  410:
        -:  411:    ssl->session_negotiate->mfl_code = buf[0];
        -:  412:
        -:  413:    return( 0 );
        -:  414:}
        -:  415:#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
        -:  416:
        -:  417:#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
        -:  418:static int ssl_parse_truncated_hmac_ext( mbedtls_ssl_context *ssl,
        -:  419:                                         const unsigned char *buf,
        -:  420:                                         size_t len )
        -:  421:{
        -:  422:    if( len != 0 )
        -:  423:    {
        -:  424:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
        -:  425:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  426:                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
        -:  427:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  428:    }
        -:  429:
        -:  430:    ((void) buf);
        -:  431:
        -:  432:    if( ssl->conf->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_ENABLED )
        -:  433:        ssl->session_negotiate->trunc_hmac = MBEDTLS_SSL_TRUNC_HMAC_ENABLED;
        -:  434:
        -:  435:    return( 0 );
        -:  436:}
        -:  437:#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */
        -:  438:
        -:  439:#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
        -:  440:static int ssl_parse_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,
        -:  441:                                      const unsigned char *buf,
        -:  442:                                      size_t len )
        -:  443:{
        -:  444:    if( len != 0 )
        -:  445:    {
        -:  446:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
        -:  447:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  448:                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
        -:  449:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  450:    }
        -:  451:
        -:  452:    ((void) buf);
        -:  453:
        -:  454:    if( ssl->conf->encrypt_then_mac == MBEDTLS_SSL_ETM_ENABLED &&
        -:  455:        ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )
        -:  456:    {
        -:  457:        ssl->session_negotiate->encrypt_then_mac = MBEDTLS_SSL_ETM_ENABLED;
        -:  458:    }
        -:  459:
        -:  460:    return( 0 );
        -:  461:}
        -:  462:#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
        -:  463:
        -:  464:#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
        -:  465:static int ssl_parse_extended_ms_ext( mbedtls_ssl_context *ssl,
        -:  466:                                      const unsigned char *buf,
        -:  467:                                      size_t len )
        -:  468:{
        -:  469:    if( len != 0 )
        -:  470:    {
        -:  471:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
        -:  472:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  473:                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
        -:  474:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  475:    }
        -:  476:
        -:  477:    ((void) buf);
        -:  478:
        -:  479:    if( ssl->conf->extended_ms == MBEDTLS_SSL_EXTENDED_MS_ENABLED &&
        -:  480:        ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )
        -:  481:    {
        -:  482:        ssl->handshake->extended_ms = MBEDTLS_SSL_EXTENDED_MS_ENABLED;
        -:  483:    }
        -:  484:
        -:  485:    return( 0 );
        -:  486:}
        -:  487:#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
        -:  488:
        -:  489:#if defined(MBEDTLS_SSL_SESSION_TICKETS)
        -:  490:static int ssl_parse_session_ticket_ext( mbedtls_ssl_context *ssl,
        -:  491:                                         unsigned char *buf,
        -:  492:                                         size_t len )
        -:  493:{
        -:  494:    int ret;
        -:  495:    mbedtls_ssl_session session;
        -:  496:
        -:  497:    mbedtls_ssl_session_init( &session );
        -:  498:
        -:  499:    if( ssl->conf->f_ticket_parse == NULL ||
        -:  500:        ssl->conf->f_ticket_write == NULL )
        -:  501:    {
        -:  502:        return( 0 );
        -:  503:    }
        -:  504:
        -:  505:    /* Remember the client asked us to send a new ticket */
        -:  506:    ssl->handshake->new_session_ticket = 1;
        -:  507:
        -:  508:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket length: %d", len ) );
        -:  509:
        -:  510:    if( len == 0 )
        -:  511:        return( 0 );
        -:  512:
        -:  513:#if defined(MBEDTLS_SSL_RENEGOTIATION)
        -:  514:    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
        -:  515:    {
        -:  516:        MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket rejected: renegotiating" ) );
        -:  517:        return( 0 );
        -:  518:    }
        -:  519:#endif /* MBEDTLS_SSL_RENEGOTIATION */
        -:  520:
        -:  521:    /*
        -:  522:     * Failures are ok: just ignore the ticket and proceed.
        -:  523:     */
        -:  524:    if( ( ret = ssl->conf->f_ticket_parse( ssl->conf->p_ticket, &session,
        -:  525:                                           buf, len ) ) != 0 )
        -:  526:    {
        -:  527:        mbedtls_ssl_session_free( &session );
        -:  528:
        -:  529:        if( ret == MBEDTLS_ERR_SSL_INVALID_MAC )
        -:  530:            MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket is not authentic" ) );
        -:  531:        else if( ret == MBEDTLS_ERR_SSL_SESSION_TICKET_EXPIRED )
        -:  532:            MBEDTLS_SSL_DEBUG_MSG( 3, ( "ticket is expired" ) );
        -:  533:        else
        -:  534:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_ticket_parse", ret );
        -:  535:
        -:  536:        return( 0 );
        -:  537:    }
        -:  538:
        -:  539:    /*
        -:  540:     * Keep the session ID sent by the client, since we MUST send it back to
        -:  541:     * inform them we're accepting the ticket  (RFC 5077 section 3.4)
        -:  542:     */
        -:  543:    session.id_len = ssl->session_negotiate->id_len;
        -:  544:    memcpy( &session.id, ssl->session_negotiate->id, session.id_len );
        -:  545:
        -:  546:    mbedtls_ssl_session_free( ssl->session_negotiate );
        -:  547:    memcpy( ssl->session_negotiate, &session, sizeof( mbedtls_ssl_session ) );
        -:  548:
        -:  549:    /* Zeroize instead of free as we copied the content */
        -:  550:    mbedtls_platform_zeroize( &session, sizeof( mbedtls_ssl_session ) );
        -:  551:
        -:  552:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "session successfully restored from ticket" ) );
        -:  553:
        -:  554:    ssl->handshake->resume = 1;
        -:  555:
        -:  556:    /* Don't send a new ticket after all, this one is OK */
        -:  557:    ssl->handshake->new_session_ticket = 0;
        -:  558:
        -:  559:    return( 0 );
        -:  560:}
        -:  561:#endif /* MBEDTLS_SSL_SESSION_TICKETS */
        -:  562:
        -:  563:#if defined(MBEDTLS_SSL_ALPN)
    #####:  564:static int ssl_parse_alpn_ext( mbedtls_ssl_context *ssl,
        -:  565:                               const unsigned char *buf, size_t len )
        -:  566:{
        -:  567:    size_t list_len, cur_len, ours_len;
        -:  568:    const unsigned char *theirs, *start, *end;
        -:  569:    const char **ours;
        -:  570:
        -:  571:    /* If ALPN not configured, just ignore the extension */
    #####:  572:    if( ssl->conf->alpn_list == NULL )
    #####:  573:        return( 0 );
        -:  574:
        -:  575:    /*
        -:  576:     * opaque ProtocolName<1..2^8-1>;
        -:  577:     *
        -:  578:     * struct {
        -:  579:     *     ProtocolName protocol_name_list<2..2^16-1>
        -:  580:     * } ProtocolNameList;
        -:  581:     */
        -:  582:
        -:  583:    /* Min length is 2 (list_len) + 1 (name_len) + 1 (name) */
    #####:  584:    if( len < 4 )
        -:  585:    {
    #####:  586:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  587:                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    #####:  588:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  589:    }
        -:  590:
    #####:  591:    list_len = ( buf[0] << 8 ) | buf[1];
    #####:  592:    if( list_len != len - 2 )
        -:  593:    {
    #####:  594:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  595:                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    #####:  596:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  597:    }
        -:  598:
        -:  599:    /*
        -:  600:     * Validate peer's list (lengths)
        -:  601:     */
    #####:  602:    start = buf + 2;
    #####:  603:    end = buf + len;
    #####:  604:    for( theirs = start; theirs != end; theirs += cur_len )
        -:  605:    {
    #####:  606:        cur_len = *theirs++;
        -:  607:
        -:  608:        /* Current identifier must fit in list */
    #####:  609:        if( cur_len > (size_t)( end - theirs ) )
        -:  610:        {
    #####:  611:            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  612:                                            MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    #####:  613:            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  614:        }
        -:  615:
        -:  616:        /* Empty strings MUST NOT be included */
    #####:  617:        if( cur_len == 0 )
        -:  618:        {
    #####:  619:            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  620:                                            MBEDTLS_SSL_ALERT_MSG_ILLEGAL_PARAMETER );
    #####:  621:            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  622:        }
        -:  623:    }
        -:  624:
        -:  625:    /*
        -:  626:     * Use our order of preference
        -:  627:     */
    #####:  628:    for( ours = ssl->conf->alpn_list; *ours != NULL; ours++ )
        -:  629:    {
    #####:  630:        ours_len = strlen( *ours );
    #####:  631:        for( theirs = start; theirs != end; theirs += cur_len )
        -:  632:        {
    #####:  633:            cur_len = *theirs++;
        -:  634:
    #####:  635:            if( cur_len == ours_len &&
    #####:  636:                memcmp( theirs, *ours, cur_len ) == 0 )
        -:  637:            {
    #####:  638:                ssl->alpn_chosen = *ours;
    #####:  639:                return( 0 );
        -:  640:            }
        -:  641:        }
        -:  642:    }
        -:  643:
        -:  644:    /* If we get there, no match was found */
    #####:  645:    mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  646:                            MBEDTLS_SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL );
    #####:  647:    return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  648:}
        -:  649:#endif /* MBEDTLS_SSL_ALPN */
        -:  650:
        -:  651:/*
        -:  652: * Auxiliary functions for ServerHello parsing and related actions
        -:  653: */
        -:  654:
        -:  655:#if defined(MBEDTLS_X509_CRT_PARSE_C)
        -:  656:/*
        -:  657: * Return 0 if the given key uses one of the acceptable curves, -1 otherwise
        -:  658: */
        -:  659:#if defined(MBEDTLS_ECDSA_C)
        -:  660:static int ssl_check_key_curve( mbedtls_pk_context *pk,
        -:  661:                                const mbedtls_ecp_curve_info **curves )
        -:  662:{
        -:  663:    const mbedtls_ecp_curve_info **crv = curves;
        -:  664:    mbedtls_ecp_group_id grp_id = mbedtls_pk_ec( *pk )->grp.id;
        -:  665:
        -:  666:    while( *crv != NULL )
        -:  667:    {
        -:  668:        if( (*crv)->grp_id == grp_id )
        -:  669:            return( 0 );
        -:  670:        crv++;
        -:  671:    }
        -:  672:
        -:  673:    return( -1 );
        -:  674:}
        -:  675:#endif /* MBEDTLS_ECDSA_C */
        -:  676:
        -:  677:/*
        -:  678: * Try picking a certificate for this ciphersuite,
        -:  679: * return 0 on success and -1 on failure.
        -:  680: */
    #####:  681:static int ssl_pick_cert( mbedtls_ssl_context *ssl,
        -:  682:                          const mbedtls_ssl_ciphersuite_t * ciphersuite_info )
        -:  683:{
    #####:  684:    mbedtls_ssl_key_cert *cur, *list, *fallback = NULL;
        -:  685:    mbedtls_pk_type_t pk_alg =
    #####:  686:        mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );
        -:  687:    uint32_t flags;
        -:  688:
        -:  689:#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
    #####:  690:    if( ssl->handshake->sni_key_cert != NULL )
    #####:  691:        list = ssl->handshake->sni_key_cert;
        -:  692:    else
        -:  693:#endif
    #####:  694:        list = ssl->conf->key_cert;
        -:  695:
    #####:  696:    if( pk_alg == MBEDTLS_PK_NONE )
    #####:  697:        return( 0 );
        -:  698:
    #####:  699:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite requires certificate" ) );
        -:  700:
    #####:  701:    if( list == NULL )
        -:  702:    {
    #####:  703:        MBEDTLS_SSL_DEBUG_MSG( 3, ( "server has no certificate" ) );
    #####:  704:        return( -1 );
        -:  705:    }
        -:  706:
    #####:  707:    for( cur = list; cur != NULL; cur = cur->next )
        -:  708:    {
    #####:  709:        MBEDTLS_SSL_DEBUG_CRT( 3, "candidate certificate chain, certificate",
        -:  710:                          cur->cert );
        -:  711:
    #####:  712:        if( ! mbedtls_pk_can_do( cur->key, pk_alg ) )
        -:  713:        {
    #####:  714:            MBEDTLS_SSL_DEBUG_MSG( 3, ( "certificate mismatch: key type" ) );
    #####:  715:            continue;
        -:  716:        }
        -:  717:
        -:  718:        /*
        -:  719:         * This avoids sending the client a cert it'll reject based on
        -:  720:         * keyUsage or other extensions.
        -:  721:         *
        -:  722:         * It also allows the user to provision different certificates for
        -:  723:         * different uses based on keyUsage, eg if they want to avoid signing
        -:  724:         * and decrypting with the same RSA key.
        -:  725:         */
    #####:  726:        if( mbedtls_ssl_check_cert_usage( cur->cert, ciphersuite_info,
        -:  727:                                  MBEDTLS_SSL_IS_SERVER, &flags ) != 0 )
        -:  728:        {
    #####:  729:            MBEDTLS_SSL_DEBUG_MSG( 3, ( "certificate mismatch: "
        -:  730:                                "(extended) key usage extension" ) );
    #####:  731:            continue;
        -:  732:        }
        -:  733:
        -:  734:#if defined(MBEDTLS_ECDSA_C)
        -:  735:        if( pk_alg == MBEDTLS_PK_ECDSA &&
        -:  736:            ssl_check_key_curve( cur->key, ssl->handshake->curves ) != 0 )
        -:  737:        {
        -:  738:            MBEDTLS_SSL_DEBUG_MSG( 3, ( "certificate mismatch: elliptic curve" ) );
        -:  739:            continue;
        -:  740:        }
        -:  741:#endif
        -:  742:
        -:  743:        /*
        -:  744:         * Try to select a SHA-1 certificate for pre-1.2 clients, but still
        -:  745:         * present them a SHA-higher cert rather than failing if it's the only
        -:  746:         * one we got that satisfies the other conditions.
        -:  747:         */
    #####:  748:        if( ssl->minor_ver < MBEDTLS_SSL_MINOR_VERSION_3 &&
    #####:  749:            cur->cert->sig_md != MBEDTLS_MD_SHA1 )
        -:  750:        {
    #####:  751:            if( fallback == NULL )
    #####:  752:                fallback = cur;
        -:  753:            {
    #####:  754:                MBEDTLS_SSL_DEBUG_MSG( 3, ( "certificate not preferred: "
        -:  755:                                    "sha-2 with pre-TLS 1.2 client" ) );
    #####:  756:            continue;
        -:  757:            }
        -:  758:        }
        -:  759:
        -:  760:        /* If we get there, we got a winner */
    #####:  761:        break;
        -:  762:    }
        -:  763:
    #####:  764:    if( cur == NULL )
    #####:  765:        cur = fallback;
        -:  766:
        -:  767:    /* Do not update ssl->handshake->key_cert unless there is a match */
    #####:  768:    if( cur != NULL )
        -:  769:    {
    #####:  770:        ssl->handshake->key_cert = cur;
    #####:  771:        MBEDTLS_SSL_DEBUG_CRT( 3, "selected certificate chain, certificate",
        -:  772:                          ssl->handshake->key_cert->cert );
    #####:  773:        return( 0 );
        -:  774:    }
        -:  775:
    #####:  776:    return( -1 );
        -:  777:}
        -:  778:#endif /* MBEDTLS_X509_CRT_PARSE_C */
        -:  779:
        -:  780:/*
        -:  781: * Check if a given ciphersuite is suitable for use with our config/keys/etc
        -:  782: * Sets ciphersuite_info only if the suite matches.
        -:  783: */
    #####:  784:static int ssl_ciphersuite_match( mbedtls_ssl_context *ssl, int suite_id,
        -:  785:                                  const mbedtls_ssl_ciphersuite_t **ciphersuite_info )
        -:  786:{
        -:  787:    const mbedtls_ssl_ciphersuite_t *suite_info;
        -:  788:
        -:  789:#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
        -:  790:    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
        -:  791:    mbedtls_pk_type_t sig_type;
        -:  792:#endif
        -:  793:
    #####:  794:    suite_info = mbedtls_ssl_ciphersuite_from_id( suite_id );
    #####:  795:    if( suite_info == NULL )
        -:  796:    {
    #####:  797:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
    #####:  798:        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        -:  799:    }
        -:  800:
    #####:  801:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "trying ciphersuite: %s", suite_info->name ) );
        -:  802:
    #####:  803:    if( suite_info->min_minor_ver > ssl->minor_ver ||
    #####:  804:        suite_info->max_minor_ver < ssl->minor_ver )
        -:  805:    {
    #####:  806:        MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: version" ) );
    #####:  807:        return( 0 );
        -:  808:    }
        -:  809:
        -:  810:#if defined(MBEDTLS_SSL_PROTO_DTLS)
    #####:  811:    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
    #####:  812:        ( suite_info->flags & MBEDTLS_CIPHERSUITE_NODTLS ) )
    #####:  813:        return( 0 );
        -:  814:#endif
        -:  815:
        -:  816:#if defined(MBEDTLS_ARC4_C)
        -:  817:    if( ssl->conf->arc4_disabled == MBEDTLS_SSL_ARC4_DISABLED &&
        -:  818:            suite_info->cipher == MBEDTLS_CIPHER_ARC4_128 )
        -:  819:    {
        -:  820:        MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: rc4" ) );
        -:  821:        return( 0 );
        -:  822:    }
        -:  823:#endif
        -:  824:
        -:  825:#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
        -:  826:    if( suite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE &&
        -:  827:        ( ssl->handshake->cli_exts & MBEDTLS_TLS_EXT_ECJPAKE_KKPP_OK ) == 0 )
        -:  828:    {
        -:  829:        MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: ecjpake "
        -:  830:                                    "not configured or ext missing" ) );
        -:  831:        return( 0 );
        -:  832:    }
        -:  833:#endif
        -:  834:
        -:  835:
        -:  836:#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C)
        -:  837:    if( mbedtls_ssl_ciphersuite_uses_ec( suite_info ) &&
        -:  838:        ( ssl->handshake->curves == NULL ||
        -:  839:          ssl->handshake->curves[0] == NULL ) )
        -:  840:    {
        -:  841:        MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: "
        -:  842:                            "no common elliptic curve" ) );
        -:  843:        return( 0 );
        -:  844:    }
        -:  845:#endif
        -:  846:
        -:  847:#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)
        -:  848:    /* If the ciphersuite requires a pre-shared key and we don't
        -:  849:     * have one, skip it now rather than failing later */
    #####:  850:    if( mbedtls_ssl_ciphersuite_uses_psk( suite_info ) &&
    #####:  851:        ssl->conf->f_psk == NULL &&
    #####:  852:        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||
    #####:  853:          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )
        -:  854:    {
    #####:  855:        MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: no pre-shared key" ) );
    #####:  856:        return( 0 );
        -:  857:    }
        -:  858:#endif
        -:  859:
        -:  860:#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
        -:  861:    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
        -:  862:    /* If the ciphersuite requires signing, check whether
        -:  863:     * a suitable hash algorithm is present. */
        -:  864:    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
        -:  865:    {
        -:  866:        sig_type = mbedtls_ssl_get_ciphersuite_sig_alg( suite_info );
        -:  867:        if( sig_type != MBEDTLS_PK_NONE &&
        -:  868:            mbedtls_ssl_sig_hash_set_find( &ssl->handshake->hash_algs, sig_type ) == MBEDTLS_MD_NONE )
        -:  869:        {
        -:  870:            MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: no suitable hash algorithm "
        -:  871:                                        "for signature algorithm %d", sig_type ) );
        -:  872:            return( 0 );
        -:  873:        }
        -:  874:    }
        -:  875:
        -:  876:#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&
        -:  877:          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
        -:  878:
        -:  879:#if defined(MBEDTLS_X509_CRT_PARSE_C)
        -:  880:    /*
        -:  881:     * Final check: if ciphersuite requires us to have a
        -:  882:     * certificate/key of a particular type:
        -:  883:     * - select the appropriate certificate if we have one, or
        -:  884:     * - try the next ciphersuite if we don't
        -:  885:     * This must be done last since we modify the key_cert list.
        -:  886:     */
    #####:  887:    if( ssl_pick_cert( ssl, suite_info ) != 0 )
        -:  888:    {
    #####:  889:        MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciphersuite mismatch: "
        -:  890:                            "no suitable certificate" ) );
    #####:  891:        return( 0 );
        -:  892:    }
        -:  893:#endif
        -:  894:
    #####:  895:    *ciphersuite_info = suite_info;
    #####:  896:    return( 0 );
        -:  897:}
        -:  898:
        -:  899:#if defined(MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO)
        -:  900:static int ssl_parse_client_hello_v2( mbedtls_ssl_context *ssl )
        -:  901:{
        -:  902:    int ret, got_common_suite;
        -:  903:    unsigned int i, j;
        -:  904:    size_t n;
        -:  905:    unsigned int ciph_len, sess_len, chal_len;
        -:  906:    unsigned char *buf, *p;
        -:  907:    const int *ciphersuites;
        -:  908:    const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
        -:  909:
        -:  910:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse client hello v2" ) );
        -:  911:
        -:  912:#if defined(MBEDTLS_SSL_RENEGOTIATION)
        -:  913:    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
        -:  914:    {
        -:  915:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "client hello v2 illegal for renegotiation" ) );
        -:  916:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  917:                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
        -:  918:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  919:    }
        -:  920:#endif /* MBEDTLS_SSL_RENEGOTIATION */
        -:  921:
        -:  922:    buf = ssl->in_hdr;
        -:  923:
        -:  924:    MBEDTLS_SSL_DEBUG_BUF( 4, "record header", buf, 5 );
        -:  925:
        -:  926:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v2, message type: %d",
        -:  927:                   buf[2] ) );
        -:  928:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v2, message len.: %d",
        -:  929:                   ( ( buf[0] & 0x7F ) << 8 ) | buf[1] ) );
        -:  930:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v2, max. version: [%d:%d]",
        -:  931:                   buf[3], buf[4] ) );
        -:  932:
        -:  933:    /*
        -:  934:     * SSLv2 Client Hello
        -:  935:     *
        -:  936:     * Record layer:
        -:  937:     *     0  .   1   message length
        -:  938:     *
        -:  939:     * SSL layer:
        -:  940:     *     2  .   2   message type
        -:  941:     *     3  .   4   protocol version
        -:  942:     */
        -:  943:    if( buf[2] != MBEDTLS_SSL_HS_CLIENT_HELLO ||
        -:  944:        buf[3] != MBEDTLS_SSL_MAJOR_VERSION_3 )
        -:  945:    {
        -:  946:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
        -:  947:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  948:    }
        -:  949:
        -:  950:    n = ( ( buf[0] << 8 ) | buf[1] ) & 0x7FFF;
        -:  951:
        -:  952:    if( n < 17 || n > 512 )
        -:  953:    {
        -:  954:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
        -:  955:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -:  956:    }
        -:  957:
        -:  958:    ssl->major_ver = MBEDTLS_SSL_MAJOR_VERSION_3;
        -:  959:    ssl->minor_ver = ( buf[4] <= ssl->conf->max_minor_ver )
        -:  960:                     ? buf[4]  : ssl->conf->max_minor_ver;
        -:  961:
        -:  962:    if( ssl->minor_ver < ssl->conf->min_minor_ver )
        -:  963:    {
        -:  964:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "client only supports ssl smaller than minimum"
        -:  965:                            " [%d:%d] < [%d:%d]",
        -:  966:                            ssl->major_ver, ssl->minor_ver,
        -:  967:                            ssl->conf->min_major_ver, ssl->conf->min_minor_ver ) );
        -:  968:
        -:  969:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -:  970:                                     MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );
        -:  971:        return( MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION );
        -:  972:    }
        -:  973:
        -:  974:    ssl->handshake->max_major_ver = buf[3];
        -:  975:    ssl->handshake->max_minor_ver = buf[4];
        -:  976:
        -:  977:    if( ( ret = mbedtls_ssl_fetch_input( ssl, 2 + n ) ) != 0 )
        -:  978:    {
        -:  979:        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
        -:  980:        return( ret );
        -:  981:    }
        -:  982:
        -:  983:    ssl->handshake->update_checksum( ssl, buf + 2, n );
        -:  984:
        -:  985:    buf = ssl->in_msg;
        -:  986:    n = ssl->in_left - 5;
        -:  987:
        -:  988:    /*
        -:  989:     *    0  .   1   ciphersuitelist length
        -:  990:     *    2  .   3   session id length
        -:  991:     *    4  .   5   challenge length
        -:  992:     *    6  .  ..   ciphersuitelist
        -:  993:     *   ..  .  ..   session id
        -:  994:     *   ..  .  ..   challenge
        -:  995:     */
        -:  996:    MBEDTLS_SSL_DEBUG_BUF( 4, "record contents", buf, n );
        -:  997:
        -:  998:    ciph_len = ( buf[0] << 8 ) | buf[1];
        -:  999:    sess_len = ( buf[2] << 8 ) | buf[3];
        -: 1000:    chal_len = ( buf[4] << 8 ) | buf[5];
        -: 1001:
        -: 1002:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "ciph_len: %d, sess_len: %d, chal_len: %d",
        -: 1003:                   ciph_len, sess_len, chal_len ) );
        -: 1004:
        -: 1005:    /*
        -: 1006:     * Make sure each parameter length is valid
        -: 1007:     */
        -: 1008:    if( ciph_len < 3 || ( ciph_len % 3 ) != 0 )
        -: 1009:    {
        -: 1010:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
        -: 1011:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1012:    }
        -: 1013:
        -: 1014:    if( sess_len > 32 )
        -: 1015:    {
        -: 1016:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
        -: 1017:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1018:    }
        -: 1019:
        -: 1020:    if( chal_len < 8 || chal_len > 32 )
        -: 1021:    {
        -: 1022:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
        -: 1023:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1024:    }
        -: 1025:
        -: 1026:    if( n != 6 + ciph_len + sess_len + chal_len )
        -: 1027:    {
        -: 1028:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
        -: 1029:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1030:    }
        -: 1031:
        -: 1032:    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, ciphersuitelist",
        -: 1033:                   buf + 6, ciph_len );
        -: 1034:    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, session id",
        -: 1035:                   buf + 6 + ciph_len, sess_len );
        -: 1036:    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, challenge",
        -: 1037:                   buf + 6 + ciph_len + sess_len, chal_len );
        -: 1038:
        -: 1039:    p = buf + 6 + ciph_len;
        -: 1040:    ssl->session_negotiate->id_len = sess_len;
        -: 1041:    memset( ssl->session_negotiate->id, 0,
        -: 1042:            sizeof( ssl->session_negotiate->id ) );
        -: 1043:    memcpy( ssl->session_negotiate->id, p, ssl->session_negotiate->id_len );
        -: 1044:
        -: 1045:    p += sess_len;
        -: 1046:    memset( ssl->handshake->randbytes, 0, 64 );
        -: 1047:    memcpy( ssl->handshake->randbytes + 32 - chal_len, p, chal_len );
        -: 1048:
        -: 1049:    /*
        -: 1050:     * Check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV
        -: 1051:     */
        -: 1052:    for( i = 0, p = buf + 6; i < ciph_len; i += 3, p += 3 )
        -: 1053:    {
        -: 1054:        if( p[0] == 0 && p[1] == 0 && p[2] == MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO )
        -: 1055:        {
        -: 1056:            MBEDTLS_SSL_DEBUG_MSG( 3, ( "received TLS_EMPTY_RENEGOTIATION_INFO " ) );
        -: 1057:#if defined(MBEDTLS_SSL_RENEGOTIATION)
        -: 1058:            if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
        -: 1059:            {
        -: 1060:                MBEDTLS_SSL_DEBUG_MSG( 1, ( "received RENEGOTIATION SCSV "
        -: 1061:                                    "during renegotiation" ) );
        -: 1062:
        -: 1063:                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 1064:                                                MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
        -: 1065:                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1066:            }
        -: 1067:#endif /* MBEDTLS_SSL_RENEGOTIATION */
        -: 1068:            ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;
        -: 1069:            break;
        -: 1070:        }
        -: 1071:    }
        -: 1072:
        -: 1073:#if defined(MBEDTLS_SSL_FALLBACK_SCSV)
        -: 1074:    for( i = 0, p = buf + 6; i < ciph_len; i += 3, p += 3 )
        -: 1075:    {
        -: 1076:        if( p[0] == 0 &&
        -: 1077:            p[1] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE >> 8 ) & 0xff ) &&
        -: 1078:            p[2] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE      ) & 0xff ) )
        -: 1079:        {
        -: 1080:            MBEDTLS_SSL_DEBUG_MSG( 3, ( "received FALLBACK_SCSV" ) );
        -: 1081:
        -: 1082:            if( ssl->minor_ver < ssl->conf->max_minor_ver )
        -: 1083:            {
        -: 1084:                MBEDTLS_SSL_DEBUG_MSG( 1, ( "inapropriate fallback" ) );
        -: 1085:
        -: 1086:                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 1087:                                        MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK );
        -: 1088:
        -: 1089:                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1090:            }
        -: 1091:
        -: 1092:            break;
        -: 1093:        }
        -: 1094:    }
        -: 1095:#endif /* MBEDTLS_SSL_FALLBACK_SCSV */
        -: 1096:
        -: 1097:    got_common_suite = 0;
        -: 1098:    ciphersuites = ssl->conf->ciphersuite_list[ssl->minor_ver];
        -: 1099:    ciphersuite_info = NULL;
        -: 1100:#if defined(MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE)
        -: 1101:    for( j = 0, p = buf + 6; j < ciph_len; j += 3, p += 3 )
        -: 1102:        for( i = 0; ciphersuites[i] != 0; i++ )
        -: 1103:#else
        -: 1104:    for( i = 0; ciphersuites[i] != 0; i++ )
        -: 1105:        for( j = 0, p = buf + 6; j < ciph_len; j += 3, p += 3 )
        -: 1106:#endif
        -: 1107:        {
        -: 1108:            if( p[0] != 0 ||
        -: 1109:                p[1] != ( ( ciphersuites[i] >> 8 ) & 0xFF ) ||
        -: 1110:                p[2] != ( ( ciphersuites[i]      ) & 0xFF ) )
        -: 1111:                continue;
        -: 1112:
        -: 1113:            got_common_suite = 1;
        -: 1114:
        -: 1115:            if( ( ret = ssl_ciphersuite_match( ssl, ciphersuites[i],
        -: 1116:                                               &ciphersuite_info ) ) != 0 )
        -: 1117:                return( ret );
        -: 1118:
        -: 1119:            if( ciphersuite_info != NULL )
        -: 1120:                goto have_ciphersuite_v2;
        -: 1121:        }
        -: 1122:
        -: 1123:    if( got_common_suite )
        -: 1124:    {
        -: 1125:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "got ciphersuites in common, "
        -: 1126:                            "but none of them usable" ) );
        -: 1127:        return( MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE );
        -: 1128:    }
        -: 1129:    else
        -: 1130:    {
        -: 1131:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no ciphersuites in common" ) );
        -: 1132:        return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );
        -: 1133:    }
        -: 1134:
        -: 1135:have_ciphersuite_v2:
        -: 1136:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "selected ciphersuite: %s", ciphersuite_info->name ) );
        -: 1137:
        -: 1138:    ssl->session_negotiate->ciphersuite = ciphersuites[i];
        -: 1139:    ssl->transform_negotiate->ciphersuite_info = ciphersuite_info;
        -: 1140:
        -: 1141:    /*
        -: 1142:     * SSLv2 Client Hello relevant renegotiation security checks
        -: 1143:     */
        -: 1144:    if( ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
        -: 1145:        ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE )
        -: 1146:    {
        -: 1147:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "legacy renegotiation, breaking off handshake" ) );
        -: 1148:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 1149:                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
        -: 1150:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1151:    }
        -: 1152:
        -: 1153:    ssl->in_left = 0;
        -: 1154:    ssl->state++;
        -: 1155:
        -: 1156:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse client hello v2" ) );
        -: 1157:
        -: 1158:    return( 0 );
        -: 1159:}
        -: 1160:#endif /* MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO */
        -: 1161:
        -: 1162:/* This function doesn't alert on errors that happen early during
        -: 1163:   ClientHello parsing because they might indicate that the client is
        -: 1164:   not talking SSL/TLS at all and would not understand our alert. */
    #####: 1165:static int ssl_parse_client_hello( mbedtls_ssl_context *ssl )
        -: 1166:{
        -: 1167:    int ret, got_common_suite;
        -: 1168:    size_t i, j;
        -: 1169:    size_t ciph_offset, comp_offset, ext_offset;
        -: 1170:    size_t msg_len, ciph_len, sess_len, comp_len, ext_len;
        -: 1171:#if defined(MBEDTLS_SSL_PROTO_DTLS)
        -: 1172:    size_t cookie_offset, cookie_len;
        -: 1173:#endif
        -: 1174:    unsigned char *buf, *p, *ext;
        -: 1175:#if defined(MBEDTLS_SSL_RENEGOTIATION)
        -: 1176:    int renegotiation_info_seen = 0;
        -: 1177:#endif
    #####: 1178:    int handshake_failure = 0;
        -: 1179:    const int *ciphersuites;
        -: 1180:    const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
        -: 1181:    int major, minor;
        -: 1182:
        -: 1183:    /* If there is no signature-algorithm extension present,
        -: 1184:     * we need to fall back to the default values for allowed
        -: 1185:     * signature-hash pairs. */
        -: 1186:#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
        -: 1187:    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
        -: 1188:    int sig_hash_alg_ext_present = 0;
        -: 1189:#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&
        -: 1190:          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
        -: 1191:
    #####: 1192:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse client hello" ) );
        -: 1193:
        -: 1194:#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
        -: 1195:read_record_header:
        -: 1196:#endif
        -: 1197:    /*
        -: 1198:     * If renegotiating, then the input was read with mbedtls_ssl_read_record(),
        -: 1199:     * otherwise read it ourselves manually in order to support SSLv2
        -: 1200:     * ClientHello, which doesn't use the same record layer format.
        -: 1201:     */
        -: 1202:#if defined(MBEDTLS_SSL_RENEGOTIATION)
        -: 1203:    if( ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE )
        -: 1204:#endif
        -: 1205:    {
    #####: 1206:        if( ( ret = mbedtls_ssl_fetch_input( ssl, 5 ) ) != 0 )
        -: 1207:        {
        -: 1208:            /* No alert on a read error. */
    #####: 1209:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
    #####: 1210:            return( ret );
        -: 1211:        }
        -: 1212:    }
        -: 1213:
    #####: 1214:    buf = ssl->in_hdr;
        -: 1215:
        -: 1216:#if defined(MBEDTLS_SSL_SRV_SUPPORT_SSLV2_CLIENT_HELLO)
        -: 1217:#if defined(MBEDTLS_SSL_PROTO_DTLS)
        -: 1218:    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_STREAM )
        -: 1219:#endif
        -: 1220:        if( ( buf[0] & 0x80 ) != 0 )
        -: 1221:            return( ssl_parse_client_hello_v2( ssl ) );
        -: 1222:#endif
        -: 1223:
    #####: 1224:    MBEDTLS_SSL_DEBUG_BUF( 4, "record header", buf, mbedtls_ssl_hdr_len( ssl ) );
        -: 1225:
        -: 1226:    /*
        -: 1227:     * SSLv3/TLS Client Hello
        -: 1228:     *
        -: 1229:     * Record layer:
        -: 1230:     *     0  .   0   message type
        -: 1231:     *     1  .   2   protocol version
        -: 1232:     *     3  .   11  DTLS: epoch + record sequence number
        -: 1233:     *     3  .   4   message length
        -: 1234:     */
    #####: 1235:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, message type: %d",
        -: 1236:                   buf[0] ) );
        -: 1237:
    #####: 1238:    if( buf[0] != MBEDTLS_SSL_MSG_HANDSHAKE )
        -: 1239:    {
    #####: 1240:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####: 1241:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1242:    }
        -: 1243:
    #####: 1244:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, message len.: %d",
        -: 1245:                   ( ssl->in_len[0] << 8 ) | ssl->in_len[1] ) );
        -: 1246:
    #####: 1247:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, protocol version: [%d:%d]",
        -: 1248:                   buf[1], buf[2] ) );
        -: 1249:
    #####: 1250:    mbedtls_ssl_read_version( &major, &minor, ssl->conf->transport, buf + 1 );
        -: 1251:
        -: 1252:    /* According to RFC 5246 Appendix E.1, the version here is typically
        -: 1253:     * "{03,00}, the lowest version number supported by the client, [or] the
        -: 1254:     * value of ClientHello.client_version", so the only meaningful check here
        -: 1255:     * is the major version shouldn't be less than 3 */
    #####: 1256:    if( major < MBEDTLS_SSL_MAJOR_VERSION_3 )
        -: 1257:    {
    #####: 1258:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####: 1259:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1260:    }
        -: 1261:
        -: 1262:    /* For DTLS if this is the initial handshake, remember the client sequence
        -: 1263:     * number to use it in our next message (RFC 6347 4.2.1) */
        -: 1264:#if defined(MBEDTLS_SSL_PROTO_DTLS)
    #####: 1265:    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM
        -: 1266:#if defined(MBEDTLS_SSL_RENEGOTIATION)
        -: 1267:        && ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE
        -: 1268:#endif
        -: 1269:        )
        -: 1270:    {
        -: 1271:        /* Epoch should be 0 for initial handshakes */
    #####: 1272:        if( ssl->in_ctr[0] != 0 || ssl->in_ctr[1] != 0 )
        -: 1273:        {
    #####: 1274:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####: 1275:            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1276:        }
        -: 1277:
    #####: 1278:        memcpy( ssl->out_ctr + 2, ssl->in_ctr + 2, 6 );
        -: 1279:
        -: 1280:#if defined(MBEDTLS_SSL_DTLS_ANTI_REPLAY)
        -: 1281:        if( mbedtls_ssl_dtls_replay_check( ssl ) != 0 )
        -: 1282:        {
        -: 1283:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "replayed record, discarding" ) );
        -: 1284:            ssl->next_record_offset = 0;
        -: 1285:            ssl->in_left = 0;
        -: 1286:            goto read_record_header;
        -: 1287:        }
        -: 1288:
        -: 1289:        /* No MAC to check yet, so we can update right now */
        -: 1290:        mbedtls_ssl_dtls_replay_update( ssl );
        -: 1291:#endif
        -: 1292:    }
        -: 1293:#endif /* MBEDTLS_SSL_PROTO_DTLS */
        -: 1294:
    #####: 1295:    msg_len = ( ssl->in_len[0] << 8 ) | ssl->in_len[1];
        -: 1296:
        -: 1297:#if defined(MBEDTLS_SSL_RENEGOTIATION)
        -: 1298:    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
        -: 1299:    {
        -: 1300:        /* Set by mbedtls_ssl_read_record() */
        -: 1301:        msg_len = ssl->in_hslen;
        -: 1302:    }
        -: 1303:    else
        -: 1304:#endif
        -: 1305:    {
    #####: 1306:        if( msg_len > MBEDTLS_SSL_MAX_CONTENT_LEN )
        -: 1307:        {
    #####: 1308:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####: 1309:            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1310:        }
        -: 1311:
    #####: 1312:        if( ( ret = mbedtls_ssl_fetch_input( ssl,
    #####: 1313:                       mbedtls_ssl_hdr_len( ssl ) + msg_len ) ) != 0 )
        -: 1314:        {
    #####: 1315:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_fetch_input", ret );
    #####: 1316:            return( ret );
        -: 1317:        }
        -: 1318:
        -: 1319:    /* Done reading this record, get ready for the next one */
        -: 1320:#if defined(MBEDTLS_SSL_PROTO_DTLS)
    #####: 1321:        if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
    #####: 1322:            ssl->next_record_offset = msg_len + mbedtls_ssl_hdr_len( ssl );
        -: 1323:        else
        -: 1324:#endif
    #####: 1325:            ssl->in_left = 0;
        -: 1326:    }
        -: 1327:
    #####: 1328:    buf = ssl->in_msg;
        -: 1329:
    #####: 1330:    MBEDTLS_SSL_DEBUG_BUF( 4, "record contents", buf, msg_len );
        -: 1331:
    #####: 1332:    ssl->handshake->update_checksum( ssl, buf, msg_len );
        -: 1333:
        -: 1334:    /*
        -: 1335:     * Handshake layer:
        -: 1336:     *     0  .   0   handshake type
        -: 1337:     *     1  .   3   handshake length
        -: 1338:     *     4  .   5   DTLS only: message seqence number
        -: 1339:     *     6  .   8   DTLS only: fragment offset
        -: 1340:     *     9  .  11   DTLS only: fragment length
        -: 1341:     */
    #####: 1342:    if( msg_len < mbedtls_ssl_hs_hdr_len( ssl ) )
        -: 1343:    {
    #####: 1344:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####: 1345:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1346:    }
        -: 1347:
    #####: 1348:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, handshake type: %d", buf[0] ) );
        -: 1349:
    #####: 1350:    if( buf[0] != MBEDTLS_SSL_HS_CLIENT_HELLO )
        -: 1351:    {
    #####: 1352:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####: 1353:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1354:    }
        -: 1355:
    #####: 1356:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, handshake len.: %d",
        -: 1357:                   ( buf[1] << 16 ) | ( buf[2] << 8 ) | buf[3] ) );
        -: 1358:
        -: 1359:    /* We don't support fragmentation of ClientHello (yet?) */
    #####: 1360:    if( buf[1] != 0 ||
    #####: 1361:        msg_len != mbedtls_ssl_hs_hdr_len( ssl ) + ( ( buf[2] << 8 ) | buf[3] ) )
        -: 1362:    {
    #####: 1363:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####: 1364:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1365:    }
        -: 1366:
        -: 1367:#if defined(MBEDTLS_SSL_PROTO_DTLS)
    #####: 1368:    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        -: 1369:    {
        -: 1370:        /*
        -: 1371:         * Copy the client's handshake message_seq on initial handshakes,
        -: 1372:         * check sequence number on renego.
        -: 1373:         */
        -: 1374:#if defined(MBEDTLS_SSL_RENEGOTIATION)
        -: 1375:        if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
        -: 1376:        {
        -: 1377:            /* This couldn't be done in ssl_prepare_handshake_record() */
        -: 1378:            unsigned int cli_msg_seq = ( ssl->in_msg[4] << 8 ) |
        -: 1379:                                         ssl->in_msg[5];
        -: 1380:
        -: 1381:            if( cli_msg_seq != ssl->handshake->in_msg_seq )
        -: 1382:            {
        -: 1383:                MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message_seq: "
        -: 1384:                                    "%d (expected %d)", cli_msg_seq,
        -: 1385:                                    ssl->handshake->in_msg_seq ) );
        -: 1386:                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1387:            }
        -: 1388:
        -: 1389:            ssl->handshake->in_msg_seq++;
        -: 1390:        }
        -: 1391:        else
        -: 1392:#endif
        -: 1393:        {
    #####: 1394:            unsigned int cli_msg_seq = ( ssl->in_msg[4] << 8 ) |
    #####: 1395:                                         ssl->in_msg[5];
    #####: 1396:            ssl->handshake->out_msg_seq = cli_msg_seq;
    #####: 1397:            ssl->handshake->in_msg_seq  = cli_msg_seq + 1;
        -: 1398:        }
        -: 1399:
        -: 1400:        /*
        -: 1401:         * For now we don't support fragmentation, so make sure
        -: 1402:         * fragment_offset == 0 and fragment_length == length
        -: 1403:         */
    #####: 1404:        if( ssl->in_msg[6] != 0 || ssl->in_msg[7] != 0 || ssl->in_msg[8] != 0 ||
    #####: 1405:            memcmp( ssl->in_msg + 1, ssl->in_msg + 9, 3 ) != 0 )
        -: 1406:        {
    #####: 1407:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "ClientHello fragmentation not supported" ) );
    #####: 1408:            return( MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE );
        -: 1409:        }
        -: 1410:    }
        -: 1411:#endif /* MBEDTLS_SSL_PROTO_DTLS */
        -: 1412:
    #####: 1413:    buf += mbedtls_ssl_hs_hdr_len( ssl );
    #####: 1414:    msg_len -= mbedtls_ssl_hs_hdr_len( ssl );
        -: 1415:
        -: 1416:    /*
        -: 1417:     * ClientHello layer:
        -: 1418:     *     0  .   1   protocol version
        -: 1419:     *     2  .  33   random bytes (starting with 4 bytes of Unix time)
        -: 1420:     *    34  .  35   session id length (1 byte)
        -: 1421:     *    35  . 34+x  session id
        -: 1422:     *   35+x . 35+x  DTLS only: cookie length (1 byte)
        -: 1423:     *   36+x .  ..   DTLS only: cookie
        -: 1424:     *    ..  .  ..   ciphersuite list length (2 bytes)
        -: 1425:     *    ..  .  ..   ciphersuite list
        -: 1426:     *    ..  .  ..   compression alg. list length (1 byte)
        -: 1427:     *    ..  .  ..   compression alg. list
        -: 1428:     *    ..  .  ..   extensions length (2 bytes, optional)
        -: 1429:     *    ..  .  ..   extensions (optional)
        -: 1430:     */
        -: 1431:
        -: 1432:    /*
        -: 1433:     * Minimal length (with everything empty and extensions ommitted) is
        -: 1434:     * 2 + 32 + 1 + 2 + 1 = 38 bytes. Check that first, so that we can
        -: 1435:     * read at least up to session id length without worrying.
        -: 1436:     */
    #####: 1437:    if( msg_len < 38 )
        -: 1438:    {
    #####: 1439:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####: 1440:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1441:    }
        -: 1442:
        -: 1443:    /*
        -: 1444:     * Check and save the protocol version
        -: 1445:     */
    #####: 1446:    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, version", buf, 2 );
        -: 1447:
    #####: 1448:    mbedtls_ssl_read_version( &ssl->major_ver, &ssl->minor_ver,
    #####: 1449:                      ssl->conf->transport, buf );
        -: 1450:
    #####: 1451:    ssl->handshake->max_major_ver = ssl->major_ver;
    #####: 1452:    ssl->handshake->max_minor_ver = ssl->minor_ver;
        -: 1453:
    #####: 1454:    if( ssl->major_ver < ssl->conf->min_major_ver ||
    #####: 1455:        ssl->minor_ver < ssl->conf->min_minor_ver )
        -: 1456:    {
    #####: 1457:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "client only supports ssl smaller than minimum"
        -: 1458:                            " [%d:%d] < [%d:%d]",
        -: 1459:                            ssl->major_ver, ssl->minor_ver,
        -: 1460:                            ssl->conf->min_major_ver, ssl->conf->min_minor_ver ) );
    #####: 1461:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 1462:                                     MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );
    #####: 1463:        return( MBEDTLS_ERR_SSL_BAD_HS_PROTOCOL_VERSION );
        -: 1464:    }
        -: 1465:
    #####: 1466:    if( ssl->major_ver > ssl->conf->max_major_ver )
        -: 1467:    {
    #####: 1468:        ssl->major_ver = ssl->conf->max_major_ver;
    #####: 1469:        ssl->minor_ver = ssl->conf->max_minor_ver;
        -: 1470:    }
    #####: 1471:    else if( ssl->minor_ver > ssl->conf->max_minor_ver )
    #####: 1472:        ssl->minor_ver = ssl->conf->max_minor_ver;
        -: 1473:
        -: 1474:    /*
        -: 1475:     * Save client random (inc. Unix time)
        -: 1476:     */
    #####: 1477:    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, random bytes", buf + 2, 32 );
        -: 1478:
    #####: 1479:    memcpy( ssl->handshake->randbytes, buf + 2, 32 );
        -: 1480:
        -: 1481:    /*
        -: 1482:     * Check the session ID length and save session ID
        -: 1483:     */
    #####: 1484:    sess_len = buf[34];
        -: 1485:
    #####: 1486:    if( sess_len > sizeof( ssl->session_negotiate->id ) ||
    #####: 1487:        sess_len + 34 + 2 > msg_len ) /* 2 for cipherlist length field */
        -: 1488:    {
    #####: 1489:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####: 1490:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 1491:                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    #####: 1492:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1493:    }
        -: 1494:
    #####: 1495:    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, session id", buf + 35, sess_len );
        -: 1496:
    #####: 1497:    ssl->session_negotiate->id_len = sess_len;
    #####: 1498:    memset( ssl->session_negotiate->id, 0,
        -: 1499:            sizeof( ssl->session_negotiate->id ) );
    #####: 1500:    memcpy( ssl->session_negotiate->id, buf + 35,
    #####: 1501:            ssl->session_negotiate->id_len );
        -: 1502:
        -: 1503:    /*
        -: 1504:     * Check the cookie length and content
        -: 1505:     */
        -: 1506:#if defined(MBEDTLS_SSL_PROTO_DTLS)
    #####: 1507:    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
        -: 1508:    {
    #####: 1509:        cookie_offset = 35 + sess_len;
    #####: 1510:        cookie_len = buf[cookie_offset];
        -: 1511:
    #####: 1512:        if( cookie_offset + 1 + cookie_len + 2 > msg_len )
        -: 1513:        {
    #####: 1514:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####: 1515:            mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 1516:                                            MBEDTLS_SSL_ALERT_MSG_PROTOCOL_VERSION );
    #####: 1517:            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1518:        }
        -: 1519:
    #####: 1520:        MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, cookie",
        -: 1521:                       buf + cookie_offset + 1, cookie_len );
        -: 1522:
        -: 1523:#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
    #####: 1524:        if( ssl->conf->f_cookie_check != NULL
        -: 1525:#if defined(MBEDTLS_SSL_RENEGOTIATION)
        -: 1526:            && ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE
        -: 1527:#endif
        -: 1528:            )
        -: 1529:        {
    #####: 1530:            if( ssl->conf->f_cookie_check( ssl->conf->p_cookie,
    #####: 1531:                                     buf + cookie_offset + 1, cookie_len,
    #####: 1532:                                     ssl->cli_id, ssl->cli_id_len ) != 0 )
        -: 1533:            {
    #####: 1534:                MBEDTLS_SSL_DEBUG_MSG( 2, ( "cookie verification failed" ) );
    #####: 1535:                ssl->handshake->verify_cookie_len = 1;
        -: 1536:            }
        -: 1537:            else
        -: 1538:            {
    #####: 1539:                MBEDTLS_SSL_DEBUG_MSG( 2, ( "cookie verification passed" ) );
    #####: 1540:                ssl->handshake->verify_cookie_len = 0;
        -: 1541:            }
        -: 1542:        }
        -: 1543:        else
        -: 1544:#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
        -: 1545:        {
        -: 1546:            /* We know we didn't send a cookie, so it should be empty */
    #####: 1547:            if( cookie_len != 0 )
        -: 1548:            {
        -: 1549:                /* This may be an attacker's probe, so don't send an alert */
    #####: 1550:                MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####: 1551:                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1552:            }
        -: 1553:
    #####: 1554:            MBEDTLS_SSL_DEBUG_MSG( 2, ( "cookie verification skipped" ) );
        -: 1555:        }
        -: 1556:
        -: 1557:    /*
        -: 1558:     * Check the ciphersuitelist length (will be parsed later)
        -: 1559:     */
    #####: 1560:        ciph_offset = cookie_offset + 1 + cookie_len;
        -: 1561:    }
        -: 1562:    else
        -: 1563:#endif /* MBEDTLS_SSL_PROTO_DTLS */
    #####: 1564:        ciph_offset = 35 + sess_len;
        -: 1565:
    #####: 1566:    ciph_len = ( buf[ciph_offset + 0] << 8 )
    #####: 1567:             | ( buf[ciph_offset + 1]      );
        -: 1568:
    #####: 1569:    if( ciph_len < 2 ||
    #####: 1570:        ciph_len + 2 + ciph_offset + 1 > msg_len || /* 1 for comp. alg. len */
    #####: 1571:        ( ciph_len % 2 ) != 0 )
        -: 1572:    {
    #####: 1573:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####: 1574:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 1575:                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    #####: 1576:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1577:    }
        -: 1578:
    #####: 1579:    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, ciphersuitelist",
        -: 1580:                   buf + ciph_offset + 2,  ciph_len );
        -: 1581:
        -: 1582:    /*
        -: 1583:     * Check the compression algorithms length and pick one
        -: 1584:     */
    #####: 1585:    comp_offset = ciph_offset + 2 + ciph_len;
        -: 1586:
    #####: 1587:    comp_len = buf[comp_offset];
        -: 1588:
    #####: 1589:    if( comp_len < 1 ||
    #####: 1590:        comp_len > 16 ||
    #####: 1591:        comp_len + comp_offset + 1 > msg_len )
        -: 1592:    {
    #####: 1593:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####: 1594:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 1595:                                        MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    #####: 1596:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1597:    }
        -: 1598:
    #####: 1599:    MBEDTLS_SSL_DEBUG_BUF( 3, "client hello, compression",
        -: 1600:                      buf + comp_offset + 1, comp_len );
        -: 1601:
    #####: 1602:    ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_NULL;
        -: 1603:#if defined(MBEDTLS_ZLIB_SUPPORT)
        -: 1604:    for( i = 0; i < comp_len; ++i )
        -: 1605:    {
        -: 1606:        if( buf[comp_offset + 1 + i] == MBEDTLS_SSL_COMPRESS_DEFLATE )
        -: 1607:        {
        -: 1608:            ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_DEFLATE;
        -: 1609:            break;
        -: 1610:        }
        -: 1611:    }
        -: 1612:#endif
        -: 1613:
        -: 1614:    /* See comments in ssl_write_client_hello() */
        -: 1615:#if defined(MBEDTLS_SSL_PROTO_DTLS)
    #####: 1616:    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
    #####: 1617:        ssl->session_negotiate->compression = MBEDTLS_SSL_COMPRESS_NULL;
        -: 1618:#endif
        -: 1619:
        -: 1620:    /* Do not parse the extensions if the protocol is SSLv3 */
        -: 1621:#if defined(MBEDTLS_SSL_PROTO_SSL3)
        -: 1622:    if( ( ssl->major_ver != 3 ) || ( ssl->minor_ver != 0 ) )
        -: 1623:    {
        -: 1624:#endif
        -: 1625:        /*
        -: 1626:         * Check the extension length
        -: 1627:         */
    #####: 1628:        ext_offset = comp_offset + 1 + comp_len;
    #####: 1629:        if( msg_len > ext_offset )
        -: 1630:        {
    #####: 1631:            if( msg_len < ext_offset + 2 )
        -: 1632:            {
    #####: 1633:                MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####: 1634:                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 1635:                                                MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    #####: 1636:                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1637:            }
        -: 1638:
    #####: 1639:            ext_len = ( buf[ext_offset + 0] << 8 )
    #####: 1640:                    | ( buf[ext_offset + 1]      );
        -: 1641:
    #####: 1642:            if( ( ext_len > 0 && ext_len < 4 ) ||
    #####: 1643:                msg_len != ext_offset + 2 + ext_len )
        -: 1644:            {
    #####: 1645:                MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####: 1646:                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 1647:                                                MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    #####: 1648:                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1649:            }
        -: 1650:        }
        -: 1651:        else
    #####: 1652:            ext_len = 0;
        -: 1653:
    #####: 1654:        ext = buf + ext_offset + 2;
    #####: 1655:        MBEDTLS_SSL_DEBUG_BUF( 3, "client hello extensions", ext, ext_len );
        -: 1656:
    #####: 1657:        while( ext_len != 0 )
        -: 1658:        {
    #####: 1659:            unsigned int ext_id   = ( ( ext[0] <<  8 )
    #####: 1660:                                    | ( ext[1]       ) );
    #####: 1661:            unsigned int ext_size = ( ( ext[2] <<  8 )
    #####: 1662:                                    | ( ext[3]       ) );
        -: 1663:
    #####: 1664:            if( ext_size + 4 > ext_len )
        -: 1665:            {
    #####: 1666:                MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####: 1667:                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 1668:                                                MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    #####: 1669:                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1670:            }
    #####: 1671:            switch( ext_id )
        -: 1672:            {
        -: 1673:#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
    #####: 1674:            case MBEDTLS_TLS_EXT_SERVERNAME:
    #####: 1675:                MBEDTLS_SSL_DEBUG_MSG( 3, ( "found ServerName extension" ) );
    #####: 1676:                if( ssl->conf->f_sni == NULL )
    #####: 1677:                    break;
        -: 1678:
    #####: 1679:                ret = ssl_parse_servername_ext( ssl, ext + 4, ext_size );
    #####: 1680:                if( ret != 0 )
    #####: 1681:                    return( ret );
    #####: 1682:                break;
        -: 1683:#endif /* MBEDTLS_SSL_SERVER_NAME_INDICATION */
        -: 1684:
    #####: 1685:            case MBEDTLS_TLS_EXT_RENEGOTIATION_INFO:
    #####: 1686:                MBEDTLS_SSL_DEBUG_MSG( 3, ( "found renegotiation extension" ) );
        -: 1687:#if defined(MBEDTLS_SSL_RENEGOTIATION)
        -: 1688:                renegotiation_info_seen = 1;
        -: 1689:#endif
        -: 1690:
    #####: 1691:                ret = ssl_parse_renegotiation_info( ssl, ext + 4, ext_size );
    #####: 1692:                if( ret != 0 )
    #####: 1693:                    return( ret );
    #####: 1694:                break;
        -: 1695:
        -: 1696:#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
        -: 1697:    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
        -: 1698:            case MBEDTLS_TLS_EXT_SIG_ALG:
        -: 1699:                MBEDTLS_SSL_DEBUG_MSG( 3, ( "found signature_algorithms extension" ) );
        -: 1700:
        -: 1701:                ret = ssl_parse_signature_algorithms_ext( ssl, ext + 4, ext_size );
        -: 1702:                if( ret != 0 )
        -: 1703:                    return( ret );
        -: 1704:
        -: 1705:                sig_hash_alg_ext_present = 1;
        -: 1706:                break;
        -: 1707:#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&
        -: 1708:          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
        -: 1709:
        -: 1710:#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
        -: 1711:    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
        -: 1712:            case MBEDTLS_TLS_EXT_SUPPORTED_ELLIPTIC_CURVES:
        -: 1713:                MBEDTLS_SSL_DEBUG_MSG( 3, ( "found supported elliptic curves extension" ) );
        -: 1714:
        -: 1715:                ret = ssl_parse_supported_elliptic_curves( ssl, ext + 4, ext_size );
        -: 1716:                if( ret != 0 )
        -: 1717:                    return( ret );
        -: 1718:                break;
        -: 1719:
        -: 1720:            case MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS:
        -: 1721:                MBEDTLS_SSL_DEBUG_MSG( 3, ( "found supported point formats extension" ) );
        -: 1722:                ssl->handshake->cli_exts |= MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT;
        -: 1723:
        -: 1724:                ret = ssl_parse_supported_point_formats( ssl, ext + 4, ext_size );
        -: 1725:                if( ret != 0 )
        -: 1726:                    return( ret );
        -: 1727:                break;
        -: 1728:#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C ||
        -: 1729:          MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
        -: 1730:
        -: 1731:#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
        -: 1732:            case MBEDTLS_TLS_EXT_ECJPAKE_KKPP:
        -: 1733:                MBEDTLS_SSL_DEBUG_MSG( 3, ( "found ecjpake kkpp extension" ) );
        -: 1734:
        -: 1735:                ret = ssl_parse_ecjpake_kkpp( ssl, ext + 4, ext_size );
        -: 1736:                if( ret != 0 )
        -: 1737:                    return( ret );
        -: 1738:                break;
        -: 1739:#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
        -: 1740:
        -: 1741:#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
        -: 1742:            case MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH:
        -: 1743:                MBEDTLS_SSL_DEBUG_MSG( 3, ( "found max fragment length extension" ) );
        -: 1744:
        -: 1745:                ret = ssl_parse_max_fragment_length_ext( ssl, ext + 4, ext_size );
        -: 1746:                if( ret != 0 )
        -: 1747:                    return( ret );
        -: 1748:                break;
        -: 1749:#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
        -: 1750:
        -: 1751:#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
        -: 1752:            case MBEDTLS_TLS_EXT_TRUNCATED_HMAC:
        -: 1753:                MBEDTLS_SSL_DEBUG_MSG( 3, ( "found truncated hmac extension" ) );
        -: 1754:
        -: 1755:                ret = ssl_parse_truncated_hmac_ext( ssl, ext + 4, ext_size );
        -: 1756:                if( ret != 0 )
        -: 1757:                    return( ret );
        -: 1758:                break;
        -: 1759:#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */
        -: 1760:
        -: 1761:#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
        -: 1762:            case MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC:
        -: 1763:                MBEDTLS_SSL_DEBUG_MSG( 3, ( "found encrypt then mac extension" ) );
        -: 1764:
        -: 1765:                ret = ssl_parse_encrypt_then_mac_ext( ssl, ext + 4, ext_size );
        -: 1766:                if( ret != 0 )
        -: 1767:                    return( ret );
        -: 1768:                break;
        -: 1769:#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
        -: 1770:
        -: 1771:#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
        -: 1772:            case MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET:
        -: 1773:                MBEDTLS_SSL_DEBUG_MSG( 3, ( "found extended master secret extension" ) );
        -: 1774:
        -: 1775:                ret = ssl_parse_extended_ms_ext( ssl, ext + 4, ext_size );
        -: 1776:                if( ret != 0 )
        -: 1777:                    return( ret );
        -: 1778:                break;
        -: 1779:#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
        -: 1780:
        -: 1781:#if defined(MBEDTLS_SSL_SESSION_TICKETS)
        -: 1782:            case MBEDTLS_TLS_EXT_SESSION_TICKET:
        -: 1783:                MBEDTLS_SSL_DEBUG_MSG( 3, ( "found session ticket extension" ) );
        -: 1784:
        -: 1785:                ret = ssl_parse_session_ticket_ext( ssl, ext + 4, ext_size );
        -: 1786:                if( ret != 0 )
        -: 1787:                    return( ret );
        -: 1788:                break;
        -: 1789:#endif /* MBEDTLS_SSL_SESSION_TICKETS */
        -: 1790:
        -: 1791:#if defined(MBEDTLS_SSL_ALPN)
    #####: 1792:            case MBEDTLS_TLS_EXT_ALPN:
    #####: 1793:                MBEDTLS_SSL_DEBUG_MSG( 3, ( "found alpn extension" ) );
        -: 1794:
    #####: 1795:                ret = ssl_parse_alpn_ext( ssl, ext + 4, ext_size );
    #####: 1796:                if( ret != 0 )
    #####: 1797:                    return( ret );
    #####: 1798:                break;
        -: 1799:#endif /* MBEDTLS_SSL_SESSION_TICKETS */
        -: 1800:
    #####: 1801:            default:
    #####: 1802:                MBEDTLS_SSL_DEBUG_MSG( 3, ( "unknown extension found: %d (ignoring)",
        -: 1803:                               ext_id ) );
        -: 1804:            }
        -: 1805:
    #####: 1806:            ext_len -= 4 + ext_size;
    #####: 1807:            ext += 4 + ext_size;
        -: 1808:
    #####: 1809:            if( ext_len > 0 && ext_len < 4 )
        -: 1810:            {
    #####: 1811:                MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client hello message" ) );
    #####: 1812:                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 1813:                                                MBEDTLS_SSL_ALERT_MSG_DECODE_ERROR );
    #####: 1814:                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1815:            }
        -: 1816:        }
        -: 1817:#if defined(MBEDTLS_SSL_PROTO_SSL3)
        -: 1818:    }
        -: 1819:#endif
        -: 1820:
        -: 1821:#if defined(MBEDTLS_SSL_FALLBACK_SCSV)
        -: 1822:    for( i = 0, p = buf + ciph_offset + 2; i < ciph_len; i += 2, p += 2 )
        -: 1823:    {
        -: 1824:        if( p[0] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE >> 8 ) & 0xff ) &&
        -: 1825:            p[1] == (unsigned char)( ( MBEDTLS_SSL_FALLBACK_SCSV_VALUE      ) & 0xff ) )
        -: 1826:        {
        -: 1827:            MBEDTLS_SSL_DEBUG_MSG( 2, ( "received FALLBACK_SCSV" ) );
        -: 1828:
        -: 1829:            if( ssl->minor_ver < ssl->conf->max_minor_ver )
        -: 1830:            {
        -: 1831:                MBEDTLS_SSL_DEBUG_MSG( 1, ( "inapropriate fallback" ) );
        -: 1832:
        -: 1833:                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 1834:                                        MBEDTLS_SSL_ALERT_MSG_INAPROPRIATE_FALLBACK );
        -: 1835:
        -: 1836:                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1837:            }
        -: 1838:
        -: 1839:            break;
        -: 1840:        }
        -: 1841:    }
        -: 1842:#endif /* MBEDTLS_SSL_FALLBACK_SCSV */
        -: 1843:
        -: 1844:#if defined(MBEDTLS_SSL_PROTO_TLS1_2) && \
        -: 1845:    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
        -: 1846:
        -: 1847:    /*
        -: 1848:     * Try to fall back to default hash SHA1 if the client
        -: 1849:     * hasn't provided any preferred signature-hash combinations.
        -: 1850:     */
        -: 1851:    if( sig_hash_alg_ext_present == 0 )
        -: 1852:    {
        -: 1853:        mbedtls_md_type_t md_default = MBEDTLS_MD_SHA1;
        -: 1854:
        -: 1855:        if( mbedtls_ssl_check_sig_hash( ssl, md_default ) != 0 )
        -: 1856:            md_default = MBEDTLS_MD_NONE;
        -: 1857:
        -: 1858:        mbedtls_ssl_sig_hash_set_const_hash( &ssl->handshake->hash_algs, md_default );
        -: 1859:    }
        -: 1860:
        -: 1861:#endif /* MBEDTLS_SSL_PROTO_TLS1_2 &&
        -: 1862:          MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED */
        -: 1863:
        -: 1864:    /*
        -: 1865:     * Check for TLS_EMPTY_RENEGOTIATION_INFO_SCSV
        -: 1866:     */
    #####: 1867:    for( i = 0, p = buf + ciph_offset + 2; i < ciph_len; i += 2, p += 2 )
        -: 1868:    {
    #####: 1869:        if( p[0] == 0 && p[1] == MBEDTLS_SSL_EMPTY_RENEGOTIATION_INFO )
        -: 1870:        {
    #####: 1871:            MBEDTLS_SSL_DEBUG_MSG( 3, ( "received TLS_EMPTY_RENEGOTIATION_INFO " ) );
        -: 1872:#if defined(MBEDTLS_SSL_RENEGOTIATION)
        -: 1873:            if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS )
        -: 1874:            {
        -: 1875:                MBEDTLS_SSL_DEBUG_MSG( 1, ( "received RENEGOTIATION SCSV "
        -: 1876:                                            "during renegotiation" ) );
        -: 1877:                mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 1878:                                                MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
        -: 1879:                return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1880:            }
        -: 1881:#endif
    #####: 1882:            ssl->secure_renegotiation = MBEDTLS_SSL_SECURE_RENEGOTIATION;
    #####: 1883:            break;
        -: 1884:        }
        -: 1885:    }
        -: 1886:
        -: 1887:    /*
        -: 1888:     * Renegotiation security checks
        -: 1889:     */
    #####: 1890:    if( ssl->secure_renegotiation != MBEDTLS_SSL_SECURE_RENEGOTIATION &&
    #####: 1891:        ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_BREAK_HANDSHAKE )
        -: 1892:    {
    #####: 1893:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "legacy renegotiation, breaking off handshake" ) );
    #####: 1894:        handshake_failure = 1;
        -: 1895:    }
        -: 1896:#if defined(MBEDTLS_SSL_RENEGOTIATION)
        -: 1897:    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
        -: 1898:             ssl->secure_renegotiation == MBEDTLS_SSL_SECURE_RENEGOTIATION &&
        -: 1899:             renegotiation_info_seen == 0 )
        -: 1900:    {
        -: 1901:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "renegotiation_info extension missing (secure)" ) );
        -: 1902:        handshake_failure = 1;
        -: 1903:    }
        -: 1904:    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
        -: 1905:             ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
        -: 1906:             ssl->conf->allow_legacy_renegotiation == MBEDTLS_SSL_LEGACY_NO_RENEGOTIATION )
        -: 1907:    {
        -: 1908:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "legacy renegotiation not allowed" ) );
        -: 1909:        handshake_failure = 1;
        -: 1910:    }
        -: 1911:    else if( ssl->renego_status == MBEDTLS_SSL_RENEGOTIATION_IN_PROGRESS &&
        -: 1912:             ssl->secure_renegotiation == MBEDTLS_SSL_LEGACY_RENEGOTIATION &&
        -: 1913:             renegotiation_info_seen == 1 )
        -: 1914:    {
        -: 1915:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "renegotiation_info extension present (legacy)" ) );
        -: 1916:        handshake_failure = 1;
        -: 1917:    }
        -: 1918:#endif /* MBEDTLS_SSL_RENEGOTIATION */
        -: 1919:
    #####: 1920:    if( handshake_failure == 1 )
        -: 1921:    {
    #####: 1922:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 1923:                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
    #####: 1924:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_HELLO );
        -: 1925:    }
        -: 1926:
        -: 1927:    /*
        -: 1928:     * Search for a matching ciphersuite
        -: 1929:     * (At the end because we need information from the EC-based extensions
        -: 1930:     * and certificate from the SNI callback triggered by the SNI extension.)
        -: 1931:     */
    #####: 1932:    got_common_suite = 0;
    #####: 1933:    ciphersuites = ssl->conf->ciphersuite_list[ssl->minor_ver];
    #####: 1934:    ciphersuite_info = NULL;
        -: 1935:#if defined(MBEDTLS_SSL_SRV_RESPECT_CLIENT_PREFERENCE)
        -: 1936:    for( j = 0, p = buf + ciph_offset + 2; j < ciph_len; j += 2, p += 2 )
        -: 1937:        for( i = 0; ciphersuites[i] != 0; i++ )
        -: 1938:#else
    #####: 1939:    for( i = 0; ciphersuites[i] != 0; i++ )
    #####: 1940:        for( j = 0, p = buf + ciph_offset + 2; j < ciph_len; j += 2, p += 2 )
        -: 1941:#endif
        -: 1942:        {
    #####: 1943:            if( p[0] != ( ( ciphersuites[i] >> 8 ) & 0xFF ) ||
    #####: 1944:                p[1] != ( ( ciphersuites[i]      ) & 0xFF ) )
    #####: 1945:                continue;
        -: 1946:
    #####: 1947:            got_common_suite = 1;
        -: 1948:
    #####: 1949:            if( ( ret = ssl_ciphersuite_match( ssl, ciphersuites[i],
        -: 1950:                                               &ciphersuite_info ) ) != 0 )
    #####: 1951:                return( ret );
        -: 1952:
    #####: 1953:            if( ciphersuite_info != NULL )
    #####: 1954:                goto have_ciphersuite;
        -: 1955:        }
        -: 1956:
    #####: 1957:    if( got_common_suite )
        -: 1958:    {
    #####: 1959:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "got ciphersuites in common, "
        -: 1960:                            "but none of them usable" ) );
    #####: 1961:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 1962:                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
    #####: 1963:        return( MBEDTLS_ERR_SSL_NO_USABLE_CIPHERSUITE );
        -: 1964:    }
        -: 1965:    else
        -: 1966:    {
    #####: 1967:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no ciphersuites in common" ) );
    #####: 1968:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 1969:                                        MBEDTLS_SSL_ALERT_MSG_HANDSHAKE_FAILURE );
    #####: 1970:        return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );
        -: 1971:    }
        -: 1972:
    #####: 1973:have_ciphersuite:
    #####: 1974:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "selected ciphersuite: %s", ciphersuite_info->name ) );
        -: 1975:
    #####: 1976:    ssl->session_negotiate->ciphersuite = ciphersuites[i];
    #####: 1977:    ssl->transform_negotiate->ciphersuite_info = ciphersuite_info;
        -: 1978:
    #####: 1979:    ssl->state++;
        -: 1980:
        -: 1981:#if defined(MBEDTLS_SSL_PROTO_DTLS)
    #####: 1982:    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
    #####: 1983:        mbedtls_ssl_recv_flight_completed( ssl );
        -: 1984:#endif
        -: 1985:
        -: 1986:    /* Debugging-only output for testsuite */
        -: 1987:#if defined(MBEDTLS_DEBUG_C)                         && \
        -: 1988:    defined(MBEDTLS_SSL_PROTO_TLS1_2)                && \
        -: 1989:    defined(MBEDTLS_KEY_EXCHANGE__WITH_CERT__ENABLED)
        -: 1990:    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
        -: 1991:    {
        -: 1992:        mbedtls_pk_type_t sig_alg = mbedtls_ssl_get_ciphersuite_sig_alg( ciphersuite_info );
        -: 1993:        if( sig_alg != MBEDTLS_PK_NONE )
        -: 1994:        {
        -: 1995:            mbedtls_md_type_t md_alg = mbedtls_ssl_sig_hash_set_find( &ssl->handshake->hash_algs,
        -: 1996:                                                                  sig_alg );
        -: 1997:            MBEDTLS_SSL_DEBUG_MSG( 3, ( "client hello v3, signature_algorithm ext: %d",
        -: 1998:                                        mbedtls_ssl_hash_from_md_alg( md_alg ) ) );
        -: 1999:        }
        -: 2000:        else
        -: 2001:        {
        -: 2002:            MBEDTLS_SSL_DEBUG_MSG( 3, ( "no hash algorithm for signature algorithm "
        -: 2003:                                        "%d - should not happen", sig_alg ) );
        -: 2004:        }
        -: 2005:    }
        -: 2006:#endif
        -: 2007:
    #####: 2008:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse client hello" ) );
        -: 2009:
    #####: 2010:    return( 0 );
        -: 2011:}
        -: 2012:
        -: 2013:#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
        -: 2014:static void ssl_write_truncated_hmac_ext( mbedtls_ssl_context *ssl,
        -: 2015:                                          unsigned char *buf,
        -: 2016:                                          size_t *olen )
        -: 2017:{
        -: 2018:    unsigned char *p = buf;
        -: 2019:
        -: 2020:    if( ssl->session_negotiate->trunc_hmac == MBEDTLS_SSL_TRUNC_HMAC_DISABLED )
        -: 2021:    {
        -: 2022:        *olen = 0;
        -: 2023:        return;
        -: 2024:    }
        -: 2025:
        -: 2026:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding truncated hmac extension" ) );
        -: 2027:
        -: 2028:    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC >> 8 ) & 0xFF );
        -: 2029:    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_TRUNCATED_HMAC      ) & 0xFF );
        -: 2030:
        -: 2031:    *p++ = 0x00;
        -: 2032:    *p++ = 0x00;
        -: 2033:
        -: 2034:    *olen = 4;
        -: 2035:}
        -: 2036:#endif /* MBEDTLS_SSL_TRUNCATED_HMAC */
        -: 2037:
        -: 2038:#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
        -: 2039:static void ssl_write_encrypt_then_mac_ext( mbedtls_ssl_context *ssl,
        -: 2040:                                            unsigned char *buf,
        -: 2041:                                            size_t *olen )
        -: 2042:{
        -: 2043:    unsigned char *p = buf;
        -: 2044:    const mbedtls_ssl_ciphersuite_t *suite = NULL;
        -: 2045:    const mbedtls_cipher_info_t *cipher = NULL;
        -: 2046:
        -: 2047:    if( ssl->session_negotiate->encrypt_then_mac == MBEDTLS_SSL_ETM_DISABLED ||
        -: 2048:        ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
        -: 2049:    {
        -: 2050:        *olen = 0;
        -: 2051:        return;
        -: 2052:    }
        -: 2053:
        -: 2054:    /*
        -: 2055:     * RFC 7366: "If a server receives an encrypt-then-MAC request extension
        -: 2056:     * from a client and then selects a stream or Authenticated Encryption
        -: 2057:     * with Associated Data (AEAD) ciphersuite, it MUST NOT send an
        -: 2058:     * encrypt-then-MAC response extension back to the client."
        -: 2059:     */
        -: 2060:    if( ( suite = mbedtls_ssl_ciphersuite_from_id(
        -: 2061:                    ssl->session_negotiate->ciphersuite ) ) == NULL ||
        -: 2062:        ( cipher = mbedtls_cipher_info_from_type( suite->cipher ) ) == NULL ||
        -: 2063:        cipher->mode != MBEDTLS_MODE_CBC )
        -: 2064:    {
        -: 2065:        *olen = 0;
        -: 2066:        return;
        -: 2067:    }
        -: 2068:
        -: 2069:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding encrypt then mac extension" ) );
        -: 2070:
        -: 2071:    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC >> 8 ) & 0xFF );
        -: 2072:    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ENCRYPT_THEN_MAC      ) & 0xFF );
        -: 2073:
        -: 2074:    *p++ = 0x00;
        -: 2075:    *p++ = 0x00;
        -: 2076:
        -: 2077:    *olen = 4;
        -: 2078:}
        -: 2079:#endif /* MBEDTLS_SSL_ENCRYPT_THEN_MAC */
        -: 2080:
        -: 2081:#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
        -: 2082:static void ssl_write_extended_ms_ext( mbedtls_ssl_context *ssl,
        -: 2083:                                       unsigned char *buf,
        -: 2084:                                       size_t *olen )
        -: 2085:{
        -: 2086:    unsigned char *p = buf;
        -: 2087:
        -: 2088:    if( ssl->handshake->extended_ms == MBEDTLS_SSL_EXTENDED_MS_DISABLED ||
        -: 2089:        ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_0 )
        -: 2090:    {
        -: 2091:        *olen = 0;
        -: 2092:        return;
        -: 2093:    }
        -: 2094:
        -: 2095:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding extended master secret "
        -: 2096:                        "extension" ) );
        -: 2097:
        -: 2098:    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET >> 8 ) & 0xFF );
        -: 2099:    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_EXTENDED_MASTER_SECRET      ) & 0xFF );
        -: 2100:
        -: 2101:    *p++ = 0x00;
        -: 2102:    *p++ = 0x00;
        -: 2103:
        -: 2104:    *olen = 4;
        -: 2105:}
        -: 2106:#endif /* MBEDTLS_SSL_EXTENDED_MASTER_SECRET */
        -: 2107:
        -: 2108:#if defined(MBEDTLS_SSL_SESSION_TICKETS)
        -: 2109:static void ssl_write_session_ticket_ext( mbedtls_ssl_context *ssl,
        -: 2110:                                          unsigned char *buf,
        -: 2111:                                          size_t *olen )
        -: 2112:{
        -: 2113:    unsigned char *p = buf;
        -: 2114:
        -: 2115:    if( ssl->handshake->new_session_ticket == 0 )
        -: 2116:    {
        -: 2117:        *olen = 0;
        -: 2118:        return;
        -: 2119:    }
        -: 2120:
        -: 2121:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding session ticket extension" ) );
        -: 2122:
        -: 2123:    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET >> 8 ) & 0xFF );
        -: 2124:    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SESSION_TICKET      ) & 0xFF );
        -: 2125:
        -: 2126:    *p++ = 0x00;
        -: 2127:    *p++ = 0x00;
        -: 2128:
        -: 2129:    *olen = 4;
        -: 2130:}
        -: 2131:#endif /* MBEDTLS_SSL_SESSION_TICKETS */
        -: 2132:
    #####: 2133:static void ssl_write_renegotiation_ext( mbedtls_ssl_context *ssl,
        -: 2134:                                         unsigned char *buf,
        -: 2135:                                         size_t *olen )
        -: 2136:{
    #####: 2137:    unsigned char *p = buf;
        -: 2138:
    #####: 2139:    if( ssl->secure_renegotiation != MBEDTLS_SSL_SECURE_RENEGOTIATION )
        -: 2140:    {
    #####: 2141:        *olen = 0;
    #####: 2142:        return;
        -: 2143:    }
        -: 2144:
    #####: 2145:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, secure renegotiation extension" ) );
        -: 2146:
    #####: 2147:    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO >> 8 ) & 0xFF );
    #####: 2148:    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_RENEGOTIATION_INFO      ) & 0xFF );
        -: 2149:
        -: 2150:#if defined(MBEDTLS_SSL_RENEGOTIATION)
        -: 2151:    if( ssl->renego_status != MBEDTLS_SSL_INITIAL_HANDSHAKE )
        -: 2152:    {
        -: 2153:        *p++ = 0x00;
        -: 2154:        *p++ = ( ssl->verify_data_len * 2 + 1 ) & 0xFF;
        -: 2155:        *p++ = ssl->verify_data_len * 2 & 0xFF;
        -: 2156:
        -: 2157:        memcpy( p, ssl->peer_verify_data, ssl->verify_data_len );
        -: 2158:        p += ssl->verify_data_len;
        -: 2159:        memcpy( p, ssl->own_verify_data, ssl->verify_data_len );
        -: 2160:        p += ssl->verify_data_len;
        -: 2161:    }
        -: 2162:    else
        -: 2163:#endif /* MBEDTLS_SSL_RENEGOTIATION */
        -: 2164:    {
    #####: 2165:        *p++ = 0x00;
    #####: 2166:        *p++ = 0x01;
    #####: 2167:        *p++ = 0x00;
        -: 2168:    }
        -: 2169:
    #####: 2170:    *olen = p - buf;
        -: 2171:}
        -: 2172:
        -: 2173:#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
        -: 2174:static void ssl_write_max_fragment_length_ext( mbedtls_ssl_context *ssl,
        -: 2175:                                               unsigned char *buf,
        -: 2176:                                               size_t *olen )
        -: 2177:{
        -: 2178:    unsigned char *p = buf;
        -: 2179:
        -: 2180:    if( ssl->session_negotiate->mfl_code == MBEDTLS_SSL_MAX_FRAG_LEN_NONE )
        -: 2181:    {
        -: 2182:        *olen = 0;
        -: 2183:        return;
        -: 2184:    }
        -: 2185:
        -: 2186:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, max_fragment_length extension" ) );
        -: 2187:
        -: 2188:    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH >> 8 ) & 0xFF );
        -: 2189:    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_MAX_FRAGMENT_LENGTH      ) & 0xFF );
        -: 2190:
        -: 2191:    *p++ = 0x00;
        -: 2192:    *p++ = 1;
        -: 2193:
        -: 2194:    *p++ = ssl->session_negotiate->mfl_code;
        -: 2195:
        -: 2196:    *olen = 5;
        -: 2197:}
        -: 2198:#endif /* MBEDTLS_SSL_MAX_FRAGMENT_LENGTH */
        -: 2199:
        -: 2200:#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
        -: 2201:    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
        -: 2202:static void ssl_write_supported_point_formats_ext( mbedtls_ssl_context *ssl,
        -: 2203:                                                   unsigned char *buf,
        -: 2204:                                                   size_t *olen )
        -: 2205:{
        -: 2206:    unsigned char *p = buf;
        -: 2207:    ((void) ssl);
        -: 2208:
        -: 2209:    if( ( ssl->handshake->cli_exts &
        -: 2210:          MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT ) == 0 )
        -: 2211:    {
        -: 2212:        *olen = 0;
        -: 2213:        return;
        -: 2214:    }
        -: 2215:
        -: 2216:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, supported_point_formats extension" ) );
        -: 2217:
        -: 2218:    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS >> 8 ) & 0xFF );
        -: 2219:    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_SUPPORTED_POINT_FORMATS      ) & 0xFF );
        -: 2220:
        -: 2221:    *p++ = 0x00;
        -: 2222:    *p++ = 2;
        -: 2223:
        -: 2224:    *p++ = 1;
        -: 2225:    *p++ = MBEDTLS_ECP_PF_UNCOMPRESSED;
        -: 2226:
        -: 2227:    *olen = 6;
        -: 2228:}
        -: 2229:#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C || MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
        -: 2230:
        -: 2231:#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
        -: 2232:static void ssl_write_ecjpake_kkpp_ext( mbedtls_ssl_context *ssl,
        -: 2233:                                        unsigned char *buf,
        -: 2234:                                        size_t *olen )
        -: 2235:{
        -: 2236:    int ret;
        -: 2237:    unsigned char *p = buf;
        -: 2238:    const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
        -: 2239:    size_t kkpp_len;
        -: 2240:
        -: 2241:    *olen = 0;
        -: 2242:
        -: 2243:    /* Skip costly computation if not needed */
        -: 2244:    if( ssl->transform_negotiate->ciphersuite_info->key_exchange !=
        -: 2245:        MBEDTLS_KEY_EXCHANGE_ECJPAKE )
        -: 2246:        return;
        -: 2247:
        -: 2248:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, ecjpake kkpp extension" ) );
        -: 2249:
        -: 2250:    if( end - p < 4 )
        -: 2251:    {
        -: 2252:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "buffer too small" ) );
        -: 2253:        return;
        -: 2254:    }
        -: 2255:
        -: 2256:    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ECJPAKE_KKPP >> 8 ) & 0xFF );
        -: 2257:    *p++ = (unsigned char)( ( MBEDTLS_TLS_EXT_ECJPAKE_KKPP      ) & 0xFF );
        -: 2258:
        -: 2259:    ret = mbedtls_ecjpake_write_round_one( &ssl->handshake->ecjpake_ctx,
        -: 2260:                                        p + 2, end - p - 2, &kkpp_len,
        -: 2261:                                        ssl->conf->f_rng, ssl->conf->p_rng );
        -: 2262:    if( ret != 0 )
        -: 2263:    {
        -: 2264:        MBEDTLS_SSL_DEBUG_RET( 1 , "mbedtls_ecjpake_write_round_one", ret );
        -: 2265:        return;
        -: 2266:    }
        -: 2267:
        -: 2268:    *p++ = (unsigned char)( ( kkpp_len >> 8 ) & 0xFF );
        -: 2269:    *p++ = (unsigned char)( ( kkpp_len      ) & 0xFF );
        -: 2270:
        -: 2271:    *olen = kkpp_len + 4;
        -: 2272:}
        -: 2273:#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
        -: 2274:
        -: 2275:#if defined(MBEDTLS_SSL_ALPN )
    #####: 2276:static void ssl_write_alpn_ext( mbedtls_ssl_context *ssl,
        -: 2277:                                unsigned char *buf, size_t *olen )
        -: 2278:{
    #####: 2279:    if( ssl->alpn_chosen == NULL )
        -: 2280:    {
    #####: 2281:        *olen = 0;
    #####: 2282:        return;
        -: 2283:    }
        -: 2284:
    #####: 2285:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, adding alpn extension" ) );
        -: 2286:
        -: 2287:    /*
        -: 2288:     * 0 . 1    ext identifier
        -: 2289:     * 2 . 3    ext length
        -: 2290:     * 4 . 5    protocol list length
        -: 2291:     * 6 . 6    protocol name length
        -: 2292:     * 7 . 7+n  protocol name
        -: 2293:     */
    #####: 2294:    buf[0] = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN >> 8 ) & 0xFF );
    #####: 2295:    buf[1] = (unsigned char)( ( MBEDTLS_TLS_EXT_ALPN      ) & 0xFF );
        -: 2296:
    #####: 2297:    *olen = 7 + strlen( ssl->alpn_chosen );
        -: 2298:
    #####: 2299:    buf[2] = (unsigned char)( ( ( *olen - 4 ) >> 8 ) & 0xFF );
    #####: 2300:    buf[3] = (unsigned char)( ( ( *olen - 4 )      ) & 0xFF );
        -: 2301:
    #####: 2302:    buf[4] = (unsigned char)( ( ( *olen - 6 ) >> 8 ) & 0xFF );
    #####: 2303:    buf[5] = (unsigned char)( ( ( *olen - 6 )      ) & 0xFF );
        -: 2304:
    #####: 2305:    buf[6] = (unsigned char)( ( ( *olen - 7 )      ) & 0xFF );
        -: 2306:
    #####: 2307:    memcpy( buf + 7, ssl->alpn_chosen, *olen - 7 );
        -: 2308:}
        -: 2309:#endif /* MBEDTLS_ECDH_C || MBEDTLS_ECDSA_C */
        -: 2310:
        -: 2311:#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
    #####: 2312:static int ssl_write_hello_verify_request( mbedtls_ssl_context *ssl )
        -: 2313:{
        -: 2314:    int ret;
    #####: 2315:    unsigned char *p = ssl->out_msg + 4;
        -: 2316:    unsigned char *cookie_len_byte;
        -: 2317:
    #####: 2318:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write hello verify request" ) );
        -: 2319:
        -: 2320:    /*
        -: 2321:     * struct {
        -: 2322:     *   ProtocolVersion server_version;
        -: 2323:     *   opaque cookie<0..2^8-1>;
        -: 2324:     * } HelloVerifyRequest;
        -: 2325:     */
        -: 2326:
        -: 2327:    /* The RFC is not clear on this point, but sending the actual negotiated
        -: 2328:     * version looks like the most interoperable thing to do. */
    #####: 2329:    mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
    #####: 2330:                       ssl->conf->transport, p );
    #####: 2331:    MBEDTLS_SSL_DEBUG_BUF( 3, "server version", p, 2 );
    #####: 2332:    p += 2;
        -: 2333:
        -: 2334:    /* If we get here, f_cookie_check is not null */
    #####: 2335:    if( ssl->conf->f_cookie_write == NULL )
        -: 2336:    {
    #####: 2337:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "inconsistent cookie callbacks" ) );
    #####: 2338:        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        -: 2339:    }
        -: 2340:
        -: 2341:    /* Skip length byte until we know the length */
    #####: 2342:    cookie_len_byte = p++;
        -: 2343:
    #####: 2344:    if( ( ret = ssl->conf->f_cookie_write( ssl->conf->p_cookie,
    #####: 2345:                                     &p, ssl->out_buf + MBEDTLS_SSL_BUFFER_LEN,
    #####: 2346:                                     ssl->cli_id, ssl->cli_id_len ) ) != 0 )
        -: 2347:    {
    #####: 2348:        MBEDTLS_SSL_DEBUG_RET( 1, "f_cookie_write", ret );
    #####: 2349:        return( ret );
        -: 2350:    }
        -: 2351:
    #####: 2352:    *cookie_len_byte = (unsigned char)( p - ( cookie_len_byte + 1 ) );
        -: 2353:
    #####: 2354:    MBEDTLS_SSL_DEBUG_BUF( 3, "cookie sent", cookie_len_byte + 1, *cookie_len_byte );
        -: 2355:
    #####: 2356:    ssl->out_msglen  = p - ssl->out_msg;
    #####: 2357:    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
    #####: 2358:    ssl->out_msg[0]  = MBEDTLS_SSL_HS_HELLO_VERIFY_REQUEST;
        -: 2359:
    #####: 2360:    ssl->state = MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT;
        -: 2361:
    #####: 2362:    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
        -: 2363:    {
    #####: 2364:        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
    #####: 2365:        return( ret );
        -: 2366:    }
        -: 2367:
    #####: 2368:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write hello verify request" ) );
        -: 2369:
    #####: 2370:    return( 0 );
        -: 2371:}
        -: 2372:#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
        -: 2373:
    #####: 2374:static int ssl_write_server_hello( mbedtls_ssl_context *ssl )
        -: 2375:{
        -: 2376:#if defined(MBEDTLS_HAVE_TIME)
        -: 2377:    mbedtls_time_t t;
        -: 2378:#endif
        -: 2379:    int ret;
    #####: 2380:    size_t olen, ext_len = 0, n;
        -: 2381:    unsigned char *buf, *p;
        -: 2382:
    #####: 2383:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write server hello" ) );
        -: 2384:
        -: 2385:#if defined(MBEDTLS_SSL_DTLS_HELLO_VERIFY)
    #####: 2386:    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
    #####: 2387:        ssl->handshake->verify_cookie_len != 0 )
        -: 2388:    {
    #####: 2389:        MBEDTLS_SSL_DEBUG_MSG( 2, ( "client hello was not authenticated" ) );
    #####: 2390:        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write server hello" ) );
        -: 2391:
    #####: 2392:        return( ssl_write_hello_verify_request( ssl ) );
        -: 2393:    }
        -: 2394:#endif /* MBEDTLS_SSL_DTLS_HELLO_VERIFY */
        -: 2395:
    #####: 2396:    if( ssl->conf->f_rng == NULL )
        -: 2397:    {
    #####: 2398:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "no RNG provided") );
    #####: 2399:        return( MBEDTLS_ERR_SSL_NO_RNG );
        -: 2400:    }
        -: 2401:
        -: 2402:    /*
        -: 2403:     *     0  .   0   handshake type
        -: 2404:     *     1  .   3   handshake length
        -: 2405:     *     4  .   5   protocol version
        -: 2406:     *     6  .   9   UNIX time()
        -: 2407:     *    10  .  37   random bytes
        -: 2408:     */
    #####: 2409:    buf = ssl->out_msg;
    #####: 2410:    p = buf + 4;
        -: 2411:
    #####: 2412:    mbedtls_ssl_write_version( ssl->major_ver, ssl->minor_ver,
    #####: 2413:                       ssl->conf->transport, p );
    #####: 2414:    p += 2;
        -: 2415:
    #####: 2416:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, chosen version: [%d:%d]",
        -: 2417:                        buf[4], buf[5] ) );
        -: 2418:
        -: 2419:#if defined(MBEDTLS_HAVE_TIME)
        -: 2420:    t = mbedtls_time( NULL );
        -: 2421:    *p++ = (unsigned char)( t >> 24 );
        -: 2422:    *p++ = (unsigned char)( t >> 16 );
        -: 2423:    *p++ = (unsigned char)( t >>  8 );
        -: 2424:    *p++ = (unsigned char)( t       );
        -: 2425:
        -: 2426:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, current time: %lu", t ) );
        -: 2427:#else
    #####: 2428:    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 4 ) ) != 0 )
    #####: 2429:        return( ret );
        -: 2430:
    #####: 2431:    p += 4;
        -: 2432:#endif /* MBEDTLS_HAVE_TIME */
        -: 2433:
    #####: 2434:    if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, p, 28 ) ) != 0 )
    #####: 2435:        return( ret );
        -: 2436:
    #####: 2437:    p += 28;
        -: 2438:
    #####: 2439:    memcpy( ssl->handshake->randbytes + 32, buf + 6, 32 );
        -: 2440:
    #####: 2441:    MBEDTLS_SSL_DEBUG_BUF( 3, "server hello, random bytes", buf + 6, 32 );
        -: 2442:
        -: 2443:    /*
        -: 2444:     * Resume is 0  by default, see ssl_handshake_init().
        -: 2445:     * It may be already set to 1 by ssl_parse_session_ticket_ext().
        -: 2446:     * If not, try looking up session ID in our cache.
        -: 2447:     */
    #####: 2448:    if( ssl->handshake->resume == 0 &&
        -: 2449:#if defined(MBEDTLS_SSL_RENEGOTIATION)
        -: 2450:        ssl->renego_status == MBEDTLS_SSL_INITIAL_HANDSHAKE &&
        -: 2451:#endif
    #####: 2452:        ssl->session_negotiate->id_len != 0 &&
    #####: 2453:        ssl->conf->f_get_cache != NULL &&
    #####: 2454:        ssl->conf->f_get_cache( ssl->conf->p_cache, ssl->session_negotiate ) == 0 )
        -: 2455:    {
    #####: 2456:        MBEDTLS_SSL_DEBUG_MSG( 3, ( "session successfully restored from cache" ) );
    #####: 2457:        ssl->handshake->resume = 1;
        -: 2458:    }
        -: 2459:
    #####: 2460:    if( ssl->handshake->resume == 0 )
        -: 2461:    {
        -: 2462:        /*
        -: 2463:         * New session, create a new session id,
        -: 2464:         * unless we're about to issue a session ticket
        -: 2465:         */
    #####: 2466:        ssl->state++;
        -: 2467:
        -: 2468:#if defined(MBEDTLS_HAVE_TIME)
        -: 2469:        ssl->session_negotiate->start = mbedtls_time( NULL );
        -: 2470:#endif
        -: 2471:
        -: 2472:#if defined(MBEDTLS_SSL_SESSION_TICKETS)
        -: 2473:        if( ssl->handshake->new_session_ticket != 0 )
        -: 2474:        {
        -: 2475:            ssl->session_negotiate->id_len = n = 0;
        -: 2476:            memset( ssl->session_negotiate->id, 0, 32 );
        -: 2477:        }
        -: 2478:        else
        -: 2479:#endif /* MBEDTLS_SSL_SESSION_TICKETS */
        -: 2480:        {
    #####: 2481:            ssl->session_negotiate->id_len = n = 32;
    #####: 2482:            if( ( ret = ssl->conf->f_rng( ssl->conf->p_rng, ssl->session_negotiate->id,
        -: 2483:                                    n ) ) != 0 )
    #####: 2484:                return( ret );
        -: 2485:        }
        -: 2486:    }
        -: 2487:    else
        -: 2488:    {
        -: 2489:        /*
        -: 2490:         * Resuming a session
        -: 2491:         */
    #####: 2492:        n = ssl->session_negotiate->id_len;
    #####: 2493:        ssl->state = MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC;
        -: 2494:
    #####: 2495:        if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )
        -: 2496:        {
    #####: 2497:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_derive_keys", ret );
    #####: 2498:            return( ret );
        -: 2499:        }
        -: 2500:    }
        -: 2501:
        -: 2502:    /*
        -: 2503:     *    38  .  38     session id length
        -: 2504:     *    39  . 38+n    session id
        -: 2505:     *   39+n . 40+n    chosen ciphersuite
        -: 2506:     *   41+n . 41+n    chosen compression alg.
        -: 2507:     *   42+n . 43+n    extensions length
        -: 2508:     *   44+n . 43+n+m  extensions
        -: 2509:     */
    #####: 2510:    *p++ = (unsigned char) ssl->session_negotiate->id_len;
    #####: 2511:    memcpy( p, ssl->session_negotiate->id, ssl->session_negotiate->id_len );
    #####: 2512:    p += ssl->session_negotiate->id_len;
        -: 2513:
    #####: 2514:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, session id len.: %d", n ) );
    #####: 2515:    MBEDTLS_SSL_DEBUG_BUF( 3,   "server hello, session id", buf + 39, n );
    #####: 2516:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "%s session has been resumed",
        -: 2517:                   ssl->handshake->resume ? "a" : "no" ) );
        -: 2518:
    #####: 2519:    *p++ = (unsigned char)( ssl->session_negotiate->ciphersuite >> 8 );
    #####: 2520:    *p++ = (unsigned char)( ssl->session_negotiate->ciphersuite      );
    #####: 2521:    *p++ = (unsigned char)( ssl->session_negotiate->compression      );
        -: 2522:
    #####: 2523:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, chosen ciphersuite: %s",
        -: 2524:           mbedtls_ssl_get_ciphersuite_name( ssl->session_negotiate->ciphersuite ) ) );
    #####: 2525:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, compress alg.: 0x%02X",
        -: 2526:                   ssl->session_negotiate->compression ) );
        -: 2527:
        -: 2528:    /* Do not write the extensions if the protocol is SSLv3 */
        -: 2529:#if defined(MBEDTLS_SSL_PROTO_SSL3)
        -: 2530:    if( ( ssl->major_ver != 3 ) || ( ssl->minor_ver != 0 ) )
        -: 2531:    {
        -: 2532:#endif
        -: 2533:
        -: 2534:    /*
        -: 2535:     *  First write extensions, then the total length
        -: 2536:     */
    #####: 2537:    ssl_write_renegotiation_ext( ssl, p + 2 + ext_len, &olen );
    #####: 2538:    ext_len += olen;
        -: 2539:
        -: 2540:#if defined(MBEDTLS_SSL_MAX_FRAGMENT_LENGTH)
        -: 2541:    ssl_write_max_fragment_length_ext( ssl, p + 2 + ext_len, &olen );
        -: 2542:    ext_len += olen;
        -: 2543:#endif
        -: 2544:
        -: 2545:#if defined(MBEDTLS_SSL_TRUNCATED_HMAC)
        -: 2546:    ssl_write_truncated_hmac_ext( ssl, p + 2 + ext_len, &olen );
        -: 2547:    ext_len += olen;
        -: 2548:#endif
        -: 2549:
        -: 2550:#if defined(MBEDTLS_SSL_ENCRYPT_THEN_MAC)
        -: 2551:    ssl_write_encrypt_then_mac_ext( ssl, p + 2 + ext_len, &olen );
        -: 2552:    ext_len += olen;
        -: 2553:#endif
        -: 2554:
        -: 2555:#if defined(MBEDTLS_SSL_EXTENDED_MASTER_SECRET)
        -: 2556:    ssl_write_extended_ms_ext( ssl, p + 2 + ext_len, &olen );
        -: 2557:    ext_len += olen;
        -: 2558:#endif
        -: 2559:
        -: 2560:#if defined(MBEDTLS_SSL_SESSION_TICKETS)
        -: 2561:    ssl_write_session_ticket_ext( ssl, p + 2 + ext_len, &olen );
        -: 2562:    ext_len += olen;
        -: 2563:#endif
        -: 2564:
        -: 2565:#if defined(MBEDTLS_ECDH_C) || defined(MBEDTLS_ECDSA_C) || \
        -: 2566:    defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
        -: 2567:    ssl_write_supported_point_formats_ext( ssl, p + 2 + ext_len, &olen );
        -: 2568:    ext_len += olen;
        -: 2569:#endif
        -: 2570:
        -: 2571:#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
        -: 2572:    ssl_write_ecjpake_kkpp_ext( ssl, p + 2 + ext_len, &olen );
        -: 2573:    ext_len += olen;
        -: 2574:#endif
        -: 2575:
        -: 2576:#if defined(MBEDTLS_SSL_ALPN)
    #####: 2577:    ssl_write_alpn_ext( ssl, p + 2 + ext_len, &olen );
    #####: 2578:    ext_len += olen;
        -: 2579:#endif
        -: 2580:
    #####: 2581:    MBEDTLS_SSL_DEBUG_MSG( 3, ( "server hello, total extension length: %d", ext_len ) );
        -: 2582:
    #####: 2583:    if( ext_len > 0 )
        -: 2584:    {
    #####: 2585:        *p++ = (unsigned char)( ( ext_len >> 8 ) & 0xFF );
    #####: 2586:        *p++ = (unsigned char)( ( ext_len      ) & 0xFF );
    #####: 2587:        p += ext_len;
        -: 2588:    }
        -: 2589:
        -: 2590:#if defined(MBEDTLS_SSL_PROTO_SSL3)
        -: 2591:    }
        -: 2592:#endif
        -: 2593:
    #####: 2594:    ssl->out_msglen  = p - buf;
    #####: 2595:    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
    #####: 2596:    ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO;
        -: 2597:
    #####: 2598:    ret = mbedtls_ssl_write_record( ssl );
        -: 2599:
    #####: 2600:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write server hello" ) );
        -: 2601:
    #####: 2602:    return( ret );
        -: 2603:}
        -: 2604:
        -: 2605:#if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)       && \
        -: 2606:    !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)   && \
        -: 2607:    !defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)  && \
        -: 2608:    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) && \
        -: 2609:    !defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)&& \
        -: 2610:    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
    #####: 2611:static int ssl_write_certificate_request( mbedtls_ssl_context *ssl )
        -: 2612:{
    #####: 2613:    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
    #####: 2614:        ssl->transform_negotiate->ciphersuite_info;
        -: 2615:
    #####: 2616:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write certificate request" ) );
        -: 2617:
    #####: 2618:    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
    #####: 2619:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
    #####: 2620:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
    #####: 2621:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
    #####: 2622:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
        -: 2623:    {
    #####: 2624:        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate request" ) );
    #####: 2625:        ssl->state++;
    #####: 2626:        return( 0 );
        -: 2627:    }
        -: 2628:
    #####: 2629:    MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
    #####: 2630:    return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        -: 2631:}
        -: 2632:#else
        -: 2633:static int ssl_write_certificate_request( mbedtls_ssl_context *ssl )
        -: 2634:{
        -: 2635:    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
        -: 2636:    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
        -: 2637:        ssl->transform_negotiate->ciphersuite_info;
        -: 2638:    size_t dn_size, total_dn_size; /* excluding length bytes */
        -: 2639:    size_t ct_len, sa_len; /* including length bytes */
        -: 2640:    unsigned char *buf, *p;
        -: 2641:    const unsigned char * const end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
        -: 2642:    const mbedtls_x509_crt *crt;
        -: 2643:    int authmode;
        -: 2644:
        -: 2645:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write certificate request" ) );
        -: 2646:
        -: 2647:    ssl->state++;
        -: 2648:
        -: 2649:#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
        -: 2650:    if( ssl->handshake->sni_authmode != MBEDTLS_SSL_VERIFY_UNSET )
        -: 2651:        authmode = ssl->handshake->sni_authmode;
        -: 2652:    else
        -: 2653:#endif
        -: 2654:        authmode = ssl->conf->authmode;
        -: 2655:
        -: 2656:    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
        -: 2657:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
        -: 2658:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
        -: 2659:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
        -: 2660:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE ||
        -: 2661:        authmode == MBEDTLS_SSL_VERIFY_NONE )
        -: 2662:    {
        -: 2663:        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write certificate request" ) );
        -: 2664:        return( 0 );
        -: 2665:    }
        -: 2666:
        -: 2667:    /*
        -: 2668:     *     0  .   0   handshake type
        -: 2669:     *     1  .   3   handshake length
        -: 2670:     *     4  .   4   cert type count
        -: 2671:     *     5  .. m-1  cert types
        -: 2672:     *     m  .. m+1  sig alg length (TLS 1.2 only)
        -: 2673:     *    m+1 .. n-1  SignatureAndHashAlgorithms (TLS 1.2 only)
        -: 2674:     *     n  .. n+1  length of all DNs
        -: 2675:     *    n+2 .. n+3  length of DN 1
        -: 2676:     *    n+4 .. ...  Distinguished Name #1
        -: 2677:     *    ... .. ...  length of DN 2, etc.
        -: 2678:     */
        -: 2679:    buf = ssl->out_msg;
        -: 2680:    p = buf + 4;
        -: 2681:
        -: 2682:    /*
        -: 2683:     * Supported certificate types
        -: 2684:     *
        -: 2685:     *     ClientCertificateType certificate_types<1..2^8-1>;
        -: 2686:     *     enum { (255) } ClientCertificateType;
        -: 2687:     */
        -: 2688:    ct_len = 0;
        -: 2689:
        -: 2690:#if defined(MBEDTLS_RSA_C)
        -: 2691:    p[1 + ct_len++] = MBEDTLS_SSL_CERT_TYPE_RSA_SIGN;
        -: 2692:#endif
        -: 2693:#if defined(MBEDTLS_ECDSA_C)
        -: 2694:    p[1 + ct_len++] = MBEDTLS_SSL_CERT_TYPE_ECDSA_SIGN;
        -: 2695:#endif
        -: 2696:
        -: 2697:    p[0] = (unsigned char) ct_len++;
        -: 2698:    p += ct_len;
        -: 2699:
        -: 2700:    sa_len = 0;
        -: 2701:#if defined(MBEDTLS_SSL_PROTO_TLS1_2)
        -: 2702:    /*
        -: 2703:     * Add signature_algorithms for verify (TLS 1.2)
        -: 2704:     *
        -: 2705:     *     SignatureAndHashAlgorithm supported_signature_algorithms<2..2^16-2>;
        -: 2706:     *
        -: 2707:     *     struct {
        -: 2708:     *           HashAlgorithm hash;
        -: 2709:     *           SignatureAlgorithm signature;
        -: 2710:     *     } SignatureAndHashAlgorithm;
        -: 2711:     *
        -: 2712:     *     enum { (255) } HashAlgorithm;
        -: 2713:     *     enum { (255) } SignatureAlgorithm;
        -: 2714:     */
        -: 2715:    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
        -: 2716:    {
        -: 2717:        const int *cur;
        -: 2718:
        -: 2719:        /*
        -: 2720:         * Supported signature algorithms
        -: 2721:         */
        -: 2722:        for( cur = ssl->conf->sig_hashes; *cur != MBEDTLS_MD_NONE; cur++ )
        -: 2723:        {
        -: 2724:            unsigned char hash = mbedtls_ssl_hash_from_md_alg( *cur );
        -: 2725:
        -: 2726:            if( MBEDTLS_SSL_HASH_NONE == hash || mbedtls_ssl_set_calc_verify_md( ssl, hash ) )
        -: 2727:                continue;
        -: 2728:
        -: 2729:#if defined(MBEDTLS_RSA_C)
        -: 2730:            p[2 + sa_len++] = hash;
        -: 2731:            p[2 + sa_len++] = MBEDTLS_SSL_SIG_RSA;
        -: 2732:#endif
        -: 2733:#if defined(MBEDTLS_ECDSA_C)
        -: 2734:            p[2 + sa_len++] = hash;
        -: 2735:            p[2 + sa_len++] = MBEDTLS_SSL_SIG_ECDSA;
        -: 2736:#endif
        -: 2737:        }
        -: 2738:
        -: 2739:        p[0] = (unsigned char)( sa_len >> 8 );
        -: 2740:        p[1] = (unsigned char)( sa_len      );
        -: 2741:        sa_len += 2;
        -: 2742:        p += sa_len;
        -: 2743:    }
        -: 2744:#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
        -: 2745:
        -: 2746:    /*
        -: 2747:     * DistinguishedName certificate_authorities<0..2^16-1>;
        -: 2748:     * opaque DistinguishedName<1..2^16-1>;
        -: 2749:     */
        -: 2750:    p += 2;
        -: 2751:
        -: 2752:    total_dn_size = 0;
        -: 2753:
        -: 2754:    if( ssl->conf->cert_req_ca_list ==  MBEDTLS_SSL_CERT_REQ_CA_LIST_ENABLED )
        -: 2755:    {
        -: 2756:#if defined(MBEDTLS_SSL_SERVER_NAME_INDICATION)
        -: 2757:        if( ssl->handshake->sni_ca_chain != NULL )
        -: 2758:            crt = ssl->handshake->sni_ca_chain;
        -: 2759:        else
        -: 2760:#endif
        -: 2761:            crt = ssl->conf->ca_chain;
        -: 2762:
        -: 2763:        while( crt != NULL && crt->version != 0 )
        -: 2764:        {
        -: 2765:            dn_size = crt->subject_raw.len;
        -: 2766:
        -: 2767:            if( end < p ||
        -: 2768:                (size_t)( end - p ) < dn_size ||
        -: 2769:                (size_t)( end - p ) < 2 + dn_size )
        -: 2770:            {
        -: 2771:                MBEDTLS_SSL_DEBUG_MSG( 1, ( "skipping CAs: buffer too short" ) );
        -: 2772:                break;
        -: 2773:            }
        -: 2774:
        -: 2775:            *p++ = (unsigned char)( dn_size >> 8 );
        -: 2776:            *p++ = (unsigned char)( dn_size      );
        -: 2777:            memcpy( p, crt->subject_raw.p, dn_size );
        -: 2778:            p += dn_size;
        -: 2779:
        -: 2780:            MBEDTLS_SSL_DEBUG_BUF( 3, "requested DN", p - dn_size, dn_size );
        -: 2781:
        -: 2782:            total_dn_size += 2 + dn_size;
        -: 2783:            crt = crt->next;
        -: 2784:        }
        -: 2785:    }
        -: 2786:
        -: 2787:    ssl->out_msglen  = p - buf;
        -: 2788:    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
        -: 2789:    ssl->out_msg[0]  = MBEDTLS_SSL_HS_CERTIFICATE_REQUEST;
        -: 2790:    ssl->out_msg[4 + ct_len + sa_len] = (unsigned char)( total_dn_size  >> 8 );
        -: 2791:    ssl->out_msg[5 + ct_len + sa_len] = (unsigned char)( total_dn_size       );
        -: 2792:
        -: 2793:    ret = mbedtls_ssl_write_record( ssl );
        -: 2794:
        -: 2795:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write certificate request" ) );
        -: 2796:
        -: 2797:    return( ret );
        -: 2798:}
        -: 2799:#endif /* !MBEDTLS_KEY_EXCHANGE_RSA_ENABLED &&
        -: 2800:          !MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED &&
        -: 2801:          !MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED &&
        -: 2802:          !MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED &&
        -: 2803:          !MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED &&
        -: 2804:          !MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */
        -: 2805:
        -: 2806:#if defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) || \
        -: 2807:    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
        -: 2808:static int ssl_get_ecdh_params_from_cert( mbedtls_ssl_context *ssl )
        -: 2809:{
        -: 2810:    int ret;
        -: 2811:
        -: 2812:    if( ! mbedtls_pk_can_do( mbedtls_ssl_own_key( ssl ), MBEDTLS_PK_ECKEY ) )
        -: 2813:    {
        -: 2814:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "server key not ECDH capable" ) );
        -: 2815:        return( MBEDTLS_ERR_SSL_PK_TYPE_MISMATCH );
        -: 2816:    }
        -: 2817:
        -: 2818:    if( ( ret = mbedtls_ecdh_get_params( &ssl->handshake->ecdh_ctx,
        -: 2819:                                 mbedtls_pk_ec( *mbedtls_ssl_own_key( ssl ) ),
        -: 2820:                                 MBEDTLS_ECDH_OURS ) ) != 0 )
        -: 2821:    {
        -: 2822:        MBEDTLS_SSL_DEBUG_RET( 1, ( "mbedtls_ecdh_get_params" ), ret );
        -: 2823:        return( ret );
        -: 2824:    }
        -: 2825:
        -: 2826:    return( 0 );
        -: 2827:}
        -: 2828:#endif /* MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||
        -: 2829:          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
        -: 2830:
    #####: 2831:static int ssl_write_server_key_exchange( mbedtls_ssl_context *ssl )
        -: 2832:{
        -: 2833:    int ret;
    #####: 2834:    size_t n = 0;
    #####: 2835:    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
    #####: 2836:                            ssl->transform_negotiate->ciphersuite_info;
        -: 2837:
        -: 2838:#if defined(MBEDTLS_KEY_EXCHANGE__SOME_PFS__ENABLED)
        -: 2839:    unsigned char *p = ssl->out_msg + 4;
        -: 2840:    size_t len;
        -: 2841:#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)
        -: 2842:    unsigned char *dig_signed = p;
        -: 2843:    size_t dig_signed_len = 0;
        -: 2844:#endif /* MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED */
        -: 2845:#endif /* MBEDTLS_KEY_EXCHANGE__SOME_PFS__ENABLED */
        -: 2846:
    #####: 2847:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write server key exchange" ) );
        -: 2848:
        -: 2849:    /*
        -: 2850:     *
        -: 2851:     * Part 1: Extract static ECDH parameters and abort
        -: 2852:     *         if ServerKeyExchange not needed.
        -: 2853:     *
        -: 2854:     */
        -: 2855:
        -: 2856:    /* For suites involving ECDH, extract DH parameters
        -: 2857:     * from certificate at this point. */
        -: 2858:#if defined(MBEDTLS_KEY_EXCHANGE__SOME__ECDH_ENABLED)
        -: 2859:    if( mbedtls_ssl_ciphersuite_uses_ecdh( ciphersuite_info ) )
        -: 2860:    {
        -: 2861:        ssl_get_ecdh_params_from_cert( ssl );
        -: 2862:    }
        -: 2863:#endif /* MBEDTLS_KEY_EXCHANGE__SOME__ECDH_ENABLED */
        -: 2864:
        -: 2865:    /* Key exchanges not involving ephemeral keys don't use
        -: 2866:     * ServerKeyExchange, so end here. */
        -: 2867:#if defined(MBEDTLS_KEY_EXCHANGE__SOME_NON_PFS__ENABLED)
    #####: 2868:    if( mbedtls_ssl_ciphersuite_no_pfs( ciphersuite_info ) )
        -: 2869:    {
    #####: 2870:        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip write server key exchange" ) );
    #####: 2871:        ssl->state++;
    #####: 2872:        return( 0 );
        -: 2873:    }
        -: 2874:#endif /* MBEDTLS_KEY_EXCHANGE__NON_PFS__ENABLED */
        -: 2875:
        -: 2876:    /*
        -: 2877:     *
        -: 2878:     * Part 2: Provide key exchange parameters for chosen ciphersuite.
        -: 2879:     *
        -: 2880:     */
        -: 2881:
        -: 2882:    /*
        -: 2883:     * - ECJPAKE key exchanges
        -: 2884:     */
        -: 2885:#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
        -: 2886:    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
        -: 2887:    {
        -: 2888:        const unsigned char *end = ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN;
        -: 2889:
        -: 2890:        ret = mbedtls_ecjpake_write_round_two( &ssl->handshake->ecjpake_ctx,
        -: 2891:                p, end - p, &len, ssl->conf->f_rng, ssl->conf->p_rng );
        -: 2892:        if( ret != 0 )
        -: 2893:        {
        -: 2894:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecjpake_write_round_two", ret );
        -: 2895:            return( ret );
        -: 2896:        }
        -: 2897:
        -: 2898:        p += len;
        -: 2899:        n += len;
        -: 2900:    }
        -: 2901:#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
        -: 2902:
        -: 2903:    /*
        -: 2904:     * For (EC)DHE key exchanges with PSK, parameters are prefixed by support
        -: 2905:     * identity hint (RFC 4279, Sec. 3). Until someone needs this feature,
        -: 2906:     * we use empty support identity hints here.
        -: 2907:     **/
        -: 2908:#if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)   || \
        -: 2909:    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
        -: 2910:    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
        -: 2911:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )
        -: 2912:    {
        -: 2913:        *(p++) = 0x00;
        -: 2914:        *(p++) = 0x00;
        -: 2915:
        -: 2916:        n += 2;
        -: 2917:    }
        -: 2918:#endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED ||
        -: 2919:          MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
        -: 2920:
        -: 2921:    /*
        -: 2922:     * - DHE key exchanges
        -: 2923:     */
        -: 2924:#if defined(MBEDTLS_KEY_EXCHANGE__SOME__DHE_ENABLED)
        -: 2925:    if( mbedtls_ssl_ciphersuite_uses_dhe( ciphersuite_info ) )
        -: 2926:    {
        -: 2927:        if( ssl->conf->dhm_P.p == NULL || ssl->conf->dhm_G.p == NULL )
        -: 2928:        {
        -: 2929:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "no DH parameters set" ) );
        -: 2930:            return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
        -: 2931:        }
        -: 2932:
        -: 2933:        /*
        -: 2934:         * Ephemeral DH parameters:
        -: 2935:         *
        -: 2936:         * struct {
        -: 2937:         *     opaque dh_p<1..2^16-1>;
        -: 2938:         *     opaque dh_g<1..2^16-1>;
        -: 2939:         *     opaque dh_Ys<1..2^16-1>;
        -: 2940:         * } ServerDHParams;
        -: 2941:         */
        -: 2942:        if( ( ret = mbedtls_dhm_set_group( &ssl->handshake->dhm_ctx,
        -: 2943:                                           &ssl->conf->dhm_P,
        -: 2944:                                           &ssl->conf->dhm_G ) ) != 0 )
        -: 2945:        {
        -: 2946:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_dhm_set_group", ret );
        -: 2947:            return( ret );
        -: 2948:        }
        -: 2949:
        -: 2950:        if( ( ret = mbedtls_dhm_make_params( &ssl->handshake->dhm_ctx,
        -: 2951:                        (int) mbedtls_mpi_size( &ssl->handshake->dhm_ctx.P ),
        -: 2952:                        p, &len, ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
        -: 2953:        {
        -: 2954:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_dhm_make_params", ret );
        -: 2955:            return( ret );
        -: 2956:        }
        -: 2957:
        -: 2958:#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)
        -: 2959:        dig_signed = p;
        -: 2960:        dig_signed_len = len;
        -: 2961:#endif
        -: 2962:
        -: 2963:        p += len;
        -: 2964:        n += len;
        -: 2965:
        -: 2966:        MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: X ", &ssl->handshake->dhm_ctx.X  );
        -: 2967:        MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: P ", &ssl->handshake->dhm_ctx.P  );
        -: 2968:        MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: G ", &ssl->handshake->dhm_ctx.G  );
        -: 2969:        MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: GX", &ssl->handshake->dhm_ctx.GX );
        -: 2970:    }
        -: 2971:#endif /* MBEDTLS_KEY_EXCHANGE__SOME__DHE_ENABLED */
        -: 2972:
        -: 2973:    /*
        -: 2974:     * - ECDHE key exchanges
        -: 2975:     */
        -: 2976:#if defined(MBEDTLS_KEY_EXCHANGE__SOME__ECDHE_ENABLED)
        -: 2977:    if( mbedtls_ssl_ciphersuite_uses_ecdhe( ciphersuite_info ) )
        -: 2978:    {
        -: 2979:        /*
        -: 2980:         * Ephemeral ECDH parameters:
        -: 2981:         *
        -: 2982:         * struct {
        -: 2983:         *     ECParameters curve_params;
        -: 2984:         *     ECPoint      public;
        -: 2985:         * } ServerECDHParams;
        -: 2986:         */
        -: 2987:        const mbedtls_ecp_curve_info **curve = NULL;
        -: 2988:        const mbedtls_ecp_group_id *gid;
        -: 2989:
        -: 2990:        /* Match our preference list against the offered curves */
        -: 2991:        for( gid = ssl->conf->curve_list; *gid != MBEDTLS_ECP_DP_NONE; gid++ )
        -: 2992:            for( curve = ssl->handshake->curves; *curve != NULL; curve++ )
        -: 2993:                if( (*curve)->grp_id == *gid )
        -: 2994:                    goto curve_matching_done;
        -: 2995:
        -: 2996:curve_matching_done:
        -: 2997:        if( curve == NULL || *curve == NULL )
        -: 2998:        {
        -: 2999:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "no matching curve for ECDHE" ) );
        -: 3000:            return( MBEDTLS_ERR_SSL_NO_CIPHER_CHOSEN );
        -: 3001:        }
        -: 3002:
        -: 3003:        MBEDTLS_SSL_DEBUG_MSG( 2, ( "ECDHE curve: %s", (*curve)->name ) );
        -: 3004:
        -: 3005:        if( ( ret = mbedtls_ecp_group_load( &ssl->handshake->ecdh_ctx.grp,
        -: 3006:                                       (*curve)->grp_id ) ) != 0 )
        -: 3007:        {
        -: 3008:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecp_group_load", ret );
        -: 3009:            return( ret );
        -: 3010:        }
        -: 3011:
        -: 3012:        if( ( ret = mbedtls_ecdh_make_params( &ssl->handshake->ecdh_ctx, &len,
        -: 3013:                                      p, MBEDTLS_SSL_MAX_CONTENT_LEN - n,
        -: 3014:                                      ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
        -: 3015:        {
        -: 3016:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_make_params", ret );
        -: 3017:            return( ret );
        -: 3018:        }
        -: 3019:
        -: 3020:#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)
        -: 3021:        dig_signed     = p;
        -: 3022:        dig_signed_len = len;
        -: 3023:#endif
        -: 3024:
        -: 3025:        p += len;
        -: 3026:        n += len;
        -: 3027:
        -: 3028:        MBEDTLS_SSL_DEBUG_ECP( 3, "ECDH: Q ", &ssl->handshake->ecdh_ctx.Q );
        -: 3029:    }
        -: 3030:#endif /* MBEDTLS_KEY_EXCHANGE__SOME__ECDHE_ENABLED */
        -: 3031:
        -: 3032:    /*
        -: 3033:     *
        -: 3034:     * Part 3: For key exchanges involving the server signing the
        -: 3035:     *         exchange parameters, compute and add the signature here.
        -: 3036:     *
        -: 3037:     */
        -: 3038:#if defined(MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED)
        -: 3039:    if( mbedtls_ssl_ciphersuite_uses_server_signature( ciphersuite_info ) )
        -: 3040:    {
        -: 3041:        size_t signature_len = 0;
        -: 3042:        unsigned int hashlen = 0;
        -: 3043:        unsigned char hash[64];
        -: 3044:
        -: 3045:        /*
        -: 3046:         * 3.1: Choose hash algorithm:
        -: 3047:         * A: For TLS 1.2, obey signature-hash-algorithm extension
        -: 3048:         *    to choose appropriate hash.
        -: 3049:         * B: For SSL3, TLS1.0, TLS1.1 and ECDHE_ECDSA, use SHA1
        -: 3050:         *    (RFC 4492, Sec. 5.4)
        -: 3051:         * C: Otherwise, use MD5 + SHA1 (RFC 4346, Sec. 7.4.3)
        -: 3052:         */
        -: 3053:
        -: 3054:        mbedtls_md_type_t md_alg;
        -: 3055:
        -: 3056:#if defined(MBEDTLS_SSL_PROTO_TLS1_2)
        -: 3057:        mbedtls_pk_type_t sig_alg =
        -: 3058:            mbedtls_ssl_get_ciphersuite_sig_pk_alg( ciphersuite_info );
        -: 3059:        if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
        -: 3060:        {
        -: 3061:            /* A: For TLS 1.2, obey signature-hash-algorithm extension
        -: 3062:             *    (RFC 5246, Sec. 7.4.1.4.1). */
        -: 3063:            if( sig_alg == MBEDTLS_PK_NONE ||
        -: 3064:                ( md_alg = mbedtls_ssl_sig_hash_set_find( &ssl->handshake->hash_algs,
        -: 3065:                                                          sig_alg ) ) == MBEDTLS_MD_NONE )
        -: 3066:            {
        -: 3067:                MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        -: 3068:                /* (... because we choose a cipher suite
        -: 3069:                 *      only if there is a matching hash.) */
        -: 3070:                return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        -: 3071:            }
        -: 3072:        }
        -: 3073:        else
        -: 3074:#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
        -: 3075:#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
        -: 3076:    defined(MBEDTLS_SSL_PROTO_TLS1_1)
        -: 3077:        if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA )
        -: 3078:        {
        -: 3079:            /* B: Default hash SHA1 */
        -: 3080:            md_alg = MBEDTLS_MD_SHA1;
        -: 3081:        }
        -: 3082:        else
        -: 3083:#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \
        -: 3084:          MBEDTLS_SSL_PROTO_TLS1_1 */
        -: 3085:        {
        -: 3086:            /* C: MD5 + SHA1 */
        -: 3087:            md_alg = MBEDTLS_MD_NONE;
        -: 3088:        }
        -: 3089:
        -: 3090:        MBEDTLS_SSL_DEBUG_MSG( 3, ( "pick hash algorithm %d for signing", md_alg ) );
        -: 3091:
        -: 3092:        /*
        -: 3093:         * 3.2: Compute the hash to be signed
        -: 3094:         */
        -: 3095:#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
        -: 3096:    defined(MBEDTLS_SSL_PROTO_TLS1_1)
        -: 3097:        if( md_alg == MBEDTLS_MD_NONE )
        -: 3098:        {
        -: 3099:            hashlen = 36;
        -: 3100:            ret = mbedtls_ssl_get_key_exchange_md_ssl_tls( ssl, hash,
        -: 3101:                                                           dig_signed,
        -: 3102:                                                           dig_signed_len );
        -: 3103:            if( ret != 0 )
        -: 3104:                return( ret );
        -: 3105:        }
        -: 3106:        else
        -: 3107:#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 || \
        -: 3108:          MBEDTLS_SSL_PROTO_TLS1_1 */
        -: 3109:#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
        -: 3110:    defined(MBEDTLS_SSL_PROTO_TLS1_2)
        -: 3111:        if( md_alg != MBEDTLS_MD_NONE )
        -: 3112:        {
        -: 3113:            /* Info from md_alg will be used instead */
        -: 3114:            hashlen = 0;
        -: 3115:            ret = mbedtls_ssl_get_key_exchange_md_tls1_2( ssl, hash,
        -: 3116:                                                          dig_signed,
        -: 3117:                                                          dig_signed_len,
        -: 3118:                                                          md_alg );
        -: 3119:            if( ret != 0 )
        -: 3120:                return( ret );
        -: 3121:        }
        -: 3122:        else
        -: 3123:#endif /* MBEDTLS_SSL_PROTO_TLS1 || MBEDTLS_SSL_PROTO_TLS1_1 || \
        -: 3124:          MBEDTLS_SSL_PROTO_TLS1_2 */
        -: 3125:        {
        -: 3126:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        -: 3127:            return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        -: 3128:        }
        -: 3129:
        -: 3130:        MBEDTLS_SSL_DEBUG_BUF( 3, "parameters hash", hash, hashlen != 0 ? hashlen :
        -: 3131:            (unsigned int) ( mbedtls_md_get_size( mbedtls_md_info_from_type( md_alg ) ) ) );
        -: 3132:
        -: 3133:        /*
        -: 3134:         * 3.3: Compute and add the signature
        -: 3135:         */
        -: 3136:        if( mbedtls_ssl_own_key( ssl ) == NULL )
        -: 3137:        {
        -: 3138:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no private key" ) );
        -: 3139:            return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );
        -: 3140:        }
        -: 3141:
        -: 3142:#if defined(MBEDTLS_SSL_PROTO_TLS1_2)
        -: 3143:        if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
        -: 3144:        {
        -: 3145:            /*
        -: 3146:             * For TLS 1.2, we need to specify signature and hash algorithm
        -: 3147:             * explicitly through a prefix to the signature.
        -: 3148:             *
        -: 3149:             * struct {
        -: 3150:             *    HashAlgorithm hash;
        -: 3151:             *    SignatureAlgorithm signature;
        -: 3152:             * } SignatureAndHashAlgorithm;
        -: 3153:             *
        -: 3154:             * struct {
        -: 3155:             *    SignatureAndHashAlgorithm algorithm;
        -: 3156:             *    opaque signature<0..2^16-1>;
        -: 3157:             * } DigitallySigned;
        -: 3158:             *
        -: 3159:             */
        -: 3160:
        -: 3161:            *(p++) = mbedtls_ssl_hash_from_md_alg( md_alg );
        -: 3162:            *(p++) = mbedtls_ssl_sig_from_pk_alg( sig_alg );
        -: 3163:
        -: 3164:            n += 2;
        -: 3165:        }
        -: 3166:#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
        -: 3167:
        -: 3168:        if( ( ret = mbedtls_pk_sign( mbedtls_ssl_own_key( ssl ), md_alg, hash, hashlen,
        -: 3169:                        p + 2 , &signature_len, ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
        -: 3170:        {
        -: 3171:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_pk_sign", ret );
        -: 3172:            return( ret );
        -: 3173:        }
        -: 3174:
        -: 3175:        *(p++) = (unsigned char)( signature_len >> 8 );
        -: 3176:        *(p++) = (unsigned char)( signature_len      );
        -: 3177:        n += 2;
        -: 3178:
        -: 3179:        MBEDTLS_SSL_DEBUG_BUF( 3, "my signature", p, signature_len );
        -: 3180:
        -: 3181:        n += signature_len;
        -: 3182:    }
        -: 3183:#endif /* MBEDTLS_KEY_EXCHANGE__WITH_SERVER_SIGNATURE__ENABLED */
        -: 3184:
        -: 3185:    /* Done with actual work; add header and send. */
        -: 3186:
    #####: 3187:    ssl->out_msglen  = 4 + n;
    #####: 3188:    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
    #####: 3189:    ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_KEY_EXCHANGE;
        -: 3190:
    #####: 3191:    ssl->state++;
        -: 3192:
    #####: 3193:    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
        -: 3194:    {
    #####: 3195:        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
    #####: 3196:        return( ret );
        -: 3197:    }
        -: 3198:
    #####: 3199:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write server key exchange" ) );
        -: 3200:
    #####: 3201:    return( 0 );
        -: 3202:}
        -: 3203:
    #####: 3204:static int ssl_write_server_hello_done( mbedtls_ssl_context *ssl )
        -: 3205:{
        -: 3206:    int ret;
        -: 3207:
    #####: 3208:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write server hello done" ) );
        -: 3209:
    #####: 3210:    ssl->out_msglen  = 4;
    #####: 3211:    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
    #####: 3212:    ssl->out_msg[0]  = MBEDTLS_SSL_HS_SERVER_HELLO_DONE;
        -: 3213:
    #####: 3214:    ssl->state++;
        -: 3215:
        -: 3216:#if defined(MBEDTLS_SSL_PROTO_DTLS)
    #####: 3217:    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM )
    #####: 3218:        mbedtls_ssl_send_flight_completed( ssl );
        -: 3219:#endif
        -: 3220:
    #####: 3221:    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
        -: 3222:    {
    #####: 3223:        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
    #####: 3224:        return( ret );
        -: 3225:    }
        -: 3226:
    #####: 3227:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write server hello done" ) );
        -: 3228:
    #####: 3229:    return( 0 );
        -: 3230:}
        -: 3231:
        -: 3232:#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED) ||                       \
        -: 3233:    defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
        -: 3234:static int ssl_parse_client_dh_public( mbedtls_ssl_context *ssl, unsigned char **p,
        -: 3235:                                       const unsigned char *end )
        -: 3236:{
        -: 3237:    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
        -: 3238:    size_t n;
        -: 3239:
        -: 3240:    /*
        -: 3241:     * Receive G^Y mod P, premaster = (G^Y)^X mod P
        -: 3242:     */
        -: 3243:    if( *p + 2 > end )
        -: 3244:    {
        -: 3245:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
        -: 3246:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
        -: 3247:    }
        -: 3248:
        -: 3249:    n = ( (*p)[0] << 8 ) | (*p)[1];
        -: 3250:    *p += 2;
        -: 3251:
        -: 3252:    if( *p + n > end )
        -: 3253:    {
        -: 3254:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
        -: 3255:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
        -: 3256:    }
        -: 3257:
        -: 3258:    if( ( ret = mbedtls_dhm_read_public( &ssl->handshake->dhm_ctx, *p, n ) ) != 0 )
        -: 3259:    {
        -: 3260:        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_dhm_read_public", ret );
        -: 3261:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );
        -: 3262:    }
        -: 3263:
        -: 3264:    *p += n;
        -: 3265:
        -: 3266:    MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: GY", &ssl->handshake->dhm_ctx.GY );
        -: 3267:
        -: 3268:    return( ret );
        -: 3269:}
        -: 3270:#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED ||
        -: 3271:          MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
        -: 3272:
        -: 3273:#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED) ||                           \
        -: 3274:    defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
        -: 3275:static int ssl_parse_encrypted_pms( mbedtls_ssl_context *ssl,
        -: 3276:                                    const unsigned char *p,
        -: 3277:                                    const unsigned char *end,
        -: 3278:                                    size_t pms_offset )
        -: 3279:{
        -: 3280:    int ret;
        -: 3281:    size_t len = mbedtls_pk_get_len( mbedtls_ssl_own_key( ssl ) );
        -: 3282:    unsigned char *pms = ssl->handshake->premaster + pms_offset;
        -: 3283:    unsigned char ver[2];
        -: 3284:    unsigned char fake_pms[48], peer_pms[48];
        -: 3285:    unsigned char mask;
        -: 3286:    size_t i, peer_pmslen;
        -: 3287:    unsigned int diff;
        -: 3288:
        -: 3289:    if( ! mbedtls_pk_can_do( mbedtls_ssl_own_key( ssl ), MBEDTLS_PK_RSA ) )
        -: 3290:    {
        -: 3291:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no RSA private key" ) );
        -: 3292:        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );
        -: 3293:    }
        -: 3294:
        -: 3295:    /*
        -: 3296:     * Decrypt the premaster using own private RSA key
        -: 3297:     */
        -: 3298:#if defined(MBEDTLS_SSL_PROTO_TLS1) || defined(MBEDTLS_SSL_PROTO_TLS1_1) || \
        -: 3299:    defined(MBEDTLS_SSL_PROTO_TLS1_2)
        -: 3300:    if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_0 )
        -: 3301:    {
        -: 3302:        if( *p++ != ( ( len >> 8 ) & 0xFF ) ||
        -: 3303:            *p++ != ( ( len      ) & 0xFF ) )
        -: 3304:        {
        -: 3305:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
        -: 3306:            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
        -: 3307:        }
        -: 3308:    }
        -: 3309:#endif
        -: 3310:
        -: 3311:    if( p + len != end )
        -: 3312:    {
        -: 3313:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
        -: 3314:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
        -: 3315:    }
        -: 3316:
        -: 3317:    mbedtls_ssl_write_version( ssl->handshake->max_major_ver,
        -: 3318:                       ssl->handshake->max_minor_ver,
        -: 3319:                       ssl->conf->transport, ver );
        -: 3320:
        -: 3321:    /*
        -: 3322:     * Protection against Bleichenbacher's attack: invalid PKCS#1 v1.5 padding
        -: 3323:     * must not cause the connection to end immediately; instead, send a
        -: 3324:     * bad_record_mac later in the handshake.
        -: 3325:     * Also, avoid data-dependant branches here to protect against
        -: 3326:     * timing-based variants.
        -: 3327:     */
        -: 3328:    ret = ssl->conf->f_rng( ssl->conf->p_rng, fake_pms, sizeof( fake_pms ) );
        -: 3329:    if( ret != 0 )
        -: 3330:        return( ret );
        -: 3331:
        -: 3332:    ret = mbedtls_pk_decrypt( mbedtls_ssl_own_key( ssl ), p, len,
        -: 3333:                      peer_pms, &peer_pmslen,
        -: 3334:                      sizeof( peer_pms ),
        -: 3335:                      ssl->conf->f_rng, ssl->conf->p_rng );
        -: 3336:
        -: 3337:    diff  = (unsigned int) ret;
        -: 3338:    diff |= peer_pmslen ^ 48;
        -: 3339:    diff |= peer_pms[0] ^ ver[0];
        -: 3340:    diff |= peer_pms[1] ^ ver[1];
        -: 3341:
        -: 3342:#if defined(MBEDTLS_SSL_DEBUG_ALL)
        -: 3343:    if( diff != 0 )
        -: 3344:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
        -: 3345:#endif
        -: 3346:
        -: 3347:    if( sizeof( ssl->handshake->premaster ) < pms_offset ||
        -: 3348:        sizeof( ssl->handshake->premaster ) - pms_offset < 48 )
        -: 3349:    {
        -: 3350:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        -: 3351:        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        -: 3352:    }
        -: 3353:    ssl->handshake->pmslen = 48;
        -: 3354:
        -: 3355:    /* mask = diff ? 0xff : 0x00 using bit operations to avoid branches */
        -: 3356:    /* MSVC has a warning about unary minus on unsigned, but this is
        -: 3357:     * well-defined and precisely what we want to do here */
        -: 3358:#if defined(_MSC_VER)
        -: 3359:#pragma warning( push )
        -: 3360:#pragma warning( disable : 4146 )
        -: 3361:#endif
        -: 3362:    mask = - ( ( diff | - diff ) >> ( sizeof( unsigned int ) * 8 - 1 ) );
        -: 3363:#if defined(_MSC_VER)
        -: 3364:#pragma warning( pop )
        -: 3365:#endif
        -: 3366:
        -: 3367:    for( i = 0; i < ssl->handshake->pmslen; i++ )
        -: 3368:        pms[i] = ( mask & fake_pms[i] ) | ( (~mask) & peer_pms[i] );
        -: 3369:
        -: 3370:    return( 0 );
        -: 3371:}
        -: 3372:#endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED ||
        -: 3373:          MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */
        -: 3374:
        -: 3375:#if defined(MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED)
    #####: 3376:static int ssl_parse_client_psk_identity( mbedtls_ssl_context *ssl, unsigned char **p,
        -: 3377:                                          const unsigned char *end )
        -: 3378:{
    #####: 3379:    int ret = 0;
        -: 3380:    size_t n;
        -: 3381:
    #####: 3382:    if( ssl->conf->f_psk == NULL &&
    #####: 3383:        ( ssl->conf->psk == NULL || ssl->conf->psk_identity == NULL ||
    #####: 3384:          ssl->conf->psk_identity_len == 0 || ssl->conf->psk_len == 0 ) )
        -: 3385:    {
    #####: 3386:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "got no pre-shared key" ) );
    #####: 3387:        return( MBEDTLS_ERR_SSL_PRIVATE_KEY_REQUIRED );
        -: 3388:    }
        -: 3389:
        -: 3390:    /*
        -: 3391:     * Receive client pre-shared key identity name
        -: 3392:     */
    #####: 3393:    if( end - *p < 2 )
        -: 3394:    {
    #####: 3395:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
    #####: 3396:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
        -: 3397:    }
        -: 3398:
    #####: 3399:    n = ( (*p)[0] << 8 ) | (*p)[1];
    #####: 3400:    *p += 2;
        -: 3401:
    #####: 3402:    if( n < 1 || n > 65535 || n > (size_t) ( end - *p ) )
        -: 3403:    {
    #####: 3404:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
    #####: 3405:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
        -: 3406:    }
        -: 3407:
    #####: 3408:    if( ssl->conf->f_psk != NULL )
        -: 3409:    {
    #####: 3410:        if( ssl->conf->f_psk( ssl->conf->p_psk, ssl, *p, n ) != 0 )
    #####: 3411:            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;
        -: 3412:    }
        -: 3413:    else
        -: 3414:    {
        -: 3415:        /* Identity is not a big secret since clients send it in the clear,
        -: 3416:         * but treat it carefully anyway, just in case */
    #####: 3417:        if( n != ssl->conf->psk_identity_len ||
    #####: 3418:            mbedtls_ssl_safer_memcmp( ssl->conf->psk_identity, *p, n ) != 0 )
        -: 3419:        {
    #####: 3420:            ret = MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY;
        -: 3421:        }
        -: 3422:    }
        -: 3423:
    #####: 3424:    if( ret == MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY )
        -: 3425:    {
    #####: 3426:        MBEDTLS_SSL_DEBUG_BUF( 3, "Unknown PSK identity", *p, n );
    #####: 3427:        mbedtls_ssl_send_alert_message( ssl, MBEDTLS_SSL_ALERT_LEVEL_FATAL,
        -: 3428:                                        MBEDTLS_SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY );
    #####: 3429:        return( MBEDTLS_ERR_SSL_UNKNOWN_IDENTITY );
        -: 3430:    }
        -: 3431:
    #####: 3432:    *p += n;
        -: 3433:
    #####: 3434:    return( 0 );
        -: 3435:}
        -: 3436:#endif /* MBEDTLS_KEY_EXCHANGE__SOME__PSK_ENABLED */
        -: 3437:
    #####: 3438:static int ssl_parse_client_key_exchange( mbedtls_ssl_context *ssl )
        -: 3439:{
        -: 3440:    int ret;
        -: 3441:    const mbedtls_ssl_ciphersuite_t *ciphersuite_info;
        -: 3442:    unsigned char *p, *end;
        -: 3443:
    #####: 3444:    ciphersuite_info = ssl->transform_negotiate->ciphersuite_info;
        -: 3445:
    #####: 3446:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse client key exchange" ) );
        -: 3447:
    #####: 3448:    if( ( ret = mbedtls_ssl_read_record( ssl ) ) != 0 )
        -: 3449:    {
    #####: 3450:        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_read_record", ret );
    #####: 3451:        return( ret );
        -: 3452:    }
        -: 3453:
    #####: 3454:    p = ssl->in_msg + mbedtls_ssl_hs_hdr_len( ssl );
    #####: 3455:    end = ssl->in_msg + ssl->in_hslen;
        -: 3456:
    #####: 3457:    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE )
        -: 3458:    {
    #####: 3459:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
    #####: 3460:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
        -: 3461:    }
        -: 3462:
    #####: 3463:    if( ssl->in_msg[0] != MBEDTLS_SSL_HS_CLIENT_KEY_EXCHANGE )
        -: 3464:    {
    #####: 3465:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange message" ) );
    #####: 3466:        return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
        -: 3467:    }
        -: 3468:
        -: 3469:#if defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)
        -: 3470:    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_RSA )
        -: 3471:    {
        -: 3472:        if( ( ret = ssl_parse_client_dh_public( ssl, &p, end ) ) != 0 )
        -: 3473:        {
        -: 3474:            MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_dh_public" ), ret );
        -: 3475:            return( ret );
        -: 3476:        }
        -: 3477:
        -: 3478:        if( p != end )
        -: 3479:        {
        -: 3480:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange" ) );
        -: 3481:            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
        -: 3482:        }
        -: 3483:
        -: 3484:        if( ( ret = mbedtls_dhm_calc_secret( &ssl->handshake->dhm_ctx,
        -: 3485:                                      ssl->handshake->premaster,
        -: 3486:                                      MBEDTLS_PREMASTER_SIZE,
        -: 3487:                                     &ssl->handshake->pmslen,
        -: 3488:                                      ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
        -: 3489:        {
        -: 3490:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_dhm_calc_secret", ret );
        -: 3491:            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS );
        -: 3492:        }
        -: 3493:
        -: 3494:        MBEDTLS_SSL_DEBUG_MPI( 3, "DHM: K ", &ssl->handshake->dhm_ctx.K  );
        -: 3495:    }
        -: 3496:    else
        -: 3497:#endif /* MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED */
        -: 3498:#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) ||                     \
        -: 3499:    defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED) ||                   \
        -: 3500:    defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED) ||                      \
        -: 3501:    defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)
        -: 3502:    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_RSA ||
        -: 3503:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA ||
        -: 3504:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_RSA ||
        -: 3505:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA )
        -: 3506:    {
        -: 3507:        if( ( ret = mbedtls_ecdh_read_public( &ssl->handshake->ecdh_ctx,
        -: 3508:                                      p, end - p) ) != 0 )
        -: 3509:        {
        -: 3510:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_read_public", ret );
        -: 3511:            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );
        -: 3512:        }
        -: 3513:
        -: 3514:        MBEDTLS_SSL_DEBUG_ECP( 3, "ECDH: Qp ", &ssl->handshake->ecdh_ctx.Qp );
        -: 3515:
        -: 3516:        if( ( ret = mbedtls_ecdh_calc_secret( &ssl->handshake->ecdh_ctx,
        -: 3517:                                      &ssl->handshake->pmslen,
        -: 3518:                                       ssl->handshake->premaster,
        -: 3519:                                       MBEDTLS_MPI_MAX_SIZE,
        -: 3520:                                       ssl->conf->f_rng, ssl->conf->p_rng ) ) != 0 )
        -: 3521:        {
        -: 3522:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_calc_secret", ret );
        -: 3523:            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS );
        -: 3524:        }
        -: 3525:
        -: 3526:        MBEDTLS_SSL_DEBUG_MPI( 3, "ECDH: z  ", &ssl->handshake->ecdh_ctx.z );
        -: 3527:    }
        -: 3528:    else
        -: 3529:#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED ||
        -: 3530:          MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED ||
        -: 3531:          MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED ||
        -: 3532:          MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED */
        -: 3533:#if defined(MBEDTLS_KEY_EXCHANGE_PSK_ENABLED)
    #####: 3534:    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK )
        -: 3535:    {
    #####: 3536:        if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )
        -: 3537:        {
    #####: 3538:            MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_psk_identity" ), ret );
    #####: 3539:            return( ret );
        -: 3540:        }
        -: 3541:
    #####: 3542:        if( p != end )
        -: 3543:        {
    #####: 3544:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange" ) );
    #####: 3545:            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
        -: 3546:        }
        -: 3547:
    #####: 3548:        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,
        -: 3549:                        ciphersuite_info->key_exchange ) ) != 0 )
        -: 3550:        {
    #####: 3551:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_psk_derive_premaster", ret );
    #####: 3552:            return( ret );
        -: 3553:        }
        -: 3554:    }
        -: 3555:    else
        -: 3556:#endif /* MBEDTLS_KEY_EXCHANGE_PSK_ENABLED */
        -: 3557:#if defined(MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED)
        -: 3558:    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK )
        -: 3559:    {
        -: 3560:        if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )
        -: 3561:        {
        -: 3562:            MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_psk_identity" ), ret );
        -: 3563:            return( ret );
        -: 3564:        }
        -: 3565:
        -: 3566:        if( ( ret = ssl_parse_encrypted_pms( ssl, p, end, 2 ) ) != 0 )
        -: 3567:        {
        -: 3568:            MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_encrypted_pms" ), ret );
        -: 3569:            return( ret );
        -: 3570:        }
        -: 3571:
        -: 3572:        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,
        -: 3573:                        ciphersuite_info->key_exchange ) ) != 0 )
        -: 3574:        {
        -: 3575:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_psk_derive_premaster", ret );
        -: 3576:            return( ret );
        -: 3577:        }
        -: 3578:    }
        -: 3579:    else
        -: 3580:#endif /* MBEDTLS_KEY_EXCHANGE_RSA_PSK_ENABLED */
        -: 3581:#if defined(MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED)
        -: 3582:    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK )
        -: 3583:    {
        -: 3584:        if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )
        -: 3585:        {
        -: 3586:            MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_psk_identity" ), ret );
        -: 3587:            return( ret );
        -: 3588:        }
        -: 3589:        if( ( ret = ssl_parse_client_dh_public( ssl, &p, end ) ) != 0 )
        -: 3590:        {
        -: 3591:            MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_dh_public" ), ret );
        -: 3592:            return( ret );
        -: 3593:        }
        -: 3594:
        -: 3595:        if( p != end )
        -: 3596:        {
        -: 3597:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad client key exchange" ) );
        -: 3598:            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE );
        -: 3599:        }
        -: 3600:
        -: 3601:        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,
        -: 3602:                        ciphersuite_info->key_exchange ) ) != 0 )
        -: 3603:        {
        -: 3604:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_psk_derive_premaster", ret );
        -: 3605:            return( ret );
        -: 3606:        }
        -: 3607:    }
        -: 3608:    else
        -: 3609:#endif /* MBEDTLS_KEY_EXCHANGE_DHE_PSK_ENABLED */
        -: 3610:#if defined(MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED)
        -: 3611:    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK )
        -: 3612:    {
        -: 3613:        if( ( ret = ssl_parse_client_psk_identity( ssl, &p, end ) ) != 0 )
        -: 3614:        {
        -: 3615:            MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_client_psk_identity" ), ret );
        -: 3616:            return( ret );
        -: 3617:        }
        -: 3618:
        -: 3619:        if( ( ret = mbedtls_ecdh_read_public( &ssl->handshake->ecdh_ctx,
        -: 3620:                                       p, end - p ) ) != 0 )
        -: 3621:        {
        -: 3622:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecdh_read_public", ret );
        -: 3623:            return( MBEDTLS_ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP );
        -: 3624:        }
        -: 3625:
        -: 3626:        MBEDTLS_SSL_DEBUG_ECP( 3, "ECDH: Qp ", &ssl->handshake->ecdh_ctx.Qp );
        -: 3627:
        -: 3628:        if( ( ret = mbedtls_ssl_psk_derive_premaster( ssl,
        -: 3629:                        ciphersuite_info->key_exchange ) ) != 0 )
        -: 3630:        {
        -: 3631:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_psk_derive_premaster", ret );
        -: 3632:            return( ret );
        -: 3633:        }
        -: 3634:    }
        -: 3635:    else
        -: 3636:#endif /* MBEDTLS_KEY_EXCHANGE_ECDHE_PSK_ENABLED */
        -: 3637:#if defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)
        -: 3638:    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA )
        -: 3639:    {
        -: 3640:        if( ( ret = ssl_parse_encrypted_pms( ssl, p, end, 0 ) ) != 0 )
        -: 3641:        {
        -: 3642:            MBEDTLS_SSL_DEBUG_RET( 1, ( "ssl_parse_parse_encrypted_pms_secret" ), ret );
        -: 3643:            return( ret );
        -: 3644:        }
        -: 3645:    }
        -: 3646:    else
        -: 3647:#endif /* MBEDTLS_KEY_EXCHANGE_RSA_ENABLED */
        -: 3648:#if defined(MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED)
        -: 3649:    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
        -: 3650:    {
        -: 3651:        ret = mbedtls_ecjpake_read_round_two( &ssl->handshake->ecjpake_ctx,
        -: 3652:                                              p, end - p );
        -: 3653:        if( ret != 0 )
        -: 3654:        {
        -: 3655:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecjpake_read_round_two", ret );
        -: 3656:            return( MBEDTLS_ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE );
        -: 3657:        }
        -: 3658:
        -: 3659:        ret = mbedtls_ecjpake_derive_secret( &ssl->handshake->ecjpake_ctx,
        -: 3660:                ssl->handshake->premaster, 32, &ssl->handshake->pmslen,
        -: 3661:                ssl->conf->f_rng, ssl->conf->p_rng );
        -: 3662:        if( ret != 0 )
        -: 3663:        {
        -: 3664:            MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ecjpake_derive_secret", ret );
        -: 3665:            return( ret );
        -: 3666:        }
        -: 3667:    }
        -: 3668:    else
        -: 3669:#endif /* MBEDTLS_KEY_EXCHANGE_ECJPAKE_ENABLED */
        -: 3670:    {
    #####: 3671:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
    #####: 3672:        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        -: 3673:    }
        -: 3674:
    #####: 3675:    if( ( ret = mbedtls_ssl_derive_keys( ssl ) ) != 0 )
        -: 3676:    {
    #####: 3677:        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_derive_keys", ret );
    #####: 3678:        return( ret );
        -: 3679:    }
        -: 3680:
    #####: 3681:    ssl->state++;
        -: 3682:
    #####: 3683:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse client key exchange" ) );
        -: 3684:
    #####: 3685:    return( 0 );
        -: 3686:}
        -: 3687:
        -: 3688:#if !defined(MBEDTLS_KEY_EXCHANGE_RSA_ENABLED)       && \
        -: 3689:    !defined(MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED)   && \
        -: 3690:    !defined(MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED)  && \
        -: 3691:    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED) && \
        -: 3692:    !defined(MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED)&& \
        -: 3693:    !defined(MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED)
    #####: 3694:static int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl )
        -: 3695:{
    #####: 3696:    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
    #####: 3697:        ssl->transform_negotiate->ciphersuite_info;
        -: 3698:
    #####: 3699:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse certificate verify" ) );
        -: 3700:
    #####: 3701:    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
    #####: 3702:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
    #####: 3703:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
    #####: 3704:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
    #####: 3705:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE )
        -: 3706:    {
    #####: 3707:        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate verify" ) );
    #####: 3708:        ssl->state++;
    #####: 3709:        return( 0 );
        -: 3710:    }
        -: 3711:
    #####: 3712:    MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
    #####: 3713:    return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        -: 3714:}
        -: 3715:#else
        -: 3716:static int ssl_parse_certificate_verify( mbedtls_ssl_context *ssl )
        -: 3717:{
        -: 3718:    int ret = MBEDTLS_ERR_SSL_FEATURE_UNAVAILABLE;
        -: 3719:    size_t i, sig_len;
        -: 3720:    unsigned char hash[48];
        -: 3721:    unsigned char *hash_start = hash;
        -: 3722:    size_t hashlen;
        -: 3723:#if defined(MBEDTLS_SSL_PROTO_TLS1_2)
        -: 3724:    mbedtls_pk_type_t pk_alg;
        -: 3725:#endif
        -: 3726:    mbedtls_md_type_t md_alg;
        -: 3727:    const mbedtls_ssl_ciphersuite_t *ciphersuite_info =
        -: 3728:        ssl->transform_negotiate->ciphersuite_info;
        -: 3729:
        -: 3730:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> parse certificate verify" ) );
        -: 3731:
        -: 3732:    if( ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_PSK ||
        -: 3733:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_RSA_PSK ||
        -: 3734:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECDHE_PSK ||
        -: 3735:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_DHE_PSK ||
        -: 3736:        ciphersuite_info->key_exchange == MBEDTLS_KEY_EXCHANGE_ECJPAKE ||
        -: 3737:        ssl->session_negotiate->peer_cert == NULL )
        -: 3738:    {
        -: 3739:        MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= skip parse certificate verify" ) );
        -: 3740:        ssl->state++;
        -: 3741:        return( 0 );
        -: 3742:    }
        -: 3743:
        -: 3744:    /* Read the message without adding it to the checksum */
        -: 3745:    do {
        -: 3746:
        -: 3747:        do ret = mbedtls_ssl_read_record_layer( ssl );
        -: 3748:        while( ret == MBEDTLS_ERR_SSL_CONTINUE_PROCESSING );
        -: 3749:
        -: 3750:        if( ret != 0 )
        -: 3751:        {
        -: 3752:            MBEDTLS_SSL_DEBUG_RET( 1, ( "mbedtls_ssl_read_record_layer" ), ret );
        -: 3753:            return( ret );
        -: 3754:        }
        -: 3755:
        -: 3756:        ret = mbedtls_ssl_handle_message_type( ssl );
        -: 3757:
        -: 3758:    } while( MBEDTLS_ERR_SSL_NON_FATAL           == ret ||
        -: 3759:             MBEDTLS_ERR_SSL_CONTINUE_PROCESSING == ret );
        -: 3760:
        -: 3761:    if( 0 != ret )
        -: 3762:    {
        -: 3763:        MBEDTLS_SSL_DEBUG_RET( 1, ( "mbedtls_ssl_handle_message_type" ), ret );
        -: 3764:        return( ret );
        -: 3765:    }
        -: 3766:
        -: 3767:    ssl->state++;
        -: 3768:
        -: 3769:    /* Process the message contents */
        -: 3770:    if( ssl->in_msgtype != MBEDTLS_SSL_MSG_HANDSHAKE ||
        -: 3771:        ssl->in_msg[0] != MBEDTLS_SSL_HS_CERTIFICATE_VERIFY )
        -: 3772:    {
        -: 3773:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate verify message" ) );
        -: 3774:        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
        -: 3775:    }
        -: 3776:
        -: 3777:    i = mbedtls_ssl_hs_hdr_len( ssl );
        -: 3778:
        -: 3779:    /*
        -: 3780:     *  struct {
        -: 3781:     *     SignatureAndHashAlgorithm algorithm; -- TLS 1.2 only
        -: 3782:     *     opaque signature<0..2^16-1>;
        -: 3783:     *  } DigitallySigned;
        -: 3784:     */
        -: 3785:#if defined(MBEDTLS_SSL_PROTO_SSL3) || defined(MBEDTLS_SSL_PROTO_TLS1) || \
        -: 3786:    defined(MBEDTLS_SSL_PROTO_TLS1_1)
        -: 3787:    if( ssl->minor_ver != MBEDTLS_SSL_MINOR_VERSION_3 )
        -: 3788:    {
        -: 3789:        md_alg = MBEDTLS_MD_NONE;
        -: 3790:        hashlen = 36;
        -: 3791:
        -: 3792:        /* For ECDSA, use SHA-1, not MD-5 + SHA-1 */
        -: 3793:        if( mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk,
        -: 3794:                        MBEDTLS_PK_ECDSA ) )
        -: 3795:        {
        -: 3796:            hash_start += 16;
        -: 3797:            hashlen -= 16;
        -: 3798:            md_alg = MBEDTLS_MD_SHA1;
        -: 3799:        }
        -: 3800:    }
        -: 3801:    else
        -: 3802:#endif /* MBEDTLS_SSL_PROTO_SSL3 || MBEDTLS_SSL_PROTO_TLS1 ||
        -: 3803:          MBEDTLS_SSL_PROTO_TLS1_1 */
        -: 3804:#if defined(MBEDTLS_SSL_PROTO_TLS1_2)
        -: 3805:    if( ssl->minor_ver == MBEDTLS_SSL_MINOR_VERSION_3 )
        -: 3806:    {
        -: 3807:        if( i + 2 > ssl->in_hslen )
        -: 3808:        {
        -: 3809:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate verify message" ) );
        -: 3810:            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
        -: 3811:        }
        -: 3812:
        -: 3813:        /*
        -: 3814:         * Hash
        -: 3815:         */
        -: 3816:        md_alg = mbedtls_ssl_md_alg_from_hash( ssl->in_msg[i] );
        -: 3817:
        -: 3818:        if( md_alg == MBEDTLS_MD_NONE || mbedtls_ssl_set_calc_verify_md( ssl, ssl->in_msg[i] ) )
        -: 3819:        {
        -: 3820:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "peer not adhering to requested sig_alg"
        -: 3821:                                " for verify message" ) );
        -: 3822:            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
        -: 3823:        }
        -: 3824:
        -: 3825:#if !defined(MBEDTLS_MD_SHA1)
        -: 3826:        if( MBEDTLS_MD_SHA1 == md_alg )
        -: 3827:            hash_start += 16;
        -: 3828:#endif
        -: 3829:
        -: 3830:        /* Info from md_alg will be used instead */
        -: 3831:        hashlen = 0;
        -: 3832:
        -: 3833:        i++;
        -: 3834:
        -: 3835:        /*
        -: 3836:         * Signature
        -: 3837:         */
        -: 3838:        if( ( pk_alg = mbedtls_ssl_pk_alg_from_sig( ssl->in_msg[i] ) )
        -: 3839:                        == MBEDTLS_PK_NONE )
        -: 3840:        {
        -: 3841:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "peer not adhering to requested sig_alg"
        -: 3842:                                " for verify message" ) );
        -: 3843:            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
        -: 3844:        }
        -: 3845:
        -: 3846:        /*
        -: 3847:         * Check the certificate's key type matches the signature alg
        -: 3848:         */
        -: 3849:        if( ! mbedtls_pk_can_do( &ssl->session_negotiate->peer_cert->pk, pk_alg ) )
        -: 3850:        {
        -: 3851:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "sig_alg doesn't match cert key" ) );
        -: 3852:            return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
        -: 3853:        }
        -: 3854:
        -: 3855:        i++;
        -: 3856:    }
        -: 3857:    else
        -: 3858:#endif /* MBEDTLS_SSL_PROTO_TLS1_2 */
        -: 3859:    {
        -: 3860:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "should never happen" ) );
        -: 3861:        return( MBEDTLS_ERR_SSL_INTERNAL_ERROR );
        -: 3862:    }
        -: 3863:
        -: 3864:    if( i + 2 > ssl->in_hslen )
        -: 3865:    {
        -: 3866:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate verify message" ) );
        -: 3867:        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
        -: 3868:    }
        -: 3869:
        -: 3870:    sig_len = ( ssl->in_msg[i] << 8 ) | ssl->in_msg[i+1];
        -: 3871:    i += 2;
        -: 3872:
        -: 3873:    if( i + sig_len != ssl->in_hslen )
        -: 3874:    {
        -: 3875:        MBEDTLS_SSL_DEBUG_MSG( 1, ( "bad certificate verify message" ) );
        -: 3876:        return( MBEDTLS_ERR_SSL_BAD_HS_CERTIFICATE_VERIFY );
        -: 3877:    }
        -: 3878:
        -: 3879:    /* Calculate hash and verify signature */
        -: 3880:    ssl->handshake->calc_verify( ssl, hash );
        -: 3881:
        -: 3882:    if( ( ret = mbedtls_pk_verify( &ssl->session_negotiate->peer_cert->pk,
        -: 3883:                           md_alg, hash_start, hashlen,
        -: 3884:                           ssl->in_msg + i, sig_len ) ) != 0 )
        -: 3885:    {
        -: 3886:        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_pk_verify", ret );
        -: 3887:        return( ret );
        -: 3888:    }
        -: 3889:
        -: 3890:    mbedtls_ssl_update_handshake_status( ssl );
        -: 3891:
        -: 3892:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= parse certificate verify" ) );
        -: 3893:
        -: 3894:    return( ret );
        -: 3895:}
        -: 3896:#endif /* !MBEDTLS_KEY_EXCHANGE_RSA_ENABLED &&
        -: 3897:          !MBEDTLS_KEY_EXCHANGE_DHE_RSA_ENABLED &&
        -: 3898:          !MBEDTLS_KEY_EXCHANGE_ECDH_RSA_ENABLED &&
        -: 3899:          !MBEDTLS_KEY_EXCHANGE_ECDHE_RSA_ENABLED &&
        -: 3900:          !MBEDTLS_KEY_EXCHANGE_ECDH_ECDSA_ENABLED &&
        -: 3901:          !MBEDTLS_KEY_EXCHANGE_ECDHE_ECDSA_ENABLED */
        -: 3902:
        -: 3903:#if defined(MBEDTLS_SSL_SESSION_TICKETS)
        -: 3904:static int ssl_write_new_session_ticket( mbedtls_ssl_context *ssl )
        -: 3905:{
        -: 3906:    int ret;
        -: 3907:    size_t tlen;
        -: 3908:    uint32_t lifetime;
        -: 3909:
        -: 3910:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "=> write new session ticket" ) );
        -: 3911:
        -: 3912:    ssl->out_msgtype = MBEDTLS_SSL_MSG_HANDSHAKE;
        -: 3913:    ssl->out_msg[0]  = MBEDTLS_SSL_HS_NEW_SESSION_TICKET;
        -: 3914:
        -: 3915:    /*
        -: 3916:     * struct {
        -: 3917:     *     uint32 ticket_lifetime_hint;
        -: 3918:     *     opaque ticket<0..2^16-1>;
        -: 3919:     * } NewSessionTicket;
        -: 3920:     *
        -: 3921:     * 4  .  7   ticket_lifetime_hint (0 = unspecified)
        -: 3922:     * 8  .  9   ticket_len (n)
        -: 3923:     * 10 .  9+n ticket content
        -: 3924:     */
        -: 3925:
        -: 3926:    if( ( ret = ssl->conf->f_ticket_write( ssl->conf->p_ticket,
        -: 3927:                                ssl->session_negotiate,
        -: 3928:                                ssl->out_msg + 10,
        -: 3929:                                ssl->out_msg + MBEDTLS_SSL_MAX_CONTENT_LEN,
        -: 3930:                                &tlen, &lifetime ) ) != 0 )
        -: 3931:    {
        -: 3932:        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_ticket_write", ret );
        -: 3933:        tlen = 0;
        -: 3934:    }
        -: 3935:
        -: 3936:    ssl->out_msg[4] = ( lifetime >> 24 ) & 0xFF;
        -: 3937:    ssl->out_msg[5] = ( lifetime >> 16 ) & 0xFF;
        -: 3938:    ssl->out_msg[6] = ( lifetime >>  8 ) & 0xFF;
        -: 3939:    ssl->out_msg[7] = ( lifetime       ) & 0xFF;
        -: 3940:
        -: 3941:    ssl->out_msg[8] = (unsigned char)( ( tlen >> 8 ) & 0xFF );
        -: 3942:    ssl->out_msg[9] = (unsigned char)( ( tlen      ) & 0xFF );
        -: 3943:
        -: 3944:    ssl->out_msglen = 10 + tlen;
        -: 3945:
        -: 3946:    /*
        -: 3947:     * Morally equivalent to updating ssl->state, but NewSessionTicket and
        -: 3948:     * ChangeCipherSpec share the same state.
        -: 3949:     */
        -: 3950:    ssl->handshake->new_session_ticket = 0;
        -: 3951:
        -: 3952:    if( ( ret = mbedtls_ssl_write_record( ssl ) ) != 0 )
        -: 3953:    {
        -: 3954:        MBEDTLS_SSL_DEBUG_RET( 1, "mbedtls_ssl_write_record", ret );
        -: 3955:        return( ret );
        -: 3956:    }
        -: 3957:
        -: 3958:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "<= write new session ticket" ) );
        -: 3959:
        -: 3960:    return( 0 );
        -: 3961:}
        -: 3962:#endif /* MBEDTLS_SSL_SESSION_TICKETS */
        -: 3963:
        -: 3964:/*
        -: 3965: * SSL handshake -- server side -- single step
        -: 3966: */
    #####: 3967:int mbedtls_ssl_handshake_server_step( mbedtls_ssl_context *ssl )
        -: 3968:{
    #####: 3969:    int ret = 0;
        -: 3970:
    #####: 3971:    if( ssl->state == MBEDTLS_SSL_HANDSHAKE_OVER || ssl->handshake == NULL )
    #####: 3972:        return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
        -: 3973:
    #####: 3974:    MBEDTLS_SSL_DEBUG_MSG( 2, ( "server state: %d", ssl->state ) );
        -: 3975:
    #####: 3976:    if( ( ret = mbedtls_ssl_flush_output( ssl ) ) != 0 )
    #####: 3977:        return( ret );
        -: 3978:
        -: 3979:#if defined(MBEDTLS_SSL_PROTO_DTLS)
    #####: 3980:    if( ssl->conf->transport == MBEDTLS_SSL_TRANSPORT_DATAGRAM &&
    #####: 3981:        ssl->handshake->retransmit_state == MBEDTLS_SSL_RETRANS_SENDING )
        -: 3982:    {
    #####: 3983:        if( ( ret = mbedtls_ssl_resend( ssl ) ) != 0 )
    #####: 3984:            return( ret );
        -: 3985:    }
        -: 3986:#endif
        -: 3987:
    #####: 3988:    switch( ssl->state )
        -: 3989:    {
    #####: 3990:        case MBEDTLS_SSL_HELLO_REQUEST:
    #####: 3991:            ssl->state = MBEDTLS_SSL_CLIENT_HELLO;
    #####: 3992:            break;
        -: 3993:
        -: 3994:        /*
        -: 3995:         *  <==   ClientHello
        -: 3996:         */
    #####: 3997:        case MBEDTLS_SSL_CLIENT_HELLO:
    #####: 3998:            ret = ssl_parse_client_hello( ssl );
    #####: 3999:            break;
        -: 4000:
        -: 4001:#if defined(MBEDTLS_SSL_PROTO_DTLS)
    #####: 4002:        case MBEDTLS_SSL_SERVER_HELLO_VERIFY_REQUEST_SENT:
    #####: 4003:            return( MBEDTLS_ERR_SSL_HELLO_VERIFY_REQUIRED );
        -: 4004:#endif
        -: 4005:
        -: 4006:        /*
        -: 4007:         *  ==>   ServerHello
        -: 4008:         *        Certificate
        -: 4009:         *      ( ServerKeyExchange  )
        -: 4010:         *      ( CertificateRequest )
        -: 4011:         *        ServerHelloDone
        -: 4012:         */
    #####: 4013:        case MBEDTLS_SSL_SERVER_HELLO:
    #####: 4014:            ret = ssl_write_server_hello( ssl );
    #####: 4015:            break;
        -: 4016:
    #####: 4017:        case MBEDTLS_SSL_SERVER_CERTIFICATE:
    #####: 4018:            ret = mbedtls_ssl_write_certificate( ssl );
    #####: 4019:            break;
        -: 4020:
    #####: 4021:        case MBEDTLS_SSL_SERVER_KEY_EXCHANGE:
    #####: 4022:            ret = ssl_write_server_key_exchange( ssl );
    #####: 4023:            break;
        -: 4024:
    #####: 4025:        case MBEDTLS_SSL_CERTIFICATE_REQUEST:
    #####: 4026:            ret = ssl_write_certificate_request( ssl );
    #####: 4027:            break;
        -: 4028:
    #####: 4029:        case MBEDTLS_SSL_SERVER_HELLO_DONE:
    #####: 4030:            ret = ssl_write_server_hello_done( ssl );
    #####: 4031:            break;
        -: 4032:
        -: 4033:        /*
        -: 4034:         *  <== ( Certificate/Alert  )
        -: 4035:         *        ClientKeyExchange
        -: 4036:         *      ( CertificateVerify  )
        -: 4037:         *        ChangeCipherSpec
        -: 4038:         *        Finished
        -: 4039:         */
    #####: 4040:        case MBEDTLS_SSL_CLIENT_CERTIFICATE:
    #####: 4041:            ret = mbedtls_ssl_parse_certificate( ssl );
    #####: 4042:            break;
        -: 4043:
    #####: 4044:        case MBEDTLS_SSL_CLIENT_KEY_EXCHANGE:
    #####: 4045:            ret = ssl_parse_client_key_exchange( ssl );
    #####: 4046:            break;
        -: 4047:
    #####: 4048:        case MBEDTLS_SSL_CERTIFICATE_VERIFY:
    #####: 4049:            ret = ssl_parse_certificate_verify( ssl );
    #####: 4050:            break;
        -: 4051:
    #####: 4052:        case MBEDTLS_SSL_CLIENT_CHANGE_CIPHER_SPEC:
    #####: 4053:            ret = mbedtls_ssl_parse_change_cipher_spec( ssl );
    #####: 4054:            break;
        -: 4055:
    #####: 4056:        case MBEDTLS_SSL_CLIENT_FINISHED:
    #####: 4057:            ret = mbedtls_ssl_parse_finished( ssl );
    #####: 4058:            break;
        -: 4059:
        -: 4060:        /*
        -: 4061:         *  ==> ( NewSessionTicket )
        -: 4062:         *        ChangeCipherSpec
        -: 4063:         *        Finished
        -: 4064:         */
    #####: 4065:        case MBEDTLS_SSL_SERVER_CHANGE_CIPHER_SPEC:
        -: 4066:#if defined(MBEDTLS_SSL_SESSION_TICKETS)
        -: 4067:            if( ssl->handshake->new_session_ticket != 0 )
        -: 4068:                ret = ssl_write_new_session_ticket( ssl );
        -: 4069:            else
        -: 4070:#endif
    #####: 4071:                ret = mbedtls_ssl_write_change_cipher_spec( ssl );
    #####: 4072:            break;
        -: 4073:
    #####: 4074:        case MBEDTLS_SSL_SERVER_FINISHED:
    #####: 4075:            ret = mbedtls_ssl_write_finished( ssl );
    #####: 4076:            break;
        -: 4077:
    #####: 4078:        case MBEDTLS_SSL_FLUSH_BUFFERS:
    #####: 4079:            MBEDTLS_SSL_DEBUG_MSG( 2, ( "handshake: done" ) );
    #####: 4080:            ssl->state = MBEDTLS_SSL_HANDSHAKE_WRAPUP;
    #####: 4081:            break;
        -: 4082:
    #####: 4083:        case MBEDTLS_SSL_HANDSHAKE_WRAPUP:
    #####: 4084:            mbedtls_ssl_handshake_wrapup( ssl );
    #####: 4085:            break;
        -: 4086:
    #####: 4087:        default:
    #####: 4088:            MBEDTLS_SSL_DEBUG_MSG( 1, ( "invalid state %d", ssl->state ) );
    #####: 4089:            return( MBEDTLS_ERR_SSL_BAD_INPUT_DATA );
        -: 4090:    }
        -: 4091:
    #####: 4092:    return( ret );
        -: 4093:}
        -: 4094:#endif /* MBEDTLS_SSL_SRV_C */
