        -:    0:Source:/home/david/Programming/wakaamaNode/src/network/mbedtls/library/rsa.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/network/mbedtls/library/rsa.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*
        -:    2: *  The RSA public-key cryptosystem
        -:    3: *
        -:    4: *  Copyright (C) 2006-2015, ARM Limited, All Rights Reserved
        -:    5: *  SPDX-License-Identifier: Apache-2.0
        -:    6: *
        -:    7: *  Licensed under the Apache License, Version 2.0 (the "License"); you may
        -:    8: *  not use this file except in compliance with the License.
        -:    9: *  You may obtain a copy of the License at
        -:   10: *
        -:   11: *  http://www.apache.org/licenses/LICENSE-2.0
        -:   12: *
        -:   13: *  Unless required by applicable law or agreed to in writing, software
        -:   14: *  distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
        -:   15: *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
        -:   16: *  See the License for the specific language governing permissions and
        -:   17: *  limitations under the License.
        -:   18: *
        -:   19: *  This file is part of mbed TLS (https://tls.mbed.org)
        -:   20: */
        -:   21:
        -:   22:/*
        -:   23: *  The following sources were referenced in the design of this implementation
        -:   24: *  of the RSA algorithm:
        -:   25: *
        -:   26: *  [1] A method for obtaining digital signatures and public-key cryptosystems
        -:   27: *      R Rivest, A Shamir, and L Adleman
        -:   28: *      http://people.csail.mit.edu/rivest/pubs.html#RSA78
        -:   29: *
        -:   30: *  [2] Handbook of Applied Cryptography - 1997, Chapter 8
        -:   31: *      Menezes, van Oorschot and Vanstone
        -:   32: *
        -:   33: *  [3] Malware Guard Extension: Using SGX to Conceal Cache Attacks
        -:   34: *      Michael Schwarz, Samuel Weiser, Daniel Gruss, Cl√©mentine Maurice and
        -:   35: *      Stefan Mangard
        -:   36: *      https://arxiv.org/abs/1702.08719v2
        -:   37: *
        -:   38: */
        -:   39:
        -:   40:#if !defined(MBEDTLS_CONFIG_FILE)
        -:   41:#include "mbedtls/config.h"
        -:   42:#else
        -:   43:#include MBEDTLS_CONFIG_FILE
        -:   44:#endif
        -:   45:
        -:   46:#if defined(MBEDTLS_RSA_C)
        -:   47:
        -:   48:#include "mbedtls/rsa.h"
        -:   49:#include "mbedtls/rsa_internal.h"
        -:   50:#include "mbedtls/oid.h"
        -:   51:#include "mbedtls/platform_util.h"
        -:   52:
        -:   53:#include <string.h>
        -:   54:
        -:   55:#if defined(MBEDTLS_PKCS1_V21)
        -:   56:#include "mbedtls/md.h"
        -:   57:#endif
        -:   58:
        -:   59:#if defined(MBEDTLS_PKCS1_V15) && !defined(__OpenBSD__)
        -:   60:#include <stdlib.h>
        -:   61:#endif
        -:   62:
        -:   63:#if defined(MBEDTLS_PLATFORM_C)
        -:   64:#include "mbedtls/platform.h"
        -:   65:#else
        -:   66:#include <stdio.h>
        -:   67:#define mbedtls_printf printf
        -:   68:#define mbedtls_calloc calloc
        -:   69:#define mbedtls_free   free
        -:   70:#endif
        -:   71:
        -:   72:#if !defined(MBEDTLS_RSA_ALT)
        -:   73:
        -:   74:#if defined(MBEDTLS_PKCS1_V15)
        -:   75:/* constant-time buffer comparison */
    #####:   76:static inline int mbedtls_safer_memcmp( const void *a, const void *b, size_t n )
        -:   77:{
        -:   78:    size_t i;
    #####:   79:    const unsigned char *A = (const unsigned char *) a;
    #####:   80:    const unsigned char *B = (const unsigned char *) b;
    #####:   81:    unsigned char diff = 0;
        -:   82:
    #####:   83:    for( i = 0; i < n; i++ )
    #####:   84:        diff |= A[i] ^ B[i];
        -:   85:
    #####:   86:    return( diff );
        -:   87:}
        -:   88:#endif /* MBEDTLS_PKCS1_V15 */
        -:   89:
    #####:   90:int mbedtls_rsa_import( mbedtls_rsa_context *ctx,
        -:   91:                        const mbedtls_mpi *N,
        -:   92:                        const mbedtls_mpi *P, const mbedtls_mpi *Q,
        -:   93:                        const mbedtls_mpi *D, const mbedtls_mpi *E )
        -:   94:{
        -:   95:    int ret;
        -:   96:
    #####:   97:    if( ( N != NULL && ( ret = mbedtls_mpi_copy( &ctx->N, N ) ) != 0 ) ||
    #####:   98:        ( P != NULL && ( ret = mbedtls_mpi_copy( &ctx->P, P ) ) != 0 ) ||
    #####:   99:        ( Q != NULL && ( ret = mbedtls_mpi_copy( &ctx->Q, Q ) ) != 0 ) ||
    #####:  100:        ( D != NULL && ( ret = mbedtls_mpi_copy( &ctx->D, D ) ) != 0 ) ||
    #####:  101:        ( E != NULL && ( ret = mbedtls_mpi_copy( &ctx->E, E ) ) != 0 ) )
        -:  102:    {
    #####:  103:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
        -:  104:    }
        -:  105:
    #####:  106:    if( N != NULL )
    #####:  107:        ctx->len = mbedtls_mpi_size( &ctx->N );
        -:  108:
    #####:  109:    return( 0 );
        -:  110:}
        -:  111:
    #####:  112:int mbedtls_rsa_import_raw( mbedtls_rsa_context *ctx,
        -:  113:                            unsigned char const *N, size_t N_len,
        -:  114:                            unsigned char const *P, size_t P_len,
        -:  115:                            unsigned char const *Q, size_t Q_len,
        -:  116:                            unsigned char const *D, size_t D_len,
        -:  117:                            unsigned char const *E, size_t E_len )
        -:  118:{
    #####:  119:    int ret = 0;
        -:  120:
    #####:  121:    if( N != NULL )
        -:  122:    {
    #####:  123:        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->N, N, N_len ) );
    #####:  124:        ctx->len = mbedtls_mpi_size( &ctx->N );
        -:  125:    }
        -:  126:
    #####:  127:    if( P != NULL )
    #####:  128:        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->P, P, P_len ) );
        -:  129:
    #####:  130:    if( Q != NULL )
    #####:  131:        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->Q, Q, Q_len ) );
        -:  132:
    #####:  133:    if( D != NULL )
    #####:  134:        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->D, D, D_len ) );
        -:  135:
    #####:  136:    if( E != NULL )
    #####:  137:        MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &ctx->E, E, E_len ) );
        -:  138:
    #####:  139:cleanup:
        -:  140:
    #####:  141:    if( ret != 0 )
    #####:  142:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
        -:  143:
    #####:  144:    return( 0 );
        -:  145:}
        -:  146:
        -:  147:/*
        -:  148: * Checks whether the context fields are set in such a way
        -:  149: * that the RSA primitives will be able to execute without error.
        -:  150: * It does *not* make guarantees for consistency of the parameters.
        -:  151: */
    #####:  152:static int rsa_check_context( mbedtls_rsa_context const *ctx, int is_priv,
        -:  153:                              int blinding_needed )
        -:  154:{
        -:  155:#if !defined(MBEDTLS_RSA_NO_CRT)
        -:  156:    /* blinding_needed is only used for NO_CRT to decide whether
        -:  157:     * P,Q need to be present or not. */
        -:  158:    ((void) blinding_needed);
        -:  159:#endif
        -:  160:
    #####:  161:    if( ctx->len != mbedtls_mpi_size( &ctx->N ) ||
    #####:  162:        ctx->len > MBEDTLS_MPI_MAX_SIZE )
        -:  163:    {
    #####:  164:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -:  165:    }
        -:  166:
        -:  167:    /*
        -:  168:     * 1. Modular exponentiation needs positive, odd moduli.
        -:  169:     */
        -:  170:
        -:  171:    /* Modular exponentiation wrt. N is always used for
        -:  172:     * RSA public key operations. */
    #####:  173:    if( mbedtls_mpi_cmp_int( &ctx->N, 0 ) <= 0 ||
    #####:  174:        mbedtls_mpi_get_bit( &ctx->N, 0 ) == 0  )
        -:  175:    {
    #####:  176:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -:  177:    }
        -:  178:
        -:  179:#if !defined(MBEDTLS_RSA_NO_CRT)
        -:  180:    /* Modular exponentiation for P and Q is only
        -:  181:     * used for private key operations and if CRT
        -:  182:     * is used. */
    #####:  183:    if( is_priv &&
    #####:  184:        ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) <= 0 ||
    #####:  185:          mbedtls_mpi_get_bit( &ctx->P, 0 ) == 0 ||
    #####:  186:          mbedtls_mpi_cmp_int( &ctx->Q, 0 ) <= 0 ||
    #####:  187:          mbedtls_mpi_get_bit( &ctx->Q, 0 ) == 0  ) )
        -:  188:    {
    #####:  189:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -:  190:    }
        -:  191:#endif /* !MBEDTLS_RSA_NO_CRT */
        -:  192:
        -:  193:    /*
        -:  194:     * 2. Exponents must be positive
        -:  195:     */
        -:  196:
        -:  197:    /* Always need E for public key operations */
    #####:  198:    if( mbedtls_mpi_cmp_int( &ctx->E, 0 ) <= 0 )
    #####:  199:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -:  200:
        -:  201:#if defined(MBEDTLS_RSA_NO_CRT)
        -:  202:    /* For private key operations, use D or DP & DQ
        -:  203:     * as (unblinded) exponents. */
        -:  204:    if( is_priv && mbedtls_mpi_cmp_int( &ctx->D, 0 ) <= 0 )
        -:  205:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -:  206:#else
    #####:  207:    if( is_priv &&
    #####:  208:        ( mbedtls_mpi_cmp_int( &ctx->DP, 0 ) <= 0 ||
    #####:  209:          mbedtls_mpi_cmp_int( &ctx->DQ, 0 ) <= 0  ) )
        -:  210:    {
    #####:  211:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -:  212:    }
        -:  213:#endif /* MBEDTLS_RSA_NO_CRT */
        -:  214:
        -:  215:    /* Blinding shouldn't make exponents negative either,
        -:  216:     * so check that P, Q >= 1 if that hasn't yet been
        -:  217:     * done as part of 1. */
        -:  218:#if defined(MBEDTLS_RSA_NO_CRT)
        -:  219:    if( is_priv && blinding_needed &&
        -:  220:        ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) <= 0 ||
        -:  221:          mbedtls_mpi_cmp_int( &ctx->Q, 0 ) <= 0 ) )
        -:  222:    {
        -:  223:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -:  224:    }
        -:  225:#endif
        -:  226:
        -:  227:    /* It wouldn't lead to an error if it wasn't satisfied,
        -:  228:     * but check for QP >= 1 nonetheless. */
        -:  229:#if !defined(MBEDTLS_RSA_NO_CRT)
    #####:  230:    if( is_priv &&
    #####:  231:        mbedtls_mpi_cmp_int( &ctx->QP, 0 ) <= 0 )
        -:  232:    {
    #####:  233:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -:  234:    }
        -:  235:#endif
        -:  236:
    #####:  237:    return( 0 );
        -:  238:}
        -:  239:
    #####:  240:int mbedtls_rsa_complete( mbedtls_rsa_context *ctx )
        -:  241:{
    #####:  242:    int ret = 0;
        -:  243:
    #####:  244:    const int have_N = ( mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 );
    #####:  245:    const int have_P = ( mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 );
    #####:  246:    const int have_Q = ( mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 );
    #####:  247:    const int have_D = ( mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 );
    #####:  248:    const int have_E = ( mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0 );
        -:  249:
        -:  250:    /*
        -:  251:     * Check whether provided parameters are enough
        -:  252:     * to deduce all others. The following incomplete
        -:  253:     * parameter sets for private keys are supported:
        -:  254:     *
        -:  255:     * (1) P, Q missing.
        -:  256:     * (2) D and potentially N missing.
        -:  257:     *
        -:  258:     */
        -:  259:
    #####:  260:    const int n_missing  =              have_P &&  have_Q &&  have_D && have_E;
    #####:  261:    const int pq_missing =   have_N && !have_P && !have_Q &&  have_D && have_E;
    #####:  262:    const int d_missing  =              have_P &&  have_Q && !have_D && have_E;
    #####:  263:    const int is_pub     =   have_N && !have_P && !have_Q && !have_D && have_E;
        -:  264:
        -:  265:    /* These three alternatives are mutually exclusive */
    #####:  266:    const int is_priv = n_missing || pq_missing || d_missing;
        -:  267:
    #####:  268:    if( !is_priv && !is_pub )
    #####:  269:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -:  270:
        -:  271:    /*
        -:  272:     * Step 1: Deduce N if P, Q are provided.
        -:  273:     */
        -:  274:
    #####:  275:    if( !have_N && have_P && have_Q )
        -:  276:    {
    #####:  277:        if( ( ret = mbedtls_mpi_mul_mpi( &ctx->N, &ctx->P,
    #####:  278:                                         &ctx->Q ) ) != 0 )
        -:  279:        {
    #####:  280:            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
        -:  281:        }
        -:  282:
    #####:  283:        ctx->len = mbedtls_mpi_size( &ctx->N );
        -:  284:    }
        -:  285:
        -:  286:    /*
        -:  287:     * Step 2: Deduce and verify all remaining core parameters.
        -:  288:     */
        -:  289:
    #####:  290:    if( pq_missing )
        -:  291:    {
    #####:  292:        ret = mbedtls_rsa_deduce_primes( &ctx->N, &ctx->E, &ctx->D,
        -:  293:                                         &ctx->P, &ctx->Q );
    #####:  294:        if( ret != 0 )
    #####:  295:            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
        -:  296:
        -:  297:    }
    #####:  298:    else if( d_missing )
        -:  299:    {
    #####:  300:        if( ( ret = mbedtls_rsa_deduce_private_exponent( &ctx->P,
    #####:  301:                                                         &ctx->Q,
    #####:  302:                                                         &ctx->E,
        -:  303:                                                         &ctx->D ) ) != 0 )
        -:  304:        {
    #####:  305:            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
        -:  306:        }
        -:  307:    }
        -:  308:
        -:  309:    /*
        -:  310:     * Step 3: Deduce all additional parameters specific
        -:  311:     *         to our current RSA implementation.
        -:  312:     */
        -:  313:
        -:  314:#if !defined(MBEDTLS_RSA_NO_CRT)
    #####:  315:    if( is_priv )
        -:  316:    {
    #####:  317:        ret = mbedtls_rsa_deduce_crt( &ctx->P,  &ctx->Q,  &ctx->D,
        -:  318:                                      &ctx->DP, &ctx->DQ, &ctx->QP );
    #####:  319:        if( ret != 0 )
    #####:  320:            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
        -:  321:    }
        -:  322:#endif /* MBEDTLS_RSA_NO_CRT */
        -:  323:
        -:  324:    /*
        -:  325:     * Step 3: Basic sanity checks
        -:  326:     */
        -:  327:
    #####:  328:    return( rsa_check_context( ctx, is_priv, 1 ) );
        -:  329:}
        -:  330:
    #####:  331:int mbedtls_rsa_export_raw( const mbedtls_rsa_context *ctx,
        -:  332:                            unsigned char *N, size_t N_len,
        -:  333:                            unsigned char *P, size_t P_len,
        -:  334:                            unsigned char *Q, size_t Q_len,
        -:  335:                            unsigned char *D, size_t D_len,
        -:  336:                            unsigned char *E, size_t E_len )
        -:  337:{
    #####:  338:    int ret = 0;
        -:  339:
        -:  340:    /* Check if key is private or public */
    #####:  341:    const int is_priv =
    #####:  342:        mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 &&
    #####:  343:        mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 &&
    #####:  344:        mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 &&
    #####:  345:        mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 &&
    #####:  346:        mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0;
        -:  347:
    #####:  348:    if( !is_priv )
        -:  349:    {
        -:  350:        /* If we're trying to export private parameters for a public key,
        -:  351:         * something must be wrong. */
    #####:  352:        if( P != NULL || Q != NULL || D != NULL )
    #####:  353:            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -:  354:
        -:  355:    }
        -:  356:
    #####:  357:    if( N != NULL )
    #####:  358:        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->N, N, N_len ) );
        -:  359:
    #####:  360:    if( P != NULL )
    #####:  361:        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->P, P, P_len ) );
        -:  362:
    #####:  363:    if( Q != NULL )
    #####:  364:        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->Q, Q, Q_len ) );
        -:  365:
    #####:  366:    if( D != NULL )
    #####:  367:        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->D, D, D_len ) );
        -:  368:
    #####:  369:    if( E != NULL )
    #####:  370:        MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &ctx->E, E, E_len ) );
        -:  371:
    #####:  372:cleanup:
        -:  373:
    #####:  374:    return( ret );
        -:  375:}
        -:  376:
    #####:  377:int mbedtls_rsa_export( const mbedtls_rsa_context *ctx,
        -:  378:                        mbedtls_mpi *N, mbedtls_mpi *P, mbedtls_mpi *Q,
        -:  379:                        mbedtls_mpi *D, mbedtls_mpi *E )
        -:  380:{
        -:  381:    int ret;
        -:  382:
        -:  383:    /* Check if key is private or public */
    #####:  384:    int is_priv =
    #####:  385:        mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 &&
    #####:  386:        mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 &&
    #####:  387:        mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 &&
    #####:  388:        mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 &&
    #####:  389:        mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0;
        -:  390:
    #####:  391:    if( !is_priv )
        -:  392:    {
        -:  393:        /* If we're trying to export private parameters for a public key,
        -:  394:         * something must be wrong. */
    #####:  395:        if( P != NULL || Q != NULL || D != NULL )
    #####:  396:            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -:  397:
        -:  398:    }
        -:  399:
        -:  400:    /* Export all requested core parameters. */
        -:  401:
    #####:  402:    if( ( N != NULL && ( ret = mbedtls_mpi_copy( N, &ctx->N ) ) != 0 ) ||
    #####:  403:        ( P != NULL && ( ret = mbedtls_mpi_copy( P, &ctx->P ) ) != 0 ) ||
    #####:  404:        ( Q != NULL && ( ret = mbedtls_mpi_copy( Q, &ctx->Q ) ) != 0 ) ||
    #####:  405:        ( D != NULL && ( ret = mbedtls_mpi_copy( D, &ctx->D ) ) != 0 ) ||
    #####:  406:        ( E != NULL && ( ret = mbedtls_mpi_copy( E, &ctx->E ) ) != 0 ) )
        -:  407:    {
    #####:  408:        return( ret );
        -:  409:    }
        -:  410:
    #####:  411:    return( 0 );
        -:  412:}
        -:  413:
        -:  414:/*
        -:  415: * Export CRT parameters
        -:  416: * This must also be implemented if CRT is not used, for being able to
        -:  417: * write DER encoded RSA keys. The helper function mbedtls_rsa_deduce_crt
        -:  418: * can be used in this case.
        -:  419: */
    #####:  420:int mbedtls_rsa_export_crt( const mbedtls_rsa_context *ctx,
        -:  421:                            mbedtls_mpi *DP, mbedtls_mpi *DQ, mbedtls_mpi *QP )
        -:  422:{
        -:  423:    int ret;
        -:  424:
        -:  425:    /* Check if key is private or public */
    #####:  426:    int is_priv =
    #####:  427:        mbedtls_mpi_cmp_int( &ctx->N, 0 ) != 0 &&
    #####:  428:        mbedtls_mpi_cmp_int( &ctx->P, 0 ) != 0 &&
    #####:  429:        mbedtls_mpi_cmp_int( &ctx->Q, 0 ) != 0 &&
    #####:  430:        mbedtls_mpi_cmp_int( &ctx->D, 0 ) != 0 &&
    #####:  431:        mbedtls_mpi_cmp_int( &ctx->E, 0 ) != 0;
        -:  432:
    #####:  433:    if( !is_priv )
    #####:  434:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -:  435:
        -:  436:#if !defined(MBEDTLS_RSA_NO_CRT)
        -:  437:    /* Export all requested blinding parameters. */
    #####:  438:    if( ( DP != NULL && ( ret = mbedtls_mpi_copy( DP, &ctx->DP ) ) != 0 ) ||
    #####:  439:        ( DQ != NULL && ( ret = mbedtls_mpi_copy( DQ, &ctx->DQ ) ) != 0 ) ||
    #####:  440:        ( QP != NULL && ( ret = mbedtls_mpi_copy( QP, &ctx->QP ) ) != 0 ) )
        -:  441:    {
    #####:  442:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
        -:  443:    }
        -:  444:#else
        -:  445:    if( ( ret = mbedtls_rsa_deduce_crt( &ctx->P, &ctx->Q, &ctx->D,
        -:  446:                                        DP, DQ, QP ) ) != 0 )
        -:  447:    {
        -:  448:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA + ret );
        -:  449:    }
        -:  450:#endif
        -:  451:
    #####:  452:    return( 0 );
        -:  453:}
        -:  454:
        -:  455:/*
        -:  456: * Initialize an RSA context
        -:  457: */
    #####:  458:void mbedtls_rsa_init( mbedtls_rsa_context *ctx,
        -:  459:               int padding,
        -:  460:               int hash_id )
        -:  461:{
    #####:  462:    memset( ctx, 0, sizeof( mbedtls_rsa_context ) );
        -:  463:
    #####:  464:    mbedtls_rsa_set_padding( ctx, padding, hash_id );
        -:  465:
        -:  466:#if defined(MBEDTLS_THREADING_C)
        -:  467:    mbedtls_mutex_init( &ctx->mutex );
        -:  468:#endif
    #####:  469:}
        -:  470:
        -:  471:/*
        -:  472: * Set padding for an existing RSA context
        -:  473: */
    #####:  474:void mbedtls_rsa_set_padding( mbedtls_rsa_context *ctx, int padding, int hash_id )
        -:  475:{
    #####:  476:    ctx->padding = padding;
    #####:  477:    ctx->hash_id = hash_id;
    #####:  478:}
        -:  479:
        -:  480:/*
        -:  481: * Get length in bytes of RSA modulus
        -:  482: */
        -:  483:
    #####:  484:size_t mbedtls_rsa_get_len( const mbedtls_rsa_context *ctx )
        -:  485:{
    #####:  486:    return( ctx->len );
        -:  487:}
        -:  488:
        -:  489:
        -:  490:#if defined(MBEDTLS_GENPRIME)
        -:  491:
        -:  492:/*
        -:  493: * Generate an RSA keypair
        -:  494: *
        -:  495: * This generation method follows the RSA key pair generation procedure of
        -:  496: * FIPS 186-4 if 2^16 < exponent < 2^256 and nbits = 2048 or nbits = 3072.
        -:  497: */
    #####:  498:int mbedtls_rsa_gen_key( mbedtls_rsa_context *ctx,
        -:  499:                 int (*f_rng)(void *, unsigned char *, size_t),
        -:  500:                 void *p_rng,
        -:  501:                 unsigned int nbits, int exponent )
        -:  502:{
        -:  503:    int ret;
        -:  504:    mbedtls_mpi H, G, L;
        -:  505:
    #####:  506:    if( f_rng == NULL || nbits < 128 || exponent < 3 )
    #####:  507:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -:  508:
    #####:  509:    if( nbits % 2 )
    #####:  510:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -:  511:
    #####:  512:    mbedtls_mpi_init( &H );
    #####:  513:    mbedtls_mpi_init( &G );
    #####:  514:    mbedtls_mpi_init( &L );
        -:  515:
        -:  516:    /*
        -:  517:     * find primes P and Q with Q < P so that:
        -:  518:     * 1.  |P-Q| > 2^( nbits / 2 - 100 )
        -:  519:     * 2.  GCD( E, (P-1)*(Q-1) ) == 1
        -:  520:     * 3.  E^-1 mod LCM(P-1, Q-1) > 2^( nbits / 2 )
        -:  521:     */
    #####:  522:    MBEDTLS_MPI_CHK( mbedtls_mpi_lset( &ctx->E, exponent ) );
        -:  523:
        -:  524:    do
        -:  525:    {
    #####:  526:        MBEDTLS_MPI_CHK( mbedtls_mpi_gen_prime( &ctx->P, nbits >> 1, 0,
        -:  527:                                                f_rng, p_rng ) );
        -:  528:
    #####:  529:        MBEDTLS_MPI_CHK( mbedtls_mpi_gen_prime( &ctx->Q, nbits >> 1, 0,
        -:  530:                                                f_rng, p_rng ) );
        -:  531:
        -:  532:        /* make sure the difference between p and q is not too small (FIPS 186-4 ¬ßB.3.3 step 5.4) */
    #####:  533:        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &H, &ctx->P, &ctx->Q ) );
    #####:  534:        if( mbedtls_mpi_bitlen( &H ) <= ( ( nbits >= 200 ) ? ( ( nbits >> 1 ) - 99 ) : 0 ) )
    #####:  535:            continue;
        -:  536:
        -:  537:        /* not required by any standards, but some users rely on the fact that P > Q */
    #####:  538:        if( H.s < 0 )
    #####:  539:            mbedtls_mpi_swap( &ctx->P, &ctx->Q );
        -:  540:
        -:  541:        /* Temporarily replace P,Q by P-1, Q-1 */
    #####:  542:        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &ctx->P, &ctx->P, 1 ) );
    #####:  543:        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &ctx->Q, &ctx->Q, 1 ) );
    #####:  544:        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &H, &ctx->P, &ctx->Q ) );
        -:  545:
        -:  546:        /* check GCD( E, (P-1)*(Q-1) ) == 1 (FIPS 186-4 ¬ßB.3.1 criterion 2(a)) */
    #####:  547:        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, &ctx->E, &H  ) );
    #####:  548:        if( mbedtls_mpi_cmp_int( &G, 1 ) != 0 )
    #####:  549:            continue;
        -:  550:
        -:  551:        /* compute smallest possible D = E^-1 mod LCM(P-1, Q-1) (FIPS 186-4 ¬ßB.3.1 criterion 3(b)) */
    #####:  552:        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &G, &ctx->P, &ctx->Q ) );
    #####:  553:        MBEDTLS_MPI_CHK( mbedtls_mpi_div_mpi( &L, NULL, &H, &G ) );
    #####:  554:        MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &ctx->D, &ctx->E, &L ) );
        -:  555:
    #####:  556:        if( mbedtls_mpi_bitlen( &ctx->D ) <= ( ( nbits + 1 ) / 2 ) ) // (FIPS 186-4 ¬ßB.3.1 criterion 3(a))
    #####:  557:            continue;
        -:  558:
    #####:  559:        break;
        -:  560:    }
        -:  561:    while( 1 );
        -:  562:
        -:  563:    /* Restore P,Q */
    #####:  564:    MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( &ctx->P,  &ctx->P, 1 ) );
    #####:  565:    MBEDTLS_MPI_CHK( mbedtls_mpi_add_int( &ctx->Q,  &ctx->Q, 1 ) );
        -:  566:
    #####:  567:    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ctx->N, &ctx->P, &ctx->Q ) );
        -:  568:
    #####:  569:    ctx->len = mbedtls_mpi_size( &ctx->N );
        -:  570:
        -:  571:#if !defined(MBEDTLS_RSA_NO_CRT)
        -:  572:    /*
        -:  573:     * DP = D mod (P - 1)
        -:  574:     * DQ = D mod (Q - 1)
        -:  575:     * QP = Q^-1 mod P
        -:  576:     */
    #####:  577:    MBEDTLS_MPI_CHK( mbedtls_rsa_deduce_crt( &ctx->P, &ctx->Q, &ctx->D,
        -:  578:                                             &ctx->DP, &ctx->DQ, &ctx->QP ) );
        -:  579:#endif /* MBEDTLS_RSA_NO_CRT */
        -:  580:
        -:  581:    /* Double-check */
    #####:  582:    MBEDTLS_MPI_CHK( mbedtls_rsa_check_privkey( ctx ) );
        -:  583:
    #####:  584:cleanup:
        -:  585:
    #####:  586:    mbedtls_mpi_free( &H );
    #####:  587:    mbedtls_mpi_free( &G );
    #####:  588:    mbedtls_mpi_free( &L );
        -:  589:
    #####:  590:    if( ret != 0 )
        -:  591:    {
    #####:  592:        mbedtls_rsa_free( ctx );
    #####:  593:        return( MBEDTLS_ERR_RSA_KEY_GEN_FAILED + ret );
        -:  594:    }
        -:  595:
    #####:  596:    return( 0 );
        -:  597:}
        -:  598:
        -:  599:#endif /* MBEDTLS_GENPRIME */
        -:  600:
        -:  601:/*
        -:  602: * Check a public RSA key
        -:  603: */
    #####:  604:int mbedtls_rsa_check_pubkey( const mbedtls_rsa_context *ctx )
        -:  605:{
    #####:  606:    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) != 0 )
    #####:  607:        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
        -:  608:
    #####:  609:    if( mbedtls_mpi_bitlen( &ctx->N ) < 128 )
        -:  610:    {
    #####:  611:        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
        -:  612:    }
        -:  613:
    #####:  614:    if( mbedtls_mpi_get_bit( &ctx->E, 0 ) == 0 ||
    #####:  615:        mbedtls_mpi_bitlen( &ctx->E )     < 2  ||
    #####:  616:        mbedtls_mpi_cmp_mpi( &ctx->E, &ctx->N ) >= 0 )
        -:  617:    {
    #####:  618:        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
        -:  619:    }
        -:  620:
    #####:  621:    return( 0 );
        -:  622:}
        -:  623:
        -:  624:/*
        -:  625: * Check for the consistency of all fields in an RSA private key context
        -:  626: */
    #####:  627:int mbedtls_rsa_check_privkey( const mbedtls_rsa_context *ctx )
        -:  628:{
    #####:  629:    if( mbedtls_rsa_check_pubkey( ctx ) != 0 ||
    #####:  630:        rsa_check_context( ctx, 1 /* private */, 1 /* blinding */ ) != 0 )
        -:  631:    {
    #####:  632:        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
        -:  633:    }
        -:  634:
    #####:  635:    if( mbedtls_rsa_validate_params( &ctx->N, &ctx->P, &ctx->Q,
        -:  636:                                     &ctx->D, &ctx->E, NULL, NULL ) != 0 )
        -:  637:    {
    #####:  638:        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
        -:  639:    }
        -:  640:
        -:  641:#if !defined(MBEDTLS_RSA_NO_CRT)
    #####:  642:    else if( mbedtls_rsa_validate_crt( &ctx->P, &ctx->Q, &ctx->D,
        -:  643:                                       &ctx->DP, &ctx->DQ, &ctx->QP ) != 0 )
        -:  644:    {
    #####:  645:        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
        -:  646:    }
        -:  647:#endif
        -:  648:
    #####:  649:    return( 0 );
        -:  650:}
        -:  651:
        -:  652:/*
        -:  653: * Check if contexts holding a public and private key match
        -:  654: */
    #####:  655:int mbedtls_rsa_check_pub_priv( const mbedtls_rsa_context *pub,
        -:  656:                                const mbedtls_rsa_context *prv )
        -:  657:{
    #####:  658:    if( mbedtls_rsa_check_pubkey( pub )  != 0 ||
    #####:  659:        mbedtls_rsa_check_privkey( prv ) != 0 )
        -:  660:    {
    #####:  661:        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
        -:  662:    }
        -:  663:
    #####:  664:    if( mbedtls_mpi_cmp_mpi( &pub->N, &prv->N ) != 0 ||
    #####:  665:        mbedtls_mpi_cmp_mpi( &pub->E, &prv->E ) != 0 )
        -:  666:    {
    #####:  667:        return( MBEDTLS_ERR_RSA_KEY_CHECK_FAILED );
        -:  668:    }
        -:  669:
    #####:  670:    return( 0 );
        -:  671:}
        -:  672:
        -:  673:/*
        -:  674: * Do an RSA public key operation
        -:  675: */
    #####:  676:int mbedtls_rsa_public( mbedtls_rsa_context *ctx,
        -:  677:                const unsigned char *input,
        -:  678:                unsigned char *output )
        -:  679:{
        -:  680:    int ret;
        -:  681:    size_t olen;
        -:  682:    mbedtls_mpi T;
        -:  683:
    #####:  684:    if( rsa_check_context( ctx, 0 /* public */, 0 /* no blinding */ ) )
    #####:  685:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -:  686:
    #####:  687:    mbedtls_mpi_init( &T );
        -:  688:
        -:  689:#if defined(MBEDTLS_THREADING_C)
        -:  690:    if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
        -:  691:        return( ret );
        -:  692:#endif
        -:  693:
    #####:  694:    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &T, input, ctx->len ) );
        -:  695:
    #####:  696:    if( mbedtls_mpi_cmp_mpi( &T, &ctx->N ) >= 0 )
        -:  697:    {
    #####:  698:        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
    #####:  699:        goto cleanup;
        -:  700:    }
        -:  701:
    #####:  702:    olen = ctx->len;
    #####:  703:    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &T, &T, &ctx->E, &ctx->N, &ctx->RN ) );
    #####:  704:    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &T, output, olen ) );
        -:  705:
    #####:  706:cleanup:
        -:  707:#if defined(MBEDTLS_THREADING_C)
        -:  708:    if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
        -:  709:        return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
        -:  710:#endif
        -:  711:
    #####:  712:    mbedtls_mpi_free( &T );
        -:  713:
    #####:  714:    if( ret != 0 )
    #####:  715:        return( MBEDTLS_ERR_RSA_PUBLIC_FAILED + ret );
        -:  716:
    #####:  717:    return( 0 );
        -:  718:}
        -:  719:
        -:  720:/*
        -:  721: * Generate or update blinding values, see section 10 of:
        -:  722: *  KOCHER, Paul C. Timing attacks on implementations of Diffie-Hellman, RSA,
        -:  723: *  DSS, and other systems. In : Advances in Cryptology-CRYPTO'96. Springer
        -:  724: *  Berlin Heidelberg, 1996. p. 104-113.
        -:  725: */
    #####:  726:static int rsa_prepare_blinding( mbedtls_rsa_context *ctx,
        -:  727:                 int (*f_rng)(void *, unsigned char *, size_t), void *p_rng )
        -:  728:{
    #####:  729:    int ret, count = 0;
        -:  730:
    #####:  731:    if( ctx->Vf.p != NULL )
        -:  732:    {
        -:  733:        /* We already have blinding values, just update them by squaring */
    #####:  734:        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ctx->Vi, &ctx->Vi, &ctx->Vi ) );
    #####:  735:        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &ctx->Vi, &ctx->Vi, &ctx->N ) );
    #####:  736:        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &ctx->Vf, &ctx->Vf, &ctx->Vf ) );
    #####:  737:        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &ctx->Vf, &ctx->Vf, &ctx->N ) );
        -:  738:
    #####:  739:        goto cleanup;
        -:  740:    }
        -:  741:
        -:  742:    /* Unblinding value: Vf = random number, invertible mod N */
        -:  743:    do {
    #####:  744:        if( count++ > 10 )
    #####:  745:            return( MBEDTLS_ERR_RSA_RNG_FAILED );
        -:  746:
    #####:  747:        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &ctx->Vf, ctx->len - 1, f_rng, p_rng ) );
    #####:  748:        MBEDTLS_MPI_CHK( mbedtls_mpi_gcd( &ctx->Vi, &ctx->Vf, &ctx->N ) );
    #####:  749:    } while( mbedtls_mpi_cmp_int( &ctx->Vi, 1 ) != 0 );
        -:  750:
        -:  751:    /* Blinding value: Vi =  Vf^(-e) mod N */
    #####:  752:    MBEDTLS_MPI_CHK( mbedtls_mpi_inv_mod( &ctx->Vi, &ctx->Vf, &ctx->N ) );
    #####:  753:    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &ctx->Vi, &ctx->Vi, &ctx->E, &ctx->N, &ctx->RN ) );
        -:  754:
        -:  755:
    #####:  756:cleanup:
    #####:  757:    return( ret );
        -:  758:}
        -:  759:
        -:  760:/*
        -:  761: * Exponent blinding supposed to prevent side-channel attacks using multiple
        -:  762: * traces of measurements to recover the RSA key. The more collisions are there,
        -:  763: * the more bits of the key can be recovered. See [3].
        -:  764: *
        -:  765: * Collecting n collisions with m bit long blinding value requires 2^(m-m/n)
        -:  766: * observations on avarage.
        -:  767: *
        -:  768: * For example with 28 byte blinding to achieve 2 collisions the adversary has
        -:  769: * to make 2^112 observations on avarage.
        -:  770: *
        -:  771: * (With the currently (as of 2017 April) known best algorithms breaking 2048
        -:  772: * bit RSA requires approximately as much time as trying out 2^112 random keys.
        -:  773: * Thus in this sense with 28 byte blinding the security is not reduced by
        -:  774: * side-channel attacks like the one in [3])
        -:  775: *
        -:  776: * This countermeasure does not help if the key recovery is possible with a
        -:  777: * single trace.
        -:  778: */
        -:  779:#define RSA_EXPONENT_BLINDING 28
        -:  780:
        -:  781:/*
        -:  782: * Do an RSA private key operation
        -:  783: */
    #####:  784:int mbedtls_rsa_private( mbedtls_rsa_context *ctx,
        -:  785:                 int (*f_rng)(void *, unsigned char *, size_t),
        -:  786:                 void *p_rng,
        -:  787:                 const unsigned char *input,
        -:  788:                 unsigned char *output )
        -:  789:{
        -:  790:    int ret;
        -:  791:    size_t olen;
        -:  792:
        -:  793:    /* Temporary holding the result */
        -:  794:    mbedtls_mpi T;
        -:  795:
        -:  796:    /* Temporaries holding P-1, Q-1 and the
        -:  797:     * exponent blinding factor, respectively. */
        -:  798:    mbedtls_mpi P1, Q1, R;
        -:  799:
        -:  800:#if !defined(MBEDTLS_RSA_NO_CRT)
        -:  801:    /* Temporaries holding the results mod p resp. mod q. */
        -:  802:    mbedtls_mpi TP, TQ;
        -:  803:
        -:  804:    /* Temporaries holding the blinded exponents for
        -:  805:     * the mod p resp. mod q computation (if used). */
        -:  806:    mbedtls_mpi DP_blind, DQ_blind;
        -:  807:
        -:  808:    /* Pointers to actual exponents to be used - either the unblinded
        -:  809:     * or the blinded ones, depending on the presence of a PRNG. */
    #####:  810:    mbedtls_mpi *DP = &ctx->DP;
    #####:  811:    mbedtls_mpi *DQ = &ctx->DQ;
        -:  812:#else
        -:  813:    /* Temporary holding the blinded exponent (if used). */
        -:  814:    mbedtls_mpi D_blind;
        -:  815:
        -:  816:    /* Pointer to actual exponent to be used - either the unblinded
        -:  817:     * or the blinded one, depending on the presence of a PRNG. */
        -:  818:    mbedtls_mpi *D = &ctx->D;
        -:  819:#endif /* MBEDTLS_RSA_NO_CRT */
        -:  820:
        -:  821:    /* Temporaries holding the initial input and the double
        -:  822:     * checked result; should be the same in the end. */
        -:  823:    mbedtls_mpi I, C;
        -:  824:
    #####:  825:    if( rsa_check_context( ctx, 1             /* private key checks */,
        -:  826:                                f_rng != NULL /* blinding y/n       */ ) != 0 )
        -:  827:    {
    #####:  828:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -:  829:    }
        -:  830:
        -:  831:#if defined(MBEDTLS_THREADING_C)
        -:  832:    if( ( ret = mbedtls_mutex_lock( &ctx->mutex ) ) != 0 )
        -:  833:        return( ret );
        -:  834:#endif
        -:  835:
        -:  836:    /* MPI Initialization */
    #####:  837:    mbedtls_mpi_init( &T );
        -:  838:
    #####:  839:    mbedtls_mpi_init( &P1 );
    #####:  840:    mbedtls_mpi_init( &Q1 );
    #####:  841:    mbedtls_mpi_init( &R );
        -:  842:
    #####:  843:    if( f_rng != NULL )
        -:  844:    {
        -:  845:#if defined(MBEDTLS_RSA_NO_CRT)
        -:  846:        mbedtls_mpi_init( &D_blind );
        -:  847:#else
    #####:  848:        mbedtls_mpi_init( &DP_blind );
    #####:  849:        mbedtls_mpi_init( &DQ_blind );
        -:  850:#endif
        -:  851:    }
        -:  852:
        -:  853:#if !defined(MBEDTLS_RSA_NO_CRT)
    #####:  854:    mbedtls_mpi_init( &TP ); mbedtls_mpi_init( &TQ );
        -:  855:#endif
        -:  856:
    #####:  857:    mbedtls_mpi_init( &I );
    #####:  858:    mbedtls_mpi_init( &C );
        -:  859:
        -:  860:    /* End of MPI initialization */
        -:  861:
    #####:  862:    MBEDTLS_MPI_CHK( mbedtls_mpi_read_binary( &T, input, ctx->len ) );
    #####:  863:    if( mbedtls_mpi_cmp_mpi( &T, &ctx->N ) >= 0 )
        -:  864:    {
    #####:  865:        ret = MBEDTLS_ERR_MPI_BAD_INPUT_DATA;
    #####:  866:        goto cleanup;
        -:  867:    }
        -:  868:
    #####:  869:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &I, &T ) );
        -:  870:
    #####:  871:    if( f_rng != NULL )
        -:  872:    {
        -:  873:        /*
        -:  874:         * Blinding
        -:  875:         * T = T * Vi mod N
        -:  876:         */
    #####:  877:        MBEDTLS_MPI_CHK( rsa_prepare_blinding( ctx, f_rng, p_rng ) );
    #####:  878:        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T, &T, &ctx->Vi ) );
    #####:  879:        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &T, &T, &ctx->N ) );
        -:  880:
        -:  881:        /*
        -:  882:         * Exponent blinding
        -:  883:         */
    #####:  884:        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &P1, &ctx->P, 1 ) );
    #####:  885:        MBEDTLS_MPI_CHK( mbedtls_mpi_sub_int( &Q1, &ctx->Q, 1 ) );
        -:  886:
        -:  887:#if defined(MBEDTLS_RSA_NO_CRT)
        -:  888:        /*
        -:  889:         * D_blind = ( P - 1 ) * ( Q - 1 ) * R + D
        -:  890:         */
        -:  891:        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &R, RSA_EXPONENT_BLINDING,
        -:  892:                         f_rng, p_rng ) );
        -:  893:        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &D_blind, &P1, &Q1 ) );
        -:  894:        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &D_blind, &D_blind, &R ) );
        -:  895:        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &D_blind, &D_blind, &ctx->D ) );
        -:  896:
        -:  897:        D = &D_blind;
        -:  898:#else
        -:  899:        /*
        -:  900:         * DP_blind = ( P - 1 ) * R + DP
        -:  901:         */
    #####:  902:        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &R, RSA_EXPONENT_BLINDING,
        -:  903:                         f_rng, p_rng ) );
    #####:  904:        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &DP_blind, &P1, &R ) );
    #####:  905:        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &DP_blind, &DP_blind,
        -:  906:                    &ctx->DP ) );
        -:  907:
    #####:  908:        DP = &DP_blind;
        -:  909:
        -:  910:        /*
        -:  911:         * DQ_blind = ( Q - 1 ) * R + DQ
        -:  912:         */
    #####:  913:        MBEDTLS_MPI_CHK( mbedtls_mpi_fill_random( &R, RSA_EXPONENT_BLINDING,
        -:  914:                         f_rng, p_rng ) );
    #####:  915:        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &DQ_blind, &Q1, &R ) );
    #####:  916:        MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &DQ_blind, &DQ_blind,
        -:  917:                    &ctx->DQ ) );
        -:  918:
    #####:  919:        DQ = &DQ_blind;
        -:  920:#endif /* MBEDTLS_RSA_NO_CRT */
        -:  921:    }
        -:  922:
        -:  923:#if defined(MBEDTLS_RSA_NO_CRT)
        -:  924:    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &T, &T, D, &ctx->N, &ctx->RN ) );
        -:  925:#else
        -:  926:    /*
        -:  927:     * Faster decryption using the CRT
        -:  928:     *
        -:  929:     * TP = input ^ dP mod P
        -:  930:     * TQ = input ^ dQ mod Q
        -:  931:     */
        -:  932:
    #####:  933:    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &TP, &T, DP, &ctx->P, &ctx->RP ) );
    #####:  934:    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &TQ, &T, DQ, &ctx->Q, &ctx->RQ ) );
        -:  935:
        -:  936:    /*
        -:  937:     * T = (TP - TQ) * (Q^-1 mod P) mod P
        -:  938:     */
    #####:  939:    MBEDTLS_MPI_CHK( mbedtls_mpi_sub_mpi( &T, &TP, &TQ ) );
    #####:  940:    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &TP, &T, &ctx->QP ) );
    #####:  941:    MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &T, &TP, &ctx->P ) );
        -:  942:
        -:  943:    /*
        -:  944:     * T = TQ + T * Q
        -:  945:     */
    #####:  946:    MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &TP, &T, &ctx->Q ) );
    #####:  947:    MBEDTLS_MPI_CHK( mbedtls_mpi_add_mpi( &T, &TQ, &TP ) );
        -:  948:#endif /* MBEDTLS_RSA_NO_CRT */
        -:  949:
    #####:  950:    if( f_rng != NULL )
        -:  951:    {
        -:  952:        /*
        -:  953:         * Unblind
        -:  954:         * T = T * Vf mod N
        -:  955:         */
    #####:  956:        MBEDTLS_MPI_CHK( mbedtls_mpi_mul_mpi( &T, &T, &ctx->Vf ) );
    #####:  957:        MBEDTLS_MPI_CHK( mbedtls_mpi_mod_mpi( &T, &T, &ctx->N ) );
        -:  958:    }
        -:  959:
        -:  960:    /* Verify the result to prevent glitching attacks. */
    #####:  961:    MBEDTLS_MPI_CHK( mbedtls_mpi_exp_mod( &C, &T, &ctx->E,
        -:  962:                                          &ctx->N, &ctx->RN ) );
    #####:  963:    if( mbedtls_mpi_cmp_mpi( &C, &I ) != 0 )
        -:  964:    {
    #####:  965:        ret = MBEDTLS_ERR_RSA_VERIFY_FAILED;
    #####:  966:        goto cleanup;
        -:  967:    }
        -:  968:
    #####:  969:    olen = ctx->len;
    #####:  970:    MBEDTLS_MPI_CHK( mbedtls_mpi_write_binary( &T, output, olen ) );
        -:  971:
    #####:  972:cleanup:
        -:  973:#if defined(MBEDTLS_THREADING_C)
        -:  974:    if( mbedtls_mutex_unlock( &ctx->mutex ) != 0 )
        -:  975:        return( MBEDTLS_ERR_THREADING_MUTEX_ERROR );
        -:  976:#endif
        -:  977:
    #####:  978:    mbedtls_mpi_free( &P1 );
    #####:  979:    mbedtls_mpi_free( &Q1 );
    #####:  980:    mbedtls_mpi_free( &R );
        -:  981:
    #####:  982:    if( f_rng != NULL )
        -:  983:    {
        -:  984:#if defined(MBEDTLS_RSA_NO_CRT)
        -:  985:        mbedtls_mpi_free( &D_blind );
        -:  986:#else
    #####:  987:        mbedtls_mpi_free( &DP_blind );
    #####:  988:        mbedtls_mpi_free( &DQ_blind );
        -:  989:#endif
        -:  990:    }
        -:  991:
    #####:  992:    mbedtls_mpi_free( &T );
        -:  993:
        -:  994:#if !defined(MBEDTLS_RSA_NO_CRT)
    #####:  995:    mbedtls_mpi_free( &TP ); mbedtls_mpi_free( &TQ );
        -:  996:#endif
        -:  997:
    #####:  998:    mbedtls_mpi_free( &C );
    #####:  999:    mbedtls_mpi_free( &I );
        -: 1000:
    #####: 1001:    if( ret != 0 )
    #####: 1002:        return( MBEDTLS_ERR_RSA_PRIVATE_FAILED + ret );
        -: 1003:
    #####: 1004:    return( 0 );
        -: 1005:}
        -: 1006:
        -: 1007:#if defined(MBEDTLS_PKCS1_V21)
        -: 1008:/**
        -: 1009: * Generate and apply the MGF1 operation (from PKCS#1 v2.1) to a buffer.
        -: 1010: *
        -: 1011: * \param dst       buffer to mask
        -: 1012: * \param dlen      length of destination buffer
        -: 1013: * \param src       source of the mask generation
        -: 1014: * \param slen      length of the source buffer
        -: 1015: * \param md_ctx    message digest context to use
        -: 1016: */
    #####: 1017:static int mgf_mask( unsigned char *dst, size_t dlen, unsigned char *src,
        -: 1018:                      size_t slen, mbedtls_md_context_t *md_ctx )
        -: 1019:{
        -: 1020:    unsigned char mask[MBEDTLS_MD_MAX_SIZE];
        -: 1021:    unsigned char counter[4];
        -: 1022:    unsigned char *p;
        -: 1023:    unsigned int hlen;
        -: 1024:    size_t i, use_len;
    #####: 1025:    int ret = 0;
        -: 1026:
    #####: 1027:    memset( mask, 0, MBEDTLS_MD_MAX_SIZE );
    #####: 1028:    memset( counter, 0, 4 );
        -: 1029:
    #####: 1030:    hlen = mbedtls_md_get_size( md_ctx->md_info );
        -: 1031:
        -: 1032:    /* Generate and apply dbMask */
    #####: 1033:    p = dst;
        -: 1034:
    #####: 1035:    while( dlen > 0 )
        -: 1036:    {
    #####: 1037:        use_len = hlen;
    #####: 1038:        if( dlen < hlen )
    #####: 1039:            use_len = dlen;
        -: 1040:
    #####: 1041:        if( ( ret = mbedtls_md_starts( md_ctx ) ) != 0 )
    #####: 1042:            goto exit;
    #####: 1043:        if( ( ret = mbedtls_md_update( md_ctx, src, slen ) ) != 0 )
    #####: 1044:            goto exit;
    #####: 1045:        if( ( ret = mbedtls_md_update( md_ctx, counter, 4 ) ) != 0 )
    #####: 1046:            goto exit;
    #####: 1047:        if( ( ret = mbedtls_md_finish( md_ctx, mask ) ) != 0 )
    #####: 1048:            goto exit;
        -: 1049:
    #####: 1050:        for( i = 0; i < use_len; ++i )
    #####: 1051:            *p++ ^= mask[i];
        -: 1052:
    #####: 1053:        counter[3]++;
        -: 1054:
    #####: 1055:        dlen -= use_len;
        -: 1056:    }
        -: 1057:
    #####: 1058:exit:
    #####: 1059:    mbedtls_platform_zeroize( mask, sizeof( mask ) );
        -: 1060:
    #####: 1061:    return( ret );
        -: 1062:}
        -: 1063:#endif /* MBEDTLS_PKCS1_V21 */
        -: 1064:
        -: 1065:#if defined(MBEDTLS_PKCS1_V21)
        -: 1066:/*
        -: 1067: * Implementation of the PKCS#1 v2.1 RSAES-OAEP-ENCRYPT function
        -: 1068: */
    #####: 1069:int mbedtls_rsa_rsaes_oaep_encrypt( mbedtls_rsa_context *ctx,
        -: 1070:                            int (*f_rng)(void *, unsigned char *, size_t),
        -: 1071:                            void *p_rng,
        -: 1072:                            int mode,
        -: 1073:                            const unsigned char *label, size_t label_len,
        -: 1074:                            size_t ilen,
        -: 1075:                            const unsigned char *input,
        -: 1076:                            unsigned char *output )
        -: 1077:{
        -: 1078:    size_t olen;
        -: 1079:    int ret;
    #####: 1080:    unsigned char *p = output;
        -: 1081:    unsigned int hlen;
        -: 1082:    const mbedtls_md_info_t *md_info;
        -: 1083:    mbedtls_md_context_t md_ctx;
        -: 1084:
    #####: 1085:    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
    #####: 1086:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1087:
    #####: 1088:    if( f_rng == NULL )
    #####: 1089:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1090:
    #####: 1091:    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
    #####: 1092:    if( md_info == NULL )
    #####: 1093:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1094:
    #####: 1095:    olen = ctx->len;
    #####: 1096:    hlen = mbedtls_md_get_size( md_info );
        -: 1097:
        -: 1098:    /* first comparison checks for overflow */
    #####: 1099:    if( ilen + 2 * hlen + 2 < ilen || olen < ilen + 2 * hlen + 2 )
    #####: 1100:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1101:
    #####: 1102:    memset( output, 0, olen );
        -: 1103:
    #####: 1104:    *p++ = 0;
        -: 1105:
        -: 1106:    /* Generate a random octet string seed */
    #####: 1107:    if( ( ret = f_rng( p_rng, p, hlen ) ) != 0 )
    #####: 1108:        return( MBEDTLS_ERR_RSA_RNG_FAILED + ret );
        -: 1109:
    #####: 1110:    p += hlen;
        -: 1111:
        -: 1112:    /* Construct DB */
    #####: 1113:    if( ( ret = mbedtls_md( md_info, label, label_len, p ) ) != 0 )
    #####: 1114:        return( ret );
    #####: 1115:    p += hlen;
    #####: 1116:    p += olen - 2 * hlen - 2 - ilen;
    #####: 1117:    *p++ = 1;
    #####: 1118:    memcpy( p, input, ilen );
        -: 1119:
    #####: 1120:    mbedtls_md_init( &md_ctx );
    #####: 1121:    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
    #####: 1122:        goto exit;
        -: 1123:
        -: 1124:    /* maskedDB: Apply dbMask to DB */
    #####: 1125:    if( ( ret = mgf_mask( output + hlen + 1, olen - hlen - 1, output + 1, hlen,
        -: 1126:                          &md_ctx ) ) != 0 )
    #####: 1127:        goto exit;
        -: 1128:
        -: 1129:    /* maskedSeed: Apply seedMask to seed */
    #####: 1130:    if( ( ret = mgf_mask( output + 1, hlen, output + hlen + 1, olen - hlen - 1,
        -: 1131:                          &md_ctx ) ) != 0 )
    #####: 1132:        goto exit;
        -: 1133:
    #####: 1134:exit:
    #####: 1135:    mbedtls_md_free( &md_ctx );
        -: 1136:
    #####: 1137:    if( ret != 0 )
    #####: 1138:        return( ret );
        -: 1139:
        -: 1140:    return( ( mode == MBEDTLS_RSA_PUBLIC )
    #####: 1141:            ? mbedtls_rsa_public(  ctx, output, output )
    #####: 1142:            : mbedtls_rsa_private( ctx, f_rng, p_rng, output, output ) );
        -: 1143:}
        -: 1144:#endif /* MBEDTLS_PKCS1_V21 */
        -: 1145:
        -: 1146:#if defined(MBEDTLS_PKCS1_V15)
        -: 1147:/*
        -: 1148: * Implementation of the PKCS#1 v2.1 RSAES-PKCS1-V1_5-ENCRYPT function
        -: 1149: */
    #####: 1150:int mbedtls_rsa_rsaes_pkcs1_v15_encrypt( mbedtls_rsa_context *ctx,
        -: 1151:                                 int (*f_rng)(void *, unsigned char *, size_t),
        -: 1152:                                 void *p_rng,
        -: 1153:                                 int mode, size_t ilen,
        -: 1154:                                 const unsigned char *input,
        -: 1155:                                 unsigned char *output )
        -: 1156:{
        -: 1157:    size_t nb_pad, olen;
        -: 1158:    int ret;
    #####: 1159:    unsigned char *p = output;
        -: 1160:
    #####: 1161:    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
    #####: 1162:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1163:
        -: 1164:    // We don't check p_rng because it won't be dereferenced here
    #####: 1165:    if( f_rng == NULL || input == NULL || output == NULL )
    #####: 1166:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1167:
    #####: 1168:    olen = ctx->len;
        -: 1169:
        -: 1170:    /* first comparison checks for overflow */
    #####: 1171:    if( ilen + 11 < ilen || olen < ilen + 11 )
    #####: 1172:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1173:
    #####: 1174:    nb_pad = olen - 3 - ilen;
        -: 1175:
    #####: 1176:    *p++ = 0;
    #####: 1177:    if( mode == MBEDTLS_RSA_PUBLIC )
        -: 1178:    {
    #####: 1179:        *p++ = MBEDTLS_RSA_CRYPT;
        -: 1180:
    #####: 1181:        while( nb_pad-- > 0 )
        -: 1182:        {
    #####: 1183:            int rng_dl = 100;
        -: 1184:
        -: 1185:            do {
    #####: 1186:                ret = f_rng( p_rng, p, 1 );
    #####: 1187:            } while( *p == 0 && --rng_dl && ret == 0 );
        -: 1188:
        -: 1189:            /* Check if RNG failed to generate data */
    #####: 1190:            if( rng_dl == 0 || ret != 0 )
    #####: 1191:                return( MBEDTLS_ERR_RSA_RNG_FAILED + ret );
        -: 1192:
    #####: 1193:            p++;
        -: 1194:        }
        -: 1195:    }
        -: 1196:    else
        -: 1197:    {
    #####: 1198:        *p++ = MBEDTLS_RSA_SIGN;
        -: 1199:
    #####: 1200:        while( nb_pad-- > 0 )
    #####: 1201:            *p++ = 0xFF;
        -: 1202:    }
        -: 1203:
    #####: 1204:    *p++ = 0;
    #####: 1205:    memcpy( p, input, ilen );
        -: 1206:
        -: 1207:    return( ( mode == MBEDTLS_RSA_PUBLIC )
    #####: 1208:            ? mbedtls_rsa_public(  ctx, output, output )
    #####: 1209:            : mbedtls_rsa_private( ctx, f_rng, p_rng, output, output ) );
        -: 1210:}
        -: 1211:#endif /* MBEDTLS_PKCS1_V15 */
        -: 1212:
        -: 1213:/*
        -: 1214: * Add the message padding, then do an RSA operation
        -: 1215: */
    #####: 1216:int mbedtls_rsa_pkcs1_encrypt( mbedtls_rsa_context *ctx,
        -: 1217:                       int (*f_rng)(void *, unsigned char *, size_t),
        -: 1218:                       void *p_rng,
        -: 1219:                       int mode, size_t ilen,
        -: 1220:                       const unsigned char *input,
        -: 1221:                       unsigned char *output )
        -: 1222:{
    #####: 1223:    switch( ctx->padding )
        -: 1224:    {
        -: 1225:#if defined(MBEDTLS_PKCS1_V15)
    #####: 1226:        case MBEDTLS_RSA_PKCS_V15:
    #####: 1227:            return mbedtls_rsa_rsaes_pkcs1_v15_encrypt( ctx, f_rng, p_rng, mode, ilen,
        -: 1228:                                                input, output );
        -: 1229:#endif
        -: 1230:
        -: 1231:#if defined(MBEDTLS_PKCS1_V21)
    #####: 1232:        case MBEDTLS_RSA_PKCS_V21:
    #####: 1233:            return mbedtls_rsa_rsaes_oaep_encrypt( ctx, f_rng, p_rng, mode, NULL, 0,
        -: 1234:                                           ilen, input, output );
        -: 1235:#endif
        -: 1236:
    #####: 1237:        default:
    #####: 1238:            return( MBEDTLS_ERR_RSA_INVALID_PADDING );
        -: 1239:    }
        -: 1240:}
        -: 1241:
        -: 1242:#if defined(MBEDTLS_PKCS1_V21)
        -: 1243:/*
        -: 1244: * Implementation of the PKCS#1 v2.1 RSAES-OAEP-DECRYPT function
        -: 1245: */
    #####: 1246:int mbedtls_rsa_rsaes_oaep_decrypt( mbedtls_rsa_context *ctx,
        -: 1247:                            int (*f_rng)(void *, unsigned char *, size_t),
        -: 1248:                            void *p_rng,
        -: 1249:                            int mode,
        -: 1250:                            const unsigned char *label, size_t label_len,
        -: 1251:                            size_t *olen,
        -: 1252:                            const unsigned char *input,
        -: 1253:                            unsigned char *output,
        -: 1254:                            size_t output_max_len )
        -: 1255:{
        -: 1256:    int ret;
        -: 1257:    size_t ilen, i, pad_len;
        -: 1258:    unsigned char *p, bad, pad_done;
        -: 1259:    unsigned char buf[MBEDTLS_MPI_MAX_SIZE];
        -: 1260:    unsigned char lhash[MBEDTLS_MD_MAX_SIZE];
        -: 1261:    unsigned int hlen;
        -: 1262:    const mbedtls_md_info_t *md_info;
        -: 1263:    mbedtls_md_context_t md_ctx;
        -: 1264:
        -: 1265:    /*
        -: 1266:     * Parameters sanity checks
        -: 1267:     */
    #####: 1268:    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
    #####: 1269:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1270:
    #####: 1271:    ilen = ctx->len;
        -: 1272:
    #####: 1273:    if( ilen < 16 || ilen > sizeof( buf ) )
    #####: 1274:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1275:
    #####: 1276:    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
    #####: 1277:    if( md_info == NULL )
    #####: 1278:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1279:
    #####: 1280:    hlen = mbedtls_md_get_size( md_info );
        -: 1281:
        -: 1282:    // checking for integer underflow
    #####: 1283:    if( 2 * hlen + 2 > ilen )
    #####: 1284:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1285:
        -: 1286:    /*
        -: 1287:     * RSA operation
        -: 1288:     */
    #####: 1289:    ret = ( mode == MBEDTLS_RSA_PUBLIC )
    #####: 1290:          ? mbedtls_rsa_public(  ctx, input, buf )
    #####: 1291:          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
        -: 1292:
    #####: 1293:    if( ret != 0 )
    #####: 1294:        goto cleanup;
        -: 1295:
        -: 1296:    /*
        -: 1297:     * Unmask data and generate lHash
        -: 1298:     */
    #####: 1299:    mbedtls_md_init( &md_ctx );
    #####: 1300:    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
        -: 1301:    {
    #####: 1302:        mbedtls_md_free( &md_ctx );
    #####: 1303:        goto cleanup;
        -: 1304:    }
        -: 1305:
        -: 1306:    /* seed: Apply seedMask to maskedSeed */
    #####: 1307:    if( ( ret = mgf_mask( buf + 1, hlen, buf + hlen + 1, ilen - hlen - 1,
    #####: 1308:                          &md_ctx ) ) != 0 ||
        -: 1309:    /* DB: Apply dbMask to maskedDB */
    #####: 1310:        ( ret = mgf_mask( buf + hlen + 1, ilen - hlen - 1, buf + 1, hlen,
        -: 1311:                          &md_ctx ) ) != 0 )
        -: 1312:    {
    #####: 1313:        mbedtls_md_free( &md_ctx );
    #####: 1314:        goto cleanup;
        -: 1315:    }
        -: 1316:
    #####: 1317:    mbedtls_md_free( &md_ctx );
        -: 1318:
        -: 1319:    /* Generate lHash */
    #####: 1320:    if( ( ret = mbedtls_md( md_info, label, label_len, lhash ) ) != 0 )
    #####: 1321:        goto cleanup;
        -: 1322:
        -: 1323:    /*
        -: 1324:     * Check contents, in "constant-time"
        -: 1325:     */
    #####: 1326:    p = buf;
    #####: 1327:    bad = 0;
        -: 1328:
    #####: 1329:    bad |= *p++; /* First byte must be 0 */
        -: 1330:
    #####: 1331:    p += hlen; /* Skip seed */
        -: 1332:
        -: 1333:    /* Check lHash */
    #####: 1334:    for( i = 0; i < hlen; i++ )
    #####: 1335:        bad |= lhash[i] ^ *p++;
        -: 1336:
        -: 1337:    /* Get zero-padding len, but always read till end of buffer
        -: 1338:     * (minus one, for the 01 byte) */
    #####: 1339:    pad_len = 0;
    #####: 1340:    pad_done = 0;
    #####: 1341:    for( i = 0; i < ilen - 2 * hlen - 2; i++ )
        -: 1342:    {
    #####: 1343:        pad_done |= p[i];
    #####: 1344:        pad_len += ((pad_done | (unsigned char)-pad_done) >> 7) ^ 1;
        -: 1345:    }
        -: 1346:
    #####: 1347:    p += pad_len;
    #####: 1348:    bad |= *p++ ^ 0x01;
        -: 1349:
        -: 1350:    /*
        -: 1351:     * The only information "leaked" is whether the padding was correct or not
        -: 1352:     * (eg, no data is copied if it was not correct). This meets the
        -: 1353:     * recommendations in PKCS#1 v2.2: an opponent cannot distinguish between
        -: 1354:     * the different error conditions.
        -: 1355:     */
    #####: 1356:    if( bad != 0 )
        -: 1357:    {
    #####: 1358:        ret = MBEDTLS_ERR_RSA_INVALID_PADDING;
    #####: 1359:        goto cleanup;
        -: 1360:    }
        -: 1361:
    #####: 1362:    if( ilen - ( p - buf ) > output_max_len )
        -: 1363:    {
    #####: 1364:        ret = MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE;
    #####: 1365:        goto cleanup;
        -: 1366:    }
        -: 1367:
    #####: 1368:    *olen = ilen - (p - buf);
    #####: 1369:    memcpy( output, p, *olen );
    #####: 1370:    ret = 0;
        -: 1371:
    #####: 1372:cleanup:
    #####: 1373:    mbedtls_platform_zeroize( buf, sizeof( buf ) );
    #####: 1374:    mbedtls_platform_zeroize( lhash, sizeof( lhash ) );
        -: 1375:
    #####: 1376:    return( ret );
        -: 1377:}
        -: 1378:#endif /* MBEDTLS_PKCS1_V21 */
        -: 1379:
        -: 1380:#if defined(MBEDTLS_PKCS1_V15)
        -: 1381:/*
        -: 1382: * Implementation of the PKCS#1 v2.1 RSAES-PKCS1-V1_5-DECRYPT function
        -: 1383: */
    #####: 1384:int mbedtls_rsa_rsaes_pkcs1_v15_decrypt( mbedtls_rsa_context *ctx,
        -: 1385:                                 int (*f_rng)(void *, unsigned char *, size_t),
        -: 1386:                                 void *p_rng,
        -: 1387:                                 int mode, size_t *olen,
        -: 1388:                                 const unsigned char *input,
        -: 1389:                                 unsigned char *output,
        -: 1390:                                 size_t output_max_len)
        -: 1391:{
        -: 1392:    int ret;
    #####: 1393:    size_t ilen, pad_count = 0, i;
    #####: 1394:    unsigned char *p, bad, pad_done = 0;
        -: 1395:    unsigned char buf[MBEDTLS_MPI_MAX_SIZE];
        -: 1396:
    #####: 1397:    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
    #####: 1398:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1399:
    #####: 1400:    ilen = ctx->len;
        -: 1401:
    #####: 1402:    if( ilen < 16 || ilen > sizeof( buf ) )
    #####: 1403:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1404:
    #####: 1405:    ret = ( mode == MBEDTLS_RSA_PUBLIC )
    #####: 1406:          ? mbedtls_rsa_public(  ctx, input, buf )
    #####: 1407:          : mbedtls_rsa_private( ctx, f_rng, p_rng, input, buf );
        -: 1408:
    #####: 1409:    if( ret != 0 )
    #####: 1410:        goto cleanup;
        -: 1411:
    #####: 1412:    p = buf;
    #####: 1413:    bad = 0;
        -: 1414:
        -: 1415:    /*
        -: 1416:     * Check and get padding len in "constant-time"
        -: 1417:     */
    #####: 1418:    bad |= *p++; /* First byte must be 0 */
        -: 1419:
        -: 1420:    /* This test does not depend on secret data */
    #####: 1421:    if( mode == MBEDTLS_RSA_PRIVATE )
        -: 1422:    {
    #####: 1423:        bad |= *p++ ^ MBEDTLS_RSA_CRYPT;
        -: 1424:
        -: 1425:        /* Get padding len, but always read till end of buffer
        -: 1426:         * (minus one, for the 00 byte) */
    #####: 1427:        for( i = 0; i < ilen - 3; i++ )
        -: 1428:        {
    #####: 1429:            pad_done  |= ((p[i] | (unsigned char)-p[i]) >> 7) ^ 1;
    #####: 1430:            pad_count += ((pad_done | (unsigned char)-pad_done) >> 7) ^ 1;
        -: 1431:        }
        -: 1432:
    #####: 1433:        p += pad_count;
    #####: 1434:        bad |= *p++; /* Must be zero */
        -: 1435:    }
        -: 1436:    else
        -: 1437:    {
    #####: 1438:        bad |= *p++ ^ MBEDTLS_RSA_SIGN;
        -: 1439:
        -: 1440:        /* Get padding len, but always read till end of buffer
        -: 1441:         * (minus one, for the 00 byte) */
    #####: 1442:        for( i = 0; i < ilen - 3; i++ )
        -: 1443:        {
    #####: 1444:            pad_done |= ( p[i] != 0xFF );
    #####: 1445:            pad_count += ( pad_done == 0 );
        -: 1446:        }
        -: 1447:
    #####: 1448:        p += pad_count;
    #####: 1449:        bad |= *p++; /* Must be zero */
        -: 1450:    }
        -: 1451:
    #####: 1452:    bad |= ( pad_count < 8 );
        -: 1453:
    #####: 1454:    if( bad )
        -: 1455:    {
    #####: 1456:        ret = MBEDTLS_ERR_RSA_INVALID_PADDING;
    #####: 1457:        goto cleanup;
        -: 1458:    }
        -: 1459:
    #####: 1460:    if( ilen - ( p - buf ) > output_max_len )
        -: 1461:    {
    #####: 1462:        ret = MBEDTLS_ERR_RSA_OUTPUT_TOO_LARGE;
    #####: 1463:        goto cleanup;
        -: 1464:    }
        -: 1465:
    #####: 1466:    *olen = ilen - (p - buf);
    #####: 1467:    memcpy( output, p, *olen );
    #####: 1468:    ret = 0;
        -: 1469:
    #####: 1470:cleanup:
    #####: 1471:    mbedtls_platform_zeroize( buf, sizeof( buf ) );
        -: 1472:
    #####: 1473:    return( ret );
        -: 1474:}
        -: 1475:#endif /* MBEDTLS_PKCS1_V15 */
        -: 1476:
        -: 1477:/*
        -: 1478: * Do an RSA operation, then remove the message padding
        -: 1479: */
    #####: 1480:int mbedtls_rsa_pkcs1_decrypt( mbedtls_rsa_context *ctx,
        -: 1481:                       int (*f_rng)(void *, unsigned char *, size_t),
        -: 1482:                       void *p_rng,
        -: 1483:                       int mode, size_t *olen,
        -: 1484:                       const unsigned char *input,
        -: 1485:                       unsigned char *output,
        -: 1486:                       size_t output_max_len)
        -: 1487:{
    #####: 1488:    switch( ctx->padding )
        -: 1489:    {
        -: 1490:#if defined(MBEDTLS_PKCS1_V15)
    #####: 1491:        case MBEDTLS_RSA_PKCS_V15:
    #####: 1492:            return mbedtls_rsa_rsaes_pkcs1_v15_decrypt( ctx, f_rng, p_rng, mode, olen,
        -: 1493:                                                input, output, output_max_len );
        -: 1494:#endif
        -: 1495:
        -: 1496:#if defined(MBEDTLS_PKCS1_V21)
    #####: 1497:        case MBEDTLS_RSA_PKCS_V21:
    #####: 1498:            return mbedtls_rsa_rsaes_oaep_decrypt( ctx, f_rng, p_rng, mode, NULL, 0,
        -: 1499:                                           olen, input, output,
        -: 1500:                                           output_max_len );
        -: 1501:#endif
        -: 1502:
    #####: 1503:        default:
    #####: 1504:            return( MBEDTLS_ERR_RSA_INVALID_PADDING );
        -: 1505:    }
        -: 1506:}
        -: 1507:
        -: 1508:#if defined(MBEDTLS_PKCS1_V21)
        -: 1509:/*
        -: 1510: * Implementation of the PKCS#1 v2.1 RSASSA-PSS-SIGN function
        -: 1511: */
    #####: 1512:int mbedtls_rsa_rsassa_pss_sign( mbedtls_rsa_context *ctx,
        -: 1513:                         int (*f_rng)(void *, unsigned char *, size_t),
        -: 1514:                         void *p_rng,
        -: 1515:                         int mode,
        -: 1516:                         mbedtls_md_type_t md_alg,
        -: 1517:                         unsigned int hashlen,
        -: 1518:                         const unsigned char *hash,
        -: 1519:                         unsigned char *sig )
        -: 1520:{
        -: 1521:    size_t olen;
    #####: 1522:    unsigned char *p = sig;
        -: 1523:    unsigned char salt[MBEDTLS_MD_MAX_SIZE];
    #####: 1524:    unsigned int slen, hlen, offset = 0;
        -: 1525:    int ret;
        -: 1526:    size_t msb;
        -: 1527:    const mbedtls_md_info_t *md_info;
        -: 1528:    mbedtls_md_context_t md_ctx;
        -: 1529:
    #####: 1530:    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
    #####: 1531:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1532:
    #####: 1533:    if( f_rng == NULL )
    #####: 1534:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1535:
    #####: 1536:    olen = ctx->len;
        -: 1537:
    #####: 1538:    if( md_alg != MBEDTLS_MD_NONE )
        -: 1539:    {
        -: 1540:        /* Gather length of hash to sign */
    #####: 1541:        md_info = mbedtls_md_info_from_type( md_alg );
    #####: 1542:        if( md_info == NULL )
    #####: 1543:            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1544:
    #####: 1545:        hashlen = mbedtls_md_get_size( md_info );
        -: 1546:    }
        -: 1547:
    #####: 1548:    md_info = mbedtls_md_info_from_type( (mbedtls_md_type_t) ctx->hash_id );
    #####: 1549:    if( md_info == NULL )
    #####: 1550:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1551:
    #####: 1552:    hlen = mbedtls_md_get_size( md_info );
    #####: 1553:    slen = hlen;
        -: 1554:
    #####: 1555:    if( olen < hlen + slen + 2 )
    #####: 1556:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1557:
    #####: 1558:    memset( sig, 0, olen );
        -: 1559:
        -: 1560:    /* Generate salt of length slen */
    #####: 1561:    if( ( ret = f_rng( p_rng, salt, slen ) ) != 0 )
    #####: 1562:        return( MBEDTLS_ERR_RSA_RNG_FAILED + ret );
        -: 1563:
        -: 1564:    /* Note: EMSA-PSS encoding is over the length of N - 1 bits */
    #####: 1565:    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
    #####: 1566:    p += olen - hlen * 2 - 2;
    #####: 1567:    *p++ = 0x01;
    #####: 1568:    memcpy( p, salt, slen );
    #####: 1569:    p += slen;
        -: 1570:
    #####: 1571:    mbedtls_md_init( &md_ctx );
    #####: 1572:    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
    #####: 1573:        goto exit;
        -: 1574:
        -: 1575:    /* Generate H = Hash( M' ) */
    #####: 1576:    if( ( ret = mbedtls_md_starts( &md_ctx ) ) != 0 )
    #####: 1577:        goto exit;
    #####: 1578:    if( ( ret = mbedtls_md_update( &md_ctx, p, 8 ) ) != 0 )
    #####: 1579:        goto exit;
    #####: 1580:    if( ( ret = mbedtls_md_update( &md_ctx, hash, hashlen ) ) != 0 )
    #####: 1581:        goto exit;
    #####: 1582:    if( ( ret = mbedtls_md_update( &md_ctx, salt, slen ) ) != 0 )
    #####: 1583:        goto exit;
    #####: 1584:    if( ( ret = mbedtls_md_finish( &md_ctx, p ) ) != 0 )
    #####: 1585:        goto exit;
        -: 1586:
        -: 1587:    /* Compensate for boundary condition when applying mask */
    #####: 1588:    if( msb % 8 == 0 )
    #####: 1589:        offset = 1;
        -: 1590:
        -: 1591:    /* maskedDB: Apply dbMask to DB */
    #####: 1592:    if( ( ret = mgf_mask( sig + offset, olen - hlen - 1 - offset, p, hlen,
        -: 1593:                          &md_ctx ) ) != 0 )
    #####: 1594:        goto exit;
        -: 1595:
    #####: 1596:    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
    #####: 1597:    sig[0] &= 0xFF >> ( olen * 8 - msb );
        -: 1598:
    #####: 1599:    p += hlen;
    #####: 1600:    *p++ = 0xBC;
        -: 1601:
    #####: 1602:    mbedtls_platform_zeroize( salt, sizeof( salt ) );
        -: 1603:
    #####: 1604:exit:
    #####: 1605:    mbedtls_md_free( &md_ctx );
        -: 1606:
    #####: 1607:    if( ret != 0 )
    #####: 1608:        return( ret );
        -: 1609:
        -: 1610:    return( ( mode == MBEDTLS_RSA_PUBLIC )
    #####: 1611:            ? mbedtls_rsa_public(  ctx, sig, sig )
    #####: 1612:            : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, sig ) );
        -: 1613:}
        -: 1614:#endif /* MBEDTLS_PKCS1_V21 */
        -: 1615:
        -: 1616:#if defined(MBEDTLS_PKCS1_V15)
        -: 1617:/*
        -: 1618: * Implementation of the PKCS#1 v2.1 RSASSA-PKCS1-V1_5-SIGN function
        -: 1619: */
        -: 1620:
        -: 1621:/* Construct a PKCS v1.5 encoding of a hashed message
        -: 1622: *
        -: 1623: * This is used both for signature generation and verification.
        -: 1624: *
        -: 1625: * Parameters:
        -: 1626: * - md_alg:  Identifies the hash algorithm used to generate the given hash;
        -: 1627: *            MBEDTLS_MD_NONE if raw data is signed.
        -: 1628: * - hashlen: Length of hash in case hashlen is MBEDTLS_MD_NONE.
        -: 1629: * - hash:    Buffer containing the hashed message or the raw data.
        -: 1630: * - dst_len: Length of the encoded message.
        -: 1631: * - dst:     Buffer to hold the encoded message.
        -: 1632: *
        -: 1633: * Assumptions:
        -: 1634: * - hash has size hashlen if md_alg == MBEDTLS_MD_NONE.
        -: 1635: * - hash has size corresponding to md_alg if md_alg != MBEDTLS_MD_NONE.
        -: 1636: * - dst points to a buffer of size at least dst_len.
        -: 1637: *
        -: 1638: */
    #####: 1639:static int rsa_rsassa_pkcs1_v15_encode( mbedtls_md_type_t md_alg,
        -: 1640:                                        unsigned int hashlen,
        -: 1641:                                        const unsigned char *hash,
        -: 1642:                                        size_t dst_len,
        -: 1643:                                        unsigned char *dst )
        -: 1644:{
    #####: 1645:    size_t oid_size  = 0;
    #####: 1646:    size_t nb_pad    = dst_len;
    #####: 1647:    unsigned char *p = dst;
    #####: 1648:    const char *oid  = NULL;
        -: 1649:
        -: 1650:    /* Are we signing hashed or raw data? */
    #####: 1651:    if( md_alg != MBEDTLS_MD_NONE )
        -: 1652:    {
    #####: 1653:        const mbedtls_md_info_t *md_info = mbedtls_md_info_from_type( md_alg );
    #####: 1654:        if( md_info == NULL )
    #####: 1655:            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1656:
    #####: 1657:        if( mbedtls_oid_get_oid_by_md( md_alg, &oid, &oid_size ) != 0 )
    #####: 1658:            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1659:
    #####: 1660:        hashlen = mbedtls_md_get_size( md_info );
        -: 1661:
        -: 1662:        /* Double-check that 8 + hashlen + oid_size can be used as a
        -: 1663:         * 1-byte ASN.1 length encoding and that there's no overflow. */
    #####: 1664:        if( 8 + hashlen + oid_size  >= 0x80         ||
    #####: 1665:            10 + hashlen            <  hashlen      ||
    #####: 1666:            10 + hashlen + oid_size <  10 + hashlen )
    #####: 1667:            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1668:
        -: 1669:        /*
        -: 1670:         * Static bounds check:
        -: 1671:         * - Need 10 bytes for five tag-length pairs.
        -: 1672:         *   (Insist on 1-byte length encodings to protect against variants of
        -: 1673:         *    Bleichenbacher's forgery attack against lax PKCS#1v1.5 verification)
        -: 1674:         * - Need hashlen bytes for hash
        -: 1675:         * - Need oid_size bytes for hash alg OID.
        -: 1676:         */
    #####: 1677:        if( nb_pad < 10 + hashlen + oid_size )
    #####: 1678:            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
    #####: 1679:        nb_pad -= 10 + hashlen + oid_size;
        -: 1680:    }
        -: 1681:    else
        -: 1682:    {
    #####: 1683:        if( nb_pad < hashlen )
    #####: 1684:            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1685:
    #####: 1686:        nb_pad -= hashlen;
        -: 1687:    }
        -: 1688:
        -: 1689:    /* Need space for signature header and padding delimiter (3 bytes),
        -: 1690:     * and 8 bytes for the minimal padding */
    #####: 1691:    if( nb_pad < 3 + 8 )
    #####: 1692:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
    #####: 1693:    nb_pad -= 3;
        -: 1694:
        -: 1695:    /* Now nb_pad is the amount of memory to be filled
        -: 1696:     * with padding, and at least 8 bytes long. */
        -: 1697:
        -: 1698:    /* Write signature header and padding */
    #####: 1699:    *p++ = 0;
    #####: 1700:    *p++ = MBEDTLS_RSA_SIGN;
    #####: 1701:    memset( p, 0xFF, nb_pad );
    #####: 1702:    p += nb_pad;
    #####: 1703:    *p++ = 0;
        -: 1704:
        -: 1705:    /* Are we signing raw data? */
    #####: 1706:    if( md_alg == MBEDTLS_MD_NONE )
        -: 1707:    {
    #####: 1708:        memcpy( p, hash, hashlen );
    #####: 1709:        return( 0 );
        -: 1710:    }
        -: 1711:
        -: 1712:    /* Signing hashed data, add corresponding ASN.1 structure
        -: 1713:     *
        -: 1714:     * DigestInfo ::= SEQUENCE {
        -: 1715:     *   digestAlgorithm DigestAlgorithmIdentifier,
        -: 1716:     *   digest Digest }
        -: 1717:     * DigestAlgorithmIdentifier ::= AlgorithmIdentifier
        -: 1718:     * Digest ::= OCTET STRING
        -: 1719:     *
        -: 1720:     * Schematic:
        -: 1721:     * TAG-SEQ + LEN [ TAG-SEQ + LEN [ TAG-OID  + LEN [ OID  ]
        -: 1722:     *                                 TAG-NULL + LEN [ NULL ] ]
        -: 1723:     *                 TAG-OCTET + LEN [ HASH ] ]
        -: 1724:     */
    #####: 1725:    *p++ = MBEDTLS_ASN1_SEQUENCE | MBEDTLS_ASN1_CONSTRUCTED;
    #####: 1726:    *p++ = (unsigned char)( 0x08 + oid_size + hashlen );
    #####: 1727:    *p++ = MBEDTLS_ASN1_SEQUENCE | MBEDTLS_ASN1_CONSTRUCTED;
    #####: 1728:    *p++ = (unsigned char)( 0x04 + oid_size );
    #####: 1729:    *p++ = MBEDTLS_ASN1_OID;
    #####: 1730:    *p++ = (unsigned char) oid_size;
    #####: 1731:    memcpy( p, oid, oid_size );
    #####: 1732:    p += oid_size;
    #####: 1733:    *p++ = MBEDTLS_ASN1_NULL;
    #####: 1734:    *p++ = 0x00;
    #####: 1735:    *p++ = MBEDTLS_ASN1_OCTET_STRING;
    #####: 1736:    *p++ = (unsigned char) hashlen;
    #####: 1737:    memcpy( p, hash, hashlen );
    #####: 1738:    p += hashlen;
        -: 1739:
        -: 1740:    /* Just a sanity-check, should be automatic
        -: 1741:     * after the initial bounds check. */
    #####: 1742:    if( p != dst + dst_len )
        -: 1743:    {
    #####: 1744:        mbedtls_platform_zeroize( dst, dst_len );
    #####: 1745:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1746:    }
        -: 1747:
    #####: 1748:    return( 0 );
        -: 1749:}
        -: 1750:
        -: 1751:/*
        -: 1752: * Do an RSA operation to sign the message digest
        -: 1753: */
    #####: 1754:int mbedtls_rsa_rsassa_pkcs1_v15_sign( mbedtls_rsa_context *ctx,
        -: 1755:                               int (*f_rng)(void *, unsigned char *, size_t),
        -: 1756:                               void *p_rng,
        -: 1757:                               int mode,
        -: 1758:                               mbedtls_md_type_t md_alg,
        -: 1759:                               unsigned int hashlen,
        -: 1760:                               const unsigned char *hash,
        -: 1761:                               unsigned char *sig )
        -: 1762:{
        -: 1763:    int ret;
    #####: 1764:    unsigned char *sig_try = NULL, *verif = NULL;
        -: 1765:
    #####: 1766:    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
    #####: 1767:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1768:
        -: 1769:    /*
        -: 1770:     * Prepare PKCS1-v1.5 encoding (padding and hash identifier)
        -: 1771:     */
        -: 1772:
    #####: 1773:    if( ( ret = rsa_rsassa_pkcs1_v15_encode( md_alg, hashlen, hash,
        -: 1774:                                             ctx->len, sig ) ) != 0 )
    #####: 1775:        return( ret );
        -: 1776:
        -: 1777:    /*
        -: 1778:     * Call respective RSA primitive
        -: 1779:     */
        -: 1780:
    #####: 1781:    if( mode == MBEDTLS_RSA_PUBLIC )
        -: 1782:    {
        -: 1783:        /* Skip verification on a public key operation */
    #####: 1784:        return( mbedtls_rsa_public( ctx, sig, sig ) );
        -: 1785:    }
        -: 1786:
        -: 1787:    /* Private key operation
        -: 1788:     *
        -: 1789:     * In order to prevent Lenstra's attack, make the signature in a
        -: 1790:     * temporary buffer and check it before returning it.
        -: 1791:     */
        -: 1792:
    #####: 1793:    sig_try = mbedtls_calloc( 1, ctx->len );
    #####: 1794:    if( sig_try == NULL )
    #####: 1795:        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
        -: 1796:
    #####: 1797:    verif = mbedtls_calloc( 1, ctx->len );
    #####: 1798:    if( verif == NULL )
        -: 1799:    {
    #####: 1800:        mbedtls_free( sig_try );
    #####: 1801:        return( MBEDTLS_ERR_MPI_ALLOC_FAILED );
        -: 1802:    }
        -: 1803:
    #####: 1804:    MBEDTLS_MPI_CHK( mbedtls_rsa_private( ctx, f_rng, p_rng, sig, sig_try ) );
    #####: 1805:    MBEDTLS_MPI_CHK( mbedtls_rsa_public( ctx, sig_try, verif ) );
        -: 1806:
    #####: 1807:    if( mbedtls_safer_memcmp( verif, sig, ctx->len ) != 0 )
        -: 1808:    {
    #####: 1809:        ret = MBEDTLS_ERR_RSA_PRIVATE_FAILED;
    #####: 1810:        goto cleanup;
        -: 1811:    }
        -: 1812:
    #####: 1813:    memcpy( sig, sig_try, ctx->len );
        -: 1814:
    #####: 1815:cleanup:
    #####: 1816:    mbedtls_free( sig_try );
    #####: 1817:    mbedtls_free( verif );
        -: 1818:
    #####: 1819:    return( ret );
        -: 1820:}
        -: 1821:#endif /* MBEDTLS_PKCS1_V15 */
        -: 1822:
        -: 1823:/*
        -: 1824: * Do an RSA operation to sign the message digest
        -: 1825: */
    #####: 1826:int mbedtls_rsa_pkcs1_sign( mbedtls_rsa_context *ctx,
        -: 1827:                    int (*f_rng)(void *, unsigned char *, size_t),
        -: 1828:                    void *p_rng,
        -: 1829:                    int mode,
        -: 1830:                    mbedtls_md_type_t md_alg,
        -: 1831:                    unsigned int hashlen,
        -: 1832:                    const unsigned char *hash,
        -: 1833:                    unsigned char *sig )
        -: 1834:{
    #####: 1835:    switch( ctx->padding )
        -: 1836:    {
        -: 1837:#if defined(MBEDTLS_PKCS1_V15)
    #####: 1838:        case MBEDTLS_RSA_PKCS_V15:
    #####: 1839:            return mbedtls_rsa_rsassa_pkcs1_v15_sign( ctx, f_rng, p_rng, mode, md_alg,
        -: 1840:                                              hashlen, hash, sig );
        -: 1841:#endif
        -: 1842:
        -: 1843:#if defined(MBEDTLS_PKCS1_V21)
    #####: 1844:        case MBEDTLS_RSA_PKCS_V21:
    #####: 1845:            return mbedtls_rsa_rsassa_pss_sign( ctx, f_rng, p_rng, mode, md_alg,
        -: 1846:                                        hashlen, hash, sig );
        -: 1847:#endif
        -: 1848:
    #####: 1849:        default:
    #####: 1850:            return( MBEDTLS_ERR_RSA_INVALID_PADDING );
        -: 1851:    }
        -: 1852:}
        -: 1853:
        -: 1854:#if defined(MBEDTLS_PKCS1_V21)
        -: 1855:/*
        -: 1856: * Implementation of the PKCS#1 v2.1 RSASSA-PSS-VERIFY function
        -: 1857: */
    #####: 1858:int mbedtls_rsa_rsassa_pss_verify_ext( mbedtls_rsa_context *ctx,
        -: 1859:                               int (*f_rng)(void *, unsigned char *, size_t),
        -: 1860:                               void *p_rng,
        -: 1861:                               int mode,
        -: 1862:                               mbedtls_md_type_t md_alg,
        -: 1863:                               unsigned int hashlen,
        -: 1864:                               const unsigned char *hash,
        -: 1865:                               mbedtls_md_type_t mgf1_hash_id,
        -: 1866:                               int expected_salt_len,
        -: 1867:                               const unsigned char *sig )
        -: 1868:{
        -: 1869:    int ret;
        -: 1870:    size_t siglen;
        -: 1871:    unsigned char *p;
        -: 1872:    unsigned char *hash_start;
        -: 1873:    unsigned char result[MBEDTLS_MD_MAX_SIZE];
        -: 1874:    unsigned char zeros[8];
        -: 1875:    unsigned int hlen;
        -: 1876:    size_t observed_salt_len, msb;
        -: 1877:    const mbedtls_md_info_t *md_info;
        -: 1878:    mbedtls_md_context_t md_ctx;
        -: 1879:    unsigned char buf[MBEDTLS_MPI_MAX_SIZE];
        -: 1880:
    #####: 1881:    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V21 )
    #####: 1882:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1883:
    #####: 1884:    siglen = ctx->len;
        -: 1885:
    #####: 1886:    if( siglen < 16 || siglen > sizeof( buf ) )
    #####: 1887:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1888:
    #####: 1889:    ret = ( mode == MBEDTLS_RSA_PUBLIC )
    #####: 1890:          ? mbedtls_rsa_public(  ctx, sig, buf )
    #####: 1891:          : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, buf );
        -: 1892:
    #####: 1893:    if( ret != 0 )
    #####: 1894:        return( ret );
        -: 1895:
    #####: 1896:    p = buf;
        -: 1897:
    #####: 1898:    if( buf[siglen - 1] != 0xBC )
    #####: 1899:        return( MBEDTLS_ERR_RSA_INVALID_PADDING );
        -: 1900:
    #####: 1901:    if( md_alg != MBEDTLS_MD_NONE )
        -: 1902:    {
        -: 1903:        /* Gather length of hash to sign */
    #####: 1904:        md_info = mbedtls_md_info_from_type( md_alg );
    #####: 1905:        if( md_info == NULL )
    #####: 1906:            return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1907:
    #####: 1908:        hashlen = mbedtls_md_get_size( md_info );
        -: 1909:    }
        -: 1910:
    #####: 1911:    md_info = mbedtls_md_info_from_type( mgf1_hash_id );
    #####: 1912:    if( md_info == NULL )
    #####: 1913:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1914:
    #####: 1915:    hlen = mbedtls_md_get_size( md_info );
        -: 1916:
    #####: 1917:    memset( zeros, 0, 8 );
        -: 1918:
        -: 1919:    /*
        -: 1920:     * Note: EMSA-PSS verification is over the length of N - 1 bits
        -: 1921:     */
    #####: 1922:    msb = mbedtls_mpi_bitlen( &ctx->N ) - 1;
        -: 1923:
    #####: 1924:    if( buf[0] >> ( 8 - siglen * 8 + msb ) )
    #####: 1925:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 1926:
        -: 1927:    /* Compensate for boundary condition when applying mask */
    #####: 1928:    if( msb % 8 == 0 )
        -: 1929:    {
    #####: 1930:        p++;
    #####: 1931:        siglen -= 1;
        -: 1932:    }
        -: 1933:
    #####: 1934:    if( siglen < hlen + 2 )
    #####: 1935:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
    #####: 1936:    hash_start = p + siglen - hlen - 1;
        -: 1937:
    #####: 1938:    mbedtls_md_init( &md_ctx );
    #####: 1939:    if( ( ret = mbedtls_md_setup( &md_ctx, md_info, 0 ) ) != 0 )
    #####: 1940:        goto exit;
        -: 1941:
    #####: 1942:    ret = mgf_mask( p, siglen - hlen - 1, hash_start, hlen, &md_ctx );
    #####: 1943:    if( ret != 0 )
    #####: 1944:        goto exit;
        -: 1945:
    #####: 1946:    buf[0] &= 0xFF >> ( siglen * 8 - msb );
        -: 1947:
    #####: 1948:    while( p < hash_start - 1 && *p == 0 )
    #####: 1949:        p++;
        -: 1950:
    #####: 1951:    if( *p++ != 0x01 )
        -: 1952:    {
    #####: 1953:        ret = MBEDTLS_ERR_RSA_INVALID_PADDING;
    #####: 1954:        goto exit;
        -: 1955:    }
        -: 1956:
    #####: 1957:    observed_salt_len = hash_start - p;
        -: 1958:
    #####: 1959:    if( expected_salt_len != MBEDTLS_RSA_SALT_LEN_ANY &&
    #####: 1960:        observed_salt_len != (size_t) expected_salt_len )
        -: 1961:    {
    #####: 1962:        ret = MBEDTLS_ERR_RSA_INVALID_PADDING;
    #####: 1963:        goto exit;
        -: 1964:    }
        -: 1965:
        -: 1966:    /*
        -: 1967:     * Generate H = Hash( M' )
        -: 1968:     */
    #####: 1969:    ret = mbedtls_md_starts( &md_ctx );
    #####: 1970:    if ( ret != 0 )
    #####: 1971:        goto exit;
    #####: 1972:    ret = mbedtls_md_update( &md_ctx, zeros, 8 );
    #####: 1973:    if ( ret != 0 )
    #####: 1974:        goto exit;
    #####: 1975:    ret = mbedtls_md_update( &md_ctx, hash, hashlen );
    #####: 1976:    if ( ret != 0 )
    #####: 1977:        goto exit;
    #####: 1978:    ret = mbedtls_md_update( &md_ctx, p, observed_salt_len );
    #####: 1979:    if ( ret != 0 )
    #####: 1980:        goto exit;
    #####: 1981:    ret = mbedtls_md_finish( &md_ctx, result );
    #####: 1982:    if ( ret != 0 )
    #####: 1983:        goto exit;
        -: 1984:
    #####: 1985:    if( memcmp( hash_start, result, hlen ) != 0 )
        -: 1986:    {
    #####: 1987:        ret = MBEDTLS_ERR_RSA_VERIFY_FAILED;
    #####: 1988:        goto exit;
        -: 1989:    }
        -: 1990:
    #####: 1991:exit:
    #####: 1992:    mbedtls_md_free( &md_ctx );
        -: 1993:
    #####: 1994:    return( ret );
        -: 1995:}
        -: 1996:
        -: 1997:/*
        -: 1998: * Simplified PKCS#1 v2.1 RSASSA-PSS-VERIFY function
        -: 1999: */
    #####: 2000:int mbedtls_rsa_rsassa_pss_verify( mbedtls_rsa_context *ctx,
        -: 2001:                           int (*f_rng)(void *, unsigned char *, size_t),
        -: 2002:                           void *p_rng,
        -: 2003:                           int mode,
        -: 2004:                           mbedtls_md_type_t md_alg,
        -: 2005:                           unsigned int hashlen,
        -: 2006:                           const unsigned char *hash,
        -: 2007:                           const unsigned char *sig )
        -: 2008:{
    #####: 2009:    mbedtls_md_type_t mgf1_hash_id = ( ctx->hash_id != MBEDTLS_MD_NONE )
    #####: 2010:                             ? (mbedtls_md_type_t) ctx->hash_id
    #####: 2011:                             : md_alg;
        -: 2012:
    #####: 2013:    return( mbedtls_rsa_rsassa_pss_verify_ext( ctx, f_rng, p_rng, mode,
        -: 2014:                                       md_alg, hashlen, hash,
        -: 2015:                                       mgf1_hash_id, MBEDTLS_RSA_SALT_LEN_ANY,
        -: 2016:                                       sig ) );
        -: 2017:
        -: 2018:}
        -: 2019:#endif /* MBEDTLS_PKCS1_V21 */
        -: 2020:
        -: 2021:#if defined(MBEDTLS_PKCS1_V15)
        -: 2022:/*
        -: 2023: * Implementation of the PKCS#1 v2.1 RSASSA-PKCS1-v1_5-VERIFY function
        -: 2024: */
    #####: 2025:int mbedtls_rsa_rsassa_pkcs1_v15_verify( mbedtls_rsa_context *ctx,
        -: 2026:                                 int (*f_rng)(void *, unsigned char *, size_t),
        -: 2027:                                 void *p_rng,
        -: 2028:                                 int mode,
        -: 2029:                                 mbedtls_md_type_t md_alg,
        -: 2030:                                 unsigned int hashlen,
        -: 2031:                                 const unsigned char *hash,
        -: 2032:                                 const unsigned char *sig )
        -: 2033:{
    #####: 2034:    int ret = 0;
    #####: 2035:    const size_t sig_len = ctx->len;
    #####: 2036:    unsigned char *encoded = NULL, *encoded_expected = NULL;
        -: 2037:
    #####: 2038:    if( mode == MBEDTLS_RSA_PRIVATE && ctx->padding != MBEDTLS_RSA_PKCS_V15 )
    #####: 2039:        return( MBEDTLS_ERR_RSA_BAD_INPUT_DATA );
        -: 2040:
        -: 2041:    /*
        -: 2042:     * Prepare expected PKCS1 v1.5 encoding of hash.
        -: 2043:     */
        -: 2044:
    #####: 2045:    if( ( encoded          = mbedtls_calloc( 1, sig_len ) ) == NULL ||
    #####: 2046:        ( encoded_expected = mbedtls_calloc( 1, sig_len ) ) == NULL )
        -: 2047:    {
    #####: 2048:        ret = MBEDTLS_ERR_MPI_ALLOC_FAILED;
    #####: 2049:        goto cleanup;
        -: 2050:    }
        -: 2051:
    #####: 2052:    if( ( ret = rsa_rsassa_pkcs1_v15_encode( md_alg, hashlen, hash, sig_len,
        -: 2053:                                             encoded_expected ) ) != 0 )
    #####: 2054:        goto cleanup;
        -: 2055:
        -: 2056:    /*
        -: 2057:     * Apply RSA primitive to get what should be PKCS1 encoded hash.
        -: 2058:     */
        -: 2059:
    #####: 2060:    ret = ( mode == MBEDTLS_RSA_PUBLIC )
    #####: 2061:          ? mbedtls_rsa_public(  ctx, sig, encoded )
    #####: 2062:          : mbedtls_rsa_private( ctx, f_rng, p_rng, sig, encoded );
    #####: 2063:    if( ret != 0 )
    #####: 2064:        goto cleanup;
        -: 2065:
        -: 2066:    /*
        -: 2067:     * Compare
        -: 2068:     */
        -: 2069:
    #####: 2070:    if( ( ret = mbedtls_safer_memcmp( encoded, encoded_expected,
        -: 2071:                                      sig_len ) ) != 0 )
        -: 2072:    {
    #####: 2073:        ret = MBEDTLS_ERR_RSA_VERIFY_FAILED;
    #####: 2074:        goto cleanup;
        -: 2075:    }
        -: 2076:
    #####: 2077:cleanup:
        -: 2078:
    #####: 2079:    if( encoded != NULL )
        -: 2080:    {
    #####: 2081:        mbedtls_platform_zeroize( encoded, sig_len );
    #####: 2082:        mbedtls_free( encoded );
        -: 2083:    }
        -: 2084:
    #####: 2085:    if( encoded_expected != NULL )
        -: 2086:    {
    #####: 2087:        mbedtls_platform_zeroize( encoded_expected, sig_len );
    #####: 2088:        mbedtls_free( encoded_expected );
        -: 2089:    }
        -: 2090:
    #####: 2091:    return( ret );
        -: 2092:}
        -: 2093:#endif /* MBEDTLS_PKCS1_V15 */
        -: 2094:
        -: 2095:/*
        -: 2096: * Do an RSA operation and check the message digest
        -: 2097: */
    #####: 2098:int mbedtls_rsa_pkcs1_verify( mbedtls_rsa_context *ctx,
        -: 2099:                      int (*f_rng)(void *, unsigned char *, size_t),
        -: 2100:                      void *p_rng,
        -: 2101:                      int mode,
        -: 2102:                      mbedtls_md_type_t md_alg,
        -: 2103:                      unsigned int hashlen,
        -: 2104:                      const unsigned char *hash,
        -: 2105:                      const unsigned char *sig )
        -: 2106:{
    #####: 2107:    switch( ctx->padding )
        -: 2108:    {
        -: 2109:#if defined(MBEDTLS_PKCS1_V15)
    #####: 2110:        case MBEDTLS_RSA_PKCS_V15:
    #####: 2111:            return mbedtls_rsa_rsassa_pkcs1_v15_verify( ctx, f_rng, p_rng, mode, md_alg,
        -: 2112:                                                hashlen, hash, sig );
        -: 2113:#endif
        -: 2114:
        -: 2115:#if defined(MBEDTLS_PKCS1_V21)
    #####: 2116:        case MBEDTLS_RSA_PKCS_V21:
    #####: 2117:            return mbedtls_rsa_rsassa_pss_verify( ctx, f_rng, p_rng, mode, md_alg,
        -: 2118:                                          hashlen, hash, sig );
        -: 2119:#endif
        -: 2120:
    #####: 2121:        default:
    #####: 2122:            return( MBEDTLS_ERR_RSA_INVALID_PADDING );
        -: 2123:    }
        -: 2124:}
        -: 2125:
        -: 2126:/*
        -: 2127: * Copy the components of an RSA key
        -: 2128: */
    #####: 2129:int mbedtls_rsa_copy( mbedtls_rsa_context *dst, const mbedtls_rsa_context *src )
        -: 2130:{
        -: 2131:    int ret;
        -: 2132:
    #####: 2133:    dst->ver = src->ver;
    #####: 2134:    dst->len = src->len;
        -: 2135:
    #####: 2136:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->N, &src->N ) );
    #####: 2137:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->E, &src->E ) );
        -: 2138:
    #####: 2139:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->D, &src->D ) );
    #####: 2140:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->P, &src->P ) );
    #####: 2141:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->Q, &src->Q ) );
        -: 2142:
        -: 2143:#if !defined(MBEDTLS_RSA_NO_CRT)
    #####: 2144:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->DP, &src->DP ) );
    #####: 2145:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->DQ, &src->DQ ) );
    #####: 2146:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->QP, &src->QP ) );
    #####: 2147:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->RP, &src->RP ) );
    #####: 2148:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->RQ, &src->RQ ) );
        -: 2149:#endif
        -: 2150:
    #####: 2151:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->RN, &src->RN ) );
        -: 2152:
    #####: 2153:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->Vi, &src->Vi ) );
    #####: 2154:    MBEDTLS_MPI_CHK( mbedtls_mpi_copy( &dst->Vf, &src->Vf ) );
        -: 2155:
    #####: 2156:    dst->padding = src->padding;
    #####: 2157:    dst->hash_id = src->hash_id;
        -: 2158:
    #####: 2159:cleanup:
    #####: 2160:    if( ret != 0 )
    #####: 2161:        mbedtls_rsa_free( dst );
        -: 2162:
    #####: 2163:    return( ret );
        -: 2164:}
        -: 2165:
        -: 2166:/*
        -: 2167: * Free the components of an RSA key
        -: 2168: */
    #####: 2169:void mbedtls_rsa_free( mbedtls_rsa_context *ctx )
        -: 2170:{
    #####: 2171:    mbedtls_mpi_free( &ctx->Vi ); mbedtls_mpi_free( &ctx->Vf );
    #####: 2172:    mbedtls_mpi_free( &ctx->RN ); mbedtls_mpi_free( &ctx->D  );
    #####: 2173:    mbedtls_mpi_free( &ctx->Q  ); mbedtls_mpi_free( &ctx->P  );
    #####: 2174:    mbedtls_mpi_free( &ctx->E  ); mbedtls_mpi_free( &ctx->N  );
        -: 2175:
        -: 2176:#if !defined(MBEDTLS_RSA_NO_CRT)
    #####: 2177:    mbedtls_mpi_free( &ctx->RQ ); mbedtls_mpi_free( &ctx->RP );
    #####: 2178:    mbedtls_mpi_free( &ctx->QP ); mbedtls_mpi_free( &ctx->DQ );
    #####: 2179:    mbedtls_mpi_free( &ctx->DP );
        -: 2180:#endif /* MBEDTLS_RSA_NO_CRT */
        -: 2181:
        -: 2182:#if defined(MBEDTLS_THREADING_C)
        -: 2183:    mbedtls_mutex_free( &ctx->mutex );
        -: 2184:#endif
    #####: 2185:}
        -: 2186:
        -: 2187:#endif /* !MBEDTLS_RSA_ALT */
        -: 2188:
        -: 2189:#if defined(MBEDTLS_SELF_TEST)
        -: 2190:
        -: 2191:#include "mbedtls/sha1.h"
        -: 2192:
        -: 2193:/*
        -: 2194: * Example RSA-1024 keypair, for test purposes
        -: 2195: */
        -: 2196:#define KEY_LEN 128
        -: 2197:
        -: 2198:#define RSA_N   "9292758453063D803DD603D5E777D788" \
        -: 2199:                "8ED1D5BF35786190FA2F23EBC0848AEA" \
        -: 2200:                "DDA92CA6C3D80B32C4D109BE0F36D6AE" \
        -: 2201:                "7130B9CED7ACDF54CFC7555AC14EEBAB" \
        -: 2202:                "93A89813FBF3C4F8066D2D800F7C38A8" \
        -: 2203:                "1AE31942917403FF4946B0A83D3D3E05" \
        -: 2204:                "EE57C6F5F5606FB5D4BC6CD34EE0801A" \
        -: 2205:                "5E94BB77B07507233A0BC7BAC8F90F79"
        -: 2206:
        -: 2207:#define RSA_E   "10001"
        -: 2208:
        -: 2209:#define RSA_D   "24BF6185468786FDD303083D25E64EFC" \
        -: 2210:                "66CA472BC44D253102F8B4A9D3BFA750" \
        -: 2211:                "91386C0077937FE33FA3252D28855837" \
        -: 2212:                "AE1B484A8A9A45F7EE8C0C634F99E8CD" \
        -: 2213:                "DF79C5CE07EE72C7F123142198164234" \
        -: 2214:                "CABB724CF78B8173B9F880FC86322407" \
        -: 2215:                "AF1FEDFDDE2BEB674CA15F3E81A1521E" \
        -: 2216:                "071513A1E85B5DFA031F21ECAE91A34D"
        -: 2217:
        -: 2218:#define RSA_P   "C36D0EB7FCD285223CFB5AABA5BDA3D8" \
        -: 2219:                "2C01CAD19EA484A87EA4377637E75500" \
        -: 2220:                "FCB2005C5C7DD6EC4AC023CDA285D796" \
        -: 2221:                "C3D9E75E1EFC42488BB4F1D13AC30A57"
        -: 2222:
        -: 2223:#define RSA_Q   "C000DF51A7C77AE8D7C7370C1FF55B69" \
        -: 2224:                "E211C2B9E5DB1ED0BF61D0D9899620F4" \
        -: 2225:                "910E4168387E3C30AA1E00C339A79508" \
        -: 2226:                "8452DD96A9A5EA5D9DCA68DA636032AF"
        -: 2227:
        -: 2228:#define PT_LEN  24
        -: 2229:#define RSA_PT  "\xAA\xBB\xCC\x03\x02\x01\x00\xFF\xFF\xFF\xFF\xFF" \
        -: 2230:                "\x11\x22\x33\x0A\x0B\x0C\xCC\xDD\xDD\xDD\xDD\xDD"
        -: 2231:
        -: 2232:#if defined(MBEDTLS_PKCS1_V15)
        -: 2233:static int myrand( void *rng_state, unsigned char *output, size_t len )
        -: 2234:{
        -: 2235:#if !defined(__OpenBSD__)
        -: 2236:    size_t i;
        -: 2237:
        -: 2238:    if( rng_state != NULL )
        -: 2239:        rng_state  = NULL;
        -: 2240:
        -: 2241:    for( i = 0; i < len; ++i )
        -: 2242:        output[i] = rand();
        -: 2243:#else
        -: 2244:    if( rng_state != NULL )
        -: 2245:        rng_state = NULL;
        -: 2246:
        -: 2247:    arc4random_buf( output, len );
        -: 2248:#endif /* !OpenBSD */
        -: 2249:
        -: 2250:    return( 0 );
        -: 2251:}
        -: 2252:#endif /* MBEDTLS_PKCS1_V15 */
        -: 2253:
        -: 2254:/*
        -: 2255: * Checkup routine
        -: 2256: */
        -: 2257:int mbedtls_rsa_self_test( int verbose )
        -: 2258:{
        -: 2259:    int ret = 0;
        -: 2260:#if defined(MBEDTLS_PKCS1_V15)
        -: 2261:    size_t len;
        -: 2262:    mbedtls_rsa_context rsa;
        -: 2263:    unsigned char rsa_plaintext[PT_LEN];
        -: 2264:    unsigned char rsa_decrypted[PT_LEN];
        -: 2265:    unsigned char rsa_ciphertext[KEY_LEN];
        -: 2266:#if defined(MBEDTLS_SHA1_C)
        -: 2267:    unsigned char sha1sum[20];
        -: 2268:#endif
        -: 2269:
        -: 2270:    mbedtls_mpi K;
        -: 2271:
        -: 2272:    mbedtls_mpi_init( &K );
        -: 2273:    mbedtls_rsa_init( &rsa, MBEDTLS_RSA_PKCS_V15, 0 );
        -: 2274:
        -: 2275:    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &K, 16, RSA_N  ) );
        -: 2276:    MBEDTLS_MPI_CHK( mbedtls_rsa_import( &rsa, &K, NULL, NULL, NULL, NULL ) );
        -: 2277:    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &K, 16, RSA_P  ) );
        -: 2278:    MBEDTLS_MPI_CHK( mbedtls_rsa_import( &rsa, NULL, &K, NULL, NULL, NULL ) );
        -: 2279:    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &K, 16, RSA_Q  ) );
        -: 2280:    MBEDTLS_MPI_CHK( mbedtls_rsa_import( &rsa, NULL, NULL, &K, NULL, NULL ) );
        -: 2281:    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &K, 16, RSA_D  ) );
        -: 2282:    MBEDTLS_MPI_CHK( mbedtls_rsa_import( &rsa, NULL, NULL, NULL, &K, NULL ) );
        -: 2283:    MBEDTLS_MPI_CHK( mbedtls_mpi_read_string( &K, 16, RSA_E  ) );
        -: 2284:    MBEDTLS_MPI_CHK( mbedtls_rsa_import( &rsa, NULL, NULL, NULL, NULL, &K ) );
        -: 2285:
        -: 2286:    MBEDTLS_MPI_CHK( mbedtls_rsa_complete( &rsa ) );
        -: 2287:
        -: 2288:    if( verbose != 0 )
        -: 2289:        mbedtls_printf( "  RSA key validation: " );
        -: 2290:
        -: 2291:    if( mbedtls_rsa_check_pubkey(  &rsa ) != 0 ||
        -: 2292:        mbedtls_rsa_check_privkey( &rsa ) != 0 )
        -: 2293:    {
        -: 2294:        if( verbose != 0 )
        -: 2295:            mbedtls_printf( "failed\n" );
        -: 2296:
        -: 2297:        ret = 1;
        -: 2298:        goto cleanup;
        -: 2299:    }
        -: 2300:
        -: 2301:    if( verbose != 0 )
        -: 2302:        mbedtls_printf( "passed\n  PKCS#1 encryption : " );
        -: 2303:
        -: 2304:    memcpy( rsa_plaintext, RSA_PT, PT_LEN );
        -: 2305:
        -: 2306:    if( mbedtls_rsa_pkcs1_encrypt( &rsa, myrand, NULL, MBEDTLS_RSA_PUBLIC,
        -: 2307:                                   PT_LEN, rsa_plaintext,
        -: 2308:                                   rsa_ciphertext ) != 0 )
        -: 2309:    {
        -: 2310:        if( verbose != 0 )
        -: 2311:            mbedtls_printf( "failed\n" );
        -: 2312:
        -: 2313:        ret = 1;
        -: 2314:        goto cleanup;
        -: 2315:    }
        -: 2316:
        -: 2317:    if( verbose != 0 )
        -: 2318:        mbedtls_printf( "passed\n  PKCS#1 decryption : " );
        -: 2319:
        -: 2320:    if( mbedtls_rsa_pkcs1_decrypt( &rsa, myrand, NULL, MBEDTLS_RSA_PRIVATE,
        -: 2321:                                   &len, rsa_ciphertext, rsa_decrypted,
        -: 2322:                                   sizeof(rsa_decrypted) ) != 0 )
        -: 2323:    {
        -: 2324:        if( verbose != 0 )
        -: 2325:            mbedtls_printf( "failed\n" );
        -: 2326:
        -: 2327:        ret = 1;
        -: 2328:        goto cleanup;
        -: 2329:    }
        -: 2330:
        -: 2331:    if( memcmp( rsa_decrypted, rsa_plaintext, len ) != 0 )
        -: 2332:    {
        -: 2333:        if( verbose != 0 )
        -: 2334:            mbedtls_printf( "failed\n" );
        -: 2335:
        -: 2336:        ret = 1;
        -: 2337:        goto cleanup;
        -: 2338:    }
        -: 2339:
        -: 2340:    if( verbose != 0 )
        -: 2341:        mbedtls_printf( "passed\n" );
        -: 2342:
        -: 2343:#if defined(MBEDTLS_SHA1_C)
        -: 2344:    if( verbose != 0 )
        -: 2345:        mbedtls_printf( "  PKCS#1 data sign  : " );
        -: 2346:
        -: 2347:    if( mbedtls_sha1_ret( rsa_plaintext, PT_LEN, sha1sum ) != 0 )
        -: 2348:    {
        -: 2349:        if( verbose != 0 )
        -: 2350:            mbedtls_printf( "failed\n" );
        -: 2351:
        -: 2352:        return( 1 );
        -: 2353:    }
        -: 2354:
        -: 2355:    if( mbedtls_rsa_pkcs1_sign( &rsa, myrand, NULL,
        -: 2356:                                MBEDTLS_RSA_PRIVATE, MBEDTLS_MD_SHA1, 0,
        -: 2357:                                sha1sum, rsa_ciphertext ) != 0 )
        -: 2358:    {
        -: 2359:        if( verbose != 0 )
        -: 2360:            mbedtls_printf( "failed\n" );
        -: 2361:
        -: 2362:        ret = 1;
        -: 2363:        goto cleanup;
        -: 2364:    }
        -: 2365:
        -: 2366:    if( verbose != 0 )
        -: 2367:        mbedtls_printf( "passed\n  PKCS#1 sig. verify: " );
        -: 2368:
        -: 2369:    if( mbedtls_rsa_pkcs1_verify( &rsa, NULL, NULL,
        -: 2370:                                  MBEDTLS_RSA_PUBLIC, MBEDTLS_MD_SHA1, 0,
        -: 2371:                                  sha1sum, rsa_ciphertext ) != 0 )
        -: 2372:    {
        -: 2373:        if( verbose != 0 )
        -: 2374:            mbedtls_printf( "failed\n" );
        -: 2375:
        -: 2376:        ret = 1;
        -: 2377:        goto cleanup;
        -: 2378:    }
        -: 2379:
        -: 2380:    if( verbose != 0 )
        -: 2381:        mbedtls_printf( "passed\n" );
        -: 2382:#endif /* MBEDTLS_SHA1_C */
        -: 2383:
        -: 2384:    if( verbose != 0 )
        -: 2385:        mbedtls_printf( "\n" );
        -: 2386:
        -: 2387:cleanup:
        -: 2388:    mbedtls_mpi_free( &K );
        -: 2389:    mbedtls_rsa_free( &rsa );
        -: 2390:#else /* MBEDTLS_PKCS1_V15 */
        -: 2391:    ((void) verbose);
        -: 2392:#endif /* MBEDTLS_PKCS1_V15 */
        -: 2393:    return( ret );
        -: 2394:}
        -: 2395:
        -: 2396:#endif /* MBEDTLS_SELF_TEST */
        -: 2397:
        -: 2398:#endif /* MBEDTLS_RSA_C */
