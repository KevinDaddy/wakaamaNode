        -:    0:Source:/home/david/Programming/wakaamaNode/src/wakaama/data.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/home/david/Programming/wakaamaNode/src/wakaama/data.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*******************************************************************************
        -:    2:*
        -:    3:* Copyright (c) 2013, 2014 Intel Corporation and others.
        -:    4:* All rights reserved. This program and the accompanying materials
        -:    5:* are made available under the terms of the Eclipse Public License v1.0
        -:    6:* and Eclipse Distribution License v1.0 which accompany this distribution.
        -:    7:*
        -:    8:* The Eclipse Public License is available at
        -:    9:*    http://www.eclipse.org/legal/epl-v10.html
        -:   10:* The Eclipse Distribution License is available at
        -:   11:*    http://www.eclipse.org/org/documents/edl-v10.php.
        -:   12:*
        -:   13:* Contributors:
        -:   14:*    David Navarro, Intel Corporation - initial API and implementation
        -:   15:*    Fabien Fleutot - Please refer to git log
        -:   16:*    Bosch Software Innovations GmbH - Please refer to git log
        -:   17:*
        -:   18:*******************************************************************************/
        -:   19:
        -:   20:#include "internals.h"
        -:   21:#include <float.h>
        -:   22:
        -:   23:#define LOG_DATA(...) {}
        -:   24:#define LOG_DATA_ARG(...) {}
        -:   25:
        -:   26:#define _PRV_STR_LENGTH 32
        -:   27:
        -:   28:// dataP array length is assumed to be 1.
    #####:   29:static int prv_textSerialize(lwm2m_data_t * dataP,
        -:   30:                             uint8_t ** bufferP)
        -:   31:{
        -:   32:    size_t res;
        -:   33:
    #####:   34:    switch (dataP->type)
        -:   35:    {
    #####:   36:    case LWM2M_TYPE_STRING:
    #####:   37:        *bufferP = (uint8_t *)lwm2m_malloc(dataP->value.asBuffer.length);
    #####:   38:        if (*bufferP == NULL) return 0;
    #####:   39:        memcpy(*bufferP, dataP->value.asBuffer.buffer, dataP->value.asBuffer.length);
    #####:   40:        return (int)dataP->value.asBuffer.length;
        -:   41:
    #####:   42:    case LWM2M_TYPE_INTEGER:
        -:   43:    {
        -:   44:        uint8_t intString[_PRV_STR_LENGTH];
        -:   45:
    #####:   46:        res = utils_intToText(dataP->value.asInteger, intString, _PRV_STR_LENGTH);
    #####:   47:        if (res == 0) return -1;
        -:   48:
    #####:   49:        *bufferP = (uint8_t *)lwm2m_malloc(res);
    #####:   50:        if (NULL == *bufferP) return -1;
        -:   51:
    #####:   52:        memcpy(*bufferP, intString, res);
        -:   53:
    #####:   54:        return (int)res;
        -:   55:    }
        -:   56:
    #####:   57:    case LWM2M_TYPE_FLOAT:
        -:   58:    {
        -:   59:        uint8_t floatString[_PRV_STR_LENGTH * 2];
        -:   60:
    #####:   61:        res = utils_floatToText(dataP->value.asFloat, floatString, _PRV_STR_LENGTH * 2);
    #####:   62:        if (res == 0) return -1;
        -:   63:
    #####:   64:        *bufferP = (uint8_t *)lwm2m_malloc(res);
    #####:   65:        if (NULL == *bufferP) return -1;
        -:   66:
    #####:   67:        memcpy(*bufferP, floatString, res);
        -:   68:
    #####:   69:        return (int)res;
        -:   70:    }
        -:   71:
    #####:   72:    case LWM2M_TYPE_BOOLEAN:
    #####:   73:        *bufferP = (uint8_t *)lwm2m_malloc(1);
    #####:   74:        if (NULL == *bufferP) return -1;
        -:   75:
    #####:   76:        *bufferP[0] = dataP->value.asBoolean ? '1' : '0';
        -:   77:
    #####:   78:        return 1;
        -:   79:
    #####:   80:    case LWM2M_TYPE_OBJECT_LINK:
        -:   81:    {
        -:   82:        char stringBuffer[11];
        -:   83:        size_t length;
        -:   84:        
    #####:   85:        length = utils_intToText(dataP->value.asObjLink.objectId, (uint8_t*)stringBuffer, 5);
    #####:   86:        if (length == 0) return -1;
        -:   87:
    #####:   88:        stringBuffer[5] = ':';
    #####:   89:        res = length + 1;
        -:   90:
    #####:   91:        length = utils_intToText(dataP->value.asObjLink.objectInstanceId, (uint8_t*)stringBuffer + res, 5);
    #####:   92:        if (length == 0) return -1;
        -:   93:
    #####:   94:        res += length;
        -:   95:
    #####:   96:        *bufferP = (uint8_t *)lwm2m_malloc(res);
    #####:   97:        if (*bufferP == NULL) return -1;
        -:   98:
    #####:   99:        memcpy(*bufferP, stringBuffer, res);
        -:  100:
    #####:  101:        return res;
        -:  102:    }
        -:  103:
    #####:  104:    case LWM2M_TYPE_OPAQUE:
        -:  105:    {
        -:  106:        size_t length;
        -:  107:
    #####:  108:        length = utils_base64GetSize(dataP->value.asBuffer.length);
    #####:  109:        *bufferP = (uint8_t *)lwm2m_malloc(length);
    #####:  110:        if (*bufferP == NULL) return 0;
    #####:  111:        length = utils_base64Encode(dataP->value.asBuffer.buffer, dataP->value.asBuffer.length, *bufferP, length);
    #####:  112:        if (length == 0)
        -:  113:        {
    #####:  114:            lwm2m_free(*bufferP);
    #####:  115:            *bufferP = NULL;
    #####:  116:            return 0;
        -:  117:        }
    #####:  118:        return (int)length;
        -:  119:    }
        -:  120:
    #####:  121:    case LWM2M_TYPE_UNDEFINED:
        -:  122:    default:
    #####:  123:        return -1;
        -:  124:    }
        -:  125:}
        -:  126:
    #####:  127:static int prv_setBuffer(lwm2m_data_t * dataP,
        -:  128:                         uint8_t * buffer,
        -:  129:                         size_t bufferLen)
        -:  130:{
    #####:  131:    dataP->value.asBuffer.buffer = (uint8_t *)lwm2m_malloc(bufferLen);
    #####:  132:    if (dataP->value.asBuffer.buffer == NULL)
        -:  133:    {
    #####:  134:        return 0;
        -:  135:    }
    #####:  136:    dataP->value.asBuffer.length = bufferLen;
    #####:  137:    memcpy(dataP->value.asBuffer.buffer, buffer, bufferLen);
        -:  138:
    #####:  139:    return 1;
        -:  140:}
        -:  141:
    #####:  142:lwm2m_data_t * lwm2m_data_new(int size)
        -:  143:{
        -:  144:    lwm2m_data_t * dataP;
        -:  145:
        -:  146:    LOG_DATA_ARG("size: %d", size);
    #####:  147:    if (size <= 0) return NULL;
        -:  148:
    #####:  149:    dataP = (lwm2m_data_t *)lwm2m_malloc(size * sizeof(lwm2m_data_t));
        -:  150:
    #####:  151:    if (dataP != NULL)
        -:  152:    {
    #####:  153:        memset(dataP, 0, size * sizeof(lwm2m_data_t));
        -:  154:    }
        -:  155:
    #####:  156:    return dataP;
        -:  157:}
        -:  158:
    #####:  159:void lwm2m_data_free(int size,
        -:  160:                     lwm2m_data_t * dataP)
        -:  161:{
        -:  162:    int i;
        -:  163:
        -:  164:    LOG_DATA_ARG("size: %d", size);
    #####:  165:    if (size == 0 || dataP == NULL) return;
        -:  166:
    #####:  167:    for (i = 0; i < size; i++)
        -:  168:    {
    #####:  169:        switch (dataP[i].type)
        -:  170:        {
    #####:  171:        case LWM2M_TYPE_MULTIPLE_RESOURCE:
        -:  172:        case LWM2M_TYPE_OBJECT_INSTANCE:
        -:  173:        case LWM2M_TYPE_OBJECT:
    #####:  174:            lwm2m_data_free(dataP[i].value.asChildren.count, dataP[i].value.asChildren.array);
    #####:  175:            break;
        -:  176:
    #####:  177:        case LWM2M_TYPE_STRING:
        -:  178:        case LWM2M_TYPE_OPAQUE:
    #####:  179:            if (dataP[i].value.asBuffer.buffer != NULL)
        -:  180:            {
    #####:  181:                lwm2m_free(dataP[i].value.asBuffer.buffer);
        -:  182:            }
        -:  183:
        -:  184:        default:
        -:  185:            // do nothing
    #####:  186:            break;
        -:  187:        }
        -:  188:    }
    #####:  189:    lwm2m_free(dataP);
        -:  190:}
        -:  191:
    #####:  192:void lwm2m_data_encode_string(const char * string,
        -:  193:                              lwm2m_data_t * dataP)
        -:  194:{
        -:  195:    size_t len;
        -:  196:    int res;
        -:  197:
        -:  198:    LOG_DATA_ARG("\"%s\"", string);
    #####:  199:    if (string == NULL)
        -:  200:    {
    #####:  201:        len = 0;
        -:  202:    }
        -:  203:    else
        -:  204:    {
    #####:  205:        for (len = 0; string[len] != 0; len++);
        -:  206:    }
        -:  207:
    #####:  208:    if (len == 0)
        -:  209:    {
    #####:  210:        dataP->value.asBuffer.length = 0;
    #####:  211:        dataP->value.asBuffer.buffer = NULL;
    #####:  212:        res = 1;
        -:  213:    }
        -:  214:    else
        -:  215:    {
    #####:  216:        res = prv_setBuffer(dataP, (uint8_t *)string, len);
        -:  217:    }
        -:  218:
    #####:  219:    if (res == 1)
        -:  220:    {
    #####:  221:        dataP->type = LWM2M_TYPE_STRING;
        -:  222:    }
        -:  223:    else
        -:  224:    {
    #####:  225:        dataP->type = LWM2M_TYPE_UNDEFINED;
        -:  226:    }
    #####:  227:}
        -:  228:
    #####:  229:void lwm2m_data_encode_opaque(uint8_t * buffer,
        -:  230:                              size_t length,
        -:  231:                              lwm2m_data_t * dataP)
        -:  232:{
        -:  233:    int res;
        -:  234:
        -:  235:    LOG_DATA_ARG("length: %d", length);
    #####:  236:    if (length == 0)
        -:  237:    {
    #####:  238:        dataP->value.asBuffer.length = 0;
    #####:  239:        dataP->value.asBuffer.buffer = NULL;
    #####:  240:        res = 1;
        -:  241:    }
        -:  242:    else
        -:  243:    {
    #####:  244:        res = prv_setBuffer(dataP, buffer, length);
        -:  245:    }
        -:  246:
    #####:  247:    if (res == 1)
        -:  248:    {
    #####:  249:        dataP->type = LWM2M_TYPE_OPAQUE;
        -:  250:    }
        -:  251:    else
        -:  252:    {
    #####:  253:        dataP->type = LWM2M_TYPE_UNDEFINED;
        -:  254:    }
    #####:  255:}
        -:  256:
    #####:  257:void lwm2m_data_encode_nstring(const char * string,
        -:  258:                               size_t length,
        -:  259:                               lwm2m_data_t * dataP)
        -:  260:{
        -:  261:    LOG_DATA_ARG("length: %d, string: \"%s\"", length, string);
    #####:  262:    lwm2m_data_encode_opaque((uint8_t *)string, length, dataP);
        -:  263:
    #####:  264:    if (dataP->type == LWM2M_TYPE_OPAQUE)
        -:  265:    {
    #####:  266:        dataP->type = LWM2M_TYPE_STRING;
        -:  267:    }
    #####:  268:}
        -:  269:
    #####:  270:void lwm2m_data_encode_int(int64_t value,
        -:  271:                           lwm2m_data_t * dataP)
        -:  272:{
        -:  273:    LOG_DATA_ARG("value: %" PRId64 "", value);
    #####:  274:    dataP->type = LWM2M_TYPE_INTEGER;
    #####:  275:    dataP->value.asInteger = value;
    #####:  276:}
        -:  277:
    #####:  278:int lwm2m_data_decode_int(const lwm2m_data_t * dataP,
        -:  279:                          int64_t * valueP)
        -:  280:{
        -:  281:    int result;
        -:  282:
        -:  283:    LOG_DATA("Entering");
    #####:  284:    switch (dataP->type)
        -:  285:    {
    #####:  286:    case LWM2M_TYPE_INTEGER:
    #####:  287:        *valueP = dataP->value.asInteger;
    #####:  288:        result = 1;
    #####:  289:        break;
        -:  290:
    #####:  291:    case LWM2M_TYPE_STRING:
    #####:  292:        result = utils_textToInt(dataP->value.asBuffer.buffer, dataP->value.asBuffer.length, valueP);
    #####:  293:        break;
        -:  294:
    #####:  295:    case LWM2M_TYPE_OPAQUE:
    #####:  296:        switch (dataP->value.asBuffer.length)
        -:  297:        {
    #####:  298:        case 1:
    #####:  299:            *valueP = (int8_t)dataP->value.asBuffer.buffer[0];
    #####:  300:            result = 1;
    #####:  301:            break;
        -:  302:
    #####:  303:        case 2:
        -:  304:        {
        -:  305:            int16_t value;
        -:  306:
    #####:  307:            utils_copyValue(&value, dataP->value.asBuffer.buffer, dataP->value.asBuffer.length);
        -:  308:
    #####:  309:            *valueP = value;
    #####:  310:            result = 1;
    #####:  311:            break;
        -:  312:        }
        -:  313:
    #####:  314:        case 4:
        -:  315:        {
        -:  316:            int32_t value;
        -:  317:
    #####:  318:            utils_copyValue(&value, dataP->value.asBuffer.buffer, dataP->value.asBuffer.length);
        -:  319:
    #####:  320:            *valueP = value;
    #####:  321:            result = 1;
    #####:  322:            break;
        -:  323:        }
        -:  324:
    #####:  325:        case 8:
    #####:  326:            utils_copyValue(valueP, dataP->value.asBuffer.buffer, dataP->value.asBuffer.length);
    #####:  327:            result = 1;
    #####:  328:            break;
        -:  329:
    #####:  330:        default:
    #####:  331:            result = 0;
        -:  332:        }
    #####:  333:        break;
        -:  334:
    #####:  335:    default:
    #####:  336:        return 0;
        -:  337:    }
        -:  338:    LOG_DATA_ARG("result: %d, value: %" PRId64, result, *valueP);
        -:  339:
    #####:  340:    return result;
        -:  341:}
        -:  342:
    #####:  343:void lwm2m_data_encode_float(double value,
        -:  344:                             lwm2m_data_t * dataP)
        -:  345:{
        -:  346:    LOG_DATA_ARG("value: %f", value);
    #####:  347:    dataP->type = LWM2M_TYPE_FLOAT;
    #####:  348:    dataP->value.asFloat = value;
    #####:  349:}
        -:  350:
    #####:  351:int lwm2m_data_decode_float(const lwm2m_data_t * dataP,
        -:  352:                            double * valueP)
        -:  353:{
        -:  354:    int result;
        -:  355:
        -:  356:    LOG_DATA("Entering");
    #####:  357:    switch (dataP->type)
        -:  358:    {
    #####:  359:    case LWM2M_TYPE_FLOAT:
    #####:  360:        *valueP = dataP->value.asFloat;
    #####:  361:        result = 1;
    #####:  362:        break;
        -:  363:
    #####:  364:    case LWM2M_TYPE_INTEGER:
    #####:  365:        *valueP = (double)dataP->value.asInteger;
    #####:  366:        result = 1;
    #####:  367:        break;
        -:  368:
    #####:  369:    case LWM2M_TYPE_STRING:
    #####:  370:        result = utils_textToFloat(dataP->value.asBuffer.buffer, dataP->value.asBuffer.length, valueP);
    #####:  371:        break;
        -:  372:
    #####:  373:    case LWM2M_TYPE_OPAQUE:
    #####:  374:        switch (dataP->value.asBuffer.length)
        -:  375:        {
    #####:  376:        case 4:
        -:  377:        {
        -:  378:            float temp;
        -:  379:
    #####:  380:            utils_copyValue(&temp, dataP->value.asBuffer.buffer, dataP->value.asBuffer.length);
        -:  381:
    #####:  382:            *valueP = temp;
    #####:  383:            result = 1;
        -:  384:        }
    #####:  385:        break;
        -:  386:
    #####:  387:        case 8:
    #####:  388:            utils_copyValue(valueP, dataP->value.asBuffer.buffer, dataP->value.asBuffer.length);
    #####:  389:            result = 1;
    #####:  390:            break;
        -:  391:
    #####:  392:        default:
    #####:  393:            result = 0;
        -:  394:        }
    #####:  395:        break;
        -:  396:
    #####:  397:    default:
    #####:  398:        result = 0;
        -:  399:    }
        -:  400:
        -:  401:    LOG_DATA_ARG("result: %d, value: %f", result, *valueP);
        -:  402:
    #####:  403:    return result;
        -:  404:}
        -:  405:
    #####:  406:void lwm2m_data_encode_bool(bool value,
        -:  407:                            lwm2m_data_t * dataP)
        -:  408:{
        -:  409:    LOG_DATA_ARG("value: %s", value?"true":"false");
    #####:  410:    dataP->type = LWM2M_TYPE_BOOLEAN;
    #####:  411:    dataP->value.asBoolean = value;
    #####:  412:}
        -:  413:
    #####:  414:int lwm2m_data_decode_bool(const lwm2m_data_t * dataP,
        -:  415:                           bool * valueP)
        -:  416:{
        -:  417:    int result;
        -:  418:
        -:  419:    LOG_DATA("Entering");
    #####:  420:    switch (dataP->type)
        -:  421:    {
    #####:  422:    case LWM2M_TYPE_BOOLEAN:
    #####:  423:        *valueP = dataP->value.asBoolean;
    #####:  424:        result = 1;
    #####:  425:        break;
        -:  426:
    #####:  427:    case LWM2M_TYPE_STRING:
    #####:  428:        if (dataP->value.asBuffer.length != 1) return 0;
        -:  429:
    #####:  430:        switch (dataP->value.asBuffer.buffer[0])
        -:  431:        {
    #####:  432:        case '0':
    #####:  433:            *valueP = false;
    #####:  434:            result = 1;
    #####:  435:            break;
    #####:  436:        case '1':
    #####:  437:            *valueP = true;
    #####:  438:            result = 1;
    #####:  439:            break;
    #####:  440:        default:
    #####:  441:            result = 0;
    #####:  442:            break;
        -:  443:        }
    #####:  444:        break;
        -:  445:
    #####:  446:    case LWM2M_TYPE_OPAQUE:
    #####:  447:        if (dataP->value.asBuffer.length != 1) return 0;
        -:  448:
    #####:  449:        switch (dataP->value.asBuffer.buffer[0])
        -:  450:        {
    #####:  451:        case 0:
    #####:  452:            *valueP = false;
    #####:  453:            result = 1;
    #####:  454:            break;
    #####:  455:        case 1:
    #####:  456:            *valueP = true;
    #####:  457:            result = 1;
    #####:  458:            break;
    #####:  459:        default:
    #####:  460:            result = 0;
    #####:  461:            break;
        -:  462:        }
    #####:  463:        break;
        -:  464:
    #####:  465:    default:
    #####:  466:        result = 0;
    #####:  467:        break;
        -:  468:    }
        -:  469:
        -:  470:    LOG_DATA_ARG("result: %d, value: %s", result, *valueP ? "true" : "false");
        -:  471:
    #####:  472:    return result;
        -:  473:}
        -:  474:
    #####:  475:void lwm2m_data_encode_objlink(uint16_t objectId,
        -:  476:                           uint16_t objectInstanceId,
        -:  477:                           lwm2m_data_t * dataP)
        -:  478:{
        -:  479:    LOG_DATA_ARG("value: %d/%d", objectId, objectInstanceId);
    #####:  480:    dataP->type = LWM2M_TYPE_OBJECT_LINK;
    #####:  481:    dataP->value.asObjLink.objectId = objectId;
    #####:  482:    dataP->value.asObjLink.objectInstanceId = objectInstanceId;
    #####:  483:}
        -:  484:
    #####:  485:void lwm2m_data_include(lwm2m_data_t * subDataP,
        -:  486:                        size_t count,
        -:  487:                        lwm2m_data_t * dataP)
        -:  488:{
        -:  489:    LOG_DATA_ARG("count: %d", count);
    #####:  490:    if (subDataP == NULL || count == 0) return;
        -:  491:
    #####:  492:    switch (subDataP[0].type)
        -:  493:    {
    #####:  494:    case LWM2M_TYPE_STRING:
        -:  495:    case LWM2M_TYPE_OPAQUE:
        -:  496:    case LWM2M_TYPE_INTEGER:
        -:  497:    case LWM2M_TYPE_FLOAT:
        -:  498:    case LWM2M_TYPE_BOOLEAN:
        -:  499:    case LWM2M_TYPE_OBJECT_LINK:
        -:  500:    case LWM2M_TYPE_MULTIPLE_RESOURCE:
    #####:  501:        dataP->type = LWM2M_TYPE_OBJECT_INSTANCE;
    #####:  502:        break;
    #####:  503:    case LWM2M_TYPE_OBJECT_INSTANCE:
    #####:  504:        dataP->type = LWM2M_TYPE_OBJECT;
    #####:  505:        break;
    #####:  506:    default:
    #####:  507:        return;
        -:  508:    }
    #####:  509:    dataP->value.asChildren.count = count;
    #####:  510:    dataP->value.asChildren.array = subDataP;
        -:  511:}
        -:  512:
    #####:  513:void lwm2m_data_encode_instances(lwm2m_data_t * subDataP,
        -:  514:                                 size_t count,
        -:  515:                                 lwm2m_data_t * dataP)
        -:  516:{
        -:  517:    LOG_DATA_ARG("count: %d", count);
    #####:  518:    lwm2m_data_include(subDataP, count, dataP);
    #####:  519:    dataP->type = LWM2M_TYPE_MULTIPLE_RESOURCE;
    #####:  520:}
        -:  521:
    #####:  522:int lwm2m_data_parse(lwm2m_uri_t * uriP,
        -:  523:                     uint8_t * buffer,
        -:  524:                     size_t bufferLen,
        -:  525:                     lwm2m_media_type_t format,
        -:  526:                     lwm2m_data_t ** dataP)
        -:  527:{
        -:  528:    int res;
        -:  529:
        -:  530:    LOG_DATA_ARG("format: %s, bufferLen: %d", STR_MEDIA_TYPE(format), bufferLen);
        -:  531:    LOG_URI(uriP);
    #####:  532:    switch (format)
        -:  533:    {
    #####:  534:    case LWM2M_CONTENT_TEXT:
    #####:  535:        if (!LWM2M_URI_IS_SET_RESOURCE(uriP)) return 0;
    #####:  536:        *dataP = lwm2m_data_new(1);
    #####:  537:        if (*dataP == NULL) return 0;
    #####:  538:        (*dataP)->id = uriP->resourceId;
    #####:  539:        (*dataP)->type = LWM2M_TYPE_STRING;
    #####:  540:        res = prv_setBuffer(*dataP, buffer, bufferLen);
    #####:  541:        if (res == 0)
        -:  542:        {
    #####:  543:            lwm2m_data_free(1, *dataP);
    #####:  544:            *dataP = NULL;
        -:  545:        }
    #####:  546:        return res;
        -:  547:
    #####:  548:    case LWM2M_CONTENT_OPAQUE:
    #####:  549:        if (!LWM2M_URI_IS_SET_RESOURCE(uriP)) return 0;
    #####:  550:        *dataP = lwm2m_data_new(1);
    #####:  551:        if (*dataP == NULL) return 0;
    #####:  552:        (*dataP)->id = uriP->resourceId;
    #####:  553:        (*dataP)->type = LWM2M_TYPE_OPAQUE;
    #####:  554:        res = prv_setBuffer(*dataP, buffer, bufferLen);
    #####:  555:        if (res == 0)
        -:  556:        {
    #####:  557:            lwm2m_data_free(1, *dataP);
    #####:  558:            *dataP = NULL;
        -:  559:    }
    #####:  560:        return res;
        -:  561:
        -:  562:#ifdef LWM2M_OLD_CONTENT_FORMAT_SUPPORT
        -:  563:    case LWM2M_CONTENT_TLV_OLD:
        -:  564:#endif
    #####:  565:    case LWM2M_CONTENT_TLV:
    #####:  566:        return tlv_parse(buffer, bufferLen, dataP);
        -:  567:
        -:  568:#ifdef LWM2M_SUPPORT_JSON
        -:  569:#ifdef LWM2M_OLD_CONTENT_FORMAT_SUPPORT
        -:  570:    case LWM2M_CONTENT_JSON_OLD:
        -:  571:#endif
    #####:  572:    case LWM2M_CONTENT_JSON:
    #####:  573:        return json_parse(uriP, buffer, bufferLen, dataP);
        -:  574:#endif
        -:  575:
    #####:  576:    default:
    #####:  577:        return 0;
        -:  578:    }
        -:  579:}
        -:  580:
    #####:  581:int lwm2m_data_serialize(lwm2m_uri_t * uriP,
        -:  582:                         int size,
        -:  583:                         lwm2m_data_t * dataP,
        -:  584:                         lwm2m_media_type_t * formatP,
        -:  585:                         uint8_t ** bufferP)
        -:  586:{
        -:  587:    LOG_URI(uriP);
        -:  588:    LOG_DATA_ARG("size: %d, formatP: %s", size, STR_MEDIA_TYPE(*formatP));
        -:  589:
        -:  590:    // Check format
    #####:  591:    if (*formatP == LWM2M_CONTENT_TEXT
    #####:  592:     || *formatP == LWM2M_CONTENT_OPAQUE)
        -:  593:    {
    #####:  594:        if (size != 1
    #####:  595:         || (uriP != NULL && !LWM2M_URI_IS_SET_RESOURCE(uriP))
    #####:  596:         || dataP->type == LWM2M_TYPE_OBJECT
    #####:  597:         || dataP->type == LWM2M_TYPE_OBJECT_INSTANCE
    #####:  598:         || dataP->type == LWM2M_TYPE_MULTIPLE_RESOURCE)
        -:  599:        {
        -:  600:#ifdef LWM2M_SUPPORT_JSON
    #####:  601:            *formatP = LWM2M_CONTENT_JSON;
        -:  602:#else
        -:  603:            *formatP = LWM2M_CONTENT_TLV;
        -:  604:#endif
        -:  605:        }
        -:  606:    }
        -:  607:
    #####:  608:    if (*formatP == LWM2M_CONTENT_OPAQUE
    #####:  609:     && dataP->type != LWM2M_TYPE_OPAQUE)
        -:  610:    {
        -:  611:        LOG_DATA("Opaque format is reserved to opaque resources.");
    #####:  612:        return -1;
        -:  613:    }
        -:  614:
        -:  615:    LOG_DATA_ARG("Final format: %s", STR_MEDIA_TYPE(*formatP));
        -:  616:
    #####:  617:    switch (*formatP)
        -:  618:    {
    #####:  619:    case LWM2M_CONTENT_TEXT:
    #####:  620:        return prv_textSerialize(dataP, bufferP);
        -:  621:
    #####:  622:    case LWM2M_CONTENT_OPAQUE:
    #####:  623:        *bufferP = (uint8_t *)lwm2m_malloc(dataP->value.asBuffer.length);
    #####:  624:        if (*bufferP == NULL) return -1;
    #####:  625:        memcpy(*bufferP, dataP->value.asBuffer.buffer, dataP->value.asBuffer.length);
    #####:  626:        return (int)dataP->value.asBuffer.length;
        -:  627:
    #####:  628:    case LWM2M_CONTENT_TLV:
        -:  629:    case LWM2M_CONTENT_TLV_OLD:
        -:  630:    {
        -:  631:            bool isResourceInstance;
        -:  632:
    #####:  633:            if (uriP != NULL && LWM2M_URI_IS_SET_RESOURCE(uriP)
    #####:  634:             && (size != 1 || dataP->id != uriP->resourceId))
        -:  635:            {
    #####:  636:                isResourceInstance = true;
        -:  637:            }
        -:  638:            else
        -:  639:            {
    #####:  640:                isResourceInstance = false;
        -:  641:            }
    #####:  642:            return tlv_serialize(isResourceInstance, size, dataP, bufferP);
        -:  643:        }
        -:  644:
        -:  645:#ifdef LWM2M_CLIENT_MODE
    #####:  646:    case LWM2M_CONTENT_LINK:
    #####:  647:        return discover_serialize(NULL, uriP, NULL, size, dataP, bufferP);
        -:  648:#endif
        -:  649:#ifdef LWM2M_SUPPORT_JSON
    #####:  650:    case LWM2M_CONTENT_JSON:
        -:  651:    case LWM2M_CONTENT_JSON_OLD:
    #####:  652:        return json_serialize(uriP, size, dataP, bufferP);
        -:  653:#endif
        -:  654:
    #####:  655:    default:
    #####:  656:        return -1;
        -:  657:    }
        -:  658:}
        -:  659:
