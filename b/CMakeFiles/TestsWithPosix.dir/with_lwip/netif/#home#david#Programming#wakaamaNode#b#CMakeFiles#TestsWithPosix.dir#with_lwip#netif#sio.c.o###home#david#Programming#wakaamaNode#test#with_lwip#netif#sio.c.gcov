        -:    0:Source:/home/david/Programming/wakaamaNode/test/with_lwip/netif/sio.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/with_lwip/netif/sio.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/* Author: Magnus Ivarsson <magnus.ivarsson@volvo.com> */
        -:    2:
        -:    3:/* to get rid of implicit function declarations */
        -:    4:#define _XOPEN_SOURCE 600
        -:    5:#define _GNU_SOURCE
        -:    6:
        -:    7:/* build with Darwin C extensions not part of POSIX, i.e. FASYNC, SIGIO.
        -:    8:   we can't use LWIP_UNIX_MACH because extensions need to be turned
        -:    9:   on before any system headers (which are pulled in through cc.h)
        -:   10:   are included */
        -:   11:#if defined(__APPLE__)
        -:   12:#define _DARWIN_C_SOURCE
        -:   13:#endif
        -:   14:
        -:   15:#include "netif/sio.h"
        -:   16:#include "netif/fifo.h"
        -:   17:#include "lwip/debug.h"
        -:   18:#include "lwip/def.h"
        -:   19:#include "lwip/sys.h"
        -:   20:#include "lwip/arch.h"
        -:   21:#include "lwip/sio.h"
        -:   22:#include "netif/ppp/ppp_opts.h"
        -:   23:
        -:   24:/* Following #undefs are here to keep compiler from issuing warnings
        -:   25:   about them being double defined. (They are defined in lwip/inet.h
        -:   26:   as well as the Unix #includes below.) */
        -:   27:#undef htonl
        -:   28:#undef ntohl
        -:   29:#undef htons
        -:   30:#undef ntohs
        -:   31:#undef HTONL
        -:   32:#undef NTOHL
        -:   33:#undef HTONS
        -:   34:#undef NTOHS
        -:   35:
        -:   36:#include <stdlib.h>
        -:   37:#include <stdio.h>
        -:   38:#if defined(LWIP_UNIX_OPENBSD)
        -:   39:#include <util.h>
        -:   40:#endif
        -:   41:#include <termios.h>
        -:   42:#include <stdio.h>
        -:   43:#include <unistd.h>
        -:   44:#include <fcntl.h>
        -:   45:#include <signal.h>
        -:   46:#include <string.h>
        -:   47:#include <sys/signal.h>
        -:   48:#include <sys/types.h>
        -:   49:
        -:   50:#ifndef LWIP_HAVE_SLIPIF
        -:   51:#define LWIP_HAVE_SLIPIF 0
        -:   52:#endif
        -:   53:
        -:   54:#if (PPP_SUPPORT || LWIP_HAVE_SLIPIF) && defined(LWIP_UNIX_LINUX)
        -:   55:#include <pty.h>
        -:   56:#endif
        -:   57:
        -:   58:/*#define BAUDRATE B19200 */
        -:   59:/*#define BAUDRATE B57600 */
        -:   60:#define BAUDRATE B115200
        -:   61:
        -:   62:#ifndef TRUE
        -:   63:#define TRUE  1
        -:   64:#endif
        -:   65:#ifndef FALSE
        -:   66:#define FALSE 0
        -:   67:#endif
        -:   68:
        -:   69:/* for all of you who dont define SIO_DEBUG in debug.h */
        -:   70:#ifndef SIO_DEBUG
        -:   71:#define SIO_DEBUG 0
        -:   72:#endif
        -:   73:
        -:   74:
        -:   75:/*  typedef struct siostruct_t */
        -:   76:/*  {  */
        -:   77:/*  	sio_status_t *sio; */
        -:   78:/*  } siostruct_t; */
        -:   79:
        -:   80:/** array of ((siostruct*)netif->state)->sio structs */
        -:   81:static sio_status_t statusar[4];
        -:   82:
        -:   83:#if ! (PPP_SUPPORT || LWIP_HAVE_SLIPIF)
        -:   84:/* --private-functions----------------------------------------------------------------- */
        -:   85:/** 
        -:   86: * Signal handler for ttyXX0 to indicate bytes received 
        -:   87: * one per interface is needed since we cannot send a instance number / pointer as callback argument (?)
        -:   88: */
    #####:   89:static void	signal_handler_IO_0( int status )
        -:   90:{
        -:   91:	LWIP_UNUSED_ARG(status);
        -:   92:	LWIP_DEBUGF(SIO_DEBUG, ("SigHand: rxSignal channel 0\n"));
    #####:   93:	fifoPut( &statusar[0].myfifo, statusar[0].fd );
    #####:   94:}
        -:   95:
        -:   96:/**
        -:   97: * Signal handler for ttyXX1 to indicate bytes received 
        -:   98: * one per interface is needed since we cannot send a instance number / pointer as callback argument (?)
        -:   99: */
    #####:  100:static void signal_handler_IO_1( int status )
        -:  101:{
        -:  102:	LWIP_UNUSED_ARG(status);
        -:  103:	LWIP_DEBUGF(SIO_DEBUG, ("SigHand: rxSignal channel 1\n"));
    #####:  104:	fifoPut( &statusar[1].myfifo, statusar[1].fd );
    #####:  105:}
        -:  106:#endif /* ! (PPP_SUPPORT || LWIP_HAVE_SLIPIF) */
        -:  107:
        -:  108:/**
        -:  109:* Initiation of serial device 
        -:  110:* @param device string with the device name and path, eg. "/dev/ttyS0"
        -:  111:* @param devnum device number
        -:  112:* @param siostat status
        -:  113:* @return file handle to serial dev.
        -:  114:*/
    #####:  115:static int sio_init( char * device, int devnum, sio_status_t * siostat )
        -:  116:{
        -:  117:	struct termios oldtio,newtio;
        -:  118:#if ! (PPP_SUPPORT || LWIP_HAVE_SLIPIF)
        -:  119:	struct sigaction saio;           /* definition of signal action */
        -:  120:#endif
        -:  121:	int fd;
        -:  122:	LWIP_UNUSED_ARG(siostat);
        -:  123:	LWIP_UNUSED_ARG(devnum);
        -:  124:
        -:  125:	/* open the device to be non-blocking (read will return immediately) */
    #####:  126:	fd = open( device, O_RDWR | O_NOCTTY | O_NONBLOCK );
    #####:  127:	if ( fd < 0 )
        -:  128:	{
    #####:  129:		perror( device );
    #####:  130:		exit( -1 );
        -:  131:	}
        -:  132:
        -:  133:#if ! (PPP_SUPPORT || LWIP_HAVE_SLIPIF)
        -:  134:	/* install the signal handler before making the device asynchronous */
    #####:  135:	switch ( devnum )
        -:  136:	{
    #####:  137:		case 0:
        -:  138:			LWIP_DEBUGF( SIO_DEBUG, ("sioinit, signal_handler_IO_0\n") );
    #####:  139:			saio.sa_handler = signal_handler_IO_0;
    #####:  140:			break;
    #####:  141:		case 1:
        -:  142:			LWIP_DEBUGF( SIO_DEBUG, ("sioinit, signal_handler_IO_1\n") );
    #####:  143:			saio.sa_handler = signal_handler_IO_1;
    #####:  144:			break;
    #####:  145:		default:
        -:  146:			LWIP_DEBUGF( SIO_DEBUG,("sioinit, devnum not allowed\n") );
    #####:  147:			break;
        -:  148:	}
        -:  149:
    #####:  150:	saio.sa_flags = 0;
        -:  151:#if defined(LWIP_UNIX_LINUX)
    #####:  152:	saio.sa_restorer = NULL;
        -:  153:#endif /* LWIP_UNIX_LINUX */
    #####:  154:	sigaction( SIGIO,&saio,NULL );
        -:  155:
        -:  156:	/* allow the process to receive SIGIO */
    #####:  157:       	if ( fcntl( fd, F_SETOWN, getpid( ) ) != 0)
        -:  158:	{
    #####:  159:		perror( device );
    #####:  160:		exit( -1 );
        -:  161:	}
        -:  162:	/* Make the file descriptor asynchronous (the manual page says only
        -:  163:	O_APPEND and O_NONBLOCK, will work with F_SETFL...) */
    #####:  164:       	if ( fcntl( fd, F_SETFL, FASYNC ) != 0)
        -:  165:	{
    #####:  166:		perror( device );
    #####:  167:		exit( -1 );
        -:  168:	}
        -:  169:#else
        -:  170:       	if ( fcntl( fd, F_SETFL, 0 ) != 0)
        -:  171:	{
        -:  172:		perror( device );
        -:  173:		exit( -1 );
        -:  174:	}
        -:  175:
        -:  176:#endif /* ! (PPP_SUPPORT || LWIP_HAVE_SLIPIF) */
        -:  177:
    #####:  178:	tcgetattr( fd,&oldtio ); /* save current port settings */
        -:  179:	/* set new port settings */
        -:  180:	/* see 'man termios' for further settings */
    #####:  181:        memset(&newtio, 0, sizeof(newtio));
    #####:  182:	newtio.c_cflag = BAUDRATE | CS8 | CLOCAL | CREAD | CRTSCTS;
    #####:  183:	newtio.c_iflag = 0;
    #####:  184:	newtio.c_oflag = 0;
    #####:  185:	newtio.c_lflag = 0; /*ECHO; */
    #####:  186:	newtio.c_cc[VMIN] = 1; /* Read 1 byte at a time, no timer */
    #####:  187:	newtio.c_cc[VTIME] = 0;
        -:  188:
    #####:  189:	tcsetattr( fd,TCSANOW,&newtio );
    #####:  190:	tcflush( fd, TCIOFLUSH );
        -:  191:
    #####:  192:	return fd;
        -:  193:}
        -:  194:
        -:  195:/**
        -:  196:*
        -:  197:*/
    #####:  198:static void sio_speed( int fd, int speed )
        -:  199:{
        -:  200:	struct termios oldtio,newtio;
        -:  201:	/*  int fd; */
        -:  202:
        -:  203:	LWIP_DEBUGF(SIO_DEBUG, ("sio_speed[%d]: baudcode:%d enter\n", fd, speed));
        -:  204:
    #####:  205:	if ( fd < 0 )
        -:  206:	{
        -:  207:		LWIP_DEBUGF(SIO_DEBUG, ("sio_speed[%d]: fd ERROR\n", fd));
    #####:  208:		exit( -1 );
        -:  209:	}
        -:  210:
    #####:  211:	tcgetattr( fd,&oldtio ); /* get current port settings */
        -:  212:
        -:  213:	/* set new port settings 
        -:  214:	* see 'man termios' for further settings */
    #####:  215:        memset(&newtio, 0, sizeof(newtio));
    #####:  216:	newtio.c_cflag = speed | CS8 | CLOCAL | CREAD; /* | CRTSCTS; */
    #####:  217:	newtio.c_iflag = 0;
    #####:  218:	newtio.c_oflag = 0;
    #####:  219:	newtio.c_lflag = 0; /*ECHO; */
    #####:  220:	newtio.c_cc[VMIN] = 1; /* Read 1 byte at a time, no timer */
    #####:  221:	newtio.c_cc[VTIME] = 0;
        -:  222:
    #####:  223:	tcsetattr( fd,TCSANOW,&newtio );
    #####:  224:	tcflush( fd, TCIOFLUSH );
        -:  225:
        -:  226:	LWIP_DEBUGF(SIO_DEBUG, ("sio_speed[%d]: leave\n", fd));
    #####:  227:}
        -:  228:
        -:  229:/* --public-functions----------------------------------------------------------------------------- */
    #####:  230:void sio_send( u8_t c, sio_status_t * siostat )
        -:  231:{
        -:  232:    /*	sio_status_t * siostat = ((siostruct_t*)netif->state)->sio; */
        -:  233:
    #####:  234:	if ( write( siostat->fd, &c, 1 ) <= 0 )
        -:  235:	{
        -:  236:		LWIP_DEBUGF(SIO_DEBUG, ("sio_send[%d]: write refused\n", siostat->fd));
        -:  237:	}
    #####:  238:}
        -:  239:
    #####:  240:void sio_send_string( u8_t *str, sio_status_t * siostat )
        -:  241:{
        -:  242:    /*	sio_status_t * siostat = ((siostruct_t*)netif->state)->sio; */
    #####:  243:	int len = strlen( (const char *)str );
        -:  244:
    #####:  245:	if ( write( siostat->fd, str, len ) <= 0 )
        -:  246:	{
        -:  247:		LWIP_DEBUGF(SIO_DEBUG, ("sio_send_string[%d]: write refused\n", siostat->fd));
        -:  248:	}
        -:  249:	LWIP_DEBUGF(SIO_DEBUG, ("sio_send_string[%d]: sent: %s\n", siostat->fd, str));
    #####:  250:}
        -:  251:
        -:  252:
    #####:  253:void sio_flush( sio_status_t * siostat )
        -:  254:{
        -:  255:	LWIP_UNUSED_ARG(siostat);
        -:  256:	/* not implemented in unix as it is not needed */
        -:  257: 	/*sio_status_t * siostat = ((siostruct_t*)netif->state)->sio; */
    #####:  258:}
        -:  259:
        -:  260:
        -:  261:#if ! (PPP_SUPPORT || LWIP_HAVE_SLIPIF)
        -:  262:/*u8_t sio_recv( struct netif * netif )*/
    #####:  263:u8_t sio_recv( sio_status_t * siostat )
        -:  264:{
        -:  265:    /*	sio_status_t * siostat = ((siostruct_t*)netif->state)->sio; */
    #####:  266:	return fifoGet( &(siostat->myfifo) );
        -:  267:}
        -:  268:
    #####:  269:s16_t sio_poll(sio_status_t * siostat)
        -:  270:{
        -:  271:    /*	sio_status_t * siostat = ((siostruct_t*)netif->state)->sio;*/
    #####:  272:	return fifoGetNonBlock( &(siostat->myfifo) );
        -:  273:}
        -:  274:
        -:  275:
    #####:  276:void sio_expect_string( u8_t *str, sio_status_t * siostat )
        -:  277:{
        -:  278:    /*	sio_status_t * siostat = ((siostruct_t*)netif->state)->sio;*/
        -:  279:	u8_t c;
    #####:  280: 	int finger=0;
        -:  281:  
        -:  282:	LWIP_DEBUGF(SIO_DEBUG, ("sio_expect_string[%d]: %s\n", siostat->fd, str));
        -:  283:	while ( 1 )
        -:  284:	{
    #####:  285:		c=fifoGet( &(siostat->myfifo) );
        -:  286:		LWIP_DEBUGF(SIO_DEBUG, ("_%c", c));
    #####:  287:		if ( c==str[finger] )
        -:  288:		{
    #####:  289:			finger++;
    #####:  290:		} else if ( finger > 0 )
        -:  291:		{
        -:  292:                    /*it might fit in the beginning? */
    #####:  293:			if ( str[0] == c )
        -:  294:			{
    #####:  295:				finger = 1;
        -:  296:			}
        -:  297:		}
    #####:  298:		if ( 0 == str[finger] ) 
    #####:  299:                    break;	/* done, we have a match */
        -:  300:	}
        -:  301:	LWIP_DEBUGF(SIO_DEBUG, ("sio_expect_string[%d]: [match]\n", siostat->fd));
    #####:  302:}
        -:  303:#endif /* ! (PPP_SUPPORT || LWIP_HAVE_SLIPIF) */
        -:  304:
    #####:  305:u32_t sio_write(sio_status_t * siostat, u8_t *buf, u32_t size)
        -:  306:{
    #####:  307:    ssize_t wsz = write( siostat->fd, buf, size );
    #####:  308:    return wsz < 0 ? 0 : wsz;
        -:  309:}
        -:  310:
    #####:  311:u32_t sio_read(sio_status_t * siostat, u8_t *buf, u32_t size)
        -:  312:{
    #####:  313:    ssize_t rsz = read( siostat->fd, buf, size );
    #####:  314:    return rsz < 0 ? 0 : rsz;
        -:  315:}
        -:  316:
    #####:  317:void sio_read_abort(sio_status_t * siostat)
        -:  318:{
        -:  319:    LWIP_UNUSED_ARG(siostat);
    #####:  320:    printf("sio_read_abort[%d]: not yet implemented for unix\n", siostat->fd);
    #####:  321:}
        -:  322:
    #####:  323:u32_t sio_tryread(sio_fd_t fd, u8_t *data, u32_t len) {
    #####:  324:    return sio_read(fd,data,len);
        -:  325:}
        -:  326:
    #####:  327:sio_fd_t sio_open(u8_t devnum)
        -:  328:{
        -:  329:	char dev[20];
        -:  330:
        -:  331:	/* would be nice with dynamic memory alloc */
    #####:  332:	sio_status_t * siostate = &statusar[ devnum ];
        -:  333:/* 	siostruct_t * tmp; */
        -:  334:
        -:  335:
        -:  336:/* 	tmp = (siostruct_t*)(netif->state); */
        -:  337:/* 	tmp->sio = siostate; */
        -:  338:
        -:  339:/* 	tmp = (siostruct_t*)(netif->state); */
        -:  340:
        -:  341:/* 	((sio_status_t*)(tmp->sio))->fd = 0; */
        -:  342:
        -:  343:	LWIP_DEBUGF(SIO_DEBUG, ("sio_open: for devnum %d\n", devnum));
        -:  344:
        -:  345:#if ! (PPP_SUPPORT || LWIP_HAVE_SLIPIF)
    #####:  346:	fifoInit( &siostate->myfifo );
        -:  347:#endif /* ! PPP_SUPPORT */
        -:  348:
    #####:  349:	snprintf( dev, sizeof(dev), "/dev/ttyS%d", devnum );
        -:  350:
    #####:  351:	if ( (devnum == 1) || (devnum == 0) )
        -:  352:	{
    #####:  353:		if ( ( siostate->fd = sio_init( dev, devnum, siostate ) ) == 0 )
        -:  354:		{
        -:  355:			LWIP_DEBUGF(SIO_DEBUG, ("sio_open: ERROR opening serial device dev=%s\n", dev));
    #####:  356:			abort( );
        -:  357:			return NULL;
        -:  358:		}
        -:  359:		LWIP_DEBUGF(SIO_DEBUG, ("sio_open[%d]: dev=%s open.\n", siostate->fd, dev));
        -:  360:	} 
        -:  361:#if PPP_SUPPORT
        -:  362:	else if (devnum == 2) {
        -:  363:	    pid_t childpid;
        -:  364:	    char name[256];
        -:  365:	    childpid = forkpty(&siostate->fd, name, NULL, NULL);
        -:  366:	    if(childpid < 0) {
        -:  367:		perror("forkpty");
        -:  368:		exit (1);
        -:  369:	    }
        -:  370:	    if(childpid == 0) {
        -:  371:		execl("/usr/sbin/pppd", "pppd",
        -:  372:			"ms-dns", "198.168.100.7",
        -:  373:			"local", "crtscts",
        -:  374:			"debug",
        -:  375:#ifdef LWIP_PPP_CHAP_TEST
        -:  376:			"auth",
        -:  377:			"require-chap",
        -:  378:			"remotename", "lwip",
        -:  379:#else
        -:  380:			"noauth",
        -:  381:#endif
        -:  382:#if LWIP_IPV6
        -:  383:			"+ipv6",
        -:  384:#endif
        -:  385:			"192.168.1.1:192.168.1.2",
        -:  386:			NULL);
        -:  387:		perror("execl pppd");
        -:  388:		exit (1);
        -:  389:	    } else {
        -:  390:		LWIP_DEBUGF(SIO_DEBUG, ("sio_open[%d]: spawned pppd pid %d on %s\n",
        -:  391:			siostate->fd, childpid, name));
        -:  392:	    }
        -:  393:
        -:  394:	}
        -:  395:#endif
        -:  396:#if LWIP_HAVE_SLIPIF
        -:  397:	else if (devnum == 3) {
        -:  398:	    pid_t childpid;
        -:  399:	    /* create PTY pair */
        -:  400:	    siostate->fd = posix_openpt(O_RDWR | O_NOCTTY);
        -:  401:	    if (siostate->fd < 0) {
        -:  402:		perror("open pty master");
        -:  403:		exit (1);
        -:  404:	    }
        -:  405:	    if (grantpt(siostate->fd) != 0) {
        -:  406:		perror("grant pty master");
        -:  407:		exit (1);
        -:  408:	    }
        -:  409:	    if (unlockpt(siostate->fd) != 0) {
        -:  410:		perror("unlock pty master");
        -:  411:		exit (1);
        -:  412:	    }
        -:  413:	    LWIP_DEBUGF(SIO_DEBUG, ("sio_open[%d]: for %s\n",
        -:  414:		    siostate->fd, ptsname(siostate->fd)));
        -:  415:	    /* fork for slattach */
        -:  416:	    childpid = fork();
        -:  417:	    if(childpid < 0) {
        -:  418:		perror("fork");
        -:  419:		exit (1);
        -:  420:	    }
        -:  421:	    if(childpid == 0) {
        -:  422:		/* esteblish SLIP interface on host side connected to PTY slave */
        -:  423:		execl("/sbin/slattach", "slattach",
        -:  424:			"-d", "-v", "-L", "-p", "slip",
        -:  425:			ptsname(siostate->fd),
        -:  426:			NULL);
        -:  427:		perror("execl slattach");
        -:  428:		exit (1);
        -:  429:	    } else {
        -:  430:		int ret;
        -:  431:		char buf[1024];
        -:  432:		LWIP_DEBUGF(SIO_DEBUG, ("sio_open[%d]: spawned slattach pid %d on %s\n",
        -:  433:			siostate->fd, childpid, ptsname(siostate->fd)));
        -:  434:		/* wait a moment for slattach startup */
        -:  435:		sleep(1);
        -:  436:		/* configure SLIP interface on host side as P2P interface */
        -:  437:		snprintf(buf, sizeof(buf),
        -:  438:			"/sbin/ifconfig sl0 mtu %d %s pointopoint %s up",
        -:  439:			SLIP_MAX_SIZE, "192.168.2.1", "192.168.2.2");
        -:  440:		LWIP_DEBUGF(SIO_DEBUG, ("sio_open[%d]: system(\"%s\");\n", siostate->fd, buf));
        -:  441:		ret = system(buf);
        -:  442:		if (ret < 0) {
        -:  443:		    perror("ifconfig failed");
        -:  444:		    exit(1);
        -:  445:		}
        -:  446:	    }
        -:  447:	}
        -:  448:#endif /* LWIP_HAVE_SLIPIF */
        -:  449:	else
        -:  450:	{
        -:  451:		LWIP_DEBUGF(SIO_DEBUG, ("sio_open: device %s (%d) is not supported\n", dev, devnum));
    #####:  452:		return NULL;
        -:  453:	}
        -:  454:
    #####:  455:	return siostate;
        -:  456:}
        -:  457:
        -:  458:/**
        -:  459:*
        -:  460:*/
    #####:  461:void sio_change_baud( sioBaudrates baud, sio_status_t * siostat )
        -:  462:{
        -:  463:    /*	sio_status_t * siostat = ((siostruct_t*)netif->state)->sio;*/
        -:  464:
        -:  465:	LWIP_DEBUGF(SIO_DEBUG, ("sio_change_baud[%d]\n", siostat->fd));
        -:  466:
    #####:  467:	switch ( baud )
        -:  468:	{
    #####:  469:		case SIO_BAUD_9600:
    #####:  470:			sio_speed( siostat->fd, B9600 );
    #####:  471:			break;
    #####:  472:		case SIO_BAUD_19200:
    #####:  473:			sio_speed( siostat->fd, B19200 );
    #####:  474:			break;
    #####:  475:		case SIO_BAUD_38400:
    #####:  476:			sio_speed( siostat->fd, B38400 );
    #####:  477:			break;
    #####:  478:		case SIO_BAUD_57600:
    #####:  479:			sio_speed( siostat->fd, B57600 );
    #####:  480:			break;
    #####:  481:		case SIO_BAUD_115200:
    #####:  482:			sio_speed( siostat->fd, B115200 );
    #####:  483:			break;
        -:  484:
    #####:  485:		default:
        -:  486:			LWIP_DEBUGF(SIO_DEBUG, ("sio_change_baud[%d]: Unknown baudrate, code:%d\n",
        -:  487:					siostat->fd, baud));
    #####:  488:			break;
        -:  489:	}
    #####:  490:}
        -:  491:
