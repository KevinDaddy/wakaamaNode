        -:    0:Source:/home/david/Programming/wakaamaNode/src/include/lwm2m/objects.h
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/connect_server_tests.cpp.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*******************************************************************************
        -:    2: * Copyright (c) 2017-2018  David Graeff <david.graeff@web.de>
        -:    3: *
        -:    4: * Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    5: * of this software and associated documentation files (the "Software"), to deal
        -:    6: * in the Software without restriction, including without limitation the rights
        -:    7: * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:    8: * copies of the Software, and to permit persons to whom the Software is
        -:    9: * furnished to do so, subject to the following conditions:
        -:   10: *
        -:   11: * The above copyright notice and this permission notice shall be included in
        -:   12: * all copies or substantial portions of the Software.
        -:   13: */
        -:   14:#pragma once
        -:   15:
        -:   16:/*
        -:   17: * Classes, Methods and Enums defined in this file are for easily creating a new lwM2M object definition
        -:   18: * and object instances. This is for the C++-API.
        -:   19: */
        -:   20:
        -:   21:#include "../../wakaama/liblwm2m.h"
        -:   22:#include "../../macro_helper.h"
        -:   23:#include "lwm2m/c_objects.h" // We need the enums of the C-API as well
        -:   24:#include <inttypes.h>
        -:   25:#include <string.h>
        -:   26:#include <type_traits>
        -:   27:#include <functional>
        -:   28:
        -:   29:template<class T>
        -:   30:class Lwm2mObjectBase;
        -:   31:
        -:   32:using Lwm2mObjectBaseVoid = Lwm2mObjectBase<void>;
        -:   33:class Lwm2mObjectInstance;
        -:   34:
        -:   35:int lwm2m_object_prepare_full_response(lwm2m_data_t ** dataArrayP, Lwm2mObjectBaseVoid* metaP);
        -:   36:uint8_t lwm2m_object_assign_single_value(lwm2m_data_t* destination, lwm2m_object_res_item_t* resP,
        -:   37:                                         Lwm2mObjectInstance* instanceP);
        -:   38:uint8_t prv_read(uint16_t instanceId,
        -:   39:                        int * numDataP,
        -:   40:                        lwm2m_data_t ** dataArrayP,
        -:   41:                        lwm2m_object_t * objectP,
        -:   42:                        lwm2m_context_t* context);
        -:   43:uint8_t prv_write(uint16_t instanceId,
        -:   44:                         int numData,
        -:   45:                         lwm2m_data_t * dataArray,
        -:   46:                         lwm2m_object_t * objectP,
        -:   47:                        lwm2m_context_t* context);
        -:   48:uint8_t prv_execute(uint16_t instanceId,
        -:   49:                    uint16_t res_id,
        -:   50:                    lwm2m_context_t* context,
        -:   51:                    lwm2m_object_t * objectP);
        -:   52:uint8_t prv_discover(uint16_t instanceId,
        -:   53:                    int * numDataP,
        -:   54:                    lwm2m_data_t ** dataArrayP,
        -:   55:                    lwm2m_object_t * objectP);
        -:   56:uint8_t prv_delete(uint16_t id, lwm2m_object_t * objectP);
        -:   57:uint8_t prv_create(uint16_t instanceId,
        -:   58:                  int numData,
        -:   59:                  lwm2m_data_t * dataArray,
        -:   60:                  lwm2m_object_t * objectP, lwm2m_context_t *contextP);
        -:   61:
        -:   62:// The Opaque type. OpaqueIndirect is defined by the C-API.
        -:   63:template<int N>
        -:   64:struct Opaque {
        -:   65:    uint16_t reserved_len=N;
        -:   66:    uint16_t used_len=0;
        -:   67:    uint8_t data[N];
        -:   68:
        -:   69:    template<typename T>
        -:   70:    inline void copy(T* d, int size) {
        -:   71:        memcpy(data, d, size);
        -:   72:        used_len = size;
        -:   73:    }
        -:   74:};
        -:   75:
        -:   76:// Preallocated string
        -:   77:template<int N>
        -:   78:struct PreallocString {
        -:   79:    uint16_t reserved_len=N;
        -:   80:    uint16_t used_len=0;
        -:   81:    uint8_t data[N];
        -:   82:
        -:   83:    template<typename T>
        -:   84:    inline void copy(T* d) {
        -:   85:        used_len = strlen(d);
        -:   86:        if (used_len>reserved_len){
        -:   87:            used_len=reserved_len;
        -:   88:        }
        -:   89:        memcpy(data, d, used_len+1);
        -:   90:    }
        -:   91:};
        -:   92:
        -:   93:template<class T>
        -:   94:struct DynArray {
        -:   95:    T data;
        -:   96:    int len;
        -:   97:    DynArray(T& value, int len) : data(value),len(len){}
        -:   98:};
        -:   99:
        -:  100:class Lwm2mObjectInstance : public lwm2m_list_t {
        -:  101:public:
    #####:  102:    Lwm2mObjectInstance() : lwm2m_list_t{nullptr,0} {}
        -:  103:    template<class T> inline T* as() {return reinterpret_cast<T*>(this);}
        -:  104:};
        -:  105:
        -:  106:// The executable type
        -:  107:using Executable = std::add_pointer<void(Lwm2mObjectInstance* instance, lwm2m_context_t* context)>::type;
        -:  108:
        -:  109:// The verify write callback of Lwm2mObjectBase
        -:  110:template<class T>
        -:  111:using VerifyWrite = bool (*)(T*, uint16_t);
        -:  112:
        -:  113:// The read indirect type
        -:  114:template<class T>
        -:  115:using IndirectRead = T (*)(Lwm2mObjectInstance*);
        -:  116:
        -:  117:// The write indirect type
        -:  118:template<class T>
        -:  119:using IndirectWrite = void (*)(Lwm2mObjectInstance*,DynArray<T>&);
        -:  120:
        -:  121:// The read/write indirect type
        -:  122:template<class T>
        -:  123:struct IndirectReadWrite {
        -:  124:    typedef T type;
        -:  125:    IndirectRead<T> read;
        -:  126:    IndirectWrite<T> write;
        -:  127:    IndirectReadWrite() = default;
        -:  128:    IndirectReadWrite(IndirectRead<T> read, IndirectWrite<T> write) : read(read),write(write){}
        -:  129:};
        -:  130:
        -:  131:template<class ObjectInstance>
        -:  132:class Lwm2mObjectBase {
        -:  133:    // Allow offset_of_impl to access the protected constructor
        -:  134:    template<typename T1, typename T2> friend struct offset_of_impl;
        -:  135:public:
        -:  136:    lwm2m_object_t object{};
        -:  137:    VerifyWrite<ObjectInstance> verifyWrite;
        -:  138:    struct alignas(alignof (uintptr_t)) Sizes {
        -:  139:        const uint16_t object;
        -:  140:        const uint16_t object_instance;
        -:  141:    };
        -:  142:    const Sizes sizes;
        -:  143:
        -:  144:    static Lwm2mObjectBase<ObjectInstance>* getBase(lwm2m_object_t* p) {
        -:  145:        const uintptr_t objectP = reinterpret_cast<uintptr_t>(p);
        -:  146:        return reinterpret_cast<Lwm2mObjectBase<ObjectInstance>*>(objectP - offset_of(&Lwm2mObjectBase<void>::object));
        -:  147:    }
        -:  148:    lwm2m_object_res_item_t* resource(uint16_t i) {
        -:  149:        const uint16_t res_len = resources_len();
        -:  150:        const uintptr_t endOfObject = reinterpret_cast<uintptr_t>(this) + sizes.object;
        -:  151:        return reinterpret_cast<lwm2m_object_res_item_t*>(endOfObject - sizeof(lwm2m_object_res_item_t)*(res_len-i));
        -:  152:    }
        -:  153:    constexpr uint16_t resources_len() const {
        -:  154:        return (sizes.object-sizeof(Lwm2mObjectBase))/sizeof(lwm2m_object_res_item_t);
        -:  155:    }
        -:  156:
        -:  157:    lwm2m_object_res_item_t* find_ressource(uint16_t id) {
        -:  158:        for (uint16_t index = 0; index < resources_len(); index++) {
        -:  159:            if (resource(index)->ressource_id == id) {
        -:  160:                return resource(index);
        -:  161:            }
        -:  162:        }
        -:  163:
        -:  164:        return nullptr;
        -:  165:    }
        -:  166:
    #####:  167:    constexpr Lwm2mObjectBase(uint16_t derived_size) :
    #####:  168:        verifyWrite(defaultVerify), sizes{derived_size,sizeof(ObjectInstance)} {}
        -:  169:
        -:  170:    void resChanged(lwm2m_context_t * contextP, uint16_t object_instance_id, uint16_t res_id) {
        -:  171:        lwm2m_uri_t uri = {LWM2M_URI_FLAG_OBJECT_ID|LWM2M_URI_FLAG_INSTANCE_ID|LWM2M_URI_FLAG_RESOURCE_ID,
        -:  172:                           object.objID, object_instance_id, res_id};
        -:  173:        lwm2m_resource_value_changed(contextP, &uri);
        -:  174:    }
        -:  175:
        -:  176:    /**
        -:  177:      * Add the given instance to the object and notify connected lwm2m servers.
        -:  178:      */
    #####:  179:    void addInstance(lwm2m_context_t * contextP, Lwm2mObjectInstance* instance) {
    #####:  180:        if (lwm2m_list_find(object.instanceList,instance->id)) return;
        -:  181:
    #####:  182:        object.instanceList=lwm2m_list_add(object.instanceList, instance);
    #####:  183:        if (contextP->state == STATE_READY && LWM2M_LIST_FIND(contextP->objectList, object.objID) != NULL)
    #####:  184:            lwm2m_update_registration(contextP, 0, true);
        -:  185:    }
        -:  186:
        -:  187:    /**
        -:  188:      * Remove the given instance from the object and notify connected lwm2m servers.
        -:  189:      */
        -:  190:    lwm2m_list_t* removeInstance(lwm2m_context_t * contextP, uint16_t instance_id) {
        -:  191:        lwm2m_list_t* removed = NULL;
        -:  192:        object.instanceList = lwm2m_list_remove(object.instanceList, instance_id, &removed);
        -:  193:
        -:  194:        if (contextP->state == STATE_READY && LWM2M_LIST_FIND(contextP->objectList, object.objID) != NULL)
        -:  195:        {
        -:  196:            lwm2m_update_registration(contextP, 0, true);
        -:  197:        }
        -:  198:        return removed;
        -:  199:    }
        -:  200:
        -:  201:    /**
        -:  202:      * Registers an object to the given lwm2m context and notifies connected lwm2m servers.
        -:  203:      */
    #####:  204:    int registerObject(lwm2m_context_t * contextP, bool allow_dynamic_instance_creation) {
    #####:  205:        object.readFunc = prv_read;
    #####:  206:        object.writeFunc = prv_write;
    #####:  207:        object.discoverFunc = prv_discover;
    #####:  208:        object.executeFunc = prv_execute;
        -:  209:
    #####:  210:        if (allow_dynamic_instance_creation)
        -:  211:        {
    #####:  212:            object.createFunc = prv_create;
    #####:  213:            object.deleteFunc = prv_delete;
        -:  214:        }
        -:  215:
    #####:  216:        return lwm2m_add_object(contextP, &object);
        -:  217:    }
        -:  218:
        -:  219:    /**
        -:  220:      * Unregisters an object from the given lwm2m context and notifies connected lwm2m servers.
        -:  221:      */
        -:  222:    int unregisterObject(lwm2m_context_t * contextP) {
        -:  223:        return lwm2m_remove_object(contextP, object.objID);
        -:  224:    }
        -:  225:
        -:  226:
        -:  227:    /**
        -:  228:      * Dynamically create an instance. Will be called when a lwm2m server requests
        -:  229:      * a new object instance.
        -:  230:      */
    #####:  231:    virtual Lwm2mObjectInstance* createInstance(uint16_t instance_id){return nullptr;}
        -:  232:    /**
        -:  233:      * Dynamically delete an instance. Will be called when a lwm2m server requests
        -:  234:      * to delete an object instance.
        -:  235:      */
    #####:  236:    virtual int deleteInstance(Lwm2mObjectInstance* instance){return COAP_NO_ERROR;}
        -:  237:
        -:  238:    protected:
        -:  239:    constexpr Lwm2mObjectBase() : verifyWrite(defaultVerify), sizes{0,0} {}
    #####:  240:    constexpr static bool defaultVerify(ObjectInstance*,uint16_t) { return true; }
        -:  241:};
        -:  242:
        -:  243:template<uint16_t objectID, class Derived, class ObjectInstance>
        -:  244:class Lwm2mObject : public Lwm2mObjectBase<ObjectInstance> {
        -:  245:public:
    #####:  246:   Lwm2mObject() : Lwm2mObjectBase<ObjectInstance>(sizeof(Derived)) {
    #####:  247:       Lwm2mObjectBase<ObjectInstance>::object.objID=objectID;
    #####:  248:   }
        -:  249:};
        -:  250:
        -:  251:////// Fallback with error
        -:  252:template<uint16_t ResID, class ObjectInstance, class ResourceType, size_t offset, uint8_t Operations, typename Enable = void>
        -:  253:class ResourceRaw : public lwm2m_object_res_item_t {
        -:  254:public:
        -:  255:    ResourceRaw() = delete;
        -:  256:};
        -:  257:
        -:  258:////// For opaque and string types
        -:  259:
        -:  260:template<uint16_t ResID, class ObjectInstance, class ResourceType, size_t offset, uint8_t Operations>
        -:  261:    class ResourceRaw<ResID,ObjectInstance,ResourceType,offset,Operations,
        -:  262:            typename std::enable_if<std::is_base_of<OpaqueIndirect, ResourceType>::value, ResourceType>::type> : public lwm2m_object_res_item_t {
        -:  263:public:
        -:  264:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_OPAQUE_INDIRECT,offset} {}
        -:  265:};
        -:  266:
        -:  267:template<uint16_t ResID, class ObjectInstance, size_t offset, uint8_t Operations>
        -:  268:    class ResourceRaw<ResID,ObjectInstance,OpaqueIndirect,offset,Operations> : public lwm2m_object_res_item_t {
        -:  269:public:
        -:  270:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_OPAQUE_INDIRECT,offset} {}
        -:  271:};
        -:  272:
        -:  273:template<uint16_t ResID, class ObjectInstance, class ResourceType, size_t offset, uint8_t Operations>
        -:  274:class ResourceRaw<ResID,ObjectInstance,ResourceType,offset,Operations,
        -:  275:        typename std::enable_if<is_base_of_template<ResourceType, Opaque>::value>::type> : public lwm2m_object_res_item_t {
        -:  276:public:
        -:  277:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_OPAQUE_PREALLOC,offset} {}
        -:  278:};
        -:  279:
        -:  280:template<uint16_t ResID, class ObjectInstance, class ResourceType, size_t offset, uint8_t Operations>
        -:  281:class ResourceRaw<ResID,ObjectInstance,ResourceType,offset,Operations,
        -:  282:        typename std::enable_if<is_base_of_template<ResourceType, PreallocString>::value>::type> :
        -:  283:        public lwm2m_object_res_item_t {
        -:  284:public:
    #####:  285:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_STRING_PREALLOC,offset} {}
------------------
_ZN11ResourceRawILt5701EN12KnownObjects6id33118instanceENS1_15SensorUnitsTypeELm70ELh1EvEC2Ev:
    #####:  285:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_STRING_PREALLOC,offset} {}
------------------
_ZN11ResourceRawILt5706EN12KnownObjects6id33118instanceENS1_10ColourTypeELm36ELh3EvEC2Ev:
    #####:  285:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_STRING_PREALLOC,offset} {}
------------------
        -:  286:};
        -:  287:
        -:  288:////// For all other allowed types
        -:  289:
        -:  290:template<uint16_t ResID, class ObjectInstance, size_t offset, uint8_t Operations>
        -:  291:class ResourceRaw<ResID,ObjectInstance,char*,offset,Operations> : public lwm2m_object_res_item_t {
        -:  292:public:
        -:  293:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_STRING,offset} {}
        -:  294:};
        -:  295:template<uint16_t ResID, class ObjectInstance, size_t offset, uint8_t Operations>
        -:  296:class ResourceRaw<ResID,ObjectInstance,const char*,offset,Operations> : public lwm2m_object_res_item_t {
        -:  297:public:
        -:  298:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_STRING,offset} {}
        -:  299:};
        -:  300:template<uint16_t ResID, class ObjectInstance, size_t offset, uint8_t Operations>
        -:  301:class ResourceRaw<ResID,ObjectInstance,unsigned char*,offset,Operations> : public lwm2m_object_res_item_t {
        -:  302:public:
        -:  303:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_STRING,offset} {}
        -:  304:};
        -:  305:template<uint16_t ResID, class ObjectInstance, size_t offset, uint8_t Operations>
        -:  306:class ResourceRaw<ResID,ObjectInstance,const unsigned char*,offset,Operations> : public lwm2m_object_res_item_t {
        -:  307:public:
        -:  308:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_STRING,offset} {}
        -:  309:};
        -:  310:template<uint16_t ResID, class ObjectInstance, size_t offset, uint8_t Operations>
        -:  311:class ResourceRaw<ResID,ObjectInstance,Executable,offset,Operations> : public lwm2m_object_res_item_t {
        -:  312:public:
        -:  313:    ResourceRaw() : lwm2m_object_res_item_t {ResID,O_RES_E,O_RES_EXEC,offset} {}
        -:  314:};
        -:  315:template<uint16_t ResID, class ObjectInstance, size_t offset, uint8_t Operations>
        -:  316:class ResourceRaw<ResID,ObjectInstance,bool,offset,Operations> : public lwm2m_object_res_item_t {
        -:  317:public:
    #####:  318:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_BOOL,offset} {}
        -:  319:};
        -:  320:template<uint16_t ResID, class ObjectInstance, size_t offset, uint8_t Operations>
        -:  321:class ResourceRaw<ResID,ObjectInstance,double,offset,Operations> : public lwm2m_object_res_item_t {
        -:  322:public:
        -:  323:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_DOUBLE,offset} {}
        -:  324:};
        -:  325:template<uint16_t ResID, class ObjectInstance, size_t offset, uint8_t Operations>
        -:  326:class ResourceRaw<ResID,ObjectInstance,float,offset,Operations> : public lwm2m_object_res_item_t {
        -:  327:public:
    #####:  328:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_DOUBLE,offset} {}
------------------
_ZN11ResourceRawILt5820EN12KnownObjects6id33118instanceEfLm32ELh1EvEC2Ev:
    #####:  328:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_DOUBLE,offset} {}
------------------
_ZN11ResourceRawILt5805EN12KnownObjects6id33118instanceEfLm28ELh1EvEC2Ev:
    #####:  328:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_DOUBLE,offset} {}
------------------
        -:  329:};
        -:  330:
        -:  331:template<uint16_t ResID, class ObjectInstance, size_t offset, uint8_t Operations>
        -:  332:class ResourceRaw<ResID,ObjectInstance,int8_t,offset,Operations> : public lwm2m_object_res_item_t {
        -:  333:public:
        -:  334:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_INT8,offset} {}
        -:  335:};
        -:  336:template<uint16_t ResID, class ObjectInstance, size_t offset, uint8_t Operations>
        -:  337:class ResourceRaw<ResID,ObjectInstance,uint8_t,offset,Operations> : public lwm2m_object_res_item_t {
        -:  338:public:
        -:  339:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_UINT8,offset} {}
        -:  340:};
        -:  341:
        -:  342:template<uint16_t ResID, class ObjectInstance, size_t offset, uint8_t Operations>
        -:  343:class ResourceRaw<ResID,ObjectInstance,int16_t,offset,Operations> : public lwm2m_object_res_item_t {
        -:  344:public:
        -:  345:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_INT16,offset} {}
        -:  346:};
        -:  347:template<uint16_t ResID, class ObjectInstance, size_t offset, uint8_t Operations>
        -:  348:class ResourceRaw<ResID,ObjectInstance,uint16_t,offset,Operations> : public lwm2m_object_res_item_t {
        -:  349:public:
        -:  350:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_UINT16,offset} {}
        -:  351:};
        -:  352:
        -:  353:template<uint16_t ResID, class ObjectInstance, size_t offset, uint8_t Operations>
        -:  354:class ResourceRaw<ResID,ObjectInstance,int32_t,offset,Operations> : public lwm2m_object_res_item_t {
        -:  355:public:
    #####:  356:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_INT32,offset} {}
------------------
_ZN11ResourceRawILt5852EN12KnownObjects6id33118instanceEiLm24ELh3EvEC2Ev:
    #####:  356:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_INT32,offset} {}
------------------
_ZN11ResourceRawILt5851EN12KnownObjects6id33118instanceEiLm20ELh3EvEC2Ev:
    #####:  356:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_INT32,offset} {}
------------------
        -:  357:};
        -:  358:template<uint16_t ResID, class ObjectInstance, size_t offset, uint8_t Operations>
        -:  359:class ResourceRaw<ResID,ObjectInstance,uint32_t,offset,Operations> : public lwm2m_object_res_item_t {
        -:  360:public:
        -:  361:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_UINT32,offset} {}
        -:  362:};
        -:  363:
        -:  364:template<uint16_t ResID, class ObjectInstance, size_t offset, uint8_t Operations>
        -:  365:class ResourceRaw<ResID,ObjectInstance,int64_t,offset,Operations> : public lwm2m_object_res_item_t {
        -:  366:public:
        -:  367:    ResourceRaw() : lwm2m_object_res_item_t {ResID,Operations,O_RES_INT64,offset} {}
        -:  368:};
        -:  369:
        -:  370://////////// For indirect resources, where we do not need to define operations ///////////
        -:  371:
        -:  372:// Fallback for non indirect resources
        -:  373:template<uint16_t ResID, class ObjectInstance, class ResourceType, size_t offset, uint8_t Operations,class Enable = void>
        -:  374:class IndirectResourceRaw : public ResourceRaw<ResID,ObjectInstance,ResourceType,offset,Operations> {
        -:  375:
        -:  376:};
        -:  377:
        -:  378:// enable_if prevents this template specialisation to match an Executable
        -:  379:template<uint16_t ResID, class ObjectInstance, size_t offset, typename SubType, uint8_t Operations>
        -:  380:class IndirectResourceRaw<ResID,ObjectInstance,IndirectRead<SubType>,offset,Operations,
        -:  381:        typename std::enable_if<!std::is_same<SubType,void>::value>::type> :
        -:  382:        public ResourceRaw<ResID,ObjectInstance,SubType,offset,O_RES_R|O_RES_E> {
        -:  383:};
        -:  384:
        -:  385:template<uint16_t ResID, class ObjectInstance, size_t offset, typename SubType, uint8_t Operations>
        -:  386:class IndirectResourceRaw<ResID,ObjectInstance,IndirectWrite<SubType>,offset,Operations> :
        -:  387:        public ResourceRaw<ResID,ObjectInstance,SubType,offset,O_RES_W|O_RES_E> {
        -:  388:};
        -:  389:
        -:  390:template<uint16_t ResID, class ObjectInstance, size_t offset, typename SubType, uint8_t Operations>
        -:  391:class IndirectResourceRaw<ResID,ObjectInstance,IndirectReadWrite<SubType>,offset,Operations> :
        -:  392:        public ResourceRaw<ResID,ObjectInstance,SubType,offset,O_RES_RW|O_RES_E> {
        -:  393:};
        -:  394:
        -:  395:// Until C++17 where we have auto for template arguments this macro is necessary
        -:  396:/*
        -:  397:#define Resource(ResID, MemberPtr, ...) \
        -:  398:  IndirectResourceRaw<ResID, baseof_member_pointer<decltype(MemberPtr)>::type, \
        -:  399:            remove_member_pointer<decltype(MemberPtr)>::type, \
        -:  400:            offset_of(MemberPtr) __VA_OPT__(,) __VA_ARGS__>
        -:  401:*/
        -:  402:
        -:  403:// Until gnuc++14/c++20 where we can use __VA_OPT__
        -:  404:#define Resource_2(ResID, MemberPtr) \
        -:  405:  IndirectResourceRaw<ResID, baseof_member_pointer<decltype(MemberPtr)>::type, \
        -:  406:            remove_member_pointer<decltype(MemberPtr)>::type, \
        -:  407:            offset_of(MemberPtr), 0>
        -:  408:
        -:  409:#define Resource_3(ResID, MemberPtr, Operations) \
        -:  410:  IndirectResourceRaw<ResID, baseof_member_pointer<decltype(MemberPtr)>::type, \
        -:  411:            remove_member_pointer<decltype(MemberPtr)>::type, \
        -:  412:            offset_of(MemberPtr), Operations>
        -:  413:
        -:  414:// The interim macro that simply strips the excess and ends up with the required macro
        -:  415:#define Resource_X(x,A,B,C,D,FUNC, ...)  FUNC
        -:  416:#define Resource(...)                    Resource_X(,##__VA_ARGS__,\
        -:  417:                                          Resource_4(__VA_ARGS__),\
        -:  418:                                          Resource_3(__VA_ARGS__),\
        -:  419:                                          Resource_2(__VA_ARGS__),\
        -:  420:                                          Resource_1(__VA_ARGS__),\
        -:  421:                                          Resource_0(__VA_ARGS__)\
        -:  422:                                         )
