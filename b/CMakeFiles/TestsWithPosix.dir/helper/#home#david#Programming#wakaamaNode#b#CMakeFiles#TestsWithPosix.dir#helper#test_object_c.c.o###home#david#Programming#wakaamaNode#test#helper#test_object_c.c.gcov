        -:    0:Source:/home/david/Programming/wakaamaNode/test/helper/test_object_c.c
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/helper/test_object_c.c.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*******************************************************************************
        -:    2: * Copyright (c) 2017-2018  David Graeff <david.graeff@web.de>
        -:    3: *
        -:    4: * Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    5: * of this software and associated documentation files (the "Software"), to deal
        -:    6: * in the Software without restriction, including without limitation the rights
        -:    7: * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:    8: * copies of the Software, and to permit persons to whom the Software is
        -:    9: * furnished to do so, subject to the following conditions:
        -:   10: *
        -:   11: * The above copyright notice and this permission notice shall be included in
        -:   12: * all copies or substantial portions of the Software.
        -:   13: */
        -:   14:
        -:   15:#include "test_object_c.h"
        -:   16:
        -:   17:#include <string.h>
        -:   18:#include <stdlib.h>
        -:   19:#include <stdio.h>
        -:   20:#include <assert.h>
        -:   21:
        -:   22:bool test_object_write_verify_cb(lwm2m_list_t* instance, uint16_t changed_res_id);
        -:   23:
        -:   24:OBJECT_META(test_object_instance_t, test_object_meta, 1024, test_object_write_verify_cb,
        -:   25:    { 0, O_RES_RW,O_RES_UINT8,   offsetof(test_object_instance_t,test_u8)},
        -:   26:    { 1, O_RES_RW,O_RES_INT8,    offsetof(test_object_instance_t,test_i8)},
        -:   27:    { 2, O_RES_RW,O_RES_UINT16,  offsetof(test_object_instance_t,test_u16)},
        -:   28:    { 3, O_RES_RW,O_RES_INT16,   offsetof(test_object_instance_t,test_i16)},
        -:   29:    { 4, O_RES_RW,O_RES_UINT32,  offsetof(test_object_instance_t,test_u32)},
        -:   30:    { 5, O_RES_RW,O_RES_INT32,   offsetof(test_object_instance_t,test_i32)},
        -:   31:    { 6, O_RES_RW,O_RES_INT64,   offsetof(test_object_instance_t,test_i64)},
        -:   32:
        -:   33:    { 7, O_RES_RW,O_RES_DOUBLE,  offsetof(test_object_instance_t,test_double)},
        -:   34:
        -:   35:    { 8, O_RES_RW,O_RES_BOOL,    offsetof(test_object_instance_t,test_bool)},
        -:   36:
        -:   37:    { 9, O_RES_R, O_RES_STRING,  offsetof(test_object_instance_t,test_str)},
        -:   38:    {10, O_RES_RW,O_RES_STRING_PREALLOC, offsetof(test_object_instance_t,test_str_prealloc)},
        -:   39:
        -:   40:    {11, O_RES_RW,O_RES_OPAQUE_INDIRECT, offsetof(test_object_instance_t,test_opaque)},
        -:   41:    {12, O_RES_RW,O_RES_OPAQUE_PREALLOC, offsetof(test_object_instance_t,test_opaque_prealloc)},
        -:   42:
        -:   43:    {13, O_RES_E, 0,                     offsetof(test_object_instance_t,test_execute_fun)},
        -:   44:
        -:   45:    {14, O_RES_R|O_RES_E,O_RES_INT8,     offsetof(test_object_instance_t,test_read_fun_int8)},
        -:   46:    {15, O_RES_R|O_RES_E,O_RES_UINT32,   offsetof(test_object_instance_t,test_read_fun_uint32)},
        -:   47:    {16, O_RES_R|O_RES_E,O_RES_STRING,   offsetof(test_object_instance_t,test_read_fun_string)},
        -:   48:    {17, O_RES_W|O_RES_E,O_RES_STRING,   offsetof(test_object_instance_t,test_write_fun_string)},
        -:   49:    {18, O_RES_RW|O_RES_E,O_RES_STRING,  offsetof(test_object_instance_t,test_readWrite_fun_string)},
        -:   50:    {19, O_RES_RW,O_RES_OPAQUE_PREALLOC, offsetof(test_object_instance_t,test_oaque_empty)},
        -:   51:)
        -:   52:
    #####:   53:lwm2m_object_t *get_test_object() {
    #####:   54:    return test_object_metaP;
        -:   55:}
        -:   56:
    #####:   57:lwm2m_list_t* test_object_create_instance(uint16_t instance_id,
        -:   58:                                          IndirectReadType(int8_t,readFun8),
        -:   59:                                          IndirectReadType(uint32_t,readFun32),
        -:   60:                                          IndirectReadType(const char*,readFunStr),
        -:   61:                                          IndirectWriteType(const char*,writeFunStr),
        -:   62:                                          ExecutableType execFun) {
    #####:   63:    test_object_instance_t * targetP = (test_object_instance_t *)malloc(sizeof(test_object_instance_t));
    #####:   64:    if (NULL == targetP) return NULL;
    #####:   65:    memset(targetP, 0, sizeof(test_object_instance_t));
    #####:   66:    targetP->shortID = instance_id;
        -:   67:
    #####:   68:    targetP->test_i8 =  -0x0F;
    #####:   69:    targetP->test_i16 = -0x0FFF;
    #####:   70:    targetP->test_i32 = -0x0FFFFFFF;
    #####:   71:    targetP->test_i64 = -0x0FFFFFFFFFFFF;
        -:   72:
    #####:   73:    targetP->test_u8 =  0x0F;
    #####:   74:    targetP->test_u16 = 0x0FFF;
    #####:   75:    targetP->test_u32 = 0x0FFFFFFF;
        -:   76:
    #####:   77:    targetP->test_bool = true;
        -:   78:
    #####:   79:    targetP->test_double = 0.12;
        -:   80:
    #####:   81:    targetP->test_str = "test";
        -:   82:
    #####:   83:    targetP->test_str_prealloc.reserved_len = 20;
    #####:   84:    strncpy((char*)targetP->test_str_prealloc.data, "test", targetP->test_str_prealloc.reserved_len);
    #####:   85:    targetP->test_str_prealloc.used_len = 4;
        -:   86:
    #####:   87:    targetP->test_opaque.data = (uint8_t*)"test";
    #####:   88:    targetP->test_opaque.reserved_len = 0;
    #####:   89:    targetP->test_opaque.used_len = 4;
        -:   90:
    #####:   91:    memcpy(targetP->test_opaque_prealloc.data, "ab\0\nab", 6);
    #####:   92:    targetP->test_opaque_prealloc.reserved_len = 20;
    #####:   93:    targetP->test_opaque_prealloc.used_len = 6;
        -:   94:
    #####:   95:    targetP->test_oaque_empty.reserved_len = 20;
    #####:   96:    targetP->test_oaque_empty.used_len = 0;
        -:   97:
    #####:   98:    targetP->test_read_fun_int8 = readFun8;
    #####:   99:    targetP->test_read_fun_uint32 = readFun32;
    #####:  100:    targetP->test_read_fun_string = readFunStr;
    #####:  101:    targetP->test_write_fun_string = writeFunStr;
    #####:  102:    targetP->test_readWrite_fun_string.read = readFunStr;
    #####:  103:    targetP->test_readWrite_fun_string.write = writeFunStr;
    #####:  104:    targetP->test_execute_fun = execFun;
        -:  105:
    #####:  106:    return (lwm2m_list_t*)targetP;
        -:  107:}
        -:  108:
    #####:  109:bool test_object_write_verify_cb(lwm2m_list_t* instance, uint16_t changed_res_id) {
    #####:  110:    test_object_instance_t* i = (test_object_instance_t*)instance;
    #####:  111:    if(changed_res_id==7 && (i->test_double > 1.0 || i->test_double < 0.0)) return false;
        -:  112:
    #####:  113:    return true;
        -:  114:}
