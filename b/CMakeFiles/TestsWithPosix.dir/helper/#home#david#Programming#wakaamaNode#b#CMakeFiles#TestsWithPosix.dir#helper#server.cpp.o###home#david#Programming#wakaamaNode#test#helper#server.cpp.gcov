        -:    0:Source:/home/david/Programming/wakaamaNode/test/helper/server.cpp
        -:    0:Graph:/home/david/Programming/wakaamaNode/b/CMakeFiles/TestsWithPosix.dir/helper/server.cpp.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*******************************************************************************
        -:    2: * Copyright (c) 2017-2018  David Graeff <david.graeff@web.de>
        -:    3: *
        -:    4: * Permission is hereby granted, free of charge, to any person obtaining a copy
        -:    5: * of this software and associated documentation files (the "Software"), to deal
        -:    6: * in the Software without restriction, including without limitation the rights
        -:    7: * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        -:    8: * copies of the Software, and to permit persons to whom the Software is
        -:    9: * furnished to do so, subject to the following conditions:
        -:   10: *
        -:   11: * The above copyright notice and this permission notice shall be included in
        -:   12: * all copies or substantial portions of the Software.
        -:   13: */
        -:   14:#include "server.h"
        -:   15:#include "lwm2m/c_connect.h"
        -:   16:#include "lwm2m/server.h"
        -:   17:#include "lwm2m/network.h"
        -:   18:#include "with_lwip/lwip_tap_helper.h"
        -:   19:#include <gtest/gtest.h>
        -:   20:
        -:   21:const char Lwm2mServer::PSK[] = "psk";
        -:   22:unsigned short Lwm2mServer::PSK_LEN = 3;
        -:   23:const char Lwm2mServer::PUBLICID[] = "publicid";
        -:   24:
    #####:   25:static void prv_monitor_callback(uint16_t clientID,
        -:   26:                                 lwm2m_uri_t * uriP,
        -:   27:                                 int status,
        -:   28:                                 lwm2m_media_type_t format,
        -:   29:                                 uint8_t * data,
        -:   30:                                 int dataLength,
        -:   31:                                 void * userData)
        -:   32:{
        -:   33:    (void)uriP; (void)format; (void)data; (void)dataLength;
    #####:   34:    Lwm2mServer* t = (Lwm2mServer*) userData;
    #####:   35:    lwm2m_context_t * lwm2mH = t->server_context;
        -:   36:    lwm2m_client_t * targetP;
        -:   37:
    #####:   38:    switch (status)
        -:   39:    {
    #####:   40:    case COAP_201_CREATED:
    #####:   41:        targetP = (lwm2m_client_t *)lwm2m_list_find((lwm2m_list_t *)lwm2mH->clientList, clientID);
    #####:   42:        t->connected_client_name = targetP->name;
        -:   43:        //prv_dump_client(targetP);
    #####:   44:        break;
        -:   45:
    #####:   46:    case COAP_202_DELETED:
    #####:   47:        t->connected_client_name.clear ();
    #####:   48:        break;
        -:   49:
    #####:   50:    case COAP_204_CHANGED:
    #####:   51:        t->incClientUpdate();
        -:   52:        //prv_dump_client(targetP);
    #####:   53:        break;
        -:   54:
    #####:   55:    default:
    #####:   56:        break;
        -:   57:    }
    #####:   58:}
        -:   59:
    #####:   60:Lwm2mServer::Lwm2mServer(std::mutex* mutex) : mutex(mutex) {
        -:   61:
    #####:   62:}
        -:   63:
    #####:   64:std::string Lwm2mServer::getConnectClientName() const {
    #####:   65:    return connected_client_name;
        -:   66:}
        -:   67:
    #####:   68:void Lwm2mServer::init(bool useDtls) {
    #####:   69:    if (server_context) return;
    #####:   70:    assert(thread==nullptr);
        -:   71:
    #####:   72:    client_updated = 0;
    #####:   73:    connected_client_name.clear ();
        -:   74:    
    #####:   75:    server_context = lwm2m_init(nullptr);
    #####:   76:    server_context->state = STATE_READY;
    #####:   77:    ASSERT_TRUE(server_context);
        -:   78:
        -:   79:    //// init server thread ////
        -:   80:
        -:   81:    // Install a monitoring callback for the server lwm2m context.
        -:   82:    // We check for the COAP_201_CREATED and COAP_202_DELETED events
    #####:   83:    lwm2m_set_monitoring_callback(server_context, prv_monitor_callback, this);
    #####:   84:    int server_bound_sockets = lwm2m_network_init(server_context,
    #####:   85:                                              useDtls ? LWM2M_DEFAULT_SECURE_SERVER_PORT : LWM2M_DEFAULT_SERVER_PORT);
    #####:   86:    ASSERT_LE(1, server_bound_sockets);
    #####:   87:    ASSERT_TRUE(server_context->userData!=NULL);
        -:   88:
        -:   89:    //// If DTLS: Set server public ID and preshared key
    #####:   90:    if (useDtls)
    #####:   91:        lwm2m_server_dtls_psk(server_context,PUBLICID,PSK,PSK_LEN);
        -:   92:    
    #####:   93:    server_running = true;
        -:   94:
        -:   95:    #ifdef POSIX_NETWORK
    #####:   96:    pipe(pfds);
    #####:   97:    ev.events=EPOLLIN | EPOLLPRI | EPOLLONESHOT;
    #####:   98:    ev.data.fd=pfds[0];
    #####:   99:    errno=0;
    #####:  100:    network_t* network = (network_t*)server_context->userData;
    #####:  101:    epoll_ctl(network->epfd, EPOLL_CTL_ADD, ev.data.fd, &ev);
    #####:  102:    assert (errno==0);
        -:  103:    #endif
        -:  104:
    #####:  105:    thread = new std::thread([this]() { loop(); });
        -:  106:}
        -:  107:
    #####:  108:void Lwm2mServer::loop() {
    #####:  109:    while (server_running) {
    #####:  110:        struct timeval next_event = {0,50*1000};
        -:  111:        {
    #####:  112:            std::lock_guard<std::mutex> guard(*mutex);
    #####:  113:            lwm2m_process (server_context,&next_event);
        -:  114:        }
    #####:  115:        lwm2m_block_wait(server_context,next_event);
        -:  116:    }
    #####:  117:    int last10 = 10;
    #####:  118:    while (last10--) {
    #####:  119:        struct timeval next_event = {0,5000};
        -:  120:        {
    #####:  121:            std::lock_guard<std::mutex> guard(*mutex);
    #####:  122:            lwm2m_process (server_context,&next_event);
    #####:  123:            if (!server_context->serverList ||
    #####:  124:                    server_context->serverList->status==STATE_DEREGISTERED)
        -:  125:                break;
        -:  126:        }
    #####:  127:        lwm2m_block_wait(server_context,next_event);
        -:  128:    }
    #####:  129:}
        -:  130:
    #####:  131:Lwm2mServer::~Lwm2mServer() {
    #####:  132:    release();
    #####:  133:}
        -:  134:
    #####:  135:void Lwm2mServer::release() {
    #####:  136:    if (!server_context) return;
        -:  137:    
    #####:  138:    server_running=false;
        -:  139:    #ifdef POSIX_NETWORK
    #####:  140:    char c = 1;
    #####:  141:    write(pfds[1], &c, 1);
        -:  142:    #endif
    #####:  143:    thread->join();
    #####:  144:    delete thread;
    #####:  145:    thread = nullptr;
        -:  146:
        -:  147:    #ifdef POSIX_NETWORK
    #####:  148:    close(pfds[0]);
    #####:  149:    close(pfds[1]);
        -:  150:    #endif
        -:  151:
    #####:  152:    lwm2m_close (server_context);
    #####:  153:    lwm2m_network_close(server_context);
    #####:  154:    lwm2m_free(server_context);
    #####:  155:    server_context = nullptr;
        -:  156:}
