{
    "docs": [
        {
            "location": "/", 
            "text": "WakaamaNode \n \n\n\n\n.w3-left{float:left!important}\n.w3-container:after,.w3-container:before{content:\"\";display:table;clear:both}\n.w3-circle{border-radius:50%}\n.w3-container,.w3-panel{padding:0.01em 16px}\n.w3-card{box-shadow:0 1px 5px 0 rgba(0,0,0,0.16),0 1px 10px 0 rgba(0,0,0,0.12);max-width:400px;margin:5px;margin-bottom:15px;position:relative;}\n.w3-card > hr {margin:0;}\n.w3-card > ul {margin-right: .625em;}\n.w3-card-4,.w3-hover-shadow:hover{box-shadow:0 4px 10px 0 rgba(0,0,0,0.2),0 4px 20px 0 rgba(0,0,0,0.19)}\n\n.md-sidebar--secondary,.md-sidebar--primary {\n  display: none;\n}\n@media only screen and (min-width: 60em) {\n  .md-content {\n    margin-right: 0;\n    margin-left: 0;\n  }\n}\n.card tr:nth-child(even){background-color: #f2f2f2;}\n\n.card tr:hover {background-color: #ddd;}\n\n.bottom-link{border:none;display:inline-block;padding:8px 16px;vertical-align:middle;overflow:hidden;text-decoration:none;color:inherit;background-color:inherit;text-align:center;cursor:pointer;white-space:nowrap;width:100%;padding: .75rem 1.25rem;\n    background-color: rgba(0,0,0,.03);\n    border-top: 1px solid rgba(0,0,0,.125);position:absolute;bottom:0px;}\n.bottom-link:hover{box-shadow:none;color:#000!important;background-color:#ccc!important}\n\n.brands:hover {\n    text-decoration: none;\n}\n.brand-espresiff {\n    background-position: 0 -440px!important;\n    width: 108px;\n}\n.brand-arduino {\n    background-position: 0 -80px!important;\n    width: 60px;\n}\n.brands {\n    background: url(assets/brands.png) no-repeat;\n    height: 40px;\n    display: inline-block;\n    vertical-align: middle;\n}\ndetails.info {\n    font-size: inherit;\n}\n\n\n\n\nThis is a high level Lightweight M2M library with a convenient C and C++ API optimized to run on embedded/constrained devices.\nIt embeds parts of \nEclipse Wakaama\n for lwm2m protocol details.\n\n\nLightweight M2M is a protocol from the Open Mobile Alliance for M2M/IoT device management and communication\n\nIt is a convention on top of CoAP/UDP, a light and compact protocol with an efficient resource data model.\nIt follows a server/client architecture with Request/Response semantics (GET, POST, PUT, DELETE), as well as observable resources.\nOptional DTLS (Datagram TLS) ensures secure communication between LWM2M Servers and LWM2M Clients.\nThe CoAP/lwM2M data model is explained on the \nObject API\n page.\n\n\n\n\n\n\n\n    \n\n        \n3 Platform integrations\n\n        \nposix/win32, esp8266-sdk, freertos\n\n    \n\n    \n\n        \nSupports 2 Network stacks\n\n        \nposix/win32, lwIP\n\n    \n\n    \n\n        \n2 Firmware update integrations\n\n        \nposix/Win32, ESP OTA\n\n    \n\n\n\n\n\n\n\n\n\n\n    \n\n    Connection API\n    \n\n\n    \n\n    The connection API hides away complexity of different required lwm2m objects (security, server and device).\n    \n\n\n    \n\n    \n\n    \nConnect with Dtls PSK encryption\n\n    \nUDP and UDP Queue mode support\n\n    \nAccess native socket handlers\n\n    \nFull network lifetime control\n\n    \nReconnect API\n\n    \nFirmware update object support \n\ud83d\udc49\n\n    \nProvide device information and state\n\n    \n\n\n    \n\n    \nC/C++ Connection/Device/Firmware API\n\n\n\n\n\n\n    \n\n    Object definition API\n    \n\n\n    \n\n    The object definition API provides elegant macros for C and a sophisticated\n    resource efficient class model for C++ to define custom lwm2m objects and resources.\n\n    \n\n\n    \n\n    \n\n    \nThe same API is used to provide all lwm2m registry objects.\n\n    \nStore resource values in object instances or let them be handed over to functions.\n\n    \nRead resource values from object instances or let those be acquired from function calls.\n\n    \n\n\n    \n\n    \nC/C++ Custom Object API\n\n\n\n\n\n\n\n    \n\n    OMA Object \n&\n Resource Registry\n    \n\n\n    \n\n    Standardised object and resource identifiers via the \nOMA Object \n&\n Resource Registry\n.\n    \n\n    \n\n\n    \nExamples\n\n    \n\n\n    \n\n    \n\n    \n\n    \nObject 3311\n - Light control\n\n    This Object is used to control a light source, such as a LED or other light. It allows a light to be turned on or off and \n\n    \n\n    \n\n\n    \n\n    \n\n    \n\n    \nObject 3312\n - Power sources\n    \n\n    It allows a power relay to be turned on or off and its dimmer setting to be control \n\n    \n\n    \n\n\n    \n\n    \n\n    \n\n\n    \n\n\n    \n\n    \nC++ API for lwm2m registry objects\n\n\n\n\n\n\n    \n\n    Stability / Low maintenance\n    \n\n\n    \n\n    \n\n    \nStable\n: Object, Connect and internal API fully covered by extensive tests.\n\n    Plain + dtls connection tests against the \nembedded wakaama\n and \nexternal leshan\n lwm2m server.\n    \n\ud83d\udc49 More info\n\n    \n\n\n    \n\n    \nTrust\n: The library is following the SemVer versioning schema and guarantees no API breakage.\n    \n\n\n    \n\n    \nLow maintenance\n: Automatic transformation of newest lwm2m registry objects into c++ classes. Automatic external code sync scripts.\n\n    \n\n\n    \n\n\n\n\n\n\n    \n\n    Embedded in mind\n    \n\n\n    \n\n    \n\n    \nPlatform/network abstraction\n\n        \n\ud83d\udc49 Implement your own\n\n    \nMain loop based.\n\n        \n\ud83d\udc49 epoll support on Posix/Win32\n\n    \nFull memory control\n\n        \n\ud83d\udc49 Fixed memory allocation support\n\n        \n\ud83d\udc49 Customize buffers via config file\n\n    \nSlim mono thread design.\n\n        \n\ud83d\udc49 Prepared for multi-thread object instance access.\n\n    \n\n\n\n\n\n\n    \n\n    Security\n    \n\n\n    \n\n    Automatic, periodic synchronisation to the \nlatest mbedTLS sources\n.\n    \n\n\n    \n\n    \n\n    \nSupports PSK mode with \nAES_128_CCM_8\n, \nAES_128_CBC_SHA256\n\n    \nSupports Raw Public Key Certificates mode ECDHE_ECDSA with \nAES_128_CCM_8\n, \nAES_128_CBC_SHA256\n\n    \nSupports X.509v3 Certificates mode\n\n    \nMore cipher suits can be enabled in the configuration file\n\n    \n\n\n    \n\n\n    \nCustom network \n DTLS\n\n\n\n\n\n\n\n\nGetting started\n\n\nHead over to the \nGet started\n page to dive right into installing and including the library in your project.\n\n\nLicense\n\n\nThis library including the platform code, tests and API wrappers are provided under the MIT license.\nWakaama is provided under the Eclipse Public License - v2.0.\n\n\n\n\n\n  \n\n  \n \n  \n\n\n\n\n\n\n\n    \n PlatformIO", 
            "title": "Lightweight M2M library"
        }, 
        {
            "location": "/#wakaamanode", 
            "text": ".w3-left{float:left!important}\n.w3-container:after,.w3-container:before{content:\"\";display:table;clear:both}\n.w3-circle{border-radius:50%}\n.w3-container,.w3-panel{padding:0.01em 16px}\n.w3-card{box-shadow:0 1px 5px 0 rgba(0,0,0,0.16),0 1px 10px 0 rgba(0,0,0,0.12);max-width:400px;margin:5px;margin-bottom:15px;position:relative;}\n.w3-card > hr {margin:0;}\n.w3-card > ul {margin-right: .625em;}\n.w3-card-4,.w3-hover-shadow:hover{box-shadow:0 4px 10px 0 rgba(0,0,0,0.2),0 4px 20px 0 rgba(0,0,0,0.19)}\n\n.md-sidebar--secondary,.md-sidebar--primary {\n  display: none;\n}\n@media only screen and (min-width: 60em) {\n  .md-content {\n    margin-right: 0;\n    margin-left: 0;\n  }\n}\n.card tr:nth-child(even){background-color: #f2f2f2;}\n\n.card tr:hover {background-color: #ddd;}\n\n.bottom-link{border:none;display:inline-block;padding:8px 16px;vertical-align:middle;overflow:hidden;text-decoration:none;color:inherit;background-color:inherit;text-align:center;cursor:pointer;white-space:nowrap;width:100%;padding: .75rem 1.25rem;\n    background-color: rgba(0,0,0,.03);\n    border-top: 1px solid rgba(0,0,0,.125);position:absolute;bottom:0px;}\n.bottom-link:hover{box-shadow:none;color:#000!important;background-color:#ccc!important}\n\n.brands:hover {\n    text-decoration: none;\n}\n.brand-espresiff {\n    background-position: 0 -440px!important;\n    width: 108px;\n}\n.brand-arduino {\n    background-position: 0 -80px!important;\n    width: 60px;\n}\n.brands {\n    background: url(assets/brands.png) no-repeat;\n    height: 40px;\n    display: inline-block;\n    vertical-align: middle;\n}\ndetails.info {\n    font-size: inherit;\n}  This is a high level Lightweight M2M library with a convenient C and C++ API optimized to run on embedded/constrained devices.\nIt embeds parts of  Eclipse Wakaama  for lwm2m protocol details.  Lightweight M2M is a protocol from the Open Mobile Alliance for M2M/IoT device management and communication \nIt is a convention on top of CoAP/UDP, a light and compact protocol with an efficient resource data model.\nIt follows a server/client architecture with Request/Response semantics (GET, POST, PUT, DELETE), as well as observable resources. Optional DTLS (Datagram TLS) ensures secure communication between LWM2M Servers and LWM2M Clients. The CoAP/lwM2M data model is explained on the  Object API  page.    \n     \n         3 Platform integrations \n         posix/win32, esp8266-sdk, freertos \n     \n     \n         Supports 2 Network stacks \n         posix/win32, lwIP \n     \n     \n         2 Firmware update integrations \n         posix/Win32, ESP OTA \n         \n     \n    Connection API\n     \n\n     \n    The connection API hides away complexity of different required lwm2m objects (security, server and device).\n     \n\n     \n     \n     Connect with Dtls PSK encryption \n     UDP and UDP Queue mode support \n     Access native socket handlers \n     Full network lifetime control \n     Reconnect API \n     Firmware update object support  \ud83d\udc49 \n     Provide device information and state \n     \n\n     \n     C/C++ Connection/Device/Firmware API   \n     \n    Object definition API\n     \n\n     \n    The object definition API provides elegant macros for C and a sophisticated\n    resource efficient class model for C++ to define custom lwm2m objects and resources. \n     \n\n     \n     \n     The same API is used to provide all lwm2m registry objects. \n     Store resource values in object instances or let them be handed over to functions. \n     Read resource values from object instances or let those be acquired from function calls. \n     \n\n     \n     C/C++ Custom Object API   \n     \n    OMA Object  &  Resource Registry\n     \n\n     \n    Standardised object and resource identifiers via the  OMA Object  &  Resource Registry .\n     \n     \n\n     Examples \n     \n\n     \n     \n     \n     Object 3311  - Light control \n    This Object is used to control a light source, such as a LED or other light. It allows a light to be turned on or off and  \n     \n     \n\n     \n     \n     \n     Object 3312  - Power sources\n     \n    It allows a power relay to be turned on or off and its dimmer setting to be control  \n     \n     \n\n     \n     \n     \n\n     \n\n     \n     C++ API for lwm2m registry objects   \n     \n    Stability / Low maintenance\n     \n\n     \n     \n     Stable : Object, Connect and internal API fully covered by extensive tests. \n    Plain + dtls connection tests against the  embedded wakaama  and  external leshan  lwm2m server.\n     \ud83d\udc49 More info \n     \n\n     \n     Trust : The library is following the SemVer versioning schema and guarantees no API breakage.\n     \n\n     \n     Low maintenance : Automatic transformation of newest lwm2m registry objects into c++ classes. Automatic external code sync scripts. \n     \n\n       \n     \n    Embedded in mind\n     \n\n     \n     \n     Platform/network abstraction \n         \ud83d\udc49 Implement your own \n     Main loop based. \n         \ud83d\udc49 epoll support on Posix/Win32 \n     Full memory control \n         \ud83d\udc49 Fixed memory allocation support \n         \ud83d\udc49 Customize buffers via config file \n     Slim mono thread design. \n         \ud83d\udc49 Prepared for multi-thread object instance access. \n       \n     \n    Security\n     \n\n     \n    Automatic, periodic synchronisation to the  latest mbedTLS sources .\n     \n\n     \n     \n     Supports PSK mode with  AES_128_CCM_8 ,  AES_128_CBC_SHA256 \n     Supports Raw Public Key Certificates mode ECDHE_ECDSA with  AES_128_CCM_8 ,  AES_128_CBC_SHA256 \n     Supports X.509v3 Certificates mode \n     More cipher suits can be enabled in the configuration file \n     \n\n     \n\n     Custom network   DTLS", 
            "title": "WakaamaNode"
        }, 
        {
            "location": "/#getting-started", 
            "text": "Head over to the  Get started  page to dive right into installing and including the library in your project.", 
            "title": "Getting started"
        }, 
        {
            "location": "/#license", 
            "text": "This library including the platform code, tests and API wrappers are provided under the MIT license.\nWakaama is provided under the Eclipse Public License - v2.0.   \n   \n    \n      \n      PlatformIO", 
            "title": "License"
        }, 
        {
            "location": "/testing/", 
            "text": "Automated tests\n\n\nTravis CI is executed on every commit. The following functionality is tested:\n\n\n\n\n The Object API for C\n\n\n Reading/Writing of c-strings and opaque memory\n\n\n Reading/Writing of boolean, int, double.\n\n\n Executing of function pointers.\n\n\n WriteVerify method is called correctly\n\n\n Object discovery works\n\n\n\n\n\n\n The Object API for C++\n\n\n Reading/Writing of c-strings and opaque memory\n\n\n Reading/Writing of boolean, int, double.\n\n\n Reading/Writing of all types above via indirect reading from a function, writing to a function\n\n\n WriteVerify method is called correctly\n\n\n Executable resources: Execute a function pointer\n\n\n Object discovery works\n\n\n\n\n\n\n The connect API in C/C++ on Posix\n\n\n Add/Remove servers\n\n\n Connect to a (wakaama lwm2m) server. On the server side: Make sure client objects are discovered\n\n\n Connect to a (wakaama lwm2m) server via dtls. On the server side: Make sure client objects are discovered\n\n\n Memory allocations match deallocations\n\n\n\n\n\n\n The connect API on LWIP\n\n\n Building the implementation\n\n\n A running example with LWIP. \ntun/tap is required on travis for this to work\n.\n\n\n\n\n\n\n Firmware updates\n\n\n On linux\n\n\n On windows\n\n\n On esp8266\n\n\n With http PULL\n\n\n With coap PUSH\n\n\n\n\n\n\nExamples\n\n\n Build all examples\n\n\n C++ example: Connext to the public leshan lwm2m server with DTSL\n\n\n C example: Connect to the public leshan lwm2m server", 
            "title": "Testing"
        }, 
        {
            "location": "/testing/#automated-tests", 
            "text": "Travis CI is executed on every commit. The following functionality is tested:    The Object API for C   Reading/Writing of c-strings and opaque memory   Reading/Writing of boolean, int, double.   Executing of function pointers.   WriteVerify method is called correctly   Object discovery works     The Object API for C++   Reading/Writing of c-strings and opaque memory   Reading/Writing of boolean, int, double.   Reading/Writing of all types above via indirect reading from a function, writing to a function   WriteVerify method is called correctly   Executable resources: Execute a function pointer   Object discovery works     The connect API in C/C++ on Posix   Add/Remove servers   Connect to a (wakaama lwm2m) server. On the server side: Make sure client objects are discovered   Connect to a (wakaama lwm2m) server via dtls. On the server side: Make sure client objects are discovered   Memory allocations match deallocations     The connect API on LWIP   Building the implementation   A running example with LWIP.  tun/tap is required on travis for this to work .     Firmware updates   On linux   On windows   On esp8266   With http PULL   With coap PUSH    Examples   Build all examples   C++ example: Connext to the public leshan lwm2m server with DTSL   C example: Connect to the public leshan lwm2m server", 
            "title": "Automated tests"
        }, 
        {
            "location": "/legal_notice/", 
            "text": ".md-sidebar--secondary,.md-sidebar--primary {\n  display: none;\n}\n@media only screen and (min-width: 60em) {\n  .md-content {\n    margin-right: 0;\n    margin-left: 0;\n  }\n}\n\n\n\n\nWebpage generator\n\n\nPowered by\n\nMkDocs\n\nand\n\nMaterial for MkDocs\n\n\nUsed Icons on this webpage\n\n\nhttps://www.flaticon.com/free-icon/lamp_982057\n made by \nxnimrodx\n from \nwww.flaticon.com\n is licensed by \nCC 3.0 BY\n\n\nhttps://www.flaticon.com/free-icon/plug_131090\n made by \nIconnice\n from \nwww.flaticon.com\n is licensed by \nCC 3.0 BY", 
            "title": "Legal notice"
        }, 
        {
            "location": "/legal_notice/#webpage-generator", 
            "text": "Powered by MkDocs \nand Material for MkDocs", 
            "title": "Webpage generator"
        }, 
        {
            "location": "/legal_notice/#used-icons-on-this-webpage", 
            "text": "https://www.flaticon.com/free-icon/lamp_982057  made by  xnimrodx  from  www.flaticon.com  is licensed by  CC 3.0 BY  https://www.flaticon.com/free-icon/plug_131090  made by  Iconnice  from  www.flaticon.com  is licensed by  CC 3.0 BY", 
            "title": "Used Icons on this webpage"
        }, 
        {
            "location": "/privacy_policy/", 
            "text": ".md-sidebar--secondary,.md-sidebar--primary {\n  display: none;\n}\n@media only screen and (min-width: 60em) {\n  .md-content {\n    margin-right: 0;\n    margin-left: 0;\n  }\n}\n\n\n\n\nGoogle Analytics\n\n\nLike millions of other websites, this page uses Google Analytics. Google Analytics monitors the activity of users of the website, which allows us to improve the quality of the content. Google Analytics uses cookies, a small piece of information stored on your computer, to uniquely identify each visitor.\n\n\nThe information collected by Google Analytics includes:\n\n\n\n\nwhat website you came from (for example github.com)\n\n\nwhat pages did you visit on here\n\n\nhow long did you stay\n\n\n\n\nWe use these data to understand how people use the website (\nhttps://openhab-nodes.github.io/wakaamaNode/\n) so as to improve them. \nFor example, we know for sure that the present page is read by very very few people and therefore it deserves less effort than the rest of the site.\nWe never sell or share this data to anyone else.\n\n\nDisqus\n\n\n\n\nDisqus only obtains consent from users for the collection and processing of data necessary for the use of Disqus.\n\n\n\n\nPlease see \nhttps://disqus.com/support/\n about the data that Disqus may store about you, when visiting any subpage on this website.\nDisquis is not used on this page and the welcome page.", 
            "title": "Privacy policy"
        }, 
        {
            "location": "/privacy_policy/#google-analytics", 
            "text": "Like millions of other websites, this page uses Google Analytics. Google Analytics monitors the activity of users of the website, which allows us to improve the quality of the content. Google Analytics uses cookies, a small piece of information stored on your computer, to uniquely identify each visitor.  The information collected by Google Analytics includes:   what website you came from (for example github.com)  what pages did you visit on here  how long did you stay   We use these data to understand how people use the website ( https://openhab-nodes.github.io/wakaamaNode/ ) so as to improve them. \nFor example, we know for sure that the present page is read by very very few people and therefore it deserves less effort than the rest of the site.\nWe never sell or share this data to anyone else.", 
            "title": "Google Analytics"
        }, 
        {
            "location": "/privacy_policy/#disqus", 
            "text": "Disqus only obtains consent from users for the collection and processing of data necessary for the use of Disqus.   Please see  https://disqus.com/support/  about the data that Disqus may store about you, when visiting any subpage on this website.\nDisquis is not used on this page and the welcome page.", 
            "title": "Disqus"
        }, 
        {
            "location": "/quickstart/getting-started/", 
            "text": "Periodic synchronisation and checking tests with newest platformio code may cause tests in the master branch to fail, please use a tagged release of the library in this case.\nIf the tests do not fail, it is safe to assume that the library works as expected. \n\n\nCurrent status: \n\n\nInstalling WakamaNode for \nPlatformIO\n development\n\n\nIn a terminal, run \nplatformio lib install WakamaNode\n.\n\n\nAdd this in your \nplatformio.ini\n for the development branch:\n\n\nlib_deps = git+https://github.com/Openhab-Nodes/wakaamaNode.git#master\n\n\n\n\nAdd this in your \nplatformio.ini\n for the release branch:\n\n\nlib_deps = git+https://github.com/Openhab-Nodes/wakaamaNode.git#v1.0\n\n\n\n\nDependencies are installed automatically.\n\n\nSome build flags can to be provided to enable certain platform codes:\n\n\n\n\nNetwork stack: Compile with \nPOSIX_NETWORK\n for posix network sockets or with \nLWIP\n for the lwIP stack support.\n  Windows and Unix/Linux builds automatically pick the posix/bsd socket API if \nLWIP\n is not set.\n\n\nPlatform (memory, time): Compile with \nESP8266\n for ESP8266 SDK support, \nPOSIX\n for posix/windows system functions, \nFREERTOS\n for freeRTOS support.\n  Windows and Unix/Linux builds automatically pick the posix/windows platform code.\n\n\n\n\nUse CMake build system\n\n\nIf you target an x86 system, you may use the cmake buildsystem instead.\n\n\n\n\nDownload the library \nhttps://github.com/Openhab-Nodes/wakaamaNode/archive/master.zip\n\n\nExtract it to \nwakaamaNode\n.\n\n\nInclude the \nwakaamaNode/src/src.cmake\n file like in the following example:\n\n\n\n\nproject\n(\nYOUR_PROJECT\n)\n\n\ninclude\n(\n${\nCMAKE_CURRENT_LIST_DIR\n}\n/wakaamaNode/src/src.cmake\n)\n\n\n\nadd_executable\n(\n${\nPROJECT_NAME\n}\n \n${\nYOUR_FILES\n}\n \n${\nWAKAAMA_NODE_DIR_SOURCES\n}\n)\n\n\n\n# We need C++11 and C11 support\n\n\ntarget_compile_features\n(\n${\nPROJECT_NAME\n}\n \nPRIVATE\n \ncxx_range_for\n)\n\n\nset_property\n(\nTARGET\n \n${\nPROJECT_NAME\n}\n \nPROPERTY\n \nC_STANDARD\n \n11\n)\n\n\n\n# Include directories\n\n\ntarget_include_directories\n(\n${\nPROJECT_NAME\n}\n \nPRIVATE\n \n{WAKAAMA_NODE_DIR_INCLUDE_DIRS}\n)\n\n\n\n# Some definitions\n\n\ntarget_compile_definitions\n(\n${\nPROJECT_NAME\n}\n \nPUBLIC\n \n${\nWAKAAMA_DEFINITIONS\n}\n)\n\n\n\n\n\nBare minimum sketch\n\n\nThe following example shows you some key aspects of the library. In particular:\n\n\n\n\nHow to connect to a lwm2m server, if enabled with a preshared key DTLS connection. (It is assumed that you are network connected already.)\n\n\nHow to set device describing attributes.\n\n\nHow to use a predefined object and object instance: In this case object 3311 (light control).\n\n\nHow to react to an object write via the \nverifyWrite\n function.\n\n\nHow to update an object instance resource via the \nlights.resChanged\n call.\n\n\n\n\nHeaders and long living objects\n\n\nInclude required headers and define your lwm2m objects, instances and the lwm2m client context:\n\n\n#include\n \ntime.h\n\n\n#include\n \nArduino.h\n\n\n\n#include\n \nlwm2m/connect.h\n\n\n#include\n \nlwm2m/objects.h\n\n\n#include\n \nlwm2m/debug.h\n\n\n\n#include\n \nlwm2mObjects/3311.h\n\n\n\nusing\n \nnamespace\n \nKnownObjects\n;\n\n\n\nid3311\n::\nobject\n \nlights\n;\n\n\nid3311\n::\ninstance\n \nledsInstance\n;\n\n\n\n// If this context object goes out of scope, you will be\n\n\n// disconnected from all connected servers automatically.\n\n\nLwM2MConnect\n \ncontext\n(\ntestClient\n);\n\n\n\n\n\nDevice infomation\n\n\nTell the lwm2m client context about your device:\n\n\ninline\n \nvoid\n \nsetupDeviceInfo\n()\n \n{\n\n    \ncontext\n.\ndeviceInstance\n.\nmanufacturer\n \n=\n \ntest manufacturer\n;\n\n    \ncontext\n.\ndeviceInstance\n.\nmodel_name\n \n=\n \ntest model\n;\n\n    \ncontext\n.\ndeviceInstance\n.\ndevice_type\n \n=\n \nsensor\n;\n\n    \ncontext\n.\ndeviceInstance\n.\nfirmware_ver\n \n=\n \n1.0\n;\n\n    \ncontext\n.\ndeviceInstance\n.\nserial_number\n \n=\n \n140234-645235-12353\n;\n\n    \n// if LWM2M_DEV_INFO_TIME is enabled\n\n    \ncontext\n.\ndeviceInstance\n.\ntime_offset\n \n=\n \n5\n;\n\n    \ncontext\n.\ndeviceInstance\n.\ntimezone\n \n=\n \n+05:00\n;\n\n\n}\n\n\n\n\n\nConfigure your lwm2m objects\n\n\nConfigure your lwm2m objects. In this case, we want a lwm2m light object (id: 3311)\nand one instance. When a write happens on the instance, set a LED on/off:\n\n\ninline\n \nvoid\n \nconfigureLwm2mObjects\n()\n \n{\n\n\n    \n// Overwrite the verify function and \nabuse\n it as value changed event.\n\n    \nlights\n.\nverifyWrite\n \n=\n \n[](\nid3311\n::\ninstance\n*\n \ni\n,\n \nuint16_t\n \nres_id\n)\n \n{\n\n        \n// Is it instance 0 and the OnOff resource?\n\n        \nif\n \n(\ni\n-\nid\n \n==\n \n0\n \n \nres_id\n \n==\n \nid3311\n::\nRESID\n::\nOnOff\n)\n \n{\n\n            \n// Change the led pin depending on the OnOff value\n\n            \ndigitalWrite\n(\nLED_BUILTIN\n,\n \ni\n-\nOnOff\n);\n\n        \n}\n\n        \n// Return true to accept the value and ACK to the server\n\n        \nreturn\n \ntrue\n;\n\n    \n};\n\n\n    \nledsInstance\n.\nid\n \n=\n \n0\n;\n \n// set instance id\n\n    \nlights\n.\naddInstance\n(\nCTX\n(\ncontext\n),\n \nledsInstance\n);\n\n    \nlights\n.\nregisterObject\n(\nCTX\n(\ncontext\n),\n \nfalse\n);\n\n\n    \n// Initialize the LED_BUILTIN pin as an output\n\n    \npinMode\n(\nLED_BUILTIN\n,\n \nOUTPUT\n);\n\n\n}\n\n\n\n\n\nAdd lwm2m server(s)\n\n\nAdd lwm2m server and configure DTLS (if enabled):\n\n\nvoid\n \nsetup\n()\n \n{\n\n    \nsetupDeviceInfo\n();\n\n    \nconfigureLwm2mObjects\n();\n\n\n    \nconnectToYourNetwork\n();\n\n\n    \nif\n \n(\n!\ncontext\n.\nsocket_count\n())\n\n        \nprintf\n(\nFailed to open socket\n\\n\n);\n\n\n    \n// Add a lwm2m server with unique id 123, lifetime of 100s, no storing of\n\n    \n// unsend messages. The host url is either coap:// or coaps://.\n\n    \ncontext\n.\nadd_server\n(\n123\n,\n \ncoap://192.168.1.18\n,\n \n100\n,\n \nfalse\n);\n\n\n    \n// Enter your DTLS connection information\n\n    \n#ifdef LWM2M_WITH_DTLS\n\n    \ncontext\n.\nuse_dtls_psk\n(\n123\n,\n \npublicid\n,\n \nPSK\n,\n \nsizeof\n(\nPSK\n));\n\n    \n#endif\n\n\n}\n\n\n\n\n\nMain event loop\n\n\nYour main event loop need to call \ncontext.process\n. Also call \nwatch_and_reconnect\n if you\nwant to automatically reconnect on a lost connection. On Posix you can call \nblock_wait\n to\nmake the process sleep until udp activity or the next due time:\n\n\nvoid\n \nloop\n()\n \n{\n\n    \nstruct\n \ntimeval\n \ntime_to_next_call\n{\n20\n,\n0\n};\n\n\n    \nint\n \nresult\n \n=\n \ncontext\n.\nprocess\n(\ntime_to_next_call\n);\n\n    \nif\n \n(\nresult\n \n==\n \nCOAP_505_NO_NETWORK_CONNECTION\n)\n \n{\n\n        \n// Couldn\nt open UDP sockets.\n\n        \n// Call lwm2m_network_init again after network is availabe again.\n\n    \n}\n \nelse\n \nif\n \n(\nresult\n \n!=\n \n0\n)\n \n{\n\n        \n// Unexpected error\n\n        \nprint_state\n(\nCTX\n(\ncontext\n));\n\n    \n}\n\n    \n// If a server connetion gets lost, the lwm2m state machine will change into\n\n    \n// BOOTSTRAP_REQUIRED state. The following method will reset the state machine\n\n    \n// and the next process() call will attempt a reconnect.\n\n    \ncontext\n.\nwatch_and_reconnect\n(\ntime_to_next_call\n,\n \n5\n);\n\n\n    \n// You may go into low power mode on an \u00b5C or use context.block_wait() on posix:\n\n    \ncontext\n.\nblock_wait\n(\nnext_event\n);\n\n\n}\n\n\n\n\n\nChange resources and tell the server\n\n\nChange resources on your object instances, but don't forget to call \nresChanged\n:\n\n// Toggle the led by a button press and inform the lwm2m server about the new state\n\n\nvoid\n \npush_button_pressed\n(\nbool\n \nnewState\n)\n \n{\n\n    \nledsInstance\n.\nOnOff\n \n=\n \nnewState\n;\n\n    \ndigitalWrite\n(\nLED_BUILTIN\n,\n \nledsInstance\n.\nOnOff\n);\n\n    \nlights\n.\nresChanged\n(\nCTX\n(\ncontext\n),\n \nledsInstance\n.\nid\n,\n \n(\nuint16_t\n)\nid3311\n::\nRESID\n::\nOnOff\n);\n\n\n}\n\n\n\n\nConfigure features with wakaama_config.h\n\n\nCopy the\n\n examples/nodemcu_with_led_object/src/wakaama_config.h\n\nfile to your project or create a \nwakaama_config.h\n file in your project source directory with the following\ncontent:\n\n\n// Put the library in client mode (you basically always need this)\n\n\n#define LWM2M_CLIENT_MODE\n\n\n\n// Enable json support\n\n\n#define LWM2M_SUPPORT_JSON\n\n\n\n// Enables the wifi object where you may provide information about the wifi strength, connected ssid etc.\n\n\n#define LWM2M_DEV_INFO_WIFI_METRICS\n\n\n\n// Allows to perform a reboot of the device. Implement lwm2m_reboot() for this to work.\n\n\n#define LWM2M_DEVICE_WITH_REBOOT\n\n\n\n// Allows to perform a factory reset. Implement lwm2m_factory_reset() for this to work.\n\n\n// In this method you should erase all user memory, connection setups and so on.\n\n\n#define LWM2M_DEVICE_WITH_FACTORY_RESET\n\n\n\n// Implement lwm2m_get_bat_level() and lwm2m_get_bat_status().\n\n\n#define LWM2M_DEVICE_INFO_WITH_BATTERY\n\n\n\n// Implement lwm2m_get_free_mem() and lwm2m_get_total_mem().\n\n\n#define LWM2M_DEVICE_INFO_WITH_MEMINFO\n\n\n\n// Implement lwm2m_get_last_error() and lwm2m_reset_last_error().\n\n\n#define LWM2M_DEVICE_INFO_WITH_ERRCODE\n\n\n\n// Implement lwm2m_gettime() and update the fields  **timezone** and **time_offset**\n\n\n// of the device information object.\n\n\n#define LWM2M_DEVICE_INFO_WITH_TIME\n\n\n\n// Adds a **hardware_ver** and a **software_ver** c-string field.\n\n\n#define LWM2M_DEVICE_INFO_WITH_ADDITIONAL_VERSIONS\n\n\n\n// Enables the firmware update mechanism.\n\n\n#define LWM2M_FIRMWARE_UPGRADES\n\n\n\n// Enable DTLS support (preshared and public key)\n\n\n#define LWM2M_WITH_DTLS\n\n\n\n// Enable additional support for X.509 certificates and PEM data\n\n\n// #define LWM2M_WITH_DTLS_X509\n\n\n\n// Overwrite maximum packet size. Defaults to 1024 bytes\n\n\n// #define MAX_PACKET_SIZE 1024\n\n\n\n\n\nEdit the file to your needs, by commenting out unwanted features.\n\n\nDemo/Example\n\n\nSee examples in\n\n src/examples\n.\nThe examples including a step-by-step how-to are explained in \nExamples\n.", 
            "title": "Getting started"
        }, 
        {
            "location": "/quickstart/getting-started/#installing-wakamanode-for-platformio-development", 
            "text": "In a terminal, run  platformio lib install WakamaNode .  Add this in your  platformio.ini  for the development branch:  lib_deps = git+https://github.com/Openhab-Nodes/wakaamaNode.git#master  Add this in your  platformio.ini  for the release branch:  lib_deps = git+https://github.com/Openhab-Nodes/wakaamaNode.git#v1.0  Dependencies are installed automatically.  Some build flags can to be provided to enable certain platform codes:   Network stack: Compile with  POSIX_NETWORK  for posix network sockets or with  LWIP  for the lwIP stack support.\n  Windows and Unix/Linux builds automatically pick the posix/bsd socket API if  LWIP  is not set.  Platform (memory, time): Compile with  ESP8266  for ESP8266 SDK support,  POSIX  for posix/windows system functions,  FREERTOS  for freeRTOS support.\n  Windows and Unix/Linux builds automatically pick the posix/windows platform code.", 
            "title": "Installing WakamaNode for PlatformIO development"
        }, 
        {
            "location": "/quickstart/getting-started/#use-cmake-build-system", 
            "text": "If you target an x86 system, you may use the cmake buildsystem instead.   Download the library  https://github.com/Openhab-Nodes/wakaamaNode/archive/master.zip  Extract it to  wakaamaNode .  Include the  wakaamaNode/src/src.cmake  file like in the following example:   project ( YOUR_PROJECT )  include ( ${ CMAKE_CURRENT_LIST_DIR } /wakaamaNode/src/src.cmake )  add_executable ( ${ PROJECT_NAME }   ${ YOUR_FILES }   ${ WAKAAMA_NODE_DIR_SOURCES } )  # We need C++11 and C11 support  target_compile_features ( ${ PROJECT_NAME }   PRIVATE   cxx_range_for )  set_property ( TARGET   ${ PROJECT_NAME }   PROPERTY   C_STANDARD   11 )  # Include directories  target_include_directories ( ${ PROJECT_NAME }   PRIVATE   {WAKAAMA_NODE_DIR_INCLUDE_DIRS} )  # Some definitions  target_compile_definitions ( ${ PROJECT_NAME }   PUBLIC   ${ WAKAAMA_DEFINITIONS } )", 
            "title": "Use CMake build system"
        }, 
        {
            "location": "/quickstart/getting-started/#bare-minimum-sketch", 
            "text": "The following example shows you some key aspects of the library. In particular:   How to connect to a lwm2m server, if enabled with a preshared key DTLS connection. (It is assumed that you are network connected already.)  How to set device describing attributes.  How to use a predefined object and object instance: In this case object 3311 (light control).  How to react to an object write via the  verifyWrite  function.  How to update an object instance resource via the  lights.resChanged  call.", 
            "title": "Bare minimum sketch"
        }, 
        {
            "location": "/quickstart/getting-started/#headers-and-long-living-objects", 
            "text": "Include required headers and define your lwm2m objects, instances and the lwm2m client context:  #include   time.h  #include   Arduino.h  #include   lwm2m/connect.h  #include   lwm2m/objects.h  #include   lwm2m/debug.h  #include   lwm2mObjects/3311.h  using   namespace   KnownObjects ;  id3311 :: object   lights ;  id3311 :: instance   ledsInstance ;  // If this context object goes out of scope, you will be  // disconnected from all connected servers automatically.  LwM2MConnect   context ( testClient );", 
            "title": "Headers and long living objects"
        }, 
        {
            "location": "/quickstart/getting-started/#device-infomation", 
            "text": "Tell the lwm2m client context about your device:  inline   void   setupDeviceInfo ()   { \n     context . deviceInstance . manufacturer   =   test manufacturer ; \n     context . deviceInstance . model_name   =   test model ; \n     context . deviceInstance . device_type   =   sensor ; \n     context . deviceInstance . firmware_ver   =   1.0 ; \n     context . deviceInstance . serial_number   =   140234-645235-12353 ; \n     // if LWM2M_DEV_INFO_TIME is enabled \n     context . deviceInstance . time_offset   =   5 ; \n     context . deviceInstance . timezone   =   +05:00 ;  }", 
            "title": "Device infomation"
        }, 
        {
            "location": "/quickstart/getting-started/#configure-your-lwm2m-objects", 
            "text": "Configure your lwm2m objects. In this case, we want a lwm2m light object (id: 3311)\nand one instance. When a write happens on the instance, set a LED on/off:  inline   void   configureLwm2mObjects ()   { \n\n     // Overwrite the verify function and  abuse  it as value changed event. \n     lights . verifyWrite   =   []( id3311 :: instance *   i ,   uint16_t   res_id )   { \n         // Is it instance 0 and the OnOff resource? \n         if   ( i - id   ==   0     res_id   ==   id3311 :: RESID :: OnOff )   { \n             // Change the led pin depending on the OnOff value \n             digitalWrite ( LED_BUILTIN ,   i - OnOff ); \n         } \n         // Return true to accept the value and ACK to the server \n         return   true ; \n     }; \n\n     ledsInstance . id   =   0 ;   // set instance id \n     lights . addInstance ( CTX ( context ),   ledsInstance ); \n     lights . registerObject ( CTX ( context ),   false ); \n\n     // Initialize the LED_BUILTIN pin as an output \n     pinMode ( LED_BUILTIN ,   OUTPUT );  }", 
            "title": "Configure your lwm2m objects"
        }, 
        {
            "location": "/quickstart/getting-started/#add-lwm2m-servers", 
            "text": "Add lwm2m server and configure DTLS (if enabled):  void   setup ()   { \n     setupDeviceInfo (); \n     configureLwm2mObjects (); \n\n     connectToYourNetwork (); \n\n     if   ( ! context . socket_count ()) \n         printf ( Failed to open socket \\n ); \n\n     // Add a lwm2m server with unique id 123, lifetime of 100s, no storing of \n     // unsend messages. The host url is either coap:// or coaps://. \n     context . add_server ( 123 ,   coap://192.168.1.18 ,   100 ,   false ); \n\n     // Enter your DTLS connection information \n     #ifdef LWM2M_WITH_DTLS \n     context . use_dtls_psk ( 123 ,   publicid ,   PSK ,   sizeof ( PSK )); \n     #endif  }", 
            "title": "Add lwm2m server(s)"
        }, 
        {
            "location": "/quickstart/getting-started/#main-event-loop", 
            "text": "Your main event loop need to call  context.process . Also call  watch_and_reconnect  if you\nwant to automatically reconnect on a lost connection. On Posix you can call  block_wait  to\nmake the process sleep until udp activity or the next due time:  void   loop ()   { \n     struct   timeval   time_to_next_call { 20 , 0 }; \n\n     int   result   =   context . process ( time_to_next_call ); \n     if   ( result   ==   COAP_505_NO_NETWORK_CONNECTION )   { \n         // Couldn t open UDP sockets. \n         // Call lwm2m_network_init again after network is availabe again. \n     }   else   if   ( result   !=   0 )   { \n         // Unexpected error \n         print_state ( CTX ( context )); \n     } \n     // If a server connetion gets lost, the lwm2m state machine will change into \n     // BOOTSTRAP_REQUIRED state. The following method will reset the state machine \n     // and the next process() call will attempt a reconnect. \n     context . watch_and_reconnect ( time_to_next_call ,   5 ); \n\n     // You may go into low power mode on an \u00b5C or use context.block_wait() on posix: \n     context . block_wait ( next_event );  }", 
            "title": "Main event loop"
        }, 
        {
            "location": "/quickstart/getting-started/#change-resources-and-tell-the-server", 
            "text": "Change resources on your object instances, but don't forget to call  resChanged : // Toggle the led by a button press and inform the lwm2m server about the new state  void   push_button_pressed ( bool   newState )   { \n     ledsInstance . OnOff   =   newState ; \n     digitalWrite ( LED_BUILTIN ,   ledsInstance . OnOff ); \n     lights . resChanged ( CTX ( context ),   ledsInstance . id ,   ( uint16_t ) id3311 :: RESID :: OnOff );  }", 
            "title": "Change resources and tell the server"
        }, 
        {
            "location": "/quickstart/getting-started/#configure-features-with-wakaama_configh", 
            "text": "Copy the  examples/nodemcu_with_led_object/src/wakaama_config.h \nfile to your project or create a  wakaama_config.h  file in your project source directory with the following\ncontent:  // Put the library in client mode (you basically always need this)  #define LWM2M_CLIENT_MODE  // Enable json support  #define LWM2M_SUPPORT_JSON  // Enables the wifi object where you may provide information about the wifi strength, connected ssid etc.  #define LWM2M_DEV_INFO_WIFI_METRICS  // Allows to perform a reboot of the device. Implement lwm2m_reboot() for this to work.  #define LWM2M_DEVICE_WITH_REBOOT  // Allows to perform a factory reset. Implement lwm2m_factory_reset() for this to work.  // In this method you should erase all user memory, connection setups and so on.  #define LWM2M_DEVICE_WITH_FACTORY_RESET  // Implement lwm2m_get_bat_level() and lwm2m_get_bat_status().  #define LWM2M_DEVICE_INFO_WITH_BATTERY  // Implement lwm2m_get_free_mem() and lwm2m_get_total_mem().  #define LWM2M_DEVICE_INFO_WITH_MEMINFO  // Implement lwm2m_get_last_error() and lwm2m_reset_last_error().  #define LWM2M_DEVICE_INFO_WITH_ERRCODE  // Implement lwm2m_gettime() and update the fields  **timezone** and **time_offset**  // of the device information object.  #define LWM2M_DEVICE_INFO_WITH_TIME  // Adds a **hardware_ver** and a **software_ver** c-string field.  #define LWM2M_DEVICE_INFO_WITH_ADDITIONAL_VERSIONS  // Enables the firmware update mechanism.  #define LWM2M_FIRMWARE_UPGRADES  // Enable DTLS support (preshared and public key)  #define LWM2M_WITH_DTLS  // Enable additional support for X.509 certificates and PEM data  // #define LWM2M_WITH_DTLS_X509  // Overwrite maximum packet size. Defaults to 1024 bytes  // #define MAX_PACKET_SIZE 1024   Edit the file to your needs, by commenting out unwanted features.", 
            "title": "Configure features with wakaama_config.h"
        }, 
        {
            "location": "/quickstart/getting-started/#demoexample", 
            "text": "See examples in  src/examples .\nThe examples including a step-by-step how-to are explained in  Examples .", 
            "title": "Demo/Example"
        }, 
        {
            "location": "/api/connection-api/", 
            "text": "Connection/Device/Firmware API\n\n\nFind the documentation and examples for the connection C and C++ API in this document.\nThe last sections describe the device- and firware update API.\n\n\nConnection C-API\n\n\nInclude \nlwm2m/c_connect.h\n.\n\n\nIn your main file declare a variable of type \nlwm2m_client_context_t\n.\n\n\n\n\nDefine a long living client context variable\n\n\nlwm2m_client_context_t\n \ncontext\n;\n\n\n\n\nThis type contains the lwm2m context of type \nlwm2m_context_t\n, that is required for most API calls.\nUsually you do not need to access any of the member fields directly.\n\n\nBecause it is so common to extract the \nlwm2m_context_t*\n, there is the \nCTX(context)\n macro doing this for you.\n\n\n\n\nExample on how to use CTX\n\n\nlwm2m_client_context_t\n \ncontext\n;\n\n\nlwm2m_process\n(\nCTX\n(\ncontext\n));\n\n\n\n\n\n\n\n/**\n\n\n * @param context Wakaama client context. May not be NULL.\n\n\n * @param endpointName The server uses this name to identify a client over multiple sessions\n\n\n * @return Return 0 if socket binding failed. Otherwise returns the number\n\n\n *     of sockets the method could bind to (for IPv4 and IPv6 each on all available interfaces).\n\n\n */\n\n\nuint8_t\n \nlwm2m_client_init\n(\nlwm2m_client_context_t\n*\n \ncontext\n,\n \nconst\n \nchar\n \n*\n \nendpointName\n);\n\n\n\n\n\nInitialize the given wakaame client context and the network module.\nClose the client context with \nlwm2m_client_close()\n.\n\n\n/**\n\n\n * @param context Wakaama client context. May not be NULL.\n\n\n */\n\n\nvoid\n \nlwm2m_client_close\n(\nlwm2m_client_context_t\n*\n \ncontext\n);\n\n\n\n\n\nClose the given wakaama client context.\n\n\nWill release dynamically aquired ressources and calls lwm2m_network_close().\nAll added servers are gone after this call.\nThis will not release objects created by lwm2m_object_create.\n\n\n/**\n\n\n * @param contextP Wakaama context\n\n\n * @param next_event Returns a timeval value that tells you when the next call is due.\n\n\n * It does not modify timeval if it already has a value that is sooner than the next due time.\n\n\n * @return Returns a wakaama error code (the result value of lwm2m_step())\n\n\n */\n\n\nint\n \nlwm2m_process\n(\nlwm2m_context_t\n \n*\n \ncontextP\n,\n \nstruct\n \ntimeval\n*\n \nnext_event\n);\n\n\n\nCall this method periodically. Internally it will process new network packages as well as progress in the wakaamas state machine.\n\n\n\n\nInfo\n\n\nOn Posix Systems you can call \nlwm2m_block_wait(context, next_event)\n to wait for\neither received network packets or for the due time of the next event.\n\n\n\n\n/**\n\n\n * @param contextP Wakaama context\n\n\n * @param next_event Uses and returns a timeval value that tells you when the next call is due.\n\n\n * It does not modify timeval if it already has a value that is sooner than the next due time.\n\n\n * @param reconnectTime Reconnect time in seconds\n\n\n */\n\n\nvoid\n \nlwm2m_watch_and_reconnect\n(\nwm2m_context_t\n \n*\n \ncontextP\n,\n \nstruct\n \ntimeval\n*\n \nnext_event\n,\n \nint\n \nreconnectTime\n);\n\n\n\nWatch server connections and reset the lwm2m state machine to force reconnects,\nif the current state is STATE_BOOTSTRAP_REQUIRED. Usually you want to call this after \nlwm2m_process\n\nfor automatic reconnection.\n\n\n/**\n\n\n * @param contextP Wakaama context\n\n\n * @param shortServerID A unique server id\n\n\n * @param uri The server URI\n\n\n * @param lifetime A lifetime in seconds\n\n\n * @param storing If notifications should be stored and resend if a server connection was interruppted and then reconnected.\n\n\n * @return Return true if successfully added and false if aborted due to no memory.\n\n\n */\n\n\nbool\n \nlwm2m_add_server\n(\nlwm2m_context_t\n \n*\ncontextP\n,\n \nuint16_t\n \nshortServerID\n,\n\n                      \nconst\n \nchar\n*\n \nuri\n,\n \nuint32_t\n \nlifetime\n,\n \nbool\n \nstoring\n);\n\n\n\nAdds a new server to the lwm2m client. The client statemachine will try to connect to this\nserver with the next iteration (usually caused by calling \nlwm2m_process()\n).\n\n\n/**\n\n\n * @param contextP A Wakaama client context\n\n\n * @param shortServerID A unique server id\n\n\n * @param publicId publicIdentity for DTLS. May be NULL if no secure connection is used.\n\n\n * The expected c-string is copied to a new memory location.\n\n\n * @param psk Passkey if DTLS is used. May be NULL. The byte array is copied to a new memory location.\n\n\n * @param pskLen Passkey length. Should be 0 if no passkey is used.\n\n\n * @return Return true if successfully added and false if aborted due to no memory.\n\n\n */\n\n\nbool\n \nlwm2m_use_dtls_psk\n(\nlwm2m_context_t\n \n*\ncontextP\n,\n \nuint16_t\n \nshortServerID\n,\n \nconst\n \nchar\n*\n \npublicId\n,\n\n                        \nconst\n \nchar\n*\n \npsk\n,\n \nunsigned\n \nshort\n \npskLen\n);\n\n\n\nAlters a servers security details by adding preshared key DTLS information. Call this before entering the\nmain loop (\nlwm2m_process()\n).\nYou may also remove DTLS information by providing a NULL argument to psk and publicid.\n\n\n\n\nWarning\n\n\nIf you have specified a \"coap://\" URI in lwm2m_add_server(...), then\npublicId and psk will be set to NULL on a connection attempt.\n\n\n\n\nThe LwM2M specification V1.0 says:\n\n\n\n\nQuote\n\n\nSince the security of the default PSK Cipher Suites\nrely on the length and the entropy of this shared secret\nit is RECOMMENDED to provision a 16 byte (128 bit) key\".\n\n\n\n\n/**\n\n\n * @param contextP Wakaama context\n\n\n * @param security_instance_id The security instance id which refers to a specific server\n\n\n */\n\n\nbool\n \nlwm2m_unregister_server\n(\nlwm2m_context_t\n \n*\ncontextP\n,\n \nuint16_t\n \nsecurity_instance_id\n);\n\n\n\n\n\nInforms the lwm2m server about a disconnect and flags the connection as disconnected.\nDisconnected servers are still available until \nlwm2m_remove_unregistered_servers\n is called.\n\n\n/**\n\n\n * @param contextP Wakaama context\n\n\n */\n\n\nvoid\n \nlwm2m_remove_unregistered_servers\n(\nlwm2m_context_t\n \n*\ncontextP\n);\n\n\n\nRemoves all unregistered server, by removing all related security objects.\nPuts the client back to STATE_INITIAL if the server list has been altered.\n\n\n/**\n\n\n * @param contextP Wakaama context\n\n\n * @param security_instance_id The security instance id which refers to a specific server\n\n\n */\n\n\nconst\n \nchar\n*\n \nlwm2m_get_server_uri\n(\nlwm2m_context_t\n \n*\ncontextP\n,\n \nuint16_t\n \nshortServerID\n);\n\n\n\nReturns the uri of a server by providing the security object id of that server connection.\n\n\nThe c-string is not copied and valid as long as the respective security object is alive.\n\n\n/**\n\n\n * @param contextP Wakaama context\n\n\n */\n\n\nbool\n \nlwm2m_is_connected\n(\nlwm2m_context_t\n \n*\ncontextP\n);\n\n\n\n\n\nReturn true if wakaama is connected to a lwm2m server.\n\n\nExample\n\n\nTo setup the library, you would follow the outlined schema of the following C code:\n\n\n// The client name will be used by the lwm2m server for identification.\n\n\nlwm2m_client_context_t\n \ncontext\n(\ntestClient\n);\n\n\n// Posix and Lwip network support is implemented.\n\n\nlwm2m_client_init\n(\ncontext\n);\n\n\n\nwhile\n(\n1\n)\n \n{\n\n   \n// Call the lwm2m state machine (lwm2m_process) periodically. \n\n   \n// tv will be used as output variable.\n\n   \n// The library tells us about the next required call to lwm2m_process().\n\n   \n// In this simple example we ignore this request.\n\n   \nstruct\n \ntimeval\n \ntv\n \n=\n \n{\n5\n,\n0\n};\n\n   \nint\n \nresult\n \n=\n \nlwm2m_process\n(\nCTX\n(\ncontext\n),\n \ntv\n);\n\n   \n// Error handling of `result`.\n\n\n}\n\n\n\n// Deregisters from the lwm2m server, frees ressources taken by wakaama.\n\n\n// Also closes the network connection and release network ressoures.\n\n\nlwm2m_client_close\n(\ncontext\n);\n\n\n\n\n\nConnection C++-API\n\n\nThe C++ API is only a slim wrapper around the C API.\nAll methods are named the same (expect the missing \nlwm2m_\n prefix)\nand have the same signature as their C-equivalent,\nexcept that no \nlwm2m_context_t\n need to be passed.\n\n\nInclude \nlwm2m/connect.h\n.\n\n\nclass\n \nLwM2MConnect\n \n:\n \npublic\n \nlwm2m_client_context_t\n \n{\n\n\npublic\n:\n\n    \nLwM2MConnect\n(\nconst\n \nchar\n \n*\n \nendpointName\n);\n\n    \n~\nLwM2MConnect\n();\n\n\n    \nint\n \nprocess\n(\nstruct\n \ntimeval\n*\n \nnext_event\n);\n\n\n    \nint\n \nblock_wait\n(\nstruct\n \ntimeval\n \nnext_event\n);\n\n\n    \nvoid\n \nwatch_and_reconnect\n(\nstruct\n \ntimeval\n*\n \nnext_event\n,\n \nint\n \nreconnectTime\n);\n\n\n    \nbool\n \nadd_server\n(\nuint16_t\n \nshortServerID\n,\n \nconst\n \nchar\n*\n \nuri\n,\n \nuint32_t\n \nlifetime\n,\n \nbool\n \nstoring\n);\n\n\n    \nbool\n \nuse_dtls_psk\n(\nuint16_t\n \nshortServerID\n,\n \nconst\n \nchar\n*\n \npublicId\n,\n \nconst\n \nchar\n*\n \npsk\n,\n \nunsigned\n \nshort\n \npskLen\n);\n\n\n    \nbool\n \nunregister_server\n(\nuint16_t\n \nsecurity_instance_id\n);\n\n\n    \nvoid\n \nremove_unregistered_servers\n();\n\n\n    \nconst\n \nchar\n*\n \nget_server_uri\n(\nuint16_t\n \nshortServerID\n);\n\n\n    \nbool\n \nis_connected\n();\n\n\n};\n\n\n\n\n\nExample\n\n\nTo setup the library, you would follow the outlined schema of the following CPP code:\n\n\nLwM2MConnect\n \ncontext\n(\ntestClient\n);\n\n\n\nstruct\n \ntimeval\n \ntv\n{\n5\n,\n0\n};\n\n\nwhile\n(\n1\n)\n \n{\n\n   \nint\n \nresult\n \n=\n \ncontext\n.\nprocess\n(\ntv\n);\n\n   \n#ifdef POSIX_NETWORK\n\n   \ncontext\n.\nblock_wait\n(\ntv\n);\n\n   \n#endif\n\n\n}\n\n\n\n\n\nDevice information API\n\n\nThe library implements the lwm2m device object for you.\n\n\n\n\nThe Device Object provides an optional device reboot and factory reset function as well as a range of device related information which can be queried by the LWM2M Server.\n\n\n\n\n/**\n\n\n * @param res_id The ressource id of the value you have changed in device_instance_t.\n\n\n */\n\n\nvoid\n \nlwm2m_device_res_has_changed\n(\nlwm2m_context_t\n \n*\ncontext\n,\n \nuint16_t\n \nres_id\n);\n\n\n\n\n\nCall this if you have changed a ressource of the \ndevice_instance_t\n object.\nYou only have to do this after you have connected to a lwm2m server.\n\n\nTo change a device information (version number etc), do the following:\n\nlwm2m_client_context_t\n \ncontext\n;\n \n// Your global client context variable\n\n\n\ncontext\n.\ndeviceInstance\n.\nfirmware_ver\n \n=\n \n1.2\n;\n\n\n// Only do this if you have called lwm2m_process at least once already\n\n\nlwm2m_device_res_has_changed\n(\nCTX\n(\ncontext\n),\n \nRES_O_FIRMWARE_VERSION\n);\n\n\n\n\nThe following device information are obtained by calling a function:\n\n\n\n\n\n\n\n\nResID\n\n\nName\n\n\nConfiguration option\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\n9\n\n\nBattery level\n\n\nLWM2M_DEVICE_INFO_WITH_BATTERY\n\n\nuint8_t lwm2m_get_bat_level()\n\n\n\n\n\n\n20\n\n\nBattery status\n\n\nsame\n\n\nuint8_t lwm2m_get_bat_status\n\n\n\n\n\n\n10\n\n\nFree memory\n\n\nLWM2M_DEVICE_INFO_WITH_MEMINFO\n\n\nint64_t lwm2m_get_free_mem()\n\n\n\n\n\n\n21\n\n\nTotal memory\n\n\nsame\n\n\nint64_t lwm2m_get_total_mem()\n\n\n\n\n\n\n11\n\n\nLast error code\n\n\nLWM2M_DEVICE_INFO_WITH_ERRCODE\n\n\nint64_t lwm2m_get_last_error()\n\n\n\n\n\n\n13\n\n\nCurrent time (s)\n\n\n\n\nint64_t lwm2m_gettime()\n\n\n\n\n\n\n\n\nYou need to implement the corresponding function if you enable the respective configuration option.\n\n\n\n\nNotify the server about a new value\n\n\nlwm2m_device_res_has_changed(CTX(context), RES_O_BATTERY_LEVEL)\n\n\n\n\nSome configuration options require you to implement further functions, see the table below:\n\n\n\n\n\n\n\n\nResID\n\n\nName\n\n\nConfiguration option\n\n\nFunction\n\n\n\n\n\n\n\n\n\n\n4\n\n\nReboot device\n\n\nLWM2M_DEVICE_WITH_REBOOT\n\n\nvoid lwm2m_reboot()\n\n\n\n\n\n\n5\n\n\nFactory reset\n\n\nLWM2M_DEVICE_WITH_FACTORY_RESET\n\n\nvoid lwm2m_factory_reset()\n\n\n\n\n\n\n\n\nExample\n\n\nYou may want to provide some c-strings stating the manufacturer, the model_name, device_type,\nfirmware version and a serial number, before you connect to a lwm2m server.\nYou would do this like in the following example:\n\n\n// C-API\n\n\nlwm2m_client_context_t\n \ncontext\n;\n\n\nlwm2m_client_init\n(\ncontext\n,\n \ntestClient\n);\n\n\n\n// C++ API\n\n\nLwM2MConnect\n \ncontext\n;\n\n\n\ncontext\n.\ndeviceInstance\n.\nmanufacturer\n \n=\n \ntest manufacturer\n;\n\n\ncontext\n.\ndeviceInstance\n.\nmodel_name\n \n=\n \ntest model\n;\n\n\ncontext\n.\ndeviceInstance\n.\ndevice_type\n \n=\n \nsensor\n;\n\n\ncontext\n.\ndeviceInstance\n.\nfirmware_ver\n \n=\n \n1.0\n;\n\n\ncontext\n.\ndeviceInstance\n.\nserial_number\n \n=\n \n140234-645235-12353\n;\n\n\n// if LWM2M_DEV_INFO_TIME is enabled\n\n\ncontext\n.\ndeviceInstance\n.\ntime_offset\n \n=\n \n5\n;\n\n\ncontext\n.\ndeviceInstance\n.\ntimezone\n \n=\n \n+05:00\n;\n\n\n\n\n\n\n\nInfo\n\n\nIf you change data after you have connected to a server, you need to call\n\nlwm2m_device_res_has_changed(context, res_id)\n after the change.\n\n\n\n\nFirmware update / OTA\n\n\nTo enable OTA, define LWM2M_FIRMWARE_UPGRADES in \nconfig_wakama.h\n.\n\n\nAn implementation exist for posix/win32 systems and for Arduino OTA compliant platforms.\n\n\nUpdate method\n\n\nThere are generally two methods for updating.\n\n\n\n\n\n\nThe Http(s) method signals the lwM2M server that a URL should be provided where the new firmware can be found.\n  Use UPDATE_PROTOCOL_HTTP or UPDATE_PROTOCOL_HTTPS for the \nFirmwareUpdate\n constructor.\n\n\n\n\n\n\nThe Coap(s) method makes the server send the new firmware via coap as an opaque data chunk.\n  Because that data chunk is expected to be huge and need to be memory buffered, small \u00b5C probably do not support this method.\n  Use UPDATE_PROTOCOL_COAP or UPDATE_PROTOCOL_COAPS for the \nFirmwareUpdate\n constructor.\n\n\n\n\n\n\nC++ API\n\n\nInclude the \nfirmware.h\n file and create an object of \nFirmwareUpdate\n.\n\n\n/**\n\n\n* Creates a firmware update object.\n\n\n*\n\n\n* @param context A lwm2m context\n\n\n* @param app_version The current APP version\n\n\n*/\n\n\nFirmwareUpdate\n::\nFirmwareUpdate\n(\nlwm2m_context_t\n \n*\ncontext\n,\n \nconst\n \nchar\n*\n \napp_version\n,\n\n    \nlwm2m_update_protocol\n \nprotocol\n);\n\n\n\n/**\n\n\n* Only for POSIX compatible systems.\n\n\n* Check if this executable is the new updated one.\n\n\n* If this is the new one:\n\n\n* Waits for the old executable to finish. We expect a\n\n\n* command line parameter \noldexe=PID\n with the PID of the\n\n\n* old executable. To notify the old executable about our\n\n\n* successful start up, a POSIX signal USR1 is send.\n\n\n*\n\n\n* @param argc Command line argument count\n\n\n* @param argv Command line arguments\n\n\n*/\n\n\nvoid\n \nFirmwareUpdate\n::\ncheckIsUpdated\n(\nint\n \nargc\n,\n \nchar\n**\n \nargv\n);\n\n\n\n/**\n\n\n* Call this in your main loop to check for new updates,\n\n\n* initiate the download and restart if necessary\n\n\n*/\n\n\nvoid\n \nFirmwareUpdate\n::\nprocess\n();\n\n\n\n\n\nExample\n\n\n#include\n \nlwm2m/firmware.h\n\n\nLwM2MConnect\n \ncontext\n;\n\n\nFirmwareUpdate\n \nfirmwareUpdate\n(\nCTX\n(\ncontext\n),\n \n1.0\n,\n \nUPDATE_PROTOCOL_HTTP\n);\n\n\n\n...\n\n\n\nvoid\n \nloop\n()\n \n{\n\n    \ncontext\n.\nprocess\n(...);\n\n    \nfirmwareUpdate\n.\nprocess\n();\n\n\n}\n\n\n...\n\n\n// if POSIX\n\n\nint\n \nmain\n(\nint\n \nargc\n,\n \nchar\n**\n \nargv\n)\n \n{\n\n    \nfirmwareUpdate\n.\ncheckIsUpdated\n(\nargc\n,\n \nargv\n);\n\n    \n...\n\n    \nwhile\n \n(\n1\n)\n \nloop\n();\n\n    \nreturn\n \n0\n;\n\n\n}", 
            "title": "Connection API"
        }, 
        {
            "location": "/api/connection-api/#connectiondevicefirmware-api", 
            "text": "Find the documentation and examples for the connection C and C++ API in this document.\nThe last sections describe the device- and firware update API.", 
            "title": "Connection/Device/Firmware API"
        }, 
        {
            "location": "/api/connection-api/#connection-c-api", 
            "text": "Include  lwm2m/c_connect.h .  In your main file declare a variable of type  lwm2m_client_context_t .   Define a long living client context variable  lwm2m_client_context_t   context ;   This type contains the lwm2m context of type  lwm2m_context_t , that is required for most API calls.\nUsually you do not need to access any of the member fields directly.  Because it is so common to extract the  lwm2m_context_t* , there is the  CTX(context)  macro doing this for you.   Example on how to use CTX  lwm2m_client_context_t   context ;  lwm2m_process ( CTX ( context ));    /**   * @param context Wakaama client context. May not be NULL.   * @param endpointName The server uses this name to identify a client over multiple sessions   * @return Return 0 if socket binding failed. Otherwise returns the number   *     of sockets the method could bind to (for IPv4 and IPv6 each on all available interfaces).   */  uint8_t   lwm2m_client_init ( lwm2m_client_context_t *   context ,   const   char   *   endpointName );   Initialize the given wakaame client context and the network module.\nClose the client context with  lwm2m_client_close() .  /**   * @param context Wakaama client context. May not be NULL.   */  void   lwm2m_client_close ( lwm2m_client_context_t *   context );   Close the given wakaama client context.  Will release dynamically aquired ressources and calls lwm2m_network_close().\nAll added servers are gone after this call.\nThis will not release objects created by lwm2m_object_create.  /**   * @param contextP Wakaama context   * @param next_event Returns a timeval value that tells you when the next call is due.   * It does not modify timeval if it already has a value that is sooner than the next due time.   * @return Returns a wakaama error code (the result value of lwm2m_step())   */  int   lwm2m_process ( lwm2m_context_t   *   contextP ,   struct   timeval *   next_event );  \nCall this method periodically. Internally it will process new network packages as well as progress in the wakaamas state machine.   Info  On Posix Systems you can call  lwm2m_block_wait(context, next_event)  to wait for\neither received network packets or for the due time of the next event.   /**   * @param contextP Wakaama context   * @param next_event Uses and returns a timeval value that tells you when the next call is due.   * It does not modify timeval if it already has a value that is sooner than the next due time.   * @param reconnectTime Reconnect time in seconds   */  void   lwm2m_watch_and_reconnect ( wm2m_context_t   *   contextP ,   struct   timeval *   next_event ,   int   reconnectTime );  \nWatch server connections and reset the lwm2m state machine to force reconnects,\nif the current state is STATE_BOOTSTRAP_REQUIRED. Usually you want to call this after  lwm2m_process \nfor automatic reconnection.  /**   * @param contextP Wakaama context   * @param shortServerID A unique server id   * @param uri The server URI   * @param lifetime A lifetime in seconds   * @param storing If notifications should be stored and resend if a server connection was interruppted and then reconnected.   * @return Return true if successfully added and false if aborted due to no memory.   */  bool   lwm2m_add_server ( lwm2m_context_t   * contextP ,   uint16_t   shortServerID , \n                       const   char *   uri ,   uint32_t   lifetime ,   bool   storing );  \nAdds a new server to the lwm2m client. The client statemachine will try to connect to this\nserver with the next iteration (usually caused by calling  lwm2m_process() ).  /**   * @param contextP A Wakaama client context   * @param shortServerID A unique server id   * @param publicId publicIdentity for DTLS. May be NULL if no secure connection is used.   * The expected c-string is copied to a new memory location.   * @param psk Passkey if DTLS is used. May be NULL. The byte array is copied to a new memory location.   * @param pskLen Passkey length. Should be 0 if no passkey is used.   * @return Return true if successfully added and false if aborted due to no memory.   */  bool   lwm2m_use_dtls_psk ( lwm2m_context_t   * contextP ,   uint16_t   shortServerID ,   const   char *   publicId , \n                         const   char *   psk ,   unsigned   short   pskLen );  \nAlters a servers security details by adding preshared key DTLS information. Call this before entering the\nmain loop ( lwm2m_process() ).\nYou may also remove DTLS information by providing a NULL argument to psk and publicid.   Warning  If you have specified a \"coap://\" URI in lwm2m_add_server(...), then\npublicId and psk will be set to NULL on a connection attempt.   The LwM2M specification V1.0 says:   Quote  Since the security of the default PSK Cipher Suites\nrely on the length and the entropy of this shared secret\nit is RECOMMENDED to provision a 16 byte (128 bit) key\".   /**   * @param contextP Wakaama context   * @param security_instance_id The security instance id which refers to a specific server   */  bool   lwm2m_unregister_server ( lwm2m_context_t   * contextP ,   uint16_t   security_instance_id );   Informs the lwm2m server about a disconnect and flags the connection as disconnected.\nDisconnected servers are still available until  lwm2m_remove_unregistered_servers  is called.  /**   * @param contextP Wakaama context   */  void   lwm2m_remove_unregistered_servers ( lwm2m_context_t   * contextP );  \nRemoves all unregistered server, by removing all related security objects.\nPuts the client back to STATE_INITIAL if the server list has been altered.  /**   * @param contextP Wakaama context   * @param security_instance_id The security instance id which refers to a specific server   */  const   char *   lwm2m_get_server_uri ( lwm2m_context_t   * contextP ,   uint16_t   shortServerID );  \nReturns the uri of a server by providing the security object id of that server connection.  The c-string is not copied and valid as long as the respective security object is alive.  /**   * @param contextP Wakaama context   */  bool   lwm2m_is_connected ( lwm2m_context_t   * contextP );   Return true if wakaama is connected to a lwm2m server.", 
            "title": "Connection C-API"
        }, 
        {
            "location": "/api/connection-api/#example", 
            "text": "To setup the library, you would follow the outlined schema of the following C code:  // The client name will be used by the lwm2m server for identification.  lwm2m_client_context_t   context ( testClient );  // Posix and Lwip network support is implemented.  lwm2m_client_init ( context );  while ( 1 )   { \n    // Call the lwm2m state machine (lwm2m_process) periodically.  \n    // tv will be used as output variable. \n    // The library tells us about the next required call to lwm2m_process(). \n    // In this simple example we ignore this request. \n    struct   timeval   tv   =   { 5 , 0 }; \n    int   result   =   lwm2m_process ( CTX ( context ),   tv ); \n    // Error handling of `result`.  }  // Deregisters from the lwm2m server, frees ressources taken by wakaama.  // Also closes the network connection and release network ressoures.  lwm2m_client_close ( context );", 
            "title": "Example"
        }, 
        {
            "location": "/api/connection-api/#connection-c-api_1", 
            "text": "The C++ API is only a slim wrapper around the C API.\nAll methods are named the same (expect the missing  lwm2m_  prefix)\nand have the same signature as their C-equivalent,\nexcept that no  lwm2m_context_t  need to be passed.  Include  lwm2m/connect.h .  class   LwM2MConnect   :   public   lwm2m_client_context_t   {  public : \n     LwM2MConnect ( const   char   *   endpointName ); \n     ~ LwM2MConnect (); \n\n     int   process ( struct   timeval *   next_event ); \n\n     int   block_wait ( struct   timeval   next_event ); \n\n     void   watch_and_reconnect ( struct   timeval *   next_event ,   int   reconnectTime ); \n\n     bool   add_server ( uint16_t   shortServerID ,   const   char *   uri ,   uint32_t   lifetime ,   bool   storing ); \n\n     bool   use_dtls_psk ( uint16_t   shortServerID ,   const   char *   publicId ,   const   char *   psk ,   unsigned   short   pskLen ); \n\n     bool   unregister_server ( uint16_t   security_instance_id ); \n\n     void   remove_unregistered_servers (); \n\n     const   char *   get_server_uri ( uint16_t   shortServerID ); \n\n     bool   is_connected ();  };", 
            "title": "Connection C++-API"
        }, 
        {
            "location": "/api/connection-api/#example_1", 
            "text": "To setup the library, you would follow the outlined schema of the following CPP code:  LwM2MConnect   context ( testClient );  struct   timeval   tv { 5 , 0 };  while ( 1 )   { \n    int   result   =   context . process ( tv ); \n    #ifdef POSIX_NETWORK \n    context . block_wait ( tv ); \n    #endif  }", 
            "title": "Example"
        }, 
        {
            "location": "/api/connection-api/#device-information-api", 
            "text": "The library implements the lwm2m device object for you.   The Device Object provides an optional device reboot and factory reset function as well as a range of device related information which can be queried by the LWM2M Server.   /**   * @param res_id The ressource id of the value you have changed in device_instance_t.   */  void   lwm2m_device_res_has_changed ( lwm2m_context_t   * context ,   uint16_t   res_id );   Call this if you have changed a ressource of the  device_instance_t  object.\nYou only have to do this after you have connected to a lwm2m server.  To change a device information (version number etc), do the following: lwm2m_client_context_t   context ;   // Your global client context variable  context . deviceInstance . firmware_ver   =   1.2 ;  // Only do this if you have called lwm2m_process at least once already  lwm2m_device_res_has_changed ( CTX ( context ),   RES_O_FIRMWARE_VERSION );   The following device information are obtained by calling a function:     ResID  Name  Configuration option  Function      9  Battery level  LWM2M_DEVICE_INFO_WITH_BATTERY  uint8_t lwm2m_get_bat_level()    20  Battery status  same  uint8_t lwm2m_get_bat_status    10  Free memory  LWM2M_DEVICE_INFO_WITH_MEMINFO  int64_t lwm2m_get_free_mem()    21  Total memory  same  int64_t lwm2m_get_total_mem()    11  Last error code  LWM2M_DEVICE_INFO_WITH_ERRCODE  int64_t lwm2m_get_last_error()    13  Current time (s)   int64_t lwm2m_gettime()     You need to implement the corresponding function if you enable the respective configuration option.   Notify the server about a new value  lwm2m_device_res_has_changed(CTX(context), RES_O_BATTERY_LEVEL)   Some configuration options require you to implement further functions, see the table below:     ResID  Name  Configuration option  Function      4  Reboot device  LWM2M_DEVICE_WITH_REBOOT  void lwm2m_reboot()    5  Factory reset  LWM2M_DEVICE_WITH_FACTORY_RESET  void lwm2m_factory_reset()", 
            "title": "Device information API"
        }, 
        {
            "location": "/api/connection-api/#example_2", 
            "text": "You may want to provide some c-strings stating the manufacturer, the model_name, device_type,\nfirmware version and a serial number, before you connect to a lwm2m server.\nYou would do this like in the following example:  // C-API  lwm2m_client_context_t   context ;  lwm2m_client_init ( context ,   testClient );  // C++ API  LwM2MConnect   context ;  context . deviceInstance . manufacturer   =   test manufacturer ;  context . deviceInstance . model_name   =   test model ;  context . deviceInstance . device_type   =   sensor ;  context . deviceInstance . firmware_ver   =   1.0 ;  context . deviceInstance . serial_number   =   140234-645235-12353 ;  // if LWM2M_DEV_INFO_TIME is enabled  context . deviceInstance . time_offset   =   5 ;  context . deviceInstance . timezone   =   +05:00 ;    Info  If you change data after you have connected to a server, you need to call lwm2m_device_res_has_changed(context, res_id)  after the change.", 
            "title": "Example"
        }, 
        {
            "location": "/api/connection-api/#firmware-update-ota", 
            "text": "To enable OTA, define LWM2M_FIRMWARE_UPGRADES in  config_wakama.h .  An implementation exist for posix/win32 systems and for Arduino OTA compliant platforms.", 
            "title": "Firmware update / OTA"
        }, 
        {
            "location": "/api/connection-api/#update-method", 
            "text": "There are generally two methods for updating.    The Http(s) method signals the lwM2M server that a URL should be provided where the new firmware can be found.\n  Use UPDATE_PROTOCOL_HTTP or UPDATE_PROTOCOL_HTTPS for the  FirmwareUpdate  constructor.    The Coap(s) method makes the server send the new firmware via coap as an opaque data chunk.\n  Because that data chunk is expected to be huge and need to be memory buffered, small \u00b5C probably do not support this method.\n  Use UPDATE_PROTOCOL_COAP or UPDATE_PROTOCOL_COAPS for the  FirmwareUpdate  constructor.", 
            "title": "Update method"
        }, 
        {
            "location": "/api/connection-api/#c-api", 
            "text": "Include the  firmware.h  file and create an object of  FirmwareUpdate .  /**  * Creates a firmware update object.  *  * @param context A lwm2m context  * @param app_version The current APP version  */  FirmwareUpdate :: FirmwareUpdate ( lwm2m_context_t   * context ,   const   char *   app_version , \n     lwm2m_update_protocol   protocol );  /**  * Only for POSIX compatible systems.  * Check if this executable is the new updated one.  * If this is the new one:  * Waits for the old executable to finish. We expect a  * command line parameter  oldexe=PID  with the PID of the  * old executable. To notify the old executable about our  * successful start up, a POSIX signal USR1 is send.  *  * @param argc Command line argument count  * @param argv Command line arguments  */  void   FirmwareUpdate :: checkIsUpdated ( int   argc ,   char **   argv );  /**  * Call this in your main loop to check for new updates,  * initiate the download and restart if necessary  */  void   FirmwareUpdate :: process ();", 
            "title": "C++ API"
        }, 
        {
            "location": "/api/connection-api/#example_3", 
            "text": "#include   lwm2m/firmware.h  LwM2MConnect   context ;  FirmwareUpdate   firmwareUpdate ( CTX ( context ),   1.0 ,   UPDATE_PROTOCOL_HTTP );  ...  void   loop ()   { \n     context . process (...); \n     firmwareUpdate . process ();  }  ...  // if POSIX  int   main ( int   argc ,   char **   argv )   { \n     firmwareUpdate . checkIsUpdated ( argc ,   argv ); \n     ... \n     while   ( 1 )   loop (); \n     return   0 ;  }", 
            "title": "Example"
        }, 
        {
            "location": "/api/about/", 
            "text": "About OMA Lightweight M2M\n\n\nStandards for constrained devices are rapidly consolidating and the availability of IP on constrained devices enabled these devices to easily connect to the Internet. The IETF has also created a set of specifications for such IP-enabled devices to work in a Web-like fashion. One such protocol is the \nConstrained Application Protocol (CoAP)\n that provides request/response methods, ways to identify resources, discovery mechanisms, etc. similar to the \nHypertext Transfer Protocol\n but for use in constrained environments.\n\n\nHowever, the use of standardized protocols does not ensure interoperability on the application layer. Therefore, there is a clear need for being able to communicate using structured data models on top of protocols like CoAP and HTTP.\n\n\nOMA (Open Mobile Alliance) has defined a standard for IoT or M2M devices, building on CoAP (and DTLS). It defines bootstrap and device management, as well as a data model.\n\n\nData model\n\n\nEach LwM2M client presents a data model - standardized, symbolic representation of its configuration and state that is accessible for reading and modifying by LwM2M Servers. It can be thought of as a combination of a hierarchical configuration file, and a view on statistical information about the device and its environment.\n\n\nThe LwM2M data model is very strictly organized as a three-level tree. Entities on each of those levels are identified with numerical identifiers. Those three levels are:\n\n\n\n\n\n\nObject\n - each Object represent some different concept of data accessible via the LwM2M client. For example, separate Objects are defined for managing connections with LwM2M servers, for managing network connections, for accessing data from various types of sensors, etc.\n\nEach Object is assigned a unique numerical identifier in the range 0-65535, inclusive. OMA manages a registry of known Object IDs. Each Object defines a set of Resources whose meanings are common for each Object Instance.\n\n\n\n\n\n\nObject Instance\n - some Objects are described as \u201csingle-instance\u201d - such Objects always have exactly one Instance with identifier 0. Examples of such Objects include the Device object which describes the device itself, and the Firmware Update object which is used to perform firmware upgrades.\n\nOther Objects may have multiple Instances; sometimes the number of Instances may be variable and the Instances themselves may be creatable via LwM2M. Examples of such Objects include the Object that manages connections to LwM2M Servers, Object that represents optional software packages installed on the device, and Objects representing sensors (whose instances are, however, not creatable). Identifiers for each Instance of such Objects may be arbitrarily chosen in the range 0-65534, inclusive - note that 65535 is reserved and forbidden in this context.\n\n\n\n\n\n\nResource\n - each Object Instance of a given Object supports the same set of Resources, as defined by the Object definition. Within a given Object, each Resource ID (which may be in the range 0-65535, inclusive) has a well-defined meaning, and represent the same concept. However, some Resources may not be present in some Object Instances, and, obviously, their values and mapping onto real-world entities may be different.\n\n\n\n\n\n\nThe numerical identifiers on each of these levels form a path, which is used as the path portion of CoAP URLs. For example, a path \n/1/2/3\n refers to Resource ID=3 in Object Instance ID=2 of Object ID=1. Whole Object Instances (/\n) or event Objects (/1) may be referred to using this syntax as well.\n\n\nFind an example for an object definition in LWM2M xml schema at \nurn:oma:lwm2m:ext:3303\n.\n\n\nObjects\n\n\nEach Object definition, which may be found in the LwM2M specification, features the following information:\n\n\n\n\nName\n - description of the object; it is not used in the actual on-wire protocol.\n\n\nObject ID\n - numerical identifier of the Object\n\n\nInstances\n - Single (always has one Instance with ID=0) or Multiple (may have arbitrary number of Instances depending on current configuration)\n\n\nMandatory\n - Mandatory (must be supported by all LwM2M Client implementations) or Optional (may not be supported)\n\n\nObject URN\n -  For example \nurn:oma:lwm2m:ext:3347\n\n\nResource definitions\n: A list of resource definitions. See section further down.\n\n\n\n\nImplemented objects\n\n\nThe current set of mandatory and therefore implemented Objects consists of:\n\n\n\n\n/0 - LwM2M Security\n - contains confidential part of information about connections to the LwM2M Servers configured in the Client. From the on-wire protocol perspective, it is write-only and accessible only via the Bootstrap Interface.\n\n\n/1 - LwM2M Server\n - contains non-confidential part of information about connections to the LwM2M Servers configured in the Client.\n\n\n/2 - Access Control\n needs to be supported and present if the Client supports more than one LwM2M Server connection at once.\n\n\n/3 - Device\n - contains basic information about the device, such as e.g. serial number.\n\n\n/5 - Firmware\n - enables OTA/Over-the-Air update support\n\n\n\n\nResources\n\n\nEach of the Resource definitions, contained in each Object definition, features the following information:\n\n\n\n\nID\n - numerical identifier of the Object.\n\n\nName\n - short description of the resource; it is not used in the actual on-wire protocol.\n\n\nOperations\n - one of:\n\n\nR\n - read-only Resource\n\n\nW\n - write-only Resource\n\n\nRW\n - writeable Resource\n\n\nE\n - executable Resource\n\n\n\n\n\n\nInstances\n - Single or Multiple; \u201cMultiple\u201d allows to have more than one instance of an object\n\n\nMandatory\n - Mandatory or Optional; Mandatory resources need to be present in all Instances on all devices. Optional resources may not be present in all Instances, and may even be not supported at all on some Clients.\n\n\nType\n - data type of the Resource value (or its instances in case of Multiple Resources).\n\n\nRange or Enumeration\n - specification of valid values for the Resource, within the given data type.\n\n\nUnits\n - units in which a numerical value is given.\n\n\nDescription\n - detailed description of the resource.\n\n\n\n\nReferences to specifications and further sources\n\n\n\n\n\"Anjay LwM2M library documentation\" \nhttps://avsystem.github.io/Anjay-doc\n\n\n\"IP for Smart Objects - IPSO Objects\" \nhttps://github.com/IPSO-Alliance/pub/edit/master/README.md\n\n\n\"The Constrained Application Protocol (CoAP)\". April 2017. \nhttps://tools.ietf.org/html/rfc7252\n\n\n\"Lightweight Machine to Machine Technical Specification, Approved Version 1.0\". Feb 2017. \nOMA-TS-LightweightM2M-V1_0-20170208-A.pdf\n\n\n\"Observing Resources in the Constrained Application Protocol (CoAP)\". April 2017. \nhttps://tools.ietf.org/html/rfc7641\n\n\n\"Constrained RESTful Environments (CoRE) Link Format\". April 2017. \nhttps://tools.ietf.org/html/rfc6690", 
            "title": "Introduction"
        }, 
        {
            "location": "/api/about/#about-oma-lightweight-m2m", 
            "text": "Standards for constrained devices are rapidly consolidating and the availability of IP on constrained devices enabled these devices to easily connect to the Internet. The IETF has also created a set of specifications for such IP-enabled devices to work in a Web-like fashion. One such protocol is the  Constrained Application Protocol (CoAP)  that provides request/response methods, ways to identify resources, discovery mechanisms, etc. similar to the  Hypertext Transfer Protocol  but for use in constrained environments.  However, the use of standardized protocols does not ensure interoperability on the application layer. Therefore, there is a clear need for being able to communicate using structured data models on top of protocols like CoAP and HTTP.  OMA (Open Mobile Alliance) has defined a standard for IoT or M2M devices, building on CoAP (and DTLS). It defines bootstrap and device management, as well as a data model.", 
            "title": "About OMA Lightweight M2M"
        }, 
        {
            "location": "/api/about/#data-model", 
            "text": "Each LwM2M client presents a data model - standardized, symbolic representation of its configuration and state that is accessible for reading and modifying by LwM2M Servers. It can be thought of as a combination of a hierarchical configuration file, and a view on statistical information about the device and its environment.  The LwM2M data model is very strictly organized as a three-level tree. Entities on each of those levels are identified with numerical identifiers. Those three levels are:    Object  - each Object represent some different concept of data accessible via the LwM2M client. For example, separate Objects are defined for managing connections with LwM2M servers, for managing network connections, for accessing data from various types of sensors, etc.\n\nEach Object is assigned a unique numerical identifier in the range 0-65535, inclusive. OMA manages a registry of known Object IDs. Each Object defines a set of Resources whose meanings are common for each Object Instance.   Object Instance  - some Objects are described as \u201csingle-instance\u201d - such Objects always have exactly one Instance with identifier 0. Examples of such Objects include the Device object which describes the device itself, and the Firmware Update object which is used to perform firmware upgrades.\n\nOther Objects may have multiple Instances; sometimes the number of Instances may be variable and the Instances themselves may be creatable via LwM2M. Examples of such Objects include the Object that manages connections to LwM2M Servers, Object that represents optional software packages installed on the device, and Objects representing sensors (whose instances are, however, not creatable). Identifiers for each Instance of such Objects may be arbitrarily chosen in the range 0-65534, inclusive - note that 65535 is reserved and forbidden in this context.   Resource  - each Object Instance of a given Object supports the same set of Resources, as defined by the Object definition. Within a given Object, each Resource ID (which may be in the range 0-65535, inclusive) has a well-defined meaning, and represent the same concept. However, some Resources may not be present in some Object Instances, and, obviously, their values and mapping onto real-world entities may be different.   The numerical identifiers on each of these levels form a path, which is used as the path portion of CoAP URLs. For example, a path  /1/2/3  refers to Resource ID=3 in Object Instance ID=2 of Object ID=1. Whole Object Instances (/ ) or event Objects (/1) may be referred to using this syntax as well.  Find an example for an object definition in LWM2M xml schema at  urn:oma:lwm2m:ext:3303 .", 
            "title": "Data model"
        }, 
        {
            "location": "/api/about/#objects", 
            "text": "Each Object definition, which may be found in the LwM2M specification, features the following information:   Name  - description of the object; it is not used in the actual on-wire protocol.  Object ID  - numerical identifier of the Object  Instances  - Single (always has one Instance with ID=0) or Multiple (may have arbitrary number of Instances depending on current configuration)  Mandatory  - Mandatory (must be supported by all LwM2M Client implementations) or Optional (may not be supported)  Object URN  -  For example  urn:oma:lwm2m:ext:3347  Resource definitions : A list of resource definitions. See section further down.", 
            "title": "Objects"
        }, 
        {
            "location": "/api/about/#implemented-objects", 
            "text": "The current set of mandatory and therefore implemented Objects consists of:   /0 - LwM2M Security  - contains confidential part of information about connections to the LwM2M Servers configured in the Client. From the on-wire protocol perspective, it is write-only and accessible only via the Bootstrap Interface.  /1 - LwM2M Server  - contains non-confidential part of information about connections to the LwM2M Servers configured in the Client.  /2 - Access Control  needs to be supported and present if the Client supports more than one LwM2M Server connection at once.  /3 - Device  - contains basic information about the device, such as e.g. serial number.  /5 - Firmware  - enables OTA/Over-the-Air update support", 
            "title": "Implemented objects"
        }, 
        {
            "location": "/api/about/#resources", 
            "text": "Each of the Resource definitions, contained in each Object definition, features the following information:   ID  - numerical identifier of the Object.  Name  - short description of the resource; it is not used in the actual on-wire protocol.  Operations  - one of:  R  - read-only Resource  W  - write-only Resource  RW  - writeable Resource  E  - executable Resource    Instances  - Single or Multiple; \u201cMultiple\u201d allows to have more than one instance of an object  Mandatory  - Mandatory or Optional; Mandatory resources need to be present in all Instances on all devices. Optional resources may not be present in all Instances, and may even be not supported at all on some Clients.  Type  - data type of the Resource value (or its instances in case of Multiple Resources).  Range or Enumeration  - specification of valid values for the Resource, within the given data type.  Units  - units in which a numerical value is given.  Description  - detailed description of the resource.", 
            "title": "Resources"
        }, 
        {
            "location": "/api/about/#references-to-specifications-and-further-sources", 
            "text": "\"Anjay LwM2M library documentation\"  https://avsystem.github.io/Anjay-doc  \"IP for Smart Objects - IPSO Objects\"  https://github.com/IPSO-Alliance/pub/edit/master/README.md  \"The Constrained Application Protocol (CoAP)\". April 2017.  https://tools.ietf.org/html/rfc7252  \"Lightweight Machine to Machine Technical Specification, Approved Version 1.0\". Feb 2017.  OMA-TS-LightweightM2M-V1_0-20170208-A.pdf  \"Observing Resources in the Constrained Application Protocol (CoAP)\". April 2017.  https://tools.ietf.org/html/rfc7641  \"Constrained RESTful Environments (CoRE) Link Format\". April 2017.  https://tools.ietf.org/html/rfc6690", 
            "title": "References to specifications and further sources"
        }, 
        {
            "location": "/api/objects-registry/", 
            "text": "OMA defined LwM2M objects and resources\n\n\nThe \nOMA LwM2M Registry\n contains a wide range of defined objects and resources,\nin a machine readable way (XML).\nNew objects and resources can be proposed via the \nLwM2M Editor\n.\n\n\nWakaamaNode provides ready-to-consume C++ objects for all lwM2M objects of the registry. Just be aware that\nspecial implementations exist for object ID 1 (LWM2M Server), 2 (Access Control), 3 (device) and 5 (firmware)\nand you should not use the auto generated ones.\n\n\nHow to use a predefined object\n\n\nA full example can be found in \nGet started\n.\nFor example if you want to use the \"Light Control\" lwM2M object:\n\n\n\n\nSearch the list below for \"Light Control\".\n\n\nFind it under object id 3311.\n\n\nInclude \nsrc/lwm2mObjects/3311.h\n and use the class \nobject\n in namespace \nKnownObjects/id311\n.\n\n\nCreate as many object instances as you need and add them to the object via \nobject.addInstance(lwm2mContext, objectInstance)\n.\n\n\nMake the object itself known to WakaamaNode with \nobject.register(lwm2mContext)\n.\n\n\n\n\n#include\n \nlwm2mObjects/3311.h\n\n\n#include\n \nlwm2m/connect.h\n\n\n\nlwm2m_client_context_t\n \ncontext\n;\n\n\n\nusing\n \nnamespace\n \nKnownObjects\n;\n\n\n\n// Define the object and as many instances as you need\n\n\nid3311\n::\nobject\n \nlights\n;\n\n\nid3311\n::\ninstance\n \nled\n;\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n    \n// Overwrite the verifyFunction and \nabuse\n it as value changed event.\n\n    \nlights\n.\nverifyWrite\n \n=\n \n[](\nLwm2mObjectInstance\n*\n \ninstance\n,\n \nuint16_t\n \nres_id\n)\n \n{\n\n        \nauto\n \ninst\n \n=\n \ninstance\n-\nas\nid3311\n::\ninstance\n();\n\n        \n// Is it instance 0 and the OnOff resource?\n\n        \nif\n \n(\ninst\n-\nid\n \n==\n \n0\n \n \nid3311\n::\nRESID\n::\nOnOff\n \n==\n \nres_id\n)\n \n{\n\n            \n// Change the led pin depending on the OnOff value\n\n            \ndigitalWrite\n(\nLED_BUILTIN\n,\n \ninst\n-\nOnOff\n);\n\n        \n}\n\n        \n// Return true to accept the value and ACK to the server\n\n        \nreturn\n \ntrue\n;\n\n    \n};\n\n\n    \nled\n.\nid\n \n=\n \n0\n;\n \n// set instance id\n\n    \nlights\n.\naddInstance\n(\nCTX\n(\ncontext\n),\n \nled\n);\n\n    \nlights\n.\nregisterObject\n(\nCTX\n(\ncontext\n));\n\n\n}\n\n\n\nvoid\n \npush_button_pressed\n(\nbool\n \nnewState\n)\n \n{\n\n    \nled\n.\nOnOff\n \n=\n \nnewState\n;\n\n    \ndigitalWrite\n(\nLED_BUILTIN\n,\n \nled\n.\nOnOff\n);\n\n    \nlights\n.\nresChanged\n(\nCTX\n(\ncontext\n),\n \nled\n.\nid\n,\n \n(\nuint16_t\n)\nid3311\n::\nRESID\n::\nOnOff\n);\n\n\n}\n\n\n\n\n\nList of supported objects\n\n\n\n#lwm2mObjects tr:nth-child(even){background-color: #f2f2f2;}\n\n#lwm2mObjects tr:hover {background-color: #ddd;}\n\n#lwm2mObjects th {\n    padding-top: 12px;\n    padding-bottom: 12px;\n    text-align: left;\n    background-color: #ef5350;\n    color: white;\n}\n  \n\n\n\n\n   \n\n      \n\n         \nObject ID\n\n         \nName\n\n         \nDescription\n\n      \n\n   \n\n   \n\n      \n\n         \n\n            \n1\n\n         \n\n         \nLWM2M Server\n\n         \nIt provides the data related to a LWM2M Server. A Bootstrap Server has no such an Object Instance associated to it.\n\n      \n\n      \n\n         \n\n            \n2\n\n         \n\n         \nAccess Control\n\n         \nIt is used to check whether the LWM2M Server has access right for performing a operation.\n\n      \n\n      \n\n         \n\n            \n3\n\n         \n\n         \nDevice\n\n         \nIt provides a range of device related information which can be queried by the LWM2M Server, and a device reboot and factory reset function.\n\n      \n\n      \n\n         \n\n            \n4\n\n         \n\n         \nConnectivity Monitoring\n\n         \nIt enables monitoring of parameters related to network connectivity. In this general connectivity Object, the Resources are limited to the most general cases common to most network bearers. It is recommended to read the description, which refers to relevant standard development organizations (e.g. 3GPP, IEEE). The goal of the Connectivity Monitoring Object is to carry information reflecting the more up to date values of the current connection for monitoring purposes. Resources such as Link Quality, Radio Signal Strenght, Cell ID are retrieved during connected mode at least for cellular networks.\n\n      \n\n      \n\n         \n\n            \n5\n\n         \n\n         \nFirmware\n\n         \nIt enables management of firmware which is to be updated. This Object includes installing firmware package, updating firmware, and performing actions after updating firmware\n\n      \n\n      \n\n         \n\n            \n6\n\n         \n\n         \nLocation\n\n         \nIt provides a range of device related information which can be queried by the LWM2M Server, and a device reboot and factory reset function.\n\n      \n\n      \n\n         \n\n            \n7\n\n         \n\n         \nConnectivity Statistics\n\n         \nThis LWM2M Objects enables client to collect statistical information and enables the LWM2M Server to retrieve these information, set the collection duration and reset the statistical parameters.\n\n      \n\n      \n\n         \n\n            \n8\n\n         \n\n         \nLock and Wipe\n\n         \nThis LWM2M objects provides the resources needed to perform the lock and wipe operations\n\n      \n\n      \n\n         \n\n            \n9\n\n         \n\n         \nSofware Management\n\n         \nThis LWM2M objects provides the resources needed to perform software management on the device. Each software component is managed via a dedicated Software Management Object instance\n\n      \n\n      \n\n         \n\n            \n10\n\n         \n\n         \nCellular connectivity\n\n         \nIt specifies resources to enable a device to connect to a 3GPP or 3GPP2 bearer, including GPRS/EDGE, UMTS, LTE, SMS. For cellular connectivity, this object focuses on Packet Switched (PS) connectivity and doesn't aim to provide comprehensive Circuit Switched (CS) connectivity management.\n\n      \n\n      \n\n         \n\n            \n11\n\n         \n\n         \nAPN connection profile\n\n         \nIt specifies resources to enable a device to connect to an APN.\n\n      \n\n      \n\n         \n\n            \n12\n\n         \n\n         \nWLAN connectivity\n\n         \nIt specifies resources to enable a device to connect to a WLAN bearer.\n\n      \n\n      \n\n         \n\n            \n13\n\n         \n\n         \nBearer selection\n\n         \nIt specifies resources to enable a device to choose a communications bearer on which to connect.\n\n      \n\n      \n\n         \n\n            \n14\n\n         \n\n         \nSoftware Component\n\n         \nThe LWM2M software management object enables remote software management in M2M devices\n\n      \n\n      \n\n         \n\n            \n15\n\n         \n\n         \nDevCapMgmt\n\n         \nIt manages the device capabilities of a device e.g. sensors, communication, etc.\n\n      \n\n      \n\n         \n\n            \n16\n\n         \n\n         \nPorfolio\n\n         \nThe Portfolio Object allows to extend the data storage capability of other Object Instances in the LwM2M system, as well as the services which may be used to authenticate and to protect privacy of data contained in those extensions. In addition, a service of data encryption is also defined\n\n      \n\n      \n\n         \n\n            \n17\n\n         \n\n         \nCommunications Characteristics\n\n         \nThis object enables configuration of various generic communications parameters.\n\n      \n\n      \n\n         \n\n            \n18\n\n         \n\n         \nNon-Access Stratum (NAS) Configuration\n\n         \nThis object provides Non-Access Stratum (NAS) configuration and is derived from 3GPP TS 24.368.\n\n      \n\n      \n\n         \n\n            \n19\n\n         \n\n         \nLwM2M APPDATA\n\n         \nThis LwM2M object provides the application service data related to a LwM2M Server, eg. Water meter data.\n\n      \n\n      \n\n         \n\n            \n20\n\n         \n\n         \nEventLog\n\n         \nThe Event Log Object is a single Instance Object defined for logging data in a straightforward         and generic way. The Resources of that Object are based on the OMA LwM2M set of reusable Resources dedicated to logging event activity.\n\n      \n\n      \n\n         \n\n            \n21\n\n         \n\n         \nPending\n\n         \nPending\n\n      \n\n      \n\n         \n\n            \n2048\n\n         \n\n         \nCmdhPolicy\n\n         \nThis Object provides links to a set of rules associated with a specific CSE that governs the behavior             of that CSE regarding rejecting, buffering and sending request or response messages via the Mcc reference point.\n\n      \n\n      \n\n         \n\n            \n2049\n\n         \n\n         \nActiveCmdhPolicy\n\n         \nThis Object provides a link to the currently active set of CMDH policies\n\n      \n\n      \n\n         \n\n            \n2050\n\n         \n\n         \nCmdhDefaults\n\n         \nDefines which CMDH related parameters will be used by default.\n\n      \n\n      \n\n         \n\n            \n2051\n\n         \n\n         \nCmdhDefEcValues\n\n         \nThis Object represents default set of values for the Event Category parameter of an incoming request or response message.\n\n      \n\n      \n\n         \n\n            \n2052\n\n         \n\n         \nCmdhEcDefParamValues\n\n         \nThis Object represents a specific set of default values for the CMDH related parameters Request Expiration Timestamp, Result Expiration Timestamp, Operational Execution Time, Result Persistence and Delivery Aggregation that are applicable for a given Event Category if these parameters are not specified in the message.\n\n      \n\n      \n\n         \n\n            \n2053\n\n         \n\n         \nCmdhLimits\n\n         \nThis Object represents limits for CMDH related parameter values.\n\n      \n\n      \n\n         \n\n            \n2054\n\n         \n\n         \nCmdhNetworkAccessRules\n\n         \nThis Object defines the usage of underlying networks for forwarding information to other CSEs during processing of CMDH-related requests in a CSE.\n\n      \n\n      \n\n         \n\n            \n2055\n\n         \n\n         \nCmdhNwAccessRule\n\n         \nThis Object defines limits in usage of specific underlying networks for forwarding information to other CSEs during processing of CMDH-related requests in a CSE.\n\n      \n\n      \n\n         \n\n            \n2056\n\n         \n\n         \nCmdhBuffer\n\n         \nThis Object defines limits in usage of buffers for temporarily storing information that needs to be forwarded to other CSEs during processing of CMDH-related requests in a CSE.\n\n      \n\n      \n\n         \n\n            \n2057\n\n         \n\n         \nCmdhBackOffParametersSet\n\n         \nThis Object defines set of parameters which can be referenced by a specific Instance of the CmdhNwAccessRule Object (ID: 2055)\n\n      \n\n      \n\n         \n\n            \n3200\n\n         \n\n         \nDigital Input\n\n         \nThis IPSO object is a generic object that can be used with any kind of digital input interface. Specific objects for a given range of sensors are described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist.\n\n      \n\n      \n\n         \n\n            \n3201\n\n         \n\n         \nDigital Output\n\n         \nThis IPSO object is a generic object that can be used with any kind of digital output interface. Specific object for a given range of sensors is described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist.\n\n      \n\n      \n\n         \n\n            \n3202\n\n         \n\n         \nAnalogue Input\n\n         \nThis IPSO object is a generic object that can be used with any kind of analogue input interface. Specific object for a given range of sensors is described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist.\n\n      \n\n      \n\n         \n\n            \n3203\n\n         \n\n         \nAnalogue Output\n\n         \nThis IPSO object is a generic object that can be used with any kind of analogue input interface. Specific object for a given range of sensors is described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist.\n\n      \n\n      \n\n         \n\n            \n3300\n\n         \n\n         \nGeneric Sensor\n\n         \nThis IPSO object allow the description of a generic sensor. It is based on the description of a value and a unit according to the UCUM specification. Thus, any type of value defined within this specification can be reporting using this object. Specific object for a given range of sensors is described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist.\n\n      \n\n      \n\n         \n\n            \n3301\n\n         \n\n         \nIlluminance Sensor\n\n         \nThis IPSO object should be used over a luminosity sensor to report a remote luminosity measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range that can be measured by the luminosity sensor. The unit used here is Lux (ucum:lx).\n\n      \n\n      \n\n         \n\n            \n3302\n\n         \n\n         \nPresence Sensor\n\n         \nThis IPSO object should be used over a presence sensor to report a remote presence detection. It also provides resources to manage a counter, the type of sensor used (e.g the technology of the probe), and configuration for the delay between busy and clear detection state.\n\n      \n\n      \n\n         \n\n            \n3303\n\n         \n\n         \nTemperature Sensor\n\n         \nThis IPSO object should be used over a temperature sensor to report a remote temperature measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range that can be measured by the temperature sensor. The unit used here is degree Celsius (ucum:Cel).\n\n      \n\n      \n\n         \n\n            \n3304\n\n         \n\n         \nHumidity Sensor\n\n         \nThis IPSO object should be used over a humidity sensor to report a remote humidity measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range that can be measured by the humidity sensor. The unit used here is relative humidity as a percentage (ucum:%).\n\n      \n\n      \n\n         \n\n            \n3305\n\n         \n\n         \nPower Measurement\n\n         \nThis IPSO object should be used over a power measurement sensor to report a remote power measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range for both active and reactive power. Il also provides resources for cumulative energy, calibration, and the power factor.\n\n      \n\n      \n\n         \n\n            \n3306\n\n         \n\n         \nActuation\n\n         \nThis IPSO object is dedicated to remote actuation such as ON/OFF action or dimming. A multistate output can also be described as a string. This is useful to send pilot wire orders for instance. It also provides a resource to reflect the time that the device has been switched on.\n\n      \n\n      \n\n         \n\n            \n3308\n\n         \n\n         \nSet Point\n\n         \nThis IPSO object should be used to set a desired value to a controller, such as a thermostat. This object enables a setpoint to be expressed units defined in the UCUM specification, to match an associated sensor or measurement value. A special resource is added to set the colour of an object.\n\n      \n\n      \n\n         \n\n            \n3310\n\n         \n\n         \nLoad Control\n\n         \nThis Object is used for demand-response load control and other load control in automation application (not limited to power).\n\n      \n\n      \n\n         \n\n            \n3311\n\n         \n\n         \nLight Control\n\n         \nThis Object is used to control a light source, such as a LED or other light. It allows a light to be turned on or off and its dimmer setting to be control as a % between 0 and 100.\n\n      \n\n      \n\n         \n\n            \n3312\n\n         \n\n         \nPower Control\n\n         \nThis Object is used to control a power source, such as a Smart Plug. It allows a power relay to be turned on or off and its dimmer setting to be control as a % between 0 and 100.\n\n      \n\n      \n\n         \n\n            \n3313\n\n         \n\n         \nAccelerometer\n\n         \nThis IPSO object can be used to represent a 1-3 axis accelerometer.\n\n      \n\n      \n\n         \n\n            \n3314\n\n         \n\n         \nMagnetometer\n\n         \nThis IPSO object can be used to represent a 1-3 axis magnetometer with optional compass direction.\n\n      \n\n      \n\n         \n\n            \n3315\n\n         \n\n         \nBarometer\n\n         \nThis IPSO object should be used with an air pressure sensor to report a remote barometer measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range that can be measured by the barometer sensor.\n\n      \n\n      \n\n         \n\n            \n3316\n\n         \n\n         \nVoltage\n\n         \nThis IPSO object should be used with voltmeter sensor to report measured voltage between two points. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. An example measurement unit is volts (ucum: V).\n\n      \n\n      \n\n         \n\n            \n3317\n\n         \n\n         \nCurrent\n\n         \nThis IPSO object should be used with an ammeter to report measured electric current in amperes. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. An example measurement unit is volts (ucum: A).\n\n      \n\n      \n\n         \n\n            \n3318\n\n         \n\n         \nFrequency\n\n         \nThis IPSO object should be used to report frequency measurements. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. An example measurement unit is volts (ucum: Hz).\n\n      \n\n      \n\n         \n\n            \n3319\n\n         \n\n         \nDepth\n\n         \nThis IPSO object should be used to report depth measurements. It can, for example, be used to describe a generic rain gauge that measures the accumulated rainfall in millimetres (mm) or in fathoms (fth).\n\n      \n\n      \n\n         \n\n            \n3320\n\n         \n\n         \nPercentage\n\n         \nThis IPSO object should can be used to report measurements relative to a 0-100% scale. For example it could be used to measure the level of a liquid in a vessel or container in units of %.\n\n      \n\n      \n\n         \n\n            \n3321\n\n         \n\n         \nAltitude\n\n         \nThis IPSO object should be used with an altitude sensor to report altitude above sea level in meters. Note that Altitude can be calculated from the measured pressure given the local sea level pressure. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. An example measurement unit is meters (ucum: m).\n\n      \n\n      \n\n         \n\n            \n3322\n\n         \n\n         \nLoad\n\n         \nThis IPSO object should be used with a load sensor (as in a scale) to report the applied weight or force. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor.\n\n      \n\n      \n\n         \n\n            \n3323\n\n         \n\n         \nPressure\n\n         \nThis IPSO object should be used to report pressure measurements. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor.\n\n      \n\n      \n\n         \n\n            \n3324\n\n         \n\n         \nLoudness\n\n         \nThis IPSO object should be used to report loudness or noise level measurements. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor.\n\n      \n\n      \n\n         \n\n            \n3325\n\n         \n\n         \nConcentration\n\n         \nThis IPSO object should be used to the particle concentration measurement of a medium. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor.\n\n      \n\n      \n\n         \n\n            \n3326\n\n         \n\n         \nAcidity\n\n         \nThis IPSO object should be used to report an acidity measurement of a liquid. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor.\n\n      \n\n      \n\n         \n\n            \n3327\n\n         \n\n         \nConductivity\n\n         \nThis IPSO object should be used to report a measurement of the electric conductivity of a medium or sample. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor.\n\n      \n\n      \n\n         \n\n            \n3328\n\n         \n\n         \nPower\n\n         \nThis IPSO object should be used to report power measurements. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor.\n\n      \n\n      \n\n         \n\n            \n3329\n\n         \n\n         \nPower Factor\n\n         \nThis IPSO object should be used to report a measurement or calculation of the power factor of a reactive electrical load.\n\n      \n\n      \n\n         \n\n            \n3330\n\n         \n\n         \nDistance\n\n         \nThis IPSO object should be used to report a distance measurement. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor.\n\n      \n\n      \n\n         \n\n            \n3331\n\n         \n\n         \nEnergy\n\n         \nThis IPSO object should be used to report energy consumption (Cumulative Power) of an electrical load.\n\n      \n\n      \n\n         \n\n            \n3332\n\n         \n\n         \nDirection\n\n         \nThis IPSO object is used to report the direction indicated by a compass, wind vane, or other directional indicator. The units of measure is plane angle degrees (ucum:deg).\n\n      \n\n      \n\n         \n\n            \n3333\n\n         \n\n         \nTime\n\n         \nThis IPSO object is used to report the current time in seconds since January 1, 1970 UTC. There is also a fractional time counter that has a range of less than one second.\n\n      \n\n      \n\n         \n\n            \n3334\n\n         \n\n         \nGyrometer\n\n         \nThis IPSO Object is used to report the current reading of a gyrometer sensor in 3 axes. It provides tracking of the minimum and maximum angular rate in all 3 axes.\n\n      \n\n      \n\n         \n\n            \n3335\n\n         \n\n         \nColor\n\n         \nThis IPSO object should be used to report the measured value of a colour sensor in some colour space described by the units resource.\n\n      \n\n      \n\n         \n\n            \n3336\n\n         \n\n         \nGPS Location\n\n         \nThis IPSO object represents GPS coordinates. This object is compatible with the LWM2M management object for location, but uses reusable resources.\n\n      \n\n      \n\n         \n\n            \n3337\n\n         \n\n         \nPositioner\n\n         \nThis IPSO object should be used with a generic position actuator from 0 to 100%.\n\n      \n\n      \n\n         \n\n            \n3338\n\n         \n\n         \nBuzzer\n\n         \nThis IPSO object should be used to actuate an audible alarm such as a buzzer, beeper, or vibration alarm.\n\n      \n\n      \n\n         \n\n            \n3339\n\n         \n\n         \nAudio Clip\n\n         \nThis IPSO object should be used for a speaker that plays a pre-recorded audio clip or an audio output that is sent elsewhere.\n\n      \n\n      \n\n         \n\n            \n3340\n\n         \n\n         \nTimer\n\n         \nThis IPSO object is used to time events and actions, using patterns common to industrial timers. A POST to the trigger resource or On/Off input state change starts the timing operation, and the timer remaining time shows zero when the operation is complete.\n\n      \n\n      \n\n         \n\n            \n3341\n\n         \n\n         \nAddressable Text Display\n\n         \nThis IPSO object is used to send text to a text-only or text mode graphics display.\n\n      \n\n      \n\n         \n\n            \n3342\n\n         \n\n         \nOn/Off Switch\n\n         \nThis IPSO object should be used with an On/Off switch to report the state of the switch.\n\n      \n\n      \n\n         \n\n            \n3343\n\n         \n\n         \nLever Control\n\n         \nThis IPSO object should be used with a dimmer or level control to report the state of the control.\n\n      \n\n      \n\n         \n\n            \n3344\n\n         \n\n         \nUp/Down Control\n\n         \nThis IPSO object is used to report the state of an up/down control element like a pair of push buttons or a rotary encoder.\n\n      \n\n      \n\n         \n\n            \n3345\n\n         \n\n         \nMultiple Axis Joystick\n\n         \nThis IPSO object can be used to report the position of a shuttle or joystick control. A digital input is provided to report the state of an associated push button.\n\n      \n\n      \n\n         \n\n            \n3346\n\n         \n\n         \nRate\n\n         \nThis object type should be used to report a rate measurement,\n\n      \n\n      \n\n         \n\n            \n3347\n\n         \n\n         \nPush Button\n\n         \nThis IPSO object is used to report the state of a momentary action push button control and to count the number of times the control has been operated since the last observation.\n\n      \n\n      \n\n         \n\n            \n3348\n\n         \n\n         \nMultistate Selector\n\n         \nThis IPSO object is used to represent the state of a multistate selector switch with a number of fixed positions.\n\n      \n\n      \n\n         \n\n            \n3349\n\n         \n\n         \nBitmap\n\n         \nSummarize several digital inputs to one value by mapping each bit to a digital input.\n\n      \n\n      \n\n         \n\n            \n3350\n\n         \n\n         \nStopwatch\n\n         \nAn ascending timer that counts how long time has passed since the timer was started after reset.\n\n      \n\n      \n\n         \n\n            \n3351\n\n         \n\n         \npowerupLog\n\n         \nOne time event sent by the device at power up.\n\n      \n\n      \n\n         \n\n            \n3352\n\n         \n\n         \nplmnSearchEvent\n\n         \nList of all PLMNs found during the initial search/scan\n\n      \n\n      \n\n         \n\n            \n3353\n\n         \n\n         \nscellID\n\n         \nserving cell information that the RRC decides to camp on\n\n      \n\n      \n\n         \n\n            \n3354\n\n         \n\n         \ncellReselectionEvent\n\n         \ncell reselection event information\n\n      \n\n      \n\n         \n\n            \n3355\n\n         \n\n         \nhandoverEvent\n\n         \nhandover event information\n\n      \n\n      \n\n         \n\n            \n3356\n\n         \n\n         \nradioLinkFailureEvent\n\n         \nRadio Link Failure Event\n\n      \n\n      \n\n         \n\n            \n3357\n\n         \n\n         \nrrcStateChangeEvent\n\n         \nCurrent RRC state change information, including the event that triggered the state change\n\n      \n\n      \n\n         \n\n            \n3358\n\n         \n\n         \nrrcTimerExpiryEvent\n\n         \nRRC timer expiry event information\n\n      \n\n      \n\n         \n\n            \n3359\n\n         \n\n         \ncellBlacklistEvent\n\n         \nCell blacklist information\n\n      \n\n      \n\n         \n\n            \n3360\n\n         \n\n         \nesmContextInfo\n\n         \nESM context information\n\n      \n\n      \n\n         \n\n            \n3361\n\n         \n\n         \nemmStateValue\n\n         \nEMM context information\n\n      \n\n      \n\n         \n\n            \n3362\n\n         \n\n         \nnasEmmTimerExpiryEvent\n\n         \nNAS EMM timer expiry information\n\n      \n\n      \n\n         \n\n            \n3363\n\n         \n\n         \nnasEsmExpiryEvent\n\n         \nNAS ESM timer expiry information\n\n      \n\n      \n\n         \n\n            \n3364\n\n         \n\n         \nemmFailureCauseEvent\n\n         \nTriggered at EMM failure - failure cause is logged\n\n      \n\n      \n\n         \n\n            \n3365\n\n         \n\n         \nrachLatency_delay\n\n         \nRACH Latency and delay information\n\n      \n\n      \n\n         \n\n            \n3366\n\n         \n\n         \nmacRachAttemptEvent\n\n         \nRACH information. Logged at RACH TX\n\n      \n\n      \n\n         \n\n            \n3367\n\n         \n\n         \nmacRachAttemptReasonEvent\n\n         \nRACH Information - reason for initiating RACH\n\n      \n\n      \n\n         \n\n            \n3368\n\n         \n\n         \nmacTimerStatusEvent\n\n         \nMAC timer expiry information\n\n      \n\n      \n\n         \n\n            \n3369\n\n         \n\n         \nmacTimingAdvanceEvent\n\n         \nTiming advance information\n\n      \n\n      \n\n         \n\n            \n3370\n\n         \n\n         \nServingCellMeasurement\n\n         \nServing Cell Measurement\n\n      \n\n      \n\n         \n\n            \n3371\n\n         \n\n         \nNeighborCellMeasurements\n\n         \nNeighbor Cell Measurements\n\n      \n\n      \n\n         \n\n            \n3372\n\n         \n\n         \nTiming Advance Information\n\n         \nNeighbor Cell Measurements\n\n      \n\n      \n\n         \n\n            \n3373\n\n         \n\n         \ntxPowerHeadroomEvent\n\n         \nTX power headroom information\n\n      \n\n      \n\n         \n\n            \n3374\n\n         \n\n         \nradioLinkMonitoring\n\n         \nRadio Link monitoring information maintained by RRC\n\n      \n\n      \n\n         \n\n            \n3375\n\n         \n\n         \nPagingDRX\n\n         \nPaging DRX information\n\n      \n\n      \n\n         \n\n            \n3376\n\n         \n\n         \ntxPowerBackOffEvent\n\n         \nTX Power backoff information\n\n      \n\n      \n\n         \n\n            \n3377\n\n         \n\n         \nMessage3Report\n\n         \nRACH message 3 report information\n\n      \n\n      \n\n         \n\n            \n3378\n\n         \n\n         \nPbchDecodingResults\n\n         \nServing cell PBCH decoding information\n\n      \n\n      \n\n         \n\n            \n3379\n\n         \n\n         \npucchPowerControl\n\n         \nPUCCH TX power control information\n\n      \n\n      \n\n         \n\n            \n3380\n\n         \n\n         \nPrachReport\n\n         \nPRACH report information\n\n      \n\n      \n\n         \n\n            \n3381\n\n         \n\n         \nVolteCallEvent\n\n         \nVoLTE call status\n\n      \n\n      \n\n         \n\n            \n3382\n\n         \n\n         \nSipRegistrationEvent\n\n         \nSIP Registration status\n\n      \n\n      \n\n         \n\n            \n3383\n\n         \n\n         \nsipPublishEvent\n\n         \nSIP Publish status\n\n      \n\n      \n\n         \n\n            \n3384\n\n         \n\n         \nsipSubscriptionEvent\n\n         \nSIP Subscription status\n\n      \n\n      \n\n         \n\n            \n3385\n\n         \n\n         \nvolteCallStateChangeEvent\n\n         \nVoLTE call status change\n\n      \n\n      \n\n         \n\n            \n3386\n\n         \n\n         \nVoLTErtpPacketLoss\n\n         \nLog is generated at the receiving end of RTP flow when newReceivedSequenceNumber - lastReceivedSequenceNumber \n 1\n\n      \n\n      \n\n         \n\n            \n10241\n\n         \n\n         \nHostDeviceInfo\n\n         \nThis LWM2M Object provides a range of host device related information which can be queried by the LWM2M Server. The host device is any integrated device with an embedded cellular radio module.\n\n      \n\n      \n\n         \n\n            \n10242\n\n         \n\n         \n3-PhasePM\n\n         \nThis Object provides the information to represent a generic 3-Phase Power Meter\n\n      \n\n      \n\n         \n\n            \n10243\n\n         \n\n         \nsinglePhasePM\n\n         \nThis Object provides the information to represent a generic Single-Phase Power Meter\n\n      \n\n      \n\n         \n\n            \n10244\n\n         \n\n         \nvehicle control unit\n\n         \nThis Object provides the information to represent a generic VCU (vehicle control unit)\n\n      \n\n      \n\n         \n\n            \n10245\n\n         \n\n         \nRelay Management\n\n         \nThis LWM2M Object provides a range of eNB related measurements and parameters of which several are changeable. Furthermore, it includes Resources to enable/disable the eNB\n\n      \n\n      \n\n         \n\n            \n10246\n\n         \n\n         \nCrowdBox Measurements\n\n         \nThis LWM2M Object provides CrowdBox-related measurements such as serving cell parameters, backhaul timing advance, and neighbour cell reports.\n\n      \n\n      \n\n         \n\n            \n10247\n\n         \n\n         \nNeighbour Cell Report\n\n         \nThis LWM2M Object provides the neighbour cell report. The CrowdBox Measurements Object and the Connected UE Report Object have both Objlnk Resources pointing to this Object\n\n      \n\n      \n\n         \n\n            \n10248\n\n         \n\n         \nConnected UE Measurements\n\n         \nThis LWM2M Object provides a range of measurements of connected UEs and provides an Object link to the Connected UE report.\n\n      \n\n      \n\n         \n\n            \n10249\n\n         \n\n         \n   Connected UE Report\n\n         \nThis LWM2M Object provides a range of information related to the connected UEs.\n\n      \n\n      \n\n         \n\n            \n10250\n\n         \n\n         \nApp Data Container\n\n         \nThis LWM2M Object is used for reporting application data of a device.\n\n      \n\n      \n\n         \n\n            \n10251\n\n         \n\n         \nAT Command\n\n         \nUsed to execute an AT command on a cellular modem\n\n      \n\n      \n\n         \n\n            \n10252\n\n         \n\n         \nManifest\n\n         \nThis object provides a range of information related to updating packages on a device\n\n      \n\n      \n\n         \n\n            \n10253\n\n         \n\n         \nConfidential Data\n\n         \nThis LWM2M Object is used for reporting data, but in a confidential way\n\n      \n\n      \n\n         \n\n            \n10254\n\n         \n\n         \nCurrent Loop Input\n\n         \nThis LwM2M Object provides a representation of a current loop sensor, which indicates the value emitted by a current source.\n\n      \n\n      \n\n         \n\n            \n10255\n\n         \n\n         \nDevice Metadata\n\n         \nThis object provides a range of information related to device metadata\n\n      \n\n      \n\n         \n\n            \n10256\n\n         \n\n         \nECID-Signal Measurement Information\n\n         \nThis LWM2M Object provides ECID signal measurements of a device.\n\n      \n\n      \n\n         \n\n            \n10257\n\n         \n\n         \nHeat/Cooling meter\n\n         \nThis Object provides the information to represent a generic (district) heat or cooling meter\n\n      \n\n      \n\n         \n\n            \n10258\n\n         \n\n         \nCurrent Loop Output\n\n         \nThis LWM2M Object provides a representation of a current loop source, which may be used to carry control signals.\n\n      \n\n      \n\n         \n\n            \n10259\n\n         \n\n         \nSystem Log\n\n         \nThis object provides read access to log buffers as well as limited configuration of logging services.\n\n      \n\n      \n\n         \n\n            \n10260\n\n         \n\n         \nRuntime Database\n\n         \nThis object allows manipulation of Runtime Database variables.\n\n      \n\n      \n\n         \n\n            \n10260\n\n         \n\n         \nRuntime Database\n\n         \nThis object allows manipulation of Runtime Database variables.\n\n      \n\n      \n\n         \n\n            \n10262\n\n         \n\n         \nInterval Data Delivery\n\n         \nThe Interval Data Delivery object provides an optimised means for managing the delivery of interval data from multiple Interval Data Object instances. \n\n      \n\n      \n\n         \n\n            \n10263\n\n         \n\n         \nEvent Data Delivery\n\n         \nThe Event Data Delivery object provides a simple means for managing the delivery of event data from multiple Event Data Object instances.\n\n      \n\n      \n\n         \n\n            \n10264\n\n         \n\n         \nDelivery Schedule\n\n         \nThe Delivery Schedule object provides a means for controlling the periodic delivery of interval and event data to the LwM2M server.\n\n      \n\n      \n\n         \n\n            \n10265\n\n         \n\n         \nLeakage Detection Configuration\n\n         \nThe leakage detection configuration object provides a means for configuring the timing and sampling frequency of a vibration based network leak detector\n\n      \n\n      \n\n         \n\n            \n10266\n\n         \n\n         \nWater Flow Readings\n\n         \nMeasures the flow of water in regular intervals\n\n      \n\n      \n\n         \n\n            \n10267\n\n         \n\n         \nDaily Maximum Flow Rate Readings\n\n         \nMeasures the maximum flow rate and its time stamp for specified period\n\n      \n\n      \n\n         \n\n            \n10268\n\n         \n\n         \nTemperature Readings\n\n         \nPeriodic temperature measurements\n\n      \n\n      \n\n         \n\n            \n10269\n\n         \n\n         \nPressure Readings\n\n         \nPeriodic pressure measurements\n\n      \n\n      \n\n         \n\n            \n10270\n\n         \n\n         \nBattery Level Readings\n\n         \nPeriodic battery level measurements\n\n      \n\n      \n\n         \n\n            \n10271\n\n         \n\n         \nCommunications Activity Time Readings\n\n         \nMeasures the total duration that the meter was activating its radio for packet transmission or receipt for the period. Used to monitor for excess poower usage over time.\n\n      \n\n      \n\n         \n\n            \n10272\n\n         \n\n         \nWater Meter Customer Leakage Alarm\n\n         \nA binary flag indicating continual usage (e.g. greater than 5 L/h for 24 hours and the flow never returning to zero at any time).\n\n      \n\n      \n\n         \n\n            \n10273\n\n         \n\n         \nWater Meter Reverse Flow Alarm\n\n         \nAn alarm indicating reverse flow through the pipe. Also supports delivery of the approximate volume of water flowing in the reverse direction in the preceding period.\n\n      \n\n      \n\n         \n\n            \n10274\n\n         \n\n         \nWater Meter Empty Pipe Alarm\n\n         \nAn alarm when meter detects there is no liquid in the pipe\n\n      \n\n      \n\n         \n\n            \n10275\n\n         \n\n         \nWater Meter Tamper Alarm\n\n         \n            Detects interference from strong magnetic field or other electrical sources. If this is not relevant for            ultrasonic meters then the tamper alarm may be used to            indicate someone attempting to open the physical enclosure or other options the manufacturer may present.        \n\n      \n\n      \n\n         \n\n            \n10276\n\n         \n\n         \nWater Meter High Pressure Alarm\n\n         \nWhere supported by the meter this is an alarm that should be raised if the meter detects pressure above a pre-configured threshold.\n\n      \n\n      \n\n         \n\n            \n10277\n\n         \n\n         \nWater Meter Low Pressure Alarm\n\n         \nWhere supported by the meter this is an alarm that should be raised if the meter detects pressure below a pre-configured threshold.\n\n      \n\n      \n\n         \n\n            \n10278\n\n         \n\n         \nHigh Temperature Alarm\n\n         \n            Where supported by the meter this is an alarm that should be raised if the meter detects temperature above a pre-configured threshold.            When the temperature drops below the clear threshold, the alarm should be cleared.        \n\n      \n\n      \n\n         \n\n            \n10279\n\n         \n\n         \nLow Temperature Alarm\n\n         \n            Where supported by the meter this is an alarm that should be raised if the meter detects temperature below a pre-configured threshold.            When the temperature rises above the clear threshold, the alarm should be cleared        \n\n      \n\n      \n\n         \n\n            \n10280\n\n         \n\n         \nWater Network Leak Alarm\n\n         \nAll meters must support the following default configuration. This alarm will be based on the frequency output of the vibration sensor/accelerometer on the SEW Daughter board. When a frequency is identified that has the characteristics of an upstream network leak, and its amplitude is above the defined threshold, the meter will report this as a network leak alarm.\n\n      \n\n      \n\n         \n\n            \n10281\n\n         \n\n         \nLow Battery Alarm \n\n         \nThis Alarm is raised when the battery voltage drops below a defined level\n\n      \n\n      \n\n         \n\n            \n10282\n\n         \n\n         \nDaughter Board Failure Alarm\n\n         \nThis binary status should indicate that the meter MCU can no longer communicate with a daughter board\n\n      \n\n      \n\n         \n\n            \n10283\n\n         \n\n         \nDevice Reboot Event\n\n         \nThis binary status should indicate that the meter MCU can no longer communicate with a daughter board\n\n      \n\n      \n\n         \n\n            \n10284\n\n         \n\n         \nTime Synchronisation Event\n\n         \nThis event records the fact that the device has rebooted\n\n      \n\n      \n\n         \n\n            \n10286\n\n         \n\n         \nApp Fota Container\n\n         \nThis LWM2M Object is used to download the firmware package of a device's application.\n\n      \n\n      \n\n         \n\n            \n10299\n\n         \n\n         \nHostDevice\n\n         \nThis LWM2M Object provides a range of host device related information which can be queried by the LWM2M Server. The host device is any integrated device with an embedded cellular radio module.\n\n      \n\n      \n\n         \n\n            \n10300\n\n         \n\n         \nPending\n\n         \nPending", 
            "title": "Registry objects"
        }, 
        {
            "location": "/api/objects-registry/#oma-defined-lwm2m-objects-and-resources", 
            "text": "The  OMA LwM2M Registry  contains a wide range of defined objects and resources,\nin a machine readable way (XML).\nNew objects and resources can be proposed via the  LwM2M Editor .  WakaamaNode provides ready-to-consume C++ objects for all lwM2M objects of the registry. Just be aware that\nspecial implementations exist for object ID 1 (LWM2M Server), 2 (Access Control), 3 (device) and 5 (firmware)\nand you should not use the auto generated ones.", 
            "title": "OMA defined LwM2M objects and resources"
        }, 
        {
            "location": "/api/objects-registry/#how-to-use-a-predefined-object", 
            "text": "A full example can be found in  Get started .\nFor example if you want to use the \"Light Control\" lwM2M object:   Search the list below for \"Light Control\".  Find it under object id 3311.  Include  src/lwm2mObjects/3311.h  and use the class  object  in namespace  KnownObjects/id311 .  Create as many object instances as you need and add them to the object via  object.addInstance(lwm2mContext, objectInstance) .  Make the object itself known to WakaamaNode with  object.register(lwm2mContext) .   #include   lwm2mObjects/3311.h  #include   lwm2m/connect.h  lwm2m_client_context_t   context ;  using   namespace   KnownObjects ;  // Define the object and as many instances as you need  id3311 :: object   lights ;  id3311 :: instance   led ;  void   setup ()   { \n     // Overwrite the verifyFunction and  abuse  it as value changed event. \n     lights . verifyWrite   =   []( Lwm2mObjectInstance *   instance ,   uint16_t   res_id )   { \n         auto   inst   =   instance - as id3311 :: instance (); \n         // Is it instance 0 and the OnOff resource? \n         if   ( inst - id   ==   0     id3311 :: RESID :: OnOff   ==   res_id )   { \n             // Change the led pin depending on the OnOff value \n             digitalWrite ( LED_BUILTIN ,   inst - OnOff ); \n         } \n         // Return true to accept the value and ACK to the server \n         return   true ; \n     }; \n\n     led . id   =   0 ;   // set instance id \n     lights . addInstance ( CTX ( context ),   led ); \n     lights . registerObject ( CTX ( context ));  }  void   push_button_pressed ( bool   newState )   { \n     led . OnOff   =   newState ; \n     digitalWrite ( LED_BUILTIN ,   led . OnOff ); \n     lights . resChanged ( CTX ( context ),   led . id ,   ( uint16_t ) id3311 :: RESID :: OnOff );  }", 
            "title": "How to use a predefined object"
        }, 
        {
            "location": "/api/objects-registry/#list-of-supported-objects", 
            "text": "#lwm2mObjects tr:nth-child(even){background-color: #f2f2f2;}\n\n#lwm2mObjects tr:hover {background-color: #ddd;}\n\n#lwm2mObjects th {\n    padding-top: 12px;\n    padding-bottom: 12px;\n    text-align: left;\n    background-color: #ef5350;\n    color: white;\n}\n    \n    \n       \n          Object ID \n          Name \n          Description \n       \n    \n    \n       \n          \n             1 \n          \n          LWM2M Server \n          It provides the data related to a LWM2M Server. A Bootstrap Server has no such an Object Instance associated to it. \n       \n       \n          \n             2 \n          \n          Access Control \n          It is used to check whether the LWM2M Server has access right for performing a operation. \n       \n       \n          \n             3 \n          \n          Device \n          It provides a range of device related information which can be queried by the LWM2M Server, and a device reboot and factory reset function. \n       \n       \n          \n             4 \n          \n          Connectivity Monitoring \n          It enables monitoring of parameters related to network connectivity. In this general connectivity Object, the Resources are limited to the most general cases common to most network bearers. It is recommended to read the description, which refers to relevant standard development organizations (e.g. 3GPP, IEEE). The goal of the Connectivity Monitoring Object is to carry information reflecting the more up to date values of the current connection for monitoring purposes. Resources such as Link Quality, Radio Signal Strenght, Cell ID are retrieved during connected mode at least for cellular networks. \n       \n       \n          \n             5 \n          \n          Firmware \n          It enables management of firmware which is to be updated. This Object includes installing firmware package, updating firmware, and performing actions after updating firmware \n       \n       \n          \n             6 \n          \n          Location \n          It provides a range of device related information which can be queried by the LWM2M Server, and a device reboot and factory reset function. \n       \n       \n          \n             7 \n          \n          Connectivity Statistics \n          This LWM2M Objects enables client to collect statistical information and enables the LWM2M Server to retrieve these information, set the collection duration and reset the statistical parameters. \n       \n       \n          \n             8 \n          \n          Lock and Wipe \n          This LWM2M objects provides the resources needed to perform the lock and wipe operations \n       \n       \n          \n             9 \n          \n          Sofware Management \n          This LWM2M objects provides the resources needed to perform software management on the device. Each software component is managed via a dedicated Software Management Object instance \n       \n       \n          \n             10 \n          \n          Cellular connectivity \n          It specifies resources to enable a device to connect to a 3GPP or 3GPP2 bearer, including GPRS/EDGE, UMTS, LTE, SMS. For cellular connectivity, this object focuses on Packet Switched (PS) connectivity and doesn't aim to provide comprehensive Circuit Switched (CS) connectivity management. \n       \n       \n          \n             11 \n          \n          APN connection profile \n          It specifies resources to enable a device to connect to an APN. \n       \n       \n          \n             12 \n          \n          WLAN connectivity \n          It specifies resources to enable a device to connect to a WLAN bearer. \n       \n       \n          \n             13 \n          \n          Bearer selection \n          It specifies resources to enable a device to choose a communications bearer on which to connect. \n       \n       \n          \n             14 \n          \n          Software Component \n          The LWM2M software management object enables remote software management in M2M devices \n       \n       \n          \n             15 \n          \n          DevCapMgmt \n          It manages the device capabilities of a device e.g. sensors, communication, etc. \n       \n       \n          \n             16 \n          \n          Porfolio \n          The Portfolio Object allows to extend the data storage capability of other Object Instances in the LwM2M system, as well as the services which may be used to authenticate and to protect privacy of data contained in those extensions. In addition, a service of data encryption is also defined \n       \n       \n          \n             17 \n          \n          Communications Characteristics \n          This object enables configuration of various generic communications parameters. \n       \n       \n          \n             18 \n          \n          Non-Access Stratum (NAS) Configuration \n          This object provides Non-Access Stratum (NAS) configuration and is derived from 3GPP TS 24.368. \n       \n       \n          \n             19 \n          \n          LwM2M APPDATA \n          This LwM2M object provides the application service data related to a LwM2M Server, eg. Water meter data. \n       \n       \n          \n             20 \n          \n          EventLog \n          The Event Log Object is a single Instance Object defined for logging data in a straightforward         and generic way. The Resources of that Object are based on the OMA LwM2M set of reusable Resources dedicated to logging event activity. \n       \n       \n          \n             21 \n          \n          Pending \n          Pending \n       \n       \n          \n             2048 \n          \n          CmdhPolicy \n          This Object provides links to a set of rules associated with a specific CSE that governs the behavior             of that CSE regarding rejecting, buffering and sending request or response messages via the Mcc reference point. \n       \n       \n          \n             2049 \n          \n          ActiveCmdhPolicy \n          This Object provides a link to the currently active set of CMDH policies \n       \n       \n          \n             2050 \n          \n          CmdhDefaults \n          Defines which CMDH related parameters will be used by default. \n       \n       \n          \n             2051 \n          \n          CmdhDefEcValues \n          This Object represents default set of values for the Event Category parameter of an incoming request or response message. \n       \n       \n          \n             2052 \n          \n          CmdhEcDefParamValues \n          This Object represents a specific set of default values for the CMDH related parameters Request Expiration Timestamp, Result Expiration Timestamp, Operational Execution Time, Result Persistence and Delivery Aggregation that are applicable for a given Event Category if these parameters are not specified in the message. \n       \n       \n          \n             2053 \n          \n          CmdhLimits \n          This Object represents limits for CMDH related parameter values. \n       \n       \n          \n             2054 \n          \n          CmdhNetworkAccessRules \n          This Object defines the usage of underlying networks for forwarding information to other CSEs during processing of CMDH-related requests in a CSE. \n       \n       \n          \n             2055 \n          \n          CmdhNwAccessRule \n          This Object defines limits in usage of specific underlying networks for forwarding information to other CSEs during processing of CMDH-related requests in a CSE. \n       \n       \n          \n             2056 \n          \n          CmdhBuffer \n          This Object defines limits in usage of buffers for temporarily storing information that needs to be forwarded to other CSEs during processing of CMDH-related requests in a CSE. \n       \n       \n          \n             2057 \n          \n          CmdhBackOffParametersSet \n          This Object defines set of parameters which can be referenced by a specific Instance of the CmdhNwAccessRule Object (ID: 2055) \n       \n       \n          \n             3200 \n          \n          Digital Input \n          This IPSO object is a generic object that can be used with any kind of digital input interface. Specific objects for a given range of sensors are described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist. \n       \n       \n          \n             3201 \n          \n          Digital Output \n          This IPSO object is a generic object that can be used with any kind of digital output interface. Specific object for a given range of sensors is described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist. \n       \n       \n          \n             3202 \n          \n          Analogue Input \n          This IPSO object is a generic object that can be used with any kind of analogue input interface. Specific object for a given range of sensors is described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist. \n       \n       \n          \n             3203 \n          \n          Analogue Output \n          This IPSO object is a generic object that can be used with any kind of analogue input interface. Specific object for a given range of sensors is described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist. \n       \n       \n          \n             3300 \n          \n          Generic Sensor \n          This IPSO object allow the description of a generic sensor. It is based on the description of a value and a unit according to the UCUM specification. Thus, any type of value defined within this specification can be reporting using this object. Specific object for a given range of sensors is described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist. \n       \n       \n          \n             3301 \n          \n          Illuminance Sensor \n          This IPSO object should be used over a luminosity sensor to report a remote luminosity measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range that can be measured by the luminosity sensor. The unit used here is Lux (ucum:lx). \n       \n       \n          \n             3302 \n          \n          Presence Sensor \n          This IPSO object should be used over a presence sensor to report a remote presence detection. It also provides resources to manage a counter, the type of sensor used (e.g the technology of the probe), and configuration for the delay between busy and clear detection state. \n       \n       \n          \n             3303 \n          \n          Temperature Sensor \n          This IPSO object should be used over a temperature sensor to report a remote temperature measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range that can be measured by the temperature sensor. The unit used here is degree Celsius (ucum:Cel). \n       \n       \n          \n             3304 \n          \n          Humidity Sensor \n          This IPSO object should be used over a humidity sensor to report a remote humidity measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range that can be measured by the humidity sensor. The unit used here is relative humidity as a percentage (ucum:%). \n       \n       \n          \n             3305 \n          \n          Power Measurement \n          This IPSO object should be used over a power measurement sensor to report a remote power measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range for both active and reactive power. Il also provides resources for cumulative energy, calibration, and the power factor. \n       \n       \n          \n             3306 \n          \n          Actuation \n          This IPSO object is dedicated to remote actuation such as ON/OFF action or dimming. A multistate output can also be described as a string. This is useful to send pilot wire orders for instance. It also provides a resource to reflect the time that the device has been switched on. \n       \n       \n          \n             3308 \n          \n          Set Point \n          This IPSO object should be used to set a desired value to a controller, such as a thermostat. This object enables a setpoint to be expressed units defined in the UCUM specification, to match an associated sensor or measurement value. A special resource is added to set the colour of an object. \n       \n       \n          \n             3310 \n          \n          Load Control \n          This Object is used for demand-response load control and other load control in automation application (not limited to power). \n       \n       \n          \n             3311 \n          \n          Light Control \n          This Object is used to control a light source, such as a LED or other light. It allows a light to be turned on or off and its dimmer setting to be control as a % between 0 and 100. \n       \n       \n          \n             3312 \n          \n          Power Control \n          This Object is used to control a power source, such as a Smart Plug. It allows a power relay to be turned on or off and its dimmer setting to be control as a % between 0 and 100. \n       \n       \n          \n             3313 \n          \n          Accelerometer \n          This IPSO object can be used to represent a 1-3 axis accelerometer. \n       \n       \n          \n             3314 \n          \n          Magnetometer \n          This IPSO object can be used to represent a 1-3 axis magnetometer with optional compass direction. \n       \n       \n          \n             3315 \n          \n          Barometer \n          This IPSO object should be used with an air pressure sensor to report a remote barometer measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range that can be measured by the barometer sensor. \n       \n       \n          \n             3316 \n          \n          Voltage \n          This IPSO object should be used with voltmeter sensor to report measured voltage between two points. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. An example measurement unit is volts (ucum: V). \n       \n       \n          \n             3317 \n          \n          Current \n          This IPSO object should be used with an ammeter to report measured electric current in amperes. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. An example measurement unit is volts (ucum: A). \n       \n       \n          \n             3318 \n          \n          Frequency \n          This IPSO object should be used to report frequency measurements. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. An example measurement unit is volts (ucum: Hz). \n       \n       \n          \n             3319 \n          \n          Depth \n          This IPSO object should be used to report depth measurements. It can, for example, be used to describe a generic rain gauge that measures the accumulated rainfall in millimetres (mm) or in fathoms (fth). \n       \n       \n          \n             3320 \n          \n          Percentage \n          This IPSO object should can be used to report measurements relative to a 0-100% scale. For example it could be used to measure the level of a liquid in a vessel or container in units of %. \n       \n       \n          \n             3321 \n          \n          Altitude \n          This IPSO object should be used with an altitude sensor to report altitude above sea level in meters. Note that Altitude can be calculated from the measured pressure given the local sea level pressure. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. An example measurement unit is meters (ucum: m). \n       \n       \n          \n             3322 \n          \n          Load \n          This IPSO object should be used with a load sensor (as in a scale) to report the applied weight or force. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. \n       \n       \n          \n             3323 \n          \n          Pressure \n          This IPSO object should be used to report pressure measurements. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. \n       \n       \n          \n             3324 \n          \n          Loudness \n          This IPSO object should be used to report loudness or noise level measurements. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. \n       \n       \n          \n             3325 \n          \n          Concentration \n          This IPSO object should be used to the particle concentration measurement of a medium. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. \n       \n       \n          \n             3326 \n          \n          Acidity \n          This IPSO object should be used to report an acidity measurement of a liquid. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. \n       \n       \n          \n             3327 \n          \n          Conductivity \n          This IPSO object should be used to report a measurement of the electric conductivity of a medium or sample. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. \n       \n       \n          \n             3328 \n          \n          Power \n          This IPSO object should be used to report power measurements. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. \n       \n       \n          \n             3329 \n          \n          Power Factor \n          This IPSO object should be used to report a measurement or calculation of the power factor of a reactive electrical load. \n       \n       \n          \n             3330 \n          \n          Distance \n          This IPSO object should be used to report a distance measurement. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. \n       \n       \n          \n             3331 \n          \n          Energy \n          This IPSO object should be used to report energy consumption (Cumulative Power) of an electrical load. \n       \n       \n          \n             3332 \n          \n          Direction \n          This IPSO object is used to report the direction indicated by a compass, wind vane, or other directional indicator. The units of measure is plane angle degrees (ucum:deg). \n       \n       \n          \n             3333 \n          \n          Time \n          This IPSO object is used to report the current time in seconds since January 1, 1970 UTC. There is also a fractional time counter that has a range of less than one second. \n       \n       \n          \n             3334 \n          \n          Gyrometer \n          This IPSO Object is used to report the current reading of a gyrometer sensor in 3 axes. It provides tracking of the minimum and maximum angular rate in all 3 axes. \n       \n       \n          \n             3335 \n          \n          Color \n          This IPSO object should be used to report the measured value of a colour sensor in some colour space described by the units resource. \n       \n       \n          \n             3336 \n          \n          GPS Location \n          This IPSO object represents GPS coordinates. This object is compatible with the LWM2M management object for location, but uses reusable resources. \n       \n       \n          \n             3337 \n          \n          Positioner \n          This IPSO object should be used with a generic position actuator from 0 to 100%. \n       \n       \n          \n             3338 \n          \n          Buzzer \n          This IPSO object should be used to actuate an audible alarm such as a buzzer, beeper, or vibration alarm. \n       \n       \n          \n             3339 \n          \n          Audio Clip \n          This IPSO object should be used for a speaker that plays a pre-recorded audio clip or an audio output that is sent elsewhere. \n       \n       \n          \n             3340 \n          \n          Timer \n          This IPSO object is used to time events and actions, using patterns common to industrial timers. A POST to the trigger resource or On/Off input state change starts the timing operation, and the timer remaining time shows zero when the operation is complete. \n       \n       \n          \n             3341 \n          \n          Addressable Text Display \n          This IPSO object is used to send text to a text-only or text mode graphics display. \n       \n       \n          \n             3342 \n          \n          On/Off Switch \n          This IPSO object should be used with an On/Off switch to report the state of the switch. \n       \n       \n          \n             3343 \n          \n          Lever Control \n          This IPSO object should be used with a dimmer or level control to report the state of the control. \n       \n       \n          \n             3344 \n          \n          Up/Down Control \n          This IPSO object is used to report the state of an up/down control element like a pair of push buttons or a rotary encoder. \n       \n       \n          \n             3345 \n          \n          Multiple Axis Joystick \n          This IPSO object can be used to report the position of a shuttle or joystick control. A digital input is provided to report the state of an associated push button. \n       \n       \n          \n             3346 \n          \n          Rate \n          This object type should be used to report a rate measurement, \n       \n       \n          \n             3347 \n          \n          Push Button \n          This IPSO object is used to report the state of a momentary action push button control and to count the number of times the control has been operated since the last observation. \n       \n       \n          \n             3348 \n          \n          Multistate Selector \n          This IPSO object is used to represent the state of a multistate selector switch with a number of fixed positions. \n       \n       \n          \n             3349 \n          \n          Bitmap \n          Summarize several digital inputs to one value by mapping each bit to a digital input. \n       \n       \n          \n             3350 \n          \n          Stopwatch \n          An ascending timer that counts how long time has passed since the timer was started after reset. \n       \n       \n          \n             3351 \n          \n          powerupLog \n          One time event sent by the device at power up. \n       \n       \n          \n             3352 \n          \n          plmnSearchEvent \n          List of all PLMNs found during the initial search/scan \n       \n       \n          \n             3353 \n          \n          scellID \n          serving cell information that the RRC decides to camp on \n       \n       \n          \n             3354 \n          \n          cellReselectionEvent \n          cell reselection event information \n       \n       \n          \n             3355 \n          \n          handoverEvent \n          handover event information \n       \n       \n          \n             3356 \n          \n          radioLinkFailureEvent \n          Radio Link Failure Event \n       \n       \n          \n             3357 \n          \n          rrcStateChangeEvent \n          Current RRC state change information, including the event that triggered the state change \n       \n       \n          \n             3358 \n          \n          rrcTimerExpiryEvent \n          RRC timer expiry event information \n       \n       \n          \n             3359 \n          \n          cellBlacklistEvent \n          Cell blacklist information \n       \n       \n          \n             3360 \n          \n          esmContextInfo \n          ESM context information \n       \n       \n          \n             3361 \n          \n          emmStateValue \n          EMM context information \n       \n       \n          \n             3362 \n          \n          nasEmmTimerExpiryEvent \n          NAS EMM timer expiry information \n       \n       \n          \n             3363 \n          \n          nasEsmExpiryEvent \n          NAS ESM timer expiry information \n       \n       \n          \n             3364 \n          \n          emmFailureCauseEvent \n          Triggered at EMM failure - failure cause is logged \n       \n       \n          \n             3365 \n          \n          rachLatency_delay \n          RACH Latency and delay information \n       \n       \n          \n             3366 \n          \n          macRachAttemptEvent \n          RACH information. Logged at RACH TX \n       \n       \n          \n             3367 \n          \n          macRachAttemptReasonEvent \n          RACH Information - reason for initiating RACH \n       \n       \n          \n             3368 \n          \n          macTimerStatusEvent \n          MAC timer expiry information \n       \n       \n          \n             3369 \n          \n          macTimingAdvanceEvent \n          Timing advance information \n       \n       \n          \n             3370 \n          \n          ServingCellMeasurement \n          Serving Cell Measurement \n       \n       \n          \n             3371 \n          \n          NeighborCellMeasurements \n          Neighbor Cell Measurements \n       \n       \n          \n             3372 \n          \n          Timing Advance Information \n          Neighbor Cell Measurements \n       \n       \n          \n             3373 \n          \n          txPowerHeadroomEvent \n          TX power headroom information \n       \n       \n          \n             3374 \n          \n          radioLinkMonitoring \n          Radio Link monitoring information maintained by RRC \n       \n       \n          \n             3375 \n          \n          PagingDRX \n          Paging DRX information \n       \n       \n          \n             3376 \n          \n          txPowerBackOffEvent \n          TX Power backoff information \n       \n       \n          \n             3377 \n          \n          Message3Report \n          RACH message 3 report information \n       \n       \n          \n             3378 \n          \n          PbchDecodingResults \n          Serving cell PBCH decoding information \n       \n       \n          \n             3379 \n          \n          pucchPowerControl \n          PUCCH TX power control information \n       \n       \n          \n             3380 \n          \n          PrachReport \n          PRACH report information \n       \n       \n          \n             3381 \n          \n          VolteCallEvent \n          VoLTE call status \n       \n       \n          \n             3382 \n          \n          SipRegistrationEvent \n          SIP Registration status \n       \n       \n          \n             3383 \n          \n          sipPublishEvent \n          SIP Publish status \n       \n       \n          \n             3384 \n          \n          sipSubscriptionEvent \n          SIP Subscription status \n       \n       \n          \n             3385 \n          \n          volteCallStateChangeEvent \n          VoLTE call status change \n       \n       \n          \n             3386 \n          \n          VoLTErtpPacketLoss \n          Log is generated at the receiving end of RTP flow when newReceivedSequenceNumber - lastReceivedSequenceNumber   1 \n       \n       \n          \n             10241 \n          \n          HostDeviceInfo \n          This LWM2M Object provides a range of host device related information which can be queried by the LWM2M Server. The host device is any integrated device with an embedded cellular radio module. \n       \n       \n          \n             10242 \n          \n          3-PhasePM \n          This Object provides the information to represent a generic 3-Phase Power Meter \n       \n       \n          \n             10243 \n          \n          singlePhasePM \n          This Object provides the information to represent a generic Single-Phase Power Meter \n       \n       \n          \n             10244 \n          \n          vehicle control unit \n          This Object provides the information to represent a generic VCU (vehicle control unit) \n       \n       \n          \n             10245 \n          \n          Relay Management \n          This LWM2M Object provides a range of eNB related measurements and parameters of which several are changeable. Furthermore, it includes Resources to enable/disable the eNB \n       \n       \n          \n             10246 \n          \n          CrowdBox Measurements \n          This LWM2M Object provides CrowdBox-related measurements such as serving cell parameters, backhaul timing advance, and neighbour cell reports. \n       \n       \n          \n             10247 \n          \n          Neighbour Cell Report \n          This LWM2M Object provides the neighbour cell report. The CrowdBox Measurements Object and the Connected UE Report Object have both Objlnk Resources pointing to this Object \n       \n       \n          \n             10248 \n          \n          Connected UE Measurements \n          This LWM2M Object provides a range of measurements of connected UEs and provides an Object link to the Connected UE report. \n       \n       \n          \n             10249 \n          \n             Connected UE Report \n          This LWM2M Object provides a range of information related to the connected UEs. \n       \n       \n          \n             10250 \n          \n          App Data Container \n          This LWM2M Object is used for reporting application data of a device. \n       \n       \n          \n             10251 \n          \n          AT Command \n          Used to execute an AT command on a cellular modem \n       \n       \n          \n             10252 \n          \n          Manifest \n          This object provides a range of information related to updating packages on a device \n       \n       \n          \n             10253 \n          \n          Confidential Data \n          This LWM2M Object is used for reporting data, but in a confidential way \n       \n       \n          \n             10254 \n          \n          Current Loop Input \n          This LwM2M Object provides a representation of a current loop sensor, which indicates the value emitted by a current source. \n       \n       \n          \n             10255 \n          \n          Device Metadata \n          This object provides a range of information related to device metadata \n       \n       \n          \n             10256 \n          \n          ECID-Signal Measurement Information \n          This LWM2M Object provides ECID signal measurements of a device. \n       \n       \n          \n             10257 \n          \n          Heat/Cooling meter \n          This Object provides the information to represent a generic (district) heat or cooling meter \n       \n       \n          \n             10258 \n          \n          Current Loop Output \n          This LWM2M Object provides a representation of a current loop source, which may be used to carry control signals. \n       \n       \n          \n             10259 \n          \n          System Log \n          This object provides read access to log buffers as well as limited configuration of logging services. \n       \n       \n          \n             10260 \n          \n          Runtime Database \n          This object allows manipulation of Runtime Database variables. \n       \n       \n          \n             10260 \n          \n          Runtime Database \n          This object allows manipulation of Runtime Database variables. \n       \n       \n          \n             10262 \n          \n          Interval Data Delivery \n          The Interval Data Delivery object provides an optimised means for managing the delivery of interval data from multiple Interval Data Object instances.  \n       \n       \n          \n             10263 \n          \n          Event Data Delivery \n          The Event Data Delivery object provides a simple means for managing the delivery of event data from multiple Event Data Object instances. \n       \n       \n          \n             10264 \n          \n          Delivery Schedule \n          The Delivery Schedule object provides a means for controlling the periodic delivery of interval and event data to the LwM2M server. \n       \n       \n          \n             10265 \n          \n          Leakage Detection Configuration \n          The leakage detection configuration object provides a means for configuring the timing and sampling frequency of a vibration based network leak detector \n       \n       \n          \n             10266 \n          \n          Water Flow Readings \n          Measures the flow of water in regular intervals \n       \n       \n          \n             10267 \n          \n          Daily Maximum Flow Rate Readings \n          Measures the maximum flow rate and its time stamp for specified period \n       \n       \n          \n             10268 \n          \n          Temperature Readings \n          Periodic temperature measurements \n       \n       \n          \n             10269 \n          \n          Pressure Readings \n          Periodic pressure measurements \n       \n       \n          \n             10270 \n          \n          Battery Level Readings \n          Periodic battery level measurements \n       \n       \n          \n             10271 \n          \n          Communications Activity Time Readings \n          Measures the total duration that the meter was activating its radio for packet transmission or receipt for the period. Used to monitor for excess poower usage over time. \n       \n       \n          \n             10272 \n          \n          Water Meter Customer Leakage Alarm \n          A binary flag indicating continual usage (e.g. greater than 5 L/h for 24 hours and the flow never returning to zero at any time). \n       \n       \n          \n             10273 \n          \n          Water Meter Reverse Flow Alarm \n          An alarm indicating reverse flow through the pipe. Also supports delivery of the approximate volume of water flowing in the reverse direction in the preceding period. \n       \n       \n          \n             10274 \n          \n          Water Meter Empty Pipe Alarm \n          An alarm when meter detects there is no liquid in the pipe \n       \n       \n          \n             10275 \n          \n          Water Meter Tamper Alarm \n                      Detects interference from strong magnetic field or other electrical sources. If this is not relevant for            ultrasonic meters then the tamper alarm may be used to            indicate someone attempting to open the physical enclosure or other options the manufacturer may present.         \n       \n       \n          \n             10276 \n          \n          Water Meter High Pressure Alarm \n          Where supported by the meter this is an alarm that should be raised if the meter detects pressure above a pre-configured threshold. \n       \n       \n          \n             10277 \n          \n          Water Meter Low Pressure Alarm \n          Where supported by the meter this is an alarm that should be raised if the meter detects pressure below a pre-configured threshold. \n       \n       \n          \n             10278 \n          \n          High Temperature Alarm \n                      Where supported by the meter this is an alarm that should be raised if the meter detects temperature above a pre-configured threshold.            When the temperature drops below the clear threshold, the alarm should be cleared.         \n       \n       \n          \n             10279 \n          \n          Low Temperature Alarm \n                      Where supported by the meter this is an alarm that should be raised if the meter detects temperature below a pre-configured threshold.            When the temperature rises above the clear threshold, the alarm should be cleared         \n       \n       \n          \n             10280 \n          \n          Water Network Leak Alarm \n          All meters must support the following default configuration. This alarm will be based on the frequency output of the vibration sensor/accelerometer on the SEW Daughter board. When a frequency is identified that has the characteristics of an upstream network leak, and its amplitude is above the defined threshold, the meter will report this as a network leak alarm. \n       \n       \n          \n             10281 \n          \n          Low Battery Alarm  \n          This Alarm is raised when the battery voltage drops below a defined level \n       \n       \n          \n             10282 \n          \n          Daughter Board Failure Alarm \n          This binary status should indicate that the meter MCU can no longer communicate with a daughter board \n       \n       \n          \n             10283 \n          \n          Device Reboot Event \n          This binary status should indicate that the meter MCU can no longer communicate with a daughter board \n       \n       \n          \n             10284 \n          \n          Time Synchronisation Event \n          This event records the fact that the device has rebooted \n       \n       \n          \n             10286 \n          \n          App Fota Container \n          This LWM2M Object is used to download the firmware package of a device's application. \n       \n       \n          \n             10299 \n          \n          HostDevice \n          This LWM2M Object provides a range of host device related information which can be queried by the LWM2M Server. The host device is any integrated device with an embedded cellular radio module. \n       \n       \n          \n             10300 \n          \n          Pending \n          Pending", 
            "title": "List of supported objects"
        }, 
        {
            "location": "/api/objects-custom/", 
            "text": "Custom lwM2M objects\n\n\nThe last chapter introducted you to objects of the OMA lwM2M registry. WakaamaNode allows you to define\nyour own  custom lwm2m object. A unique object ID is necessary.\n\n\nThe next section explains some background information about the object ID namespace.\nThereafter you will find the C++ and C API for lwm2m object definitions.\n\n\nAbout the object ID namespace\n\n\nThe object id namespace is divided into several ObjectID Classes.\n\n\n\n\n\n\n\n\nCategory\n\n\nURN\n\n\nObject ID\n\n\nrange\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noma-label\n\n\nurn:oma:lwm2m:oma:\nid\n:\nversion\n\n\n0 - 1023\n\n\nObjects Produced by OMA. Only OMA can use this range\n\n\n\n\n\n\n\n\nreserved\n\n\n\n\n1024 - 2047\n\n\nReserved for future use\n\n\n\n\n\n\n\n\next-label\n\n\nurn:oma:lwm2m:ext:\nid\n:\nversion\n\n\n2048 - 10240\n\n\nObjects registered by 3\nrd\n party standards organisations or alliances\n\n\n\n\n\n\n\n\nx-label\n\n\nurn:oma:lwm2m: x:\nid\n:\nversion\n\n\n10241 - 26240\n26241 - 32768\n32769 - 42768\n\n\nObjects registered by companies or individuals.\nObjects Produced by Vendors to re-use\nBlock of objects reserved by vendors (Max 50). Private range, Objects will not be published\n\n\n\n\n\n\n\n\n\n\nIf your use case is not yet considered within the registries objects, it is time to fill out an application for a new object.\n\n\nFor testing purposes, you can use one of the undefined ids (range 42769..65000). If possible, you should at least\nmake use of the \npredefined resource ids (range: 2048..26240)\n.\n\n\nDefine your custom objects either via C or the C++ interface.\n\n\nObject definition C++ API\n\n\nInclude \nlwm2m/objects.h\n.\n\n\nLwm2mObject class\n\n\nclass\n \nLwm2mObject\nObjectID\n,\n \nDerivedObject\n,\n \nObjectInstance\n\n\n\n\n\nLwm2mObject is not to be used directly.\nInherit from Lwm2mObject to implement your own lwM2M object. Specify the \nObjectID\n, for example \"1024\",\nthe derived object class and the associated object instance class.\n\n\nTo allow WakaamaNode to handle all read/write/execute handling for you, you need to describe the available\nresources of an lwM2M object.\nExample:\n\n\nclass\n \nMyObject\n: \npublic\n \nLwm2mObject\n1024\n,\n \nMyObject\n,\n \nMyObjectInstance\n\n\n{\n\n\npublic\n:\n\n    \nResource\n(\n0\n,\n \nMyObjectInstance\n::\ntest\n,\n \nO_RES_RW\n)\n \ntest\n;\n\n\n};\n\n\n\n\n\nHere a Readable/Writable(O_RES_RW) resource with ResourceID 0 is declared. It references the \nMyObjectInstance::test\n class member of \"MyObjectInstance\"\nfor reading the resource value and writing to it.\nThe name of the class member is not relevant and should describe the resource, for example \"power\" or \"volume\".\n\n\nThe exact syntax and semantic of \nResource\n is described further down in the \nResource class\n section.\n\n\n/**\n\n\n * @param instance The object instance to add. See Lwm2mObjectInstance. May not be null.\n\n\n */\n\n\nvoid\n \nLwm2mObject\n::\naddInstance\n(\nLwm2mObjectInstance\n \n*\n \ninstance\n);\n\n\n\n\n\nAdd a \nLwm2mObjectInstance\n to your object.\nThe instance is automatically registered to the lwm2m server, if already connected.\n\n\n/**\n\n\n * @param instance The instance ID for the instance to remove. See Lwm2mObjectInstance.\n\n\n *        Nothing happens if the instance is not known to the object.\n\n\n */\n\n\nvoid\n \nLwm2mObject\n::\nremoveInstance\n(\nuint16\n \ninstanceID\n);\n\n\n\n\n\nRemoves a \nLwm2mObjectInstance\n from your object.\nThe instance is automatically unregistered from the lwm2m server, if already connected.\n\n\n/**\n\n\n * @param lwm2mContext The Wakaama context.\n\n\n */\n\n\nvoid\n \nLwm2mObject\n::\nregisterObject\n(\nvoid\n*\n \nlwm2mContext\n,\n \nbool\n \nallow_dynamic_instance_creation\n);\n\n\n\n\n\nRegisters the object to Wakaama.\nThe object is automatically registered to the lwM2M server, if already connected.\n\n\n/**\n\n\n * @param lwm2mContext The Wakaama context.\n\n\n */\n\n\nvoid\n \nLwm2mObject\n::\nunregisterObject\n(\nvoid\n*\n \nlwm2mContext\n);\n\n\n\n\n\nUnregisters the object from Wakaama.\n\n\n/**\n\n\n * @param instance_id Instance ID\n\n\n */\n\n\nvirtual\n \nLwm2mObjectInstance\n*\n \ncreateInstance\n(\nuint16_t\n \ninstance_id\n);\n\n\n\n\n\nIf creating instances dynamically by the server or with the given ID is not supported return \nnullptr\n.\nReturn a working object instance with the given instance ID otherwise.\n\n\nThe default does nothing and returns a \nnullptr\n.\n\n\n/**\n\n\n * @param instance Object instance to delete\n\n\n * @return Return COAP_NO_ERROR if no error happened.\n\n\n */\n\n\nvirtual\n \nint\n \ndeleteInstance\n(\nLwm2mObjectInstance\n*\n \ninstance\n);\n\n\n\n\n\nImplement this function in your object class to allow to delete an object instance by the server.\n\n\n/**\n\n\n * @param lwm2mContext The Wakaama context.\n\n\n * @param object_instance_id Object instance id\n\n\n * @param res_id Resource id\n\n\n */\n\n\nvoid\n \nresChanged\n(\nvoid\n*\n \nlwm2mContext\n,\n \nuint16_t\n \nobject_instance_id\n,\n \nuint16_t\n \nres_id\n);\n\n\n\n\n\nCall this method if you have changed a resource of the given instance with the given resource id.\n\n\n/**\n\n\n * @param instance Object instance that is going to be modified\n\n\n * @param res_id The resource that will get changed\n\n\n * @return Return true if change is accepted or false if change is denied.\n\n\n */\n\n\nvoid\n*\n \nverifyWrite\n(\nLwm2mObjectInstance\n*\n \ninstance\n,\n \nuint16_t\n \nres_id\n);\n\n\n\n\n\nImplement a function with the above signature and assign it to the \nverifyWrite\n object field to verify a change on an object instance resource.\n\n\nLwm2mObjectInstance class\n\n\nclass\n \nLwm2mObjectInstance\n\n\n\n\n\nLwm2mObjectInstance is not to be used directly.\nInherit from this class to implement a data holder for an object instance.\nExample:\n\nstruct\n \nMyObjectInstance\n:\n \npublic\n \nLwm2mObjectInstance\n \n{\n\n    \nuint8_t\n  \nfirstResource\n;\n\n\n}\n\n\n\n\nAllowed data types are 8/16/32/64 bit unsigned/signed integers,\nfloats, doubles, booleans and unsigned/signed c-strings.\n\n\n\nCoAP and lwM2M support opaque resources.\nWakaamaNode provides the \nOpaque\nN\n and \nOpaqueIndirect\n type.\nSee \nOpaque Resources\n for an example.\n\n\nResources can be executable. Declare a class member of type \nExecutable\n that will be used\nas function pointer. See \nExecutable Resource\n for an example.\n\n\nThe name of the class member is not relevant and should describe the resource, for example \"power\" or \"volume\".\n\n\nLwm2mObjectInstance does not have any methods.\n\n\nResource class\n\n\nclass\n \nResource\nResID\n,\n \nResourceValueReference\n,\n \nOperations\n\n\n\n\n\nUse the templated \nResource\n class to describe the resource ID, reference to the member variable that stores the value and supported operations in this order.\n\nUntil C++17, the syntax of declaring a Resource needs \"(\" instead of \"\n\" brackets.\n\n\nSupported operations are O_RES_R (read only), O_RES_W (assign only), O_RES_RW (read/write).\n\n\nExecutable Resources\n\n\nFor an executable resource, you do not need to specify the Operations, because it will always be O_RES_E.\n\n\nIn the following example a constructor is used to force the \nMyObjectInstance\n\nuser to assign a function:\n\n\nstruct\n \nMyObjectInstance\n:\n \npublic\n \nLwm2mObjectInstance\n \n{\n\n    \nExecutable\n \nexec\n;\n\n\n    \nMyObjectInstance\n(\nExecutable\n \nanExecutableResourceFunction\n)\n \n:\n \nexec\n(\nanExecutableResourceFunction\n)\n \n{}\n\n\n}\n\n\n\n\n\nThe corresponding object looks like this:\n\n\nclass\n \nMyObject\n: \npublic\n \nLwm2mObject\n1024\n,\nMyObject\n,\nMyObjectInstance\n\n\n{\n\n\npublic\n:\n\n    \nResource\n0\n,\n \nMyObjectInstance\n::\nexec\n \nexec\n;\n\n\n};\n\n\n\n\n\nOpaque Resources\n\n\nIf you have an opaque resource, you have two options. Either you directly reserve enough space in-place via the \nOpaque\nN\n\ntemplated class, or you let the class variable point to a memory location, which basically means an indirect memory access. Use \nOpaqueIndirect\n in this case.\nAn example:\n\n\nchar\n \nmemory\n[\n100\n];\n\n\n\nstruct\n \nMyObjectInstance\n:\n \npublic\n \nLwm2mObjectInstance\n \n{\n\n   \n// Equals an in-place array with the size of 20 bytes\n\n   \nOpaque\n20\n \nopaqueRes\n;\n\n\n   \n// Similar to Opaque, but will be designated as string resource\n\n   \nPreallocString\n20\n \npreallocStringRes\n;\n   \n\n   \n// You need to assign the OpaqueIndirect::data pointer a memory location.\n\n   \nOpaqueIndirect\n \nopaqueIndirectRes\n;\n\n\n   \nMyObjectInstance\n()\n \n:\n \nopaqueIndirectRes\n{\n100\n,\n0\n,\nmemory\n}\n \n{}\n\n\n};\n\n\n\n\n\nRead from / Write to resource value function\n\n\nInstead of storing data in member variables of your object instance, you can make the library to retrieve\nthe resource value from a function call, or store a new resource value by calling a function.\n\n\nIn the example of an object instance below you can see all three types (read from function, write to function, read/write from/to function):\n\n\nstruct\n \nMyObjectInstance\n:\n \npublic\n \nLwm2mObjectInstance\n \n{\n\n    \nIndirectRead\nint8_t\n \ntest_read_fun_int8\n;\n\n    \nIndirectRead\nuint32_t\n \ntest_read_fun_uint32\n;\n\n\n    \nIndirectRead\nconst\n \nchar\n*\n \ntest_read_fun_string\n;\n\n    \nIndirectWrite\nconst\n \nchar\n*\n \ntest_write_fun_string\n;\n\n    \nIndirectReadWrite\nconst\n \nchar\n*\n \ntest_readWrite_fun_string\n;\n\n\n}\n \nyour_object_instance_t\n;\n\n\n\n\n\nAs you can see, you will use the templated classes \nIndirectRead\n, \nIndirectWrite\n and \nIndirectReadWrite\n.\n\n\nThe library will crash, if the function pointer is dangling / not assigned to a valid function!\n\n\nThe signature of the read and write methods will always pass the object instance as first parameter,\nsee the definition of \nmy_read_method\n and \nstring_write_method\n in the example below.\n\n\nAn example object looks like this, with a constructor setting the function pointers:\n\n\nuint32_t\n \nmy_read_method\n(\nLwm2mObjectInstance\n*\n)\n \n{\n \nreturn\n \n12\n;\n \n}\n\n\n\nvoid\n \nstring_write_method\n(\nLwm2mObjectInstance\n*\n,\n \nconst\n \nchar\n*\n \nv\n)\n \n{}\n\n\n\nclass\n \nMyObject\n: \npublic\n \nLwm2mObject\n1024\n,\nMyObject\n,\nMyObjectInstance\n\n\n{\n\n\npublic\n:\n\n    \nResource\n(\n1\n,\n \nMyObjectInstance\n::\ntest_read_fun_uint32\n)\n \ntest_read_fun_uint32\n;\n\n    \nResource\n(\n3\n,\n \nMyObjectInstance\n::\ntest_write_fun_string\n)\n \ntest_write_fun_string\n;\n\n\n    \nMyObject\n(\nIndirectRead\nuint32_t\n \nreadfun\n,\n \nIndirectRead\nuint32_t\n \nwritefun\n)\n \n:\n\n        \ntest_read_fun_uint32\n(\nreadfun\n),\n \ntest_write_fun_string\n(\nwriteFun\n)\n \n{}\n\n\n};\n\n\n\nMyObject\n \no\n(\nmy_read_method\n,\n \nstring_write_method\n);\n\n\n\n\n\nObject definition C API\n\n\nInclude \nlwm2m/c_objects.h\n.\n\n\n/**\n\n\n * @param context   The wakaama context.\n\n\n * @param object   The wakaama lwm2m object with meta information attached.\n\n\n * @param allow_dynamic_instance_creation Allows or disallows the use of lwm2m_object_instances_add(). Heap memory will be used.\n\n\n * @return The error code or COAP_NO_ERROR if no error.\n\n\n */\n\n\nint\n \nlwm2m_add_initialize_object\n(\nlwm2m_context_t\n \n*\n \ncontextP\n,\n\n                                \nlwm2m_object_t\n*\n \nobject\n,\n\n                                \nbool\n \nallow_dynamic_instance_creation\n);\n\n\n\nInitializes an lwm2m object, created with OBJECT_META().\nThis will also add the object to the wakaama object registry. If the client\nis already connected to a server, the server will be notified.\n\n\nRemove an object with lwm2m_remove_object(context, object_id) again.\n\n\n/**\n\n\n * @param context   The wakaama context.\n\n\n * @param object The lwm2m_object.\n\n\n * @param instance An object instance.\n\n\n */\n\n\nvoid\n \nlwm2m_object_instance_add\n(\nlwm2m_context_t\n \n*\n \ncontext\n,\n \nlwm2m_object_t\n*\n \nobject\n,\n \nlwm2m_list_t\n*\n \ninstance\n);\n\n\n\nAdd an instance to an object.\n\n\nIdeally you do this before you connect to a server and before you call \nlwm2m_add_initialize_object\n.\nThe server will be notified of the updated object otherwise.\n\n\nA lwm2m object instance consists of one ore more ressources identified by their ressource ids.\nA ressource may be an uint8, int8, uint16, int16, uint32, int32, uint64, int64, double, c-string.\n\n\nPlease be aware that your object instance\nhave to \"inherit\" lwm2m_list_t::next and lwm2m_list_t::id like in the following example:\n\n\ntypedef\n \nstruct\n \n{\n\n   \nstruct\n \n_prv_instance_next\n;\n \n// matches lwm2m_list_t::next\n\n   \nuint16_t\n \nshortID\n;\n             \n// matches lwm2m_list_t::id\n\n   \n...\n \nYour\n \nmembers\n \nare\n \ndefined\n \nhere\n...\n\n\n}\n \nyour_object_instance_t\n;\n\n\n\n\n\nIf you implement any object with an id registered at\n\nOMA Object \n Resource Registry\n,\nyour object instances have to provide all of the defined ressources\n\n\nOBJECT_META\n\n\nTo allow WakaamaNode to\n\n\n\n\nread from resources,\n\n\nwrite to resources and\n\n\nexecute resources\n\n\n\n\nyou have to provide a machine readable description. You do this by definining a\nlwm2m_object_meta_information_t. Imagine you have defined an object instance looking like below:\n\n\ntypedef\n \nstruct\n \n{\n\n   \nstruct\n \n_prv_instance_next\n;\n \n// matches lwm2m_list_t::next\n\n   \nuint16_t\n \nshortID\n;\n          \n// matches lwm2m_list_t::id\n\n\n   \nuint8_t\n \ntest\n;\n\n   \nExecutableType\n \nexec\n;\n\n   \ndouble\n \ndec\n;\n\n\n}\n \nyour_object_instance_t\n;\n\n\n\n\n\nUse OBJECT_META() to describe your object to the library:\n\n\nOBJECT_META\n(\nyour_object_instance_t\n,\n \ntest_object\n,\n \n1024\n,\n \ntest_object_write_verify_cb\n,\n\n    \n{\n0\n,\n \nO_RES_RW\n,\nO_RES_UINT8\n \n,\n \noffsetof\n(\nyour_object_instance_t\n,\ntest\n)},\n\n    \n{\n1\n,\n \nO_RES_E\n \n,\nO_RES_EXEC\n  \n,\n \noffsetof\n(\nyour_object_instance_t\n,\nexec\n)},\n\n    \n{\n2\n,\n \nO_RES_RW\n,\nO_RES_DOUBLE\n,\n \noffsetof\n(\nyour_object_instance_t\n,\ndec\n)}\n\n\n);\n\n\n\n\n\nWhich results in a \ntest_object\n object declaration as well as a pointer to it \ntest_objectP\n, that can be handed over to \nlwm2m_add_initialize_object\n.\n\n\nOBJECT_META expects the object instance (here: \nyour_object_instance_t\n),\nand the variable name for the object via the first and second argument.\n\n\nThe third argument is the object ID.\n\n\nThe 4\nth\n argument may be set to NULL. Otherwise set it to a callback method which is called on\na write to your object instance. You may react on a write in this method and you may deny the write if the new value\nis not in range of your allowed values. The callback method needs this signature:\n\n\nbool test_object_write_verify_cb(lwm2m_list_t* instance, uint16_t changed_res_id);\n\n\nThe subsequent arguments describe the ressources of your object instances. Each entry is enclosed in curly brackets and consists of these values:\n\n\n\n\nThe id of the ressource\n\n\nThe Resource access modifier (see next sections).\n\n\nThe Resource type (see next sections).\n\n\nMember pointer\n\n\n\n\nResource Access modifier\n\n\nYou can use the following access modifiers:\n\n\n\n\nO_RES_R\n: Read only access\n\n\nO_RES_W\n:Write only access\n\n\nO_RES_RW\n: Read/Write access\n\n\nO_RES_E\n: Makes this resource executable\n\n\nO_RES_E|O_RES_R\n: Reads the resource value from a function\n\n\nO_RES_E|O_RES_W\n: Writes the resource value to a function\n\n\nO_RES_E|O_RES_RW\n: The resource value is read from and written to a function\n\n\n\n\nResource type\n\n\nYou can use the following types:\n\n\ntypedef\n \nenum\n \n_lwm2m_object_util_type_\n \n{\n\n    \nO_RES_EXEC\n   \n=\n \n0\n,\n \n///\n Executable resource == no type\n\n    \nO_RES_BOOL\n   \n=\n \n1\n,\n \n///\n A boolean value\n\n    \nO_RES_DOUBLE\n \n=\n \n2\n,\n \n///\n A floating point decimal value\n\n    \nO_RES_INT8\n   \n=\n \n3\n,\n \n///\n Int with range [-128,127]\n\n    \nO_RES_UINT8\n  \n=\n \n4\n,\n \n///\n Int with range [0,255]\n\n    \nO_RES_INT16\n  \n=\n \n5\n,\n \n///\n Int with range [-32000,32000]\n\n    \nO_RES_UINT16\n \n=\n \n6\n,\n \n///\n Int with range [0,65500]\n\n    \nO_RES_INT32\n  \n=\n \n7\n,\n \n///\n Int with range [-2^31,2^31-1]\n\n    \nO_RES_UINT32\n \n=\n \n8\n,\n \n///\n Int with range [0, 2^32-1]\n\n    \nO_RES_INT64\n  \n=\n \n9\n,\n \n///\n Int with range [-2^63, 2^63-1]\n\n    \nO_RES_STRING\n          \n=\n \n10\n,\n \n///\n Readonly c-string\n\n    \nO_RES_STRING_PREALLOC\n \n=\n \n11\n,\n \n///\n preallocated space. To be used with OpaqueType(N) in C or Opaque\nN\n in C++.\n\n    \nO_RES_OPAQUE_INDIRECT\n \n=\n \n12\n,\n \n///\n To be used with type OpaqueIndirect\n\n    \nO_RES_OPAQUE_PREALLOC\n \n=\n \n13\n  \n///\n preallocated space. To be used with OpaqueType(N) in C or Opaque\nN\n in C++.\n\n\n}\n \nlwm2m_object_util_type_t\n;\n\n\n\n\n\nExecutable Resources\n\n\nAn executable resource expects a function pointer in your object instance struct. Use the special \nExecutableType\n type:\n\n\ntypedef\n \nstruct\n \n{\n\n   \nstruct\n \n_prv_instance_next\n;\n \n// matches lwm2m_list_t::next\n\n   \nuint16_t\n \nshortID\n;\n          \n// matches lwm2m_list_t::id\n\n   \nExecutableType\n \nmyExecRes\n;\n\n\n}\n \nyour_object_instance_t\n;\n\n\n\n\n\nThe signature of your executabe function pointer should be: \nvoid myFun();\n.\n\n\nOpaque Resources\n\n\nIf you have an opaque resource, you have two options. Either you directly reserve enough space in-place via the \nOpaqueType(N)\n\nmacro, or you let the struct variable point to a memory location, which basically means an indirect memory access. Use \nOpaqueIndirect\n in this case.\nAn example:\n\n\ntypedef\n \nstruct\n \n{\n\n   \nstruct\n \n_prv_instance_next\n;\n \n// matches lwm2m_list_t::next\n\n   \nuint16_t\n \nshortID\n;\n          \n// matches lwm2m_list_t::id\n\n\n   \n// Equals an in-place array with the size of 20 bytes\n\n   \nOpaqueType\n(\n20\n)\n \nopaqueRes\n;\n\n\n   \n// You need to assign the OpaqueIndirect::data pointer a memory location.\n\n   \nOpaqueIndirect\n \nopaqueIndirectRes\n;\n\n\n}\n \nyour_object_instance_t\n;\n\n\n\n\n\nBefore you can actually use \nyour_object_instance_t\n, you need to initialize opaque members.\n\n\n\n\nSet the reserved size: For \nopaqueRes\n this is done by: \nopaqueRes.reserved_len = 20;\n.\n\n\nSet the used size to 0: \nopaqueRes.used_len = 0;\n. This value will be updated on a write access.\n\n\nSet the function pointer for \nOpaqueIndirect\n: \nopaqueIndirectRes.data = myMemory;\n.\n\n\n\n\nThe C-API does not reallocate memory. If there's not enough space, a \nCOAP_413_ENTITY_TOO_LARGE\n error code is returned.\n\n\nRead from / Write to resource value function\n\n\nInstead of storing data in member variables of your object instance, you can make the library to retrieve\nthe resource value from a function call, or store a new resource value by calling a function.\n\n\nIn the example of an object instance below you can see all three types (read from function, write to function, read/write from/to function):\n\n\ntypedef\n \nstruct\n \n{\n\n    \nstruct\n \n_prv_instance_next\n;\n \n// matches lwm2m_list_t::next\n\n    \nuint16_t\n \nshortID\n;\n          \n// matches lwm2m_list_t::id\n\n\n    \nIndirectReadType\n(\nint8_t\n,\ntest_read_fun_int8\n);\n\n    \nIndirectReadType\n(\nuint32_t\n,\ntest_read_fun_uint32\n);\n\n\n    \nIndirectReadType\n(\nconst\n \nchar\n*\n,\ntest_read_fun_string\n);\n\n    \nIndirectWriteType\n(\nconst\n \nchar\n*\n,\ntest_write_fun_string\n);\n\n    \nIndirectReadWriteType\n(\nconst\n \nchar\n*\n)\n \ntest_readWrite_fun_string\n;\n\n\n}\n \nyour_object_instance_t\n;\n\n\n\n\n\nAs you can see, you will use the macros \nIndirectReadType\n, \nIndirectWriteType\n and \nIndirectReadWriteType\n.\nThe first two expect a parameter tuple (type, variable name). The third expects the type only.\n\n\nThe library will crash, if the function pointer is dangling / not assigned to a valid function!\n\n\nBefore you can actually use \nyour_object_instance_t\n, you need to initialize indirect read/write members.\n\n\nFor the example above this would look like:\n\n    \nyour_object_instance_t\n.\ntest_read_fun_int8\n \n=\n \nreadFun8\n;\n\n    \nyour_object_instance_t\n.\ntest_read_fun_uint32\n \n=\n \nreadFun32\n;\n\n\n    \nyour_object_instance_t\n.\ntest_read_fun_string\n \n=\n \nreadFunStr\n;\n\n    \nyour_object_instance_t\n.\ntest_write_fun_string\n \n=\n \nwriteFunStr\n;\n\n    \nyour_object_instance_t\n.\ntest_readWrite_fun_string\n.\nread\n \n=\n \nreadFunStr\n;\n\n    \nyour_object_instance_t\n.\ntest_readWrite_fun_string\n.\nwrite\n \n=\n \nwriteFunStr\n;", 
            "title": "Custom objects"
        }, 
        {
            "location": "/api/objects-custom/#custom-lwm2m-objects", 
            "text": "The last chapter introducted you to objects of the OMA lwM2M registry. WakaamaNode allows you to define\nyour own  custom lwm2m object. A unique object ID is necessary.  The next section explains some background information about the object ID namespace.\nThereafter you will find the C++ and C API for lwm2m object definitions.", 
            "title": "Custom lwM2M objects"
        }, 
        {
            "location": "/api/objects-custom/#about-the-object-id-namespace", 
            "text": "The object id namespace is divided into several ObjectID Classes.     Category  URN  Object ID  range  Description      oma-label  urn:oma:lwm2m:oma: id : version  0 - 1023  Objects Produced by OMA. Only OMA can use this range     reserved   1024 - 2047  Reserved for future use     ext-label  urn:oma:lwm2m:ext: id : version  2048 - 10240  Objects registered by 3 rd  party standards organisations or alliances     x-label  urn:oma:lwm2m: x: id : version  10241 - 26240 26241 - 32768 32769 - 42768  Objects registered by companies or individuals. Objects Produced by Vendors to re-use Block of objects reserved by vendors (Max 50). Private range, Objects will not be published      If your use case is not yet considered within the registries objects, it is time to fill out an application for a new object.  For testing purposes, you can use one of the undefined ids (range 42769..65000). If possible, you should at least\nmake use of the  predefined resource ids (range: 2048..26240) .  Define your custom objects either via C or the C++ interface.", 
            "title": "About the object ID namespace"
        }, 
        {
            "location": "/api/objects-custom/#object-definition-c-api", 
            "text": "Include  lwm2m/objects.h .", 
            "title": "Object definition C++ API"
        }, 
        {
            "location": "/api/objects-custom/#lwm2mobject-class", 
            "text": "class   Lwm2mObject ObjectID ,   DerivedObject ,   ObjectInstance   Lwm2mObject is not to be used directly.\nInherit from Lwm2mObject to implement your own lwM2M object. Specify the  ObjectID , for example \"1024\",\nthe derived object class and the associated object instance class.  To allow WakaamaNode to handle all read/write/execute handling for you, you need to describe the available\nresources of an lwM2M object.\nExample:  class   MyObject :  public   Lwm2mObject 1024 ,   MyObject ,   MyObjectInstance  {  public : \n     Resource ( 0 ,   MyObjectInstance :: test ,   O_RES_RW )   test ;  };   Here a Readable/Writable(O_RES_RW) resource with ResourceID 0 is declared. It references the  MyObjectInstance::test  class member of \"MyObjectInstance\"\nfor reading the resource value and writing to it.\nThe name of the class member is not relevant and should describe the resource, for example \"power\" or \"volume\".  The exact syntax and semantic of  Resource  is described further down in the  Resource class  section.  /**   * @param instance The object instance to add. See Lwm2mObjectInstance. May not be null.   */  void   Lwm2mObject :: addInstance ( Lwm2mObjectInstance   *   instance );   Add a  Lwm2mObjectInstance  to your object.\nThe instance is automatically registered to the lwm2m server, if already connected.  /**   * @param instance The instance ID for the instance to remove. See Lwm2mObjectInstance.   *        Nothing happens if the instance is not known to the object.   */  void   Lwm2mObject :: removeInstance ( uint16   instanceID );   Removes a  Lwm2mObjectInstance  from your object.\nThe instance is automatically unregistered from the lwm2m server, if already connected.  /**   * @param lwm2mContext The Wakaama context.   */  void   Lwm2mObject :: registerObject ( void *   lwm2mContext ,   bool   allow_dynamic_instance_creation );   Registers the object to Wakaama.\nThe object is automatically registered to the lwM2M server, if already connected.  /**   * @param lwm2mContext The Wakaama context.   */  void   Lwm2mObject :: unregisterObject ( void *   lwm2mContext );   Unregisters the object from Wakaama.  /**   * @param instance_id Instance ID   */  virtual   Lwm2mObjectInstance *   createInstance ( uint16_t   instance_id );   If creating instances dynamically by the server or with the given ID is not supported return  nullptr .\nReturn a working object instance with the given instance ID otherwise.  The default does nothing and returns a  nullptr .  /**   * @param instance Object instance to delete   * @return Return COAP_NO_ERROR if no error happened.   */  virtual   int   deleteInstance ( Lwm2mObjectInstance *   instance );   Implement this function in your object class to allow to delete an object instance by the server.  /**   * @param lwm2mContext The Wakaama context.   * @param object_instance_id Object instance id   * @param res_id Resource id   */  void   resChanged ( void *   lwm2mContext ,   uint16_t   object_instance_id ,   uint16_t   res_id );   Call this method if you have changed a resource of the given instance with the given resource id.  /**   * @param instance Object instance that is going to be modified   * @param res_id The resource that will get changed   * @return Return true if change is accepted or false if change is denied.   */  void *   verifyWrite ( Lwm2mObjectInstance *   instance ,   uint16_t   res_id );   Implement a function with the above signature and assign it to the  verifyWrite  object field to verify a change on an object instance resource.", 
            "title": "Lwm2mObject class"
        }, 
        {
            "location": "/api/objects-custom/#lwm2mobjectinstance-class", 
            "text": "class   Lwm2mObjectInstance   Lwm2mObjectInstance is not to be used directly.\nInherit from this class to implement a data holder for an object instance.\nExample: struct   MyObjectInstance :   public   Lwm2mObjectInstance   { \n     uint8_t    firstResource ;  }   Allowed data types are 8/16/32/64 bit unsigned/signed integers,\nfloats, doubles, booleans and unsigned/signed c-strings.  \nCoAP and lwM2M support opaque resources.\nWakaamaNode provides the  Opaque N  and  OpaqueIndirect  type.\nSee  Opaque Resources  for an example.  Resources can be executable. Declare a class member of type  Executable  that will be used\nas function pointer. See  Executable Resource  for an example.  The name of the class member is not relevant and should describe the resource, for example \"power\" or \"volume\".  Lwm2mObjectInstance does not have any methods.", 
            "title": "Lwm2mObjectInstance class"
        }, 
        {
            "location": "/api/objects-custom/#resource-class", 
            "text": "class   Resource ResID ,   ResourceValueReference ,   Operations   Use the templated  Resource  class to describe the resource ID, reference to the member variable that stores the value and supported operations in this order. Until C++17, the syntax of declaring a Resource needs \"(\" instead of \" \" brackets.  Supported operations are O_RES_R (read only), O_RES_W (assign only), O_RES_RW (read/write).", 
            "title": "Resource class"
        }, 
        {
            "location": "/api/objects-custom/#executable-resources", 
            "text": "For an executable resource, you do not need to specify the Operations, because it will always be O_RES_E.  In the following example a constructor is used to force the  MyObjectInstance \nuser to assign a function:  struct   MyObjectInstance :   public   Lwm2mObjectInstance   { \n     Executable   exec ; \n\n     MyObjectInstance ( Executable   anExecutableResourceFunction )   :   exec ( anExecutableResourceFunction )   {}  }   The corresponding object looks like this:  class   MyObject :  public   Lwm2mObject 1024 , MyObject , MyObjectInstance  {  public : \n     Resource 0 ,   MyObjectInstance :: exec   exec ;  };", 
            "title": "Executable Resources"
        }, 
        {
            "location": "/api/objects-custom/#opaque-resources", 
            "text": "If you have an opaque resource, you have two options. Either you directly reserve enough space in-place via the  Opaque N \ntemplated class, or you let the class variable point to a memory location, which basically means an indirect memory access. Use  OpaqueIndirect  in this case.\nAn example:  char   memory [ 100 ];  struct   MyObjectInstance :   public   Lwm2mObjectInstance   { \n    // Equals an in-place array with the size of 20 bytes \n    Opaque 20   opaqueRes ; \n\n    // Similar to Opaque, but will be designated as string resource \n    PreallocString 20   preallocStringRes ;    \n\n    // You need to assign the OpaqueIndirect::data pointer a memory location. \n    OpaqueIndirect   opaqueIndirectRes ; \n\n    MyObjectInstance ()   :   opaqueIndirectRes { 100 , 0 , memory }   {}  };", 
            "title": "Opaque Resources"
        }, 
        {
            "location": "/api/objects-custom/#read-from-write-to-resource-value-function", 
            "text": "Instead of storing data in member variables of your object instance, you can make the library to retrieve\nthe resource value from a function call, or store a new resource value by calling a function.  In the example of an object instance below you can see all three types (read from function, write to function, read/write from/to function):  struct   MyObjectInstance :   public   Lwm2mObjectInstance   { \n     IndirectRead int8_t   test_read_fun_int8 ; \n     IndirectRead uint32_t   test_read_fun_uint32 ; \n\n     IndirectRead const   char *   test_read_fun_string ; \n     IndirectWrite const   char *   test_write_fun_string ; \n     IndirectReadWrite const   char *   test_readWrite_fun_string ;  }   your_object_instance_t ;   As you can see, you will use the templated classes  IndirectRead ,  IndirectWrite  and  IndirectReadWrite .  The library will crash, if the function pointer is dangling / not assigned to a valid function!  The signature of the read and write methods will always pass the object instance as first parameter,\nsee the definition of  my_read_method  and  string_write_method  in the example below.  An example object looks like this, with a constructor setting the function pointers:  uint32_t   my_read_method ( Lwm2mObjectInstance * )   {   return   12 ;   }  void   string_write_method ( Lwm2mObjectInstance * ,   const   char *   v )   {}  class   MyObject :  public   Lwm2mObject 1024 , MyObject , MyObjectInstance  {  public : \n     Resource ( 1 ,   MyObjectInstance :: test_read_fun_uint32 )   test_read_fun_uint32 ; \n     Resource ( 3 ,   MyObjectInstance :: test_write_fun_string )   test_write_fun_string ; \n\n     MyObject ( IndirectRead uint32_t   readfun ,   IndirectRead uint32_t   writefun )   : \n         test_read_fun_uint32 ( readfun ),   test_write_fun_string ( writeFun )   {}  };  MyObject   o ( my_read_method ,   string_write_method );", 
            "title": "Read from / Write to resource value function"
        }, 
        {
            "location": "/api/objects-custom/#object-definition-c-api_1", 
            "text": "Include  lwm2m/c_objects.h .  /**   * @param context   The wakaama context.   * @param object   The wakaama lwm2m object with meta information attached.   * @param allow_dynamic_instance_creation Allows or disallows the use of lwm2m_object_instances_add(). Heap memory will be used.   * @return The error code or COAP_NO_ERROR if no error.   */  int   lwm2m_add_initialize_object ( lwm2m_context_t   *   contextP , \n                                 lwm2m_object_t *   object , \n                                 bool   allow_dynamic_instance_creation );  \nInitializes an lwm2m object, created with OBJECT_META().\nThis will also add the object to the wakaama object registry. If the client\nis already connected to a server, the server will be notified.  Remove an object with lwm2m_remove_object(context, object_id) again.  /**   * @param context   The wakaama context.   * @param object The lwm2m_object.   * @param instance An object instance.   */  void   lwm2m_object_instance_add ( lwm2m_context_t   *   context ,   lwm2m_object_t *   object ,   lwm2m_list_t *   instance );  \nAdd an instance to an object.  Ideally you do this before you connect to a server and before you call  lwm2m_add_initialize_object .\nThe server will be notified of the updated object otherwise.  A lwm2m object instance consists of one ore more ressources identified by their ressource ids.\nA ressource may be an uint8, int8, uint16, int16, uint32, int32, uint64, int64, double, c-string.  Please be aware that your object instance\nhave to \"inherit\" lwm2m_list_t::next and lwm2m_list_t::id like in the following example:  typedef   struct   { \n    struct   _prv_instance_next ;   // matches lwm2m_list_t::next \n    uint16_t   shortID ;               // matches lwm2m_list_t::id \n    ...   Your   members   are   defined   here ...  }   your_object_instance_t ;   If you implement any object with an id registered at OMA Object   Resource Registry ,\nyour object instances have to provide all of the defined ressources", 
            "title": "Object definition C API"
        }, 
        {
            "location": "/api/objects-custom/#object_meta", 
            "text": "To allow WakaamaNode to   read from resources,  write to resources and  execute resources   you have to provide a machine readable description. You do this by definining a\nlwm2m_object_meta_information_t. Imagine you have defined an object instance looking like below:  typedef   struct   { \n    struct   _prv_instance_next ;   // matches lwm2m_list_t::next \n    uint16_t   shortID ;            // matches lwm2m_list_t::id \n\n    uint8_t   test ; \n    ExecutableType   exec ; \n    double   dec ;  }   your_object_instance_t ;   Use OBJECT_META() to describe your object to the library:  OBJECT_META ( your_object_instance_t ,   test_object ,   1024 ,   test_object_write_verify_cb , \n     { 0 ,   O_RES_RW , O_RES_UINT8   ,   offsetof ( your_object_instance_t , test )}, \n     { 1 ,   O_RES_E   , O_RES_EXEC    ,   offsetof ( your_object_instance_t , exec )}, \n     { 2 ,   O_RES_RW , O_RES_DOUBLE ,   offsetof ( your_object_instance_t , dec )}  );   Which results in a  test_object  object declaration as well as a pointer to it  test_objectP , that can be handed over to  lwm2m_add_initialize_object .  OBJECT_META expects the object instance (here:  your_object_instance_t ),\nand the variable name for the object via the first and second argument.  The third argument is the object ID.  The 4 th  argument may be set to NULL. Otherwise set it to a callback method which is called on\na write to your object instance. You may react on a write in this method and you may deny the write if the new value\nis not in range of your allowed values. The callback method needs this signature:  bool test_object_write_verify_cb(lwm2m_list_t* instance, uint16_t changed_res_id);  The subsequent arguments describe the ressources of your object instances. Each entry is enclosed in curly brackets and consists of these values:   The id of the ressource  The Resource access modifier (see next sections).  The Resource type (see next sections).  Member pointer", 
            "title": "OBJECT_META"
        }, 
        {
            "location": "/api/objects-custom/#resource-access-modifier", 
            "text": "You can use the following access modifiers:   O_RES_R : Read only access  O_RES_W :Write only access  O_RES_RW : Read/Write access  O_RES_E : Makes this resource executable  O_RES_E|O_RES_R : Reads the resource value from a function  O_RES_E|O_RES_W : Writes the resource value to a function  O_RES_E|O_RES_RW : The resource value is read from and written to a function", 
            "title": "Resource Access modifier"
        }, 
        {
            "location": "/api/objects-custom/#resource-type", 
            "text": "You can use the following types:  typedef   enum   _lwm2m_object_util_type_   { \n     O_RES_EXEC     =   0 ,   ///  Executable resource == no type \n     O_RES_BOOL     =   1 ,   ///  A boolean value \n     O_RES_DOUBLE   =   2 ,   ///  A floating point decimal value \n     O_RES_INT8     =   3 ,   ///  Int with range [-128,127] \n     O_RES_UINT8    =   4 ,   ///  Int with range [0,255] \n     O_RES_INT16    =   5 ,   ///  Int with range [-32000,32000] \n     O_RES_UINT16   =   6 ,   ///  Int with range [0,65500] \n     O_RES_INT32    =   7 ,   ///  Int with range [-2^31,2^31-1] \n     O_RES_UINT32   =   8 ,   ///  Int with range [0, 2^32-1] \n     O_RES_INT64    =   9 ,   ///  Int with range [-2^63, 2^63-1] \n     O_RES_STRING            =   10 ,   ///  Readonly c-string \n     O_RES_STRING_PREALLOC   =   11 ,   ///  preallocated space. To be used with OpaqueType(N) in C or Opaque N  in C++. \n     O_RES_OPAQUE_INDIRECT   =   12 ,   ///  To be used with type OpaqueIndirect \n     O_RES_OPAQUE_PREALLOC   =   13    ///  preallocated space. To be used with OpaqueType(N) in C or Opaque N  in C++.  }   lwm2m_object_util_type_t ;", 
            "title": "Resource type"
        }, 
        {
            "location": "/api/objects-custom/#executable-resources_1", 
            "text": "An executable resource expects a function pointer in your object instance struct. Use the special  ExecutableType  type:  typedef   struct   { \n    struct   _prv_instance_next ;   // matches lwm2m_list_t::next \n    uint16_t   shortID ;            // matches lwm2m_list_t::id \n    ExecutableType   myExecRes ;  }   your_object_instance_t ;   The signature of your executabe function pointer should be:  void myFun(); .", 
            "title": "Executable Resources"
        }, 
        {
            "location": "/api/objects-custom/#opaque-resources_1", 
            "text": "If you have an opaque resource, you have two options. Either you directly reserve enough space in-place via the  OpaqueType(N) \nmacro, or you let the struct variable point to a memory location, which basically means an indirect memory access. Use  OpaqueIndirect  in this case.\nAn example:  typedef   struct   { \n    struct   _prv_instance_next ;   // matches lwm2m_list_t::next \n    uint16_t   shortID ;            // matches lwm2m_list_t::id \n\n    // Equals an in-place array with the size of 20 bytes \n    OpaqueType ( 20 )   opaqueRes ; \n\n    // You need to assign the OpaqueIndirect::data pointer a memory location. \n    OpaqueIndirect   opaqueIndirectRes ;  }   your_object_instance_t ;   Before you can actually use  your_object_instance_t , you need to initialize opaque members.   Set the reserved size: For  opaqueRes  this is done by:  opaqueRes.reserved_len = 20; .  Set the used size to 0:  opaqueRes.used_len = 0; . This value will be updated on a write access.  Set the function pointer for  OpaqueIndirect :  opaqueIndirectRes.data = myMemory; .   The C-API does not reallocate memory. If there's not enough space, a  COAP_413_ENTITY_TOO_LARGE  error code is returned.", 
            "title": "Opaque Resources"
        }, 
        {
            "location": "/api/objects-custom/#read-from-write-to-resource-value-function_1", 
            "text": "Instead of storing data in member variables of your object instance, you can make the library to retrieve\nthe resource value from a function call, or store a new resource value by calling a function.  In the example of an object instance below you can see all three types (read from function, write to function, read/write from/to function):  typedef   struct   { \n     struct   _prv_instance_next ;   // matches lwm2m_list_t::next \n     uint16_t   shortID ;            // matches lwm2m_list_t::id \n\n     IndirectReadType ( int8_t , test_read_fun_int8 ); \n     IndirectReadType ( uint32_t , test_read_fun_uint32 ); \n\n     IndirectReadType ( const   char * , test_read_fun_string ); \n     IndirectWriteType ( const   char * , test_write_fun_string ); \n     IndirectReadWriteType ( const   char * )   test_readWrite_fun_string ;  }   your_object_instance_t ;   As you can see, you will use the macros  IndirectReadType ,  IndirectWriteType  and  IndirectReadWriteType .\nThe first two expect a parameter tuple (type, variable name). The third expects the type only.  The library will crash, if the function pointer is dangling / not assigned to a valid function!  Before you can actually use  your_object_instance_t , you need to initialize indirect read/write members.  For the example above this would look like:      your_object_instance_t . test_read_fun_int8   =   readFun8 ; \n     your_object_instance_t . test_read_fun_uint32   =   readFun32 ; \n\n     your_object_instance_t . test_read_fun_string   =   readFunStr ; \n     your_object_instance_t . test_write_fun_string   =   writeFunStr ; \n     your_object_instance_t . test_readWrite_fun_string . read   =   readFunStr ; \n     your_object_instance_t . test_readWrite_fun_string . write   =   writeFunStr ;", 
            "title": "Read from / Write to resource value function"
        }, 
        {
            "location": "/api/objects-custom-cpp-example/", 
            "text": "Example\n\n\nIf you are going to use a lwM2M object, that is defined in the \nOMA lwM2M registry\n,\nhead over to the \nRegistry objects\n page.\nWakamaNode provides ready-to-use, auto-generated c++ classes for all those objects.\n\n\nFor this example, we assume the following custom lwM2M object definition:\n\n\n\n\n\n\n\n\nObject\n\n\nID\n\n\nMultiple Instances\n\n\nMandatoty\n\n\n\n\n\n\n\n\n\n\nTest\n\n\n1024\n\n\nYes\n\n\nNo\n\n\n\n\n\n\n\n\nRessources:\n\n\n\n\n\n\n\n\nName\n\n\nID\n\n\nOperations\n\n\nType\n\n\nRange\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntest\n\n\n0\n\n\nR/W\n\n\nInteger\n\n\n0-128\n\n\n\n\n\n\n\n\nexec\n\n\n1\n\n\nE\n\n\n\n\n\n\n\n\n\n\n\n\ndec\n\n\n2\n\n\nR/W\n\n\nFloat\n\n\n\n\n\n\n\n\n\n\nsig\n\n\n3\n\n\nR/W\n\n\nInteger\n\n\n\n\n16-bit signed integer\n\n\n\n\n\n\ntext\n\n\n4\n\n\nR/W\n\n\nString\n\n\n\n\nchar* c-string\n\n\n\n\n\n\nopaq\n\n\n5\n\n\nW\n\n\nOpaque\n\n\n32 Byte\n\n\nvoid* data\n\n\n\n\n\n\nread\n\n\n9\n\n\nR\n\n\nInteger\n\n\n\n\nRead value from method\n\n\n\n\n\n\n\n\nIf you use the C++ object definition API, you only need to provide an object description (meta object data)\nand all read/write/execute handling is done for you. \n\n\nCreate an object instance class, that serves as data holder for each individual instance.\n\n\nusing\n \nMyReadIntFunction\n \n=\n \nint\n \n(\n*\n)(\nLwm2mObjectInstance\n*\n);\n\n\n\nstruct\n \nMyObjectInstance\n:\n \npublic\n \nLwm2mObjectInstance\n \n{\n\n    \nuint8_t\n  \ntest\n;\n\n    \nExecutable\n \nexec\n;\n\n    \ndouble\n   \ndec\n;\n\n    \nint16_t\n  \nsig\n;\n\n\n    \nchar\n*\n    \ntext\n;\n\n\n    \nOpaque\n32\n \nopaque\n;\n\n\n    \nIndirectRead\nint\n    \nread\n;\n\n\n    \n// Force the MyObjectInstance user to assign a read and execute funtion. We don\nt want to crash!\n\n    \nMyObjectInstance\n(\nMyReadIntFunction\n \nreadF\n,\n \nMyExecuteFunction\n \nexecF\n)\n \n:\n \nexec\n(\nexecF\n)\n \nread\n(\nreadF\n)\n \n{}\n\n\n};\n\n\n\n\n\nYou inherit from \nLwm2mObjectInstance\n for the object instance data holder.\n\n\nDeclare an object class that describes object 1024 to the library:\n\n\n#include\n \nlwm2m/objects.h\n\n\n\n// Object with LwM2M ID 1024\n\n\nclass\n \nMyObject\n:\n \npublic\n \nLwm2mObject\n1024\n,\nMyObject\n,\nMyObjectInstance\n\n\n{\n\n\npublic\n:\n\n    \nResource\n(\n0\n,\n \nMyObjectInstance\n::\ntest\n,\n \nO_RES_RW\n)\n \ntest\n;\n\n    \nResource\n(\n1\n,\n \nMyObjectInstance\n::\nexec\n,\n \nO_RES_E\n \n)\n \nexec\n;\n\n    \nResource\n(\n2\n,\n \nMyObjectInstance\n::\ndec\n,\n  \nO_RES_RW\n)\n \ndec\n;\n\n    \nResource\n(\n3\n,\n \nMyObjectInstance\n::\nsig\n,\n  \nO_RES_RW\n)\n \nsig\n;\n\n\n    \nResource\n(\n4\n,\n \nMyObjectInstance\n::\ntext\n,\n \nO_RES_RW\n)\n \ntext\n;\n\n\n    \nResource\n(\n5\n,\n \nMyObjectInstance\n::\nopaque\n,\nO_RES_W\n)\n \nopaque\n;\n\n\n    \n// You don\nt need to specify the operation, if it is a\n\n    \n// IndirectRead, IndirectWrite, IndirectReadWrite type\n\n    \nResource\n(\n9\n,\n \nMyObjectInstance\n::\nread\n)\n \nread\n;\n\n\n    \n// Use writeVerify to enforce restrictions on the resource values\n\n    \nMyObject\n()\n \n:\n \nwriteVerify\n([](\nMyObjectInstance\n*\n \ni\n,\n \nuint16_t\n \nres_id\n)\n \n{\n\n        \nreturn\n \n(\nres_id\n==\n0\n)\n \n?\n \n(\nreturn\n \ni\n-\ntest\n=\n128\n)\n \n:\n \ntrue\n;\n\n    \n})\n \n{}\n\n\n};\n\n\n\n\n\nInherit from \nLwm2mObject\n and specify the object ID as template parameter for your object class.\n\n\nUse the templated \nResource\n class to describe the resource ID, reference to the member variable and supported operations in this order.\n\n\nSupported operations are O_RES_R (read only), O_RES_W (assign only), O_RES_RW (read/write), O_RES_E (executable).\n\n\nRead resource value from function\n\n\nIt is possible to read a resource value from a function instead of a classes member variable.\nUse \nPollingResource\n and define the resource ID and resource type.\n\n\nIn this example \nmy_read_method\n would look like this:\n\n\nint\n \nmy_read_method\n()\n \n{\n \nreturn\n \n12\n;\n \n}\n\n\n\n\n\nInput validation\n\n\nIf you have looked carefully at the object definition, you see that \ntest\n is restricted to 0..128:\n\n              \nSupported\n    \nMultiple\n\n  \nName\n \n|\n \nID\n \n|\n \nOperations\n \n|\n \nInstances\n \n|\n \nMandatory\n \n|\n  \nType\n   \n|\n \nRange\n \n|\n\n  \ntest\n \n|\n  \n0\n \n|\n    \nR\n/\nW\n     \n|\n    \nNo\n     \n|\n    \nYes\n    \n|\n \nInteger\n \n|\n \n0\n-\n128\n \n|\n\n\n\n\nThis is less that the data type allows, so we have to provide an input validation method. Thankfully, we can\nuse the \nwriteVerify\n function.\n\n\nA lambda function, assigned during construction, returns \nfalse\n if the value if resource 0 is greater than 128:\n\n\nMyObject\n()\n \n:\n \nwriteVerify\n([](\nMyObjectInstance\n*\n \ni\n,\n \nuint16_t\n \nres_id\n)\n \n{\n\n    \nreturn\n \n(\nres_id\n==\n0\n)\n \n?\n \n(\nreturn\n \ni\n-\ntest\n=\n128\n)\n \n:\n \ntrue\n;\n\n\n})\n \n{}\n\n\n\n\n\nReact to resource write operations\n\n\nYou may \"abuse\" the validation function to react on an altered resource.\n\n\nAnother way is a giant switch in\na defined \nvoid lwm2m_resource_changed_event(uint16_t object_id, uint16_t object_instance_id, uint16_t resource_id)\n.\nIf you do not implement this method somewhere, a default no-op method will be used.\n\n\nAdd object and object instances\n\n\nAn example for adding an object \nMyObject\n with one instance \nMyObjectInstance\n is provided below.\n\n\nMyObject\n \nmyObj\n(\nfalse\n);\n\n\n\nint\n \nmy_read_method\n(\nLwm2mObjectInstance\n*\n)\n \n{\n \nreturn\n \n12\n;\n \n}\n\n\nMyObjectInstance\n \nmyInstance\n(\nmy_read_method\n);\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n    \nmyObj\n.\naddInstance\n(\nlwm2mContext\n,\n \nmyInstance\n);\n\n    \n// The second argument either allows or disallows the lwm2m server\n\n    \n// to create/delete object instances\n\n    \nmyObj\n.\nregisterObject\n(\nlwm2mContext\n,\n \nfalse\n);\n\n\n}\n\n\n\n\n\nYou can register objects either before or after you are connected to a lwM2M server. If you are already connected,\nthe register call will be a little bit more expensive, because the object need to be published to the server.\n\n\nRemove object or object instance\n\n\nMyObject\n \nmyObj\n(\nfalse\n);\n\n\n\nint\n \nmy_read_method\n(\nLwm2mObjectInstance\n*\n)\n \n{\n \nreturn\n \n12\n;\n \n}\n\n\nMyObjectInstance\n \nmyInstance\n(\nmy_read_method\n);\n\n\n\nvoid\n \nexit\n()\n \n{\n\n    \nmyObj\n.\nremoveInstance\n(\nlwm2mContext\n,\n \nmyInstance\n.\ninstanceID\n);\n\n    \nmyObj\n.\nunregisterObject\n(\nlwm2mContext\n);\n\n\n}", 
            "title": "Custom objects /CPP Example"
        }, 
        {
            "location": "/api/objects-custom-cpp-example/#example", 
            "text": "If you are going to use a lwM2M object, that is defined in the  OMA lwM2M registry ,\nhead over to the  Registry objects  page.\nWakamaNode provides ready-to-use, auto-generated c++ classes for all those objects.  For this example, we assume the following custom lwM2M object definition:     Object  ID  Multiple Instances  Mandatoty      Test  1024  Yes  No     Ressources:     Name  ID  Operations  Type  Range  Description      test  0  R/W  Integer  0-128     exec  1  E       dec  2  R/W  Float      sig  3  R/W  Integer   16-bit signed integer    text  4  R/W  String   char* c-string    opaq  5  W  Opaque  32 Byte  void* data    read  9  R  Integer   Read value from method     If you use the C++ object definition API, you only need to provide an object description (meta object data)\nand all read/write/execute handling is done for you.   Create an object instance class, that serves as data holder for each individual instance.  using   MyReadIntFunction   =   int   ( * )( Lwm2mObjectInstance * );  struct   MyObjectInstance :   public   Lwm2mObjectInstance   { \n     uint8_t    test ; \n     Executable   exec ; \n     double     dec ; \n     int16_t    sig ; \n\n     char *      text ; \n\n     Opaque 32   opaque ; \n\n     IndirectRead int      read ; \n\n     // Force the MyObjectInstance user to assign a read and execute funtion. We don t want to crash! \n     MyObjectInstance ( MyReadIntFunction   readF ,   MyExecuteFunction   execF )   :   exec ( execF )   read ( readF )   {}  };   You inherit from  Lwm2mObjectInstance  for the object instance data holder.  Declare an object class that describes object 1024 to the library:  #include   lwm2m/objects.h  // Object with LwM2M ID 1024  class   MyObject :   public   Lwm2mObject 1024 , MyObject , MyObjectInstance  {  public : \n     Resource ( 0 ,   MyObjectInstance :: test ,   O_RES_RW )   test ; \n     Resource ( 1 ,   MyObjectInstance :: exec ,   O_RES_E   )   exec ; \n     Resource ( 2 ,   MyObjectInstance :: dec ,    O_RES_RW )   dec ; \n     Resource ( 3 ,   MyObjectInstance :: sig ,    O_RES_RW )   sig ; \n\n     Resource ( 4 ,   MyObjectInstance :: text ,   O_RES_RW )   text ; \n\n     Resource ( 5 ,   MyObjectInstance :: opaque , O_RES_W )   opaque ; \n\n     // You don t need to specify the operation, if it is a \n     // IndirectRead, IndirectWrite, IndirectReadWrite type \n     Resource ( 9 ,   MyObjectInstance :: read )   read ; \n\n     // Use writeVerify to enforce restrictions on the resource values \n     MyObject ()   :   writeVerify ([]( MyObjectInstance *   i ,   uint16_t   res_id )   { \n         return   ( res_id == 0 )   ?   ( return   i - test = 128 )   :   true ; \n     })   {}  };   Inherit from  Lwm2mObject  and specify the object ID as template parameter for your object class.  Use the templated  Resource  class to describe the resource ID, reference to the member variable and supported operations in this order.  Supported operations are O_RES_R (read only), O_RES_W (assign only), O_RES_RW (read/write), O_RES_E (executable).", 
            "title": "Example"
        }, 
        {
            "location": "/api/objects-custom-cpp-example/#read-resource-value-from-function", 
            "text": "It is possible to read a resource value from a function instead of a classes member variable.\nUse  PollingResource  and define the resource ID and resource type.  In this example  my_read_method  would look like this:  int   my_read_method ()   {   return   12 ;   }", 
            "title": "Read resource value from function"
        }, 
        {
            "location": "/api/objects-custom-cpp-example/#input-validation", 
            "text": "If you have looked carefully at the object definition, you see that  test  is restricted to 0..128:                Supported      Multiple \n   Name   |   ID   |   Operations   |   Instances   |   Mandatory   |    Type     |   Range   | \n   test   |    0   |      R / W       |      No       |      Yes      |   Integer   |   0 - 128   |   This is less that the data type allows, so we have to provide an input validation method. Thankfully, we can\nuse the  writeVerify  function.  A lambda function, assigned during construction, returns  false  if the value if resource 0 is greater than 128:  MyObject ()   :   writeVerify ([]( MyObjectInstance *   i ,   uint16_t   res_id )   { \n     return   ( res_id == 0 )   ?   ( return   i - test = 128 )   :   true ;  })   {}", 
            "title": "Input validation"
        }, 
        {
            "location": "/api/objects-custom-cpp-example/#react-to-resource-write-operations", 
            "text": "You may \"abuse\" the validation function to react on an altered resource.  Another way is a giant switch in\na defined  void lwm2m_resource_changed_event(uint16_t object_id, uint16_t object_instance_id, uint16_t resource_id) .\nIf you do not implement this method somewhere, a default no-op method will be used.", 
            "title": "React to resource write operations"
        }, 
        {
            "location": "/api/objects-custom-cpp-example/#add-object-and-object-instances", 
            "text": "An example for adding an object  MyObject  with one instance  MyObjectInstance  is provided below.  MyObject   myObj ( false );  int   my_read_method ( Lwm2mObjectInstance * )   {   return   12 ;   }  MyObjectInstance   myInstance ( my_read_method );  void   setup ()   { \n     myObj . addInstance ( lwm2mContext ,   myInstance ); \n     // The second argument either allows or disallows the lwm2m server \n     // to create/delete object instances \n     myObj . registerObject ( lwm2mContext ,   false );  }   You can register objects either before or after you are connected to a lwM2M server. If you are already connected,\nthe register call will be a little bit more expensive, because the object need to be published to the server.", 
            "title": "Add object and object instances"
        }, 
        {
            "location": "/api/objects-custom-cpp-example/#remove-object-or-object-instance", 
            "text": "MyObject   myObj ( false );  int   my_read_method ( Lwm2mObjectInstance * )   {   return   12 ;   }  MyObjectInstance   myInstance ( my_read_method );  void   exit ()   { \n     myObj . removeInstance ( lwm2mContext ,   myInstance . instanceID ); \n     myObj . unregisterObject ( lwm2mContext );  }", 
            "title": "Remove object or object instance"
        }, 
        {
            "location": "/api/objects-custom-c-example/", 
            "text": "Example\n\n\nIf you are going to use a lwM2M object, that is defined in the \nOMA lwM2M registry\n,\nhead over to the \nRegistry objects\n page.\nWakamaNode provides ready-to-use, auto-generated c++ classes for all those objects.\n\n\nFor this example, we assume the following custom lwM2M object definition:\n\n\n\n\n\n\n\n\nObject\n\n\nID\n\n\nMultiple Instances\n\n\nMandatoty\n\n\n\n\n\n\n\n\n\n\nTest\n\n\n1024\n\n\nYes\n\n\nNo\n\n\n\n\n\n\n\n\nRessources:\n\n\n\n\n\n\n\n\nName\n\n\nID\n\n\nOperations\n\n\nType\n\n\nRange\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntest\n\n\n1\n\n\nR/W\n\n\nInteger\n\n\n0-128\n\n\n\n\n\n\n\n\nexec\n\n\n2\n\n\nE\n\n\n\n\n\n\n\n\n\n\n\n\ndec\n\n\n3\n\n\nR/W\n\n\nFloat\n\n\n\n\n\n\n\n\n\n\n\n\nIf you use the object definition API, you only need to provide an object description (meta object data)\nand all read/write/execute handling is done for you. \n\n\nThe meta object data is usually definied in your custom \nmy_object.c\n. We assume the following custom object:\n\n\ntypedef\n \nstruct\n\n\n{\n\n    \nstruct\n \ntest_object_instance_t\n \n*\n \nnext\n;\n   \n// matches lwm2m_list_t::next\n\n    \nuint16_t\n \nshortID\n;\n                       \n// matches lwm2m_list_t::id\n\n\n    \nuint8_t\n  \ntest\n;\n\n    \nExecutable\n    \nexecF\n;\n \n// function pointer\n\n    \ndouble\n   \ndec\n;\n\n    \nint16_t\n  \nsig\n;\n\n\n}\n \ntest_object_instance_t\n;\n\n\n\n\n\nWith the help of the \nOBJECT_META(object_struct, result_variable_name, write_verify_callback, ressources...)\n macro we define the object description:\n\n\nOBJECT_META\n(\ntest_object_instance_t\n,\n \ntest_object_meta\n,\n \ntest_object_write_verify_cb\n,\n\n    \n{\n0\n,\n \nO_RES_RW\n,\nO_RES_UINT8\n     \n,\n \noffsetof\n(\ntest_object_instance_t\n,\ntest\n)},\n\n    \n{\n1\n,\n \nO_RES_E\n \n,\n0\n               \n,\n \noffsetof\n(\ntest_object_instance_t\n,\nexecF\n)},\n\n    \n{\n2\n,\n \nO_RES_RW\n,\nO_RES_DOUBLE\n    \n,\n \noffsetof\n(\ntest_object_instance_t\n,\ndec\n)},\n\n    \n{\n3\n,\n \nO_RES_RW\n,\nO_RES_INT16\n     \n,\n \noffsetof\n(\ntest_object_instance_t\n,\nsig\n)}\n\n\n);\n\n\n\nlwm2m_object_meta_information_t\n \n*\ntest_object_get_meta\n()\n \n{\n\n    \nreturn\n \ntest_object_metaP\n;\n\n\n}\n\n\n\n\n\nRemember that we do not use the \nresult_variable_name\n (in this case \ntest_object_meta\n) directly.\nIt is of type \nlwm2m_object_meta_information_t\n,\nwhich is not understood by the WakamaNode and Wakaama API. But thankfully \nOBJECT_META\n also defines\na pointer of type \nlwm2m_object_t\n, which is named like the given \nresult_variable_name\n with a \nP\n suffix.\nIn this case: \ntest_object_metaP\n.\n\n\nThe ressources are described each with an entry of the following form:\n\n{RES_ID, RES_ACCESS, RES_TYPE, offsetof(object_struct, res_name)}\n.\n\n\nInput validation\n\n\nIf you have looked carefully at the object definition above, you see that \ntest\n is restricted to 0..128.\nThis is less that the data type allows, so we have to provide an input validation method and\nmake it known to the meta object via the third argument (write_verify_callback).\n\n\nFor the above example such a method could look like this:\n\n\nbool\n \ntest_object_write_verify_cb\n(\nlwm2m_list_t\n*\n \ninstance\n,\n \nuint16_t\n \nchanged_res_id\n)\n \n{\n\n    \ntest_object_instance_t\n*\n \ni\n \n=\n \n(\ntest_object_instance_t\n*\n)\ninstance\n;\n\n    \n// Return false for an invalid object\n\n    \nif\n(\nchanged_res_id\n==\n1\n \n \ni\n-\ntest\n \n \n128\n)\n \nreturn\n \nfalse\n;\n\n    \n// If we return true, the new value will be applied to the instance object for us.\n\n    \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\nReact to resource write operations\n\n\nYou may \"misuse\" the validation function to react on an altered resource. Another way is to implement\n\nvoid lwm2m_resource_changed_event(uint16_t object_id, uint16_t object_instance_id, uint16_t resource_id)\n\nand have a giant switch for all resources.\n\n\nAdd object and object instances\n\n\nFirst define a method in your \nmy_object.c\n unit that creates a new object instance, like in the code below:\n\n\nlwm2m_list_t\n*\n \nled_object_create_instances\n()\n \n{\n\n    \ntest_object_instance_t\n \n*\n \ntargetP\n \n=\n \n(\ntest_object_instance_t\n \n*\n)\nmalloc\n(\nsizeof\n(\ntest_object_instance_t\n));\n\n    \nif\n \n(\nNULL\n \n==\n \ntargetP\n)\n \nreturn\n \nNULL\n;\n\n    \nmemset\n(\ntargetP\n,\n \n0\n,\n \nsizeof\n(\ntest_object_instance_t\n));\n\n    \ntargetP\n-\nshortID\n \n=\n \n0\n;\n \n// Assign instance ID\n\n    \ntargetP\n-\nstate\n \n=\n \n0\n;\n\n    \nreturn\n \n(\nlwm2m_list_t\n*\n)\ntargetP\n;\n\n\n}\n\n\n\n\n\nIn your \nmy_object.h\n file, make the method declaration available:\n\n\n#pragma once\n\n\n\nlwm2m_object_meta_information_t\n*\n \nled_object_get_meta\n();\n\n\nlwm2m_list_t\n*\n \nled_object_create_instances\n()\n \n;\n\n\n\n\n\nIn you application file, create the object and instance and register each.\n\n\n#include\n \nmy_object.h\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n    \n// Create object\n\n    \nlwm2m_object_t\n*\n \ntest_object\n \n=\n \nlwm2m_object_create\n(\n5850\n,\n \ntrue\n,\n \nled_object_get_meta\n());\n\n    \n// Add instance\n\n    \nlwm2m_object_instances_add\n(\ntest_object\n,\n \nled_object_create_instances\n());\n\n    \n// Register object\n\n    \nlwm2m_add_object\n(\nclient_context\n,\n \ntest_object\n);\n\n\n\n}\n\n\n\n\n\nYou can register objects either before or after you are connected to a lwM2M server. If you are already connected,\nthe register call will be a little bit more expensive, because the object need to be published to the server.\n\n\nRemove object or object instance\n\n\n#include\n \nmy_object.h\n\n\n\nlwm2m_object_t\n*\n \ntest_object\n \n=\n \n...;\n\n\n\nvoid\n \nexit\n()\n \n{\n\n    \nlwm2m_object_free\n(\ntest_object\n);\n\n\n}", 
            "title": "Custom objects /C Example"
        }, 
        {
            "location": "/api/objects-custom-c-example/#example", 
            "text": "If you are going to use a lwM2M object, that is defined in the  OMA lwM2M registry ,\nhead over to the  Registry objects  page.\nWakamaNode provides ready-to-use, auto-generated c++ classes for all those objects.  For this example, we assume the following custom lwM2M object definition:     Object  ID  Multiple Instances  Mandatoty      Test  1024  Yes  No     Ressources:     Name  ID  Operations  Type  Range  Description      test  1  R/W  Integer  0-128     exec  2  E       dec  3  R/W  Float       If you use the object definition API, you only need to provide an object description (meta object data)\nand all read/write/execute handling is done for you.   The meta object data is usually definied in your custom  my_object.c . We assume the following custom object:  typedef   struct  { \n     struct   test_object_instance_t   *   next ;     // matches lwm2m_list_t::next \n     uint16_t   shortID ;                         // matches lwm2m_list_t::id \n\n     uint8_t    test ; \n     Executable      execF ;   // function pointer \n     double     dec ; \n     int16_t    sig ;  }   test_object_instance_t ;   With the help of the  OBJECT_META(object_struct, result_variable_name, write_verify_callback, ressources...)  macro we define the object description:  OBJECT_META ( test_object_instance_t ,   test_object_meta ,   test_object_write_verify_cb , \n     { 0 ,   O_RES_RW , O_RES_UINT8       ,   offsetof ( test_object_instance_t , test )}, \n     { 1 ,   O_RES_E   , 0                 ,   offsetof ( test_object_instance_t , execF )}, \n     { 2 ,   O_RES_RW , O_RES_DOUBLE      ,   offsetof ( test_object_instance_t , dec )}, \n     { 3 ,   O_RES_RW , O_RES_INT16       ,   offsetof ( test_object_instance_t , sig )}  );  lwm2m_object_meta_information_t   * test_object_get_meta ()   { \n     return   test_object_metaP ;  }   Remember that we do not use the  result_variable_name  (in this case  test_object_meta ) directly.\nIt is of type  lwm2m_object_meta_information_t ,\nwhich is not understood by the WakamaNode and Wakaama API. But thankfully  OBJECT_META  also defines\na pointer of type  lwm2m_object_t , which is named like the given  result_variable_name  with a  P  suffix.\nIn this case:  test_object_metaP .  The ressources are described each with an entry of the following form: {RES_ID, RES_ACCESS, RES_TYPE, offsetof(object_struct, res_name)} .", 
            "title": "Example"
        }, 
        {
            "location": "/api/objects-custom-c-example/#input-validation", 
            "text": "If you have looked carefully at the object definition above, you see that  test  is restricted to 0..128.\nThis is less that the data type allows, so we have to provide an input validation method and\nmake it known to the meta object via the third argument (write_verify_callback).  For the above example such a method could look like this:  bool   test_object_write_verify_cb ( lwm2m_list_t *   instance ,   uint16_t   changed_res_id )   { \n     test_object_instance_t *   i   =   ( test_object_instance_t * ) instance ; \n     // Return false for an invalid object \n     if ( changed_res_id == 1     i - test     128 )   return   false ; \n     // If we return true, the new value will be applied to the instance object for us. \n     return   true ;  }", 
            "title": "Input validation"
        }, 
        {
            "location": "/api/objects-custom-c-example/#react-to-resource-write-operations", 
            "text": "You may \"misuse\" the validation function to react on an altered resource. Another way is to implement void lwm2m_resource_changed_event(uint16_t object_id, uint16_t object_instance_id, uint16_t resource_id) \nand have a giant switch for all resources.", 
            "title": "React to resource write operations"
        }, 
        {
            "location": "/api/objects-custom-c-example/#add-object-and-object-instances", 
            "text": "First define a method in your  my_object.c  unit that creates a new object instance, like in the code below:  lwm2m_list_t *   led_object_create_instances ()   { \n     test_object_instance_t   *   targetP   =   ( test_object_instance_t   * ) malloc ( sizeof ( test_object_instance_t )); \n     if   ( NULL   ==   targetP )   return   NULL ; \n     memset ( targetP ,   0 ,   sizeof ( test_object_instance_t )); \n     targetP - shortID   =   0 ;   // Assign instance ID \n     targetP - state   =   0 ; \n     return   ( lwm2m_list_t * ) targetP ;  }   In your  my_object.h  file, make the method declaration available:  #pragma once  lwm2m_object_meta_information_t *   led_object_get_meta ();  lwm2m_list_t *   led_object_create_instances ()   ;   In you application file, create the object and instance and register each.  #include   my_object.h  void   setup ()   { \n     // Create object \n     lwm2m_object_t *   test_object   =   lwm2m_object_create ( 5850 ,   true ,   led_object_get_meta ()); \n     // Add instance \n     lwm2m_object_instances_add ( test_object ,   led_object_create_instances ()); \n     // Register object \n     lwm2m_add_object ( client_context ,   test_object );  }   You can register objects either before or after you are connected to a lwM2M server. If you are already connected,\nthe register call will be a little bit more expensive, because the object need to be published to the server.", 
            "title": "Add object and object instances"
        }, 
        {
            "location": "/api/objects-custom-c-example/#remove-object-or-object-instance", 
            "text": "#include   my_object.h  lwm2m_object_t *   test_object   =   ...;  void   exit ()   { \n     lwm2m_object_free ( test_object );  }", 
            "title": "Remove object or object instance"
        }, 
        {
            "location": "/advanced-usage/custom-platform/", 
            "text": "Custom platform\n\n\nPlatform code need to implement the following methods:\n\n\nvoid\n*\n \nlwm2m_malloc\n(\nsize_t\n \ns\n);\n\n\n\nvoid\n \nlwm2m_free\n(\nvoid\n \n*\n \np\n);\n\n\n\nchar\n*\n \nlwm2m_strdup\n(\nconst\n \nchar\n \n*\n \nstr\n);\n\n\n\nint\n \nlwm2m_strncmp\n(\nconst\n \nchar\n \n*\n \ns1\n,\n\n                     \nconst\n \nchar\n \n*\n \ns2\n,\n\n                     \nsize_t\n \nn\n);\n\n\n\ntime_t\n \n__attribute__\n((\nweak\n))\n \nlwm2m_gettime\n(\nvoid\n);\n\n\n\n#ifdef LWM2M_WITH_LOGS\n\n\nvoid\n \n__attribute__\n((\nweak\n))\n \nlwm2m_printf\n(\nconst\n \nchar\n \n*\n \nformat\n,\n \n...);\n\n\n#endif\n\n\n\n\n\nlwm2m_printf\n is implemented with a weak linkage, so that the application is\nable to override the log destination.\n\n\nThe implementation is expected to reside in the\n\n src/platform\n\ndirectory.", 
            "title": "Custom platform"
        }, 
        {
            "location": "/advanced-usage/custom-platform/#custom-platform", 
            "text": "Platform code need to implement the following methods:  void *   lwm2m_malloc ( size_t   s );  void   lwm2m_free ( void   *   p );  char *   lwm2m_strdup ( const   char   *   str );  int   lwm2m_strncmp ( const   char   *   s1 , \n                      const   char   *   s2 , \n                      size_t   n );  time_t   __attribute__ (( weak ))   lwm2m_gettime ( void );  #ifdef LWM2M_WITH_LOGS  void   __attribute__ (( weak ))   lwm2m_printf ( const   char   *   format ,   ...);  #endif   lwm2m_printf  is implemented with a weak linkage, so that the application is\nable to override the log destination.  The implementation is expected to reside in the  src/platform \ndirectory.", 
            "title": "Custom platform"
        }, 
        {
            "location": "/advanced-usage/custom-network/", 
            "text": "Network integration\n\n\nCurrently the lwip stack and a posix compatible stack as well as the windows network stack is supported.\n\n\nBasically an implementation has to keep track of open connections, open up an udp connection and close an udp connection.\n\n\nThe implementation is expected to reside in the\n\n src/network\n\ndirectory.\n\n\nRequired methods\n\n\nNetwork stack code need to implement the following methods:\n\n\n/**\n\n\n * @brief Initializes the network layer\n\n\n *\n\n\n * @param contextP  The wakaama context. Network socket information is stored in the\n\n\n *                  contexts userdata.\n\n\n * @param localPort Must be 0 for clients in which case a port is automatically choosen.\n\n\n *                  For servers LWM2M_DEFAULT_SERVER_PORT is recommended.\n\n\n * @return Return 0 if socket binding failed. Otherwise returns the number\n\n\n *     of sockets we could bind to (for IPv4 and IPv6 each on all available interfaces).\n\n\n */\n\n\nuint8_t\n \nlwm2m_network_init\n(\nlwm2m_context_t\n \n*\n \ncontextP\n,\n \nuint16_t\n \nlocalPort\n);\n\n\n\n/**\n\n\n * @brief Return the native socket handler for the given socket number.\n\n\n * Usually this method is relevant if posix sockets are used and you need the socket handlers for select().\n\n\n * @param contextP The wakaama context.\n\n\n * @param sock_no Number from 0..v-1 where v has been returned by lwm2m_network_init().\n\n\n * @return Native socket handler for the given socket number\n\n\n */\n\n\nint\n \nlwm2m_network_native_sock\n(\nlwm2m_context_t\n \n*\n \ncontextP\n,\n \nuint8_t\n \nsock_no\n);\n\n\n\n/**\n\n\n * @brief lwm2m_network_process\n\n\n * Processes incoming network traffic and calls lwm2m_handle_packet.\n\n\n * @param contextP The wakaama context.\n\n\n * @return Return false if no open sockets are available.\n\n\n */\n\n\nbool\n \nlwm2m_network_process\n(\nlwm2m_context_t\n \n*\n \ncontextP\n);\n\n\n\n/**\n\n\n * @brief Closes all opened sockets and clean context-\nuserdata.\n\n\n * @param contextP The wakaama context.\n\n\n */\n\n\nvoid\n \nlwm2m_network_close\n(\nlwm2m_context_t\n \n*\n \ncontextP\n);\n\n\n\n/**\n\n\n * @brief Force the network stack to use the given network interface\n\n\n * This is useful for testing purposes. The routing table will be ignored\n\n\n * and the given interface will be used for outgoing traffic.\n\n\n * @param contextP The wakaama context.\n\n\n * @param interface A generic value which can be used to point to a network\n\n\n * interface. The interpretation depends on the network backend.\n\n\n */\n\n\nvoid\n \nlwm2m_network_force_interface\n(\nlwm2m_context_t\n \n*\n \ncontextP\n,\n \nvoid\n*\n \ninterface\n);\n\n\n\n\n\nDTLS\n\n\nA reference network stack implementation for a DTLS secured connection based on mbed TLS is included.\nYou need to define \n#define LWM2M_WITH_DTLS\n in your \nwakaama_config.h\n.\nDo not expect this to be safe in any way without a security audit on your side!\n\n\nhttps://tls.mbed.org/kb/how-to/how-do-i-port-mbed-tls-to-a-new-environment-OS\n explains the required\nplatform and network code for mbed TLS to work.\n\n\nPlease be aware that mbed TLS uses heap memory and maximum buffer sizes need to be tuned for your use-cases.", 
            "title": "Custom network stack"
        }, 
        {
            "location": "/advanced-usage/custom-network/#network-integration", 
            "text": "Currently the lwip stack and a posix compatible stack as well as the windows network stack is supported.  Basically an implementation has to keep track of open connections, open up an udp connection and close an udp connection.  The implementation is expected to reside in the  src/network \ndirectory.", 
            "title": "Network integration"
        }, 
        {
            "location": "/advanced-usage/custom-network/#required-methods", 
            "text": "Network stack code need to implement the following methods:  /**   * @brief Initializes the network layer   *   * @param contextP  The wakaama context. Network socket information is stored in the   *                  contexts userdata.   * @param localPort Must be 0 for clients in which case a port is automatically choosen.   *                  For servers LWM2M_DEFAULT_SERVER_PORT is recommended.   * @return Return 0 if socket binding failed. Otherwise returns the number   *     of sockets we could bind to (for IPv4 and IPv6 each on all available interfaces).   */  uint8_t   lwm2m_network_init ( lwm2m_context_t   *   contextP ,   uint16_t   localPort );  /**   * @brief Return the native socket handler for the given socket number.   * Usually this method is relevant if posix sockets are used and you need the socket handlers for select().   * @param contextP The wakaama context.   * @param sock_no Number from 0..v-1 where v has been returned by lwm2m_network_init().   * @return Native socket handler for the given socket number   */  int   lwm2m_network_native_sock ( lwm2m_context_t   *   contextP ,   uint8_t   sock_no );  /**   * @brief lwm2m_network_process   * Processes incoming network traffic and calls lwm2m_handle_packet.   * @param contextP The wakaama context.   * @return Return false if no open sockets are available.   */  bool   lwm2m_network_process ( lwm2m_context_t   *   contextP );  /**   * @brief Closes all opened sockets and clean context- userdata.   * @param contextP The wakaama context.   */  void   lwm2m_network_close ( lwm2m_context_t   *   contextP );  /**   * @brief Force the network stack to use the given network interface   * This is useful for testing purposes. The routing table will be ignored   * and the given interface will be used for outgoing traffic.   * @param contextP The wakaama context.   * @param interface A generic value which can be used to point to a network   * interface. The interpretation depends on the network backend.   */  void   lwm2m_network_force_interface ( lwm2m_context_t   *   contextP ,   void *   interface );", 
            "title": "Required methods"
        }, 
        {
            "location": "/advanced-usage/custom-network/#dtls", 
            "text": "A reference network stack implementation for a DTLS secured connection based on mbed TLS is included.\nYou need to define  #define LWM2M_WITH_DTLS  in your  wakaama_config.h .\nDo not expect this to be safe in any way without a security audit on your side!  https://tls.mbed.org/kb/how-to/how-do-i-port-mbed-tls-to-a-new-environment-OS  explains the required\nplatform and network code for mbed TLS to work.  Please be aware that mbed TLS uses heap memory and maximum buffer sizes need to be tuned for your use-cases.", 
            "title": "DTLS"
        }, 
        {
            "location": "/advanced-usage/ota/", 
            "text": "OTA updates\n\n\nlwM2M defines a firmware upgrade object. The wakaamaNode library provides two\nreference implementations: For the Arduino OTA model and for Posix/Windows binaries.\n\n\nFind the implementations in the\n\n src/firmware\n\ndirectory.\n\n\nUpdating or even checking the version is a server initatiated operation, wakaamaNode\nwill not perform any checks on its own.\n\n\nOn Posix/Windows systems\n\n\nThe firmware update object accepts pushed binaries via coap in the default implementation.\nThe new binary is saved as \"new.current_binary_name\". As soon as the update resource is executed,\nthe current binary will be moved to \"old.current_binary_name\" and the \"new.current_binary_name\"\ntakes it place.\n\n\nThe new binary is started with a command line argument \"oldpid=PID\". It sends a posix signal SIGTERM\nto the old binary via the PID and waits for it to finish.\n\n\nThe old binary waits for SIGTERM and terminates if received.\nIf not received in time (because the new binary has startup problems for example), the old executable\nwill stay active.\n\n\nA posix/win32 binary is required to call \nvoid checkIsUpdated(int argc, char** argv)\n on startup.\n\n\nArduino OTA\n\n\nBecause memory space is assumed to be limited, the update process accepts a http URI only and does not take\nbinaries directly via COAP.\n\n\nThe ESP8266 method \nESPhttpUpdate.update(\n192.168.0.2\n, 80, \n/arduino.bin\n);\n is used.\n\n\nOTA security\n\n\nYou should only accept an OTA request, if you are connected to a DTLS secured connection\nwith an authentificated server.", 
            "title": "Over-the-air updates"
        }, 
        {
            "location": "/advanced-usage/ota/#ota-updates", 
            "text": "lwM2M defines a firmware upgrade object. The wakaamaNode library provides two\nreference implementations: For the Arduino OTA model and for Posix/Windows binaries.  Find the implementations in the  src/firmware \ndirectory.  Updating or even checking the version is a server initatiated operation, wakaamaNode\nwill not perform any checks on its own.", 
            "title": "OTA updates"
        }, 
        {
            "location": "/advanced-usage/ota/#on-posixwindows-systems", 
            "text": "The firmware update object accepts pushed binaries via coap in the default implementation.\nThe new binary is saved as \"new.current_binary_name\". As soon as the update resource is executed,\nthe current binary will be moved to \"old.current_binary_name\" and the \"new.current_binary_name\"\ntakes it place.  The new binary is started with a command line argument \"oldpid=PID\". It sends a posix signal SIGTERM\nto the old binary via the PID and waits for it to finish.  The old binary waits for SIGTERM and terminates if received.\nIf not received in time (because the new binary has startup problems for example), the old executable\nwill stay active.  A posix/win32 binary is required to call  void checkIsUpdated(int argc, char** argv)  on startup.", 
            "title": "On Posix/Windows systems"
        }, 
        {
            "location": "/advanced-usage/ota/#arduino-ota", 
            "text": "Because memory space is assumed to be limited, the update process accepts a http URI only and does not take\nbinaries directly via COAP.  The ESP8266 method  ESPhttpUpdate.update( 192.168.0.2 , 80,  /arduino.bin );  is used.", 
            "title": "Arduino OTA"
        }, 
        {
            "location": "/advanced-usage/ota/#ota-security", 
            "text": "You should only accept an OTA request, if you are connected to a DTLS secured connection\nwith an authentificated server.", 
            "title": "OTA security"
        }, 
        {
            "location": "/advanced-usage/deep-sleep/", 
            "text": "After a long deep sleep a new IP may be assigned by the DHCP/stateless-address-autoconfiguration part of your network layer.\nThis requires a new DTLS security context and a new lwM2M handshake,\ntherefore a proper session closing is recommended before entering deep sleep.\n\n\nTo ensure that all messages are sent and the (DTLS) session is shutdown correctly,\nuse the function \nlwm2m_network_close(context)\n. Reinitialize\nthe network after the deep sleep has finished with \nlwm2m_network_init(context,port)\n.\n\n\n#include\n \nlwm2m/network.h\n\n\n\nvoid\n \nloop\n()\n \n{\n\n  \nif\n \n(\nrequestDeepsleep\n)\n \n{\n\n    \nrequestDeepsleep\n \n=\n \nfalse\n;\n\n    \nlwm2m_network_close\n(\nCTX\n(\ncontext\n));\n\n\n    \nESP\n.\ndeepSleep\n();\n \n// Example call to enter deep sleep\n\n    \nsleep\n(\n10\n);\n \n// Some time for the OS and network layer to recover\n\n\n    \nlwm2m_network_init\n(\nCTX\n(\ncontext\n),\n \n0\n);\n\n  \n}\n\n\n}", 
            "title": "Deep sleep"
        }, 
        {
            "location": "/advanced-usage/own-mainloop/", 
            "text": "The library can be integrated into your own select/poll/epoll based mainloop fairly easy,\nbecause you have access to the native socket handlers via \nlwm2m_network_native_sock(context,sock_no)\n\nand the next due time to call \nlwm2m_process(context,next_event)\n.\n\n\nIf you are already using the linux \nepoll\n API (or \nwepoll\n on Windows), you should have a look at the implementation of \nlwm2m_block_wait\n in\n\n\n network/network_posix.c\n.\n\n\nAdd own file descriptors to lwm2m_block_wait\n\n\nYou can access the epoll descriptor this way:\n\n\n#include\n \nlwm2m/../../network/network_common.h\n\n\n\nnetwork_t\n*\n \nnetwork\n \n=\n \n(\nnetwork_t\n*\n)\ncontextP\n-\nuserData\n;\n\n\nint\n \nepoll_desc\n \n=\n \nnetwork\n-\nepfd\n;\n\n\n\n\n\nAdd your file descriptor:\n\n\nstruct\n \nepoll_event\n \nev\n=\n{\n \n.\nevents\n=\nEPOLLIN\n \n|\n \nEPOLLPRI\n \n|\n \nEPOLLERR\n \n|\n \nEPOLLHUP\n,\n \n{\n0\n}\n \n};\n\n\nev\n.\ndata\n.\nfd\n=\nyour_file_desc\n;\n\n\nepoll_ctl\n(\nepoll_desc\n,\n \nEPOLL_CTL_ADD\n,\n \nyour_file_desc\n,\n \nev\n);\n\n\n\n\n\nExample implementation of a select() based lwm2m_block_wait\n\n\nint\n \nlwm2m_block_wait\n(\nlwm2m_context_t\n \n*\n \ncontextP\n,\n \nstruct\n \ntimeval\n \nnext_event\n)\n \n{\n\n    \nfd_set\n \nreadfds\n \n=\n \n{{\n0\n}};\n\n    \nunsigned\n \nsockets\n \n=\n \n((\nnetwork_t\n*\n)\ncontextP\n-\nuserData\n)\n-\nopen_listen_sockets\n;\n\n    \nfor\n \n(\nunsigned\n \nc\n \n=\n \n0\n;\n \nc\n \n \nsockets\n;\n \n++\nc\n)\n \n{\n\n        \nintptr_t\n \nsock\n \n=\n \nlwm2m_network_native_sock\n(\ncontextP\n,\n \nc\n);\n\n        \nif\n \n(\nsock\n \n==\n \n-\n1\n)\n \ncontinue\n;\n\n        \nFD_SET\n(\nsock\n,\n \nreadfds\n);\n\n    \n}\n\n\n    \nconst\n \nint\n \nselect_result\n \n=\n \nselect\n(\nFD_SETSIZE\n,\n \nreadfds\n,\n \nNULL\n,\n \nNULL\n,\n \nnext_event\n);\n\n\n    \nif\n \n(\nselect_result\n \n \n0\n \n \nerrno\n \n!=\n \nEINTR\n)\n \n{\n\n        \nfprintf\n(\nstderr\n,\n \nError in select(): %d %s\n\\r\\n\n,\n \nerrno\n,\n \nstrerror\n(\nerrno\n));\n\n        \nreturn\n \n-\n1\n;\n\n    \n}\n\n\n    \nfor\n \n(\nunsigned\n \nc\n \n=\n \n0\n;\n \nc\n \n \nsockets\n;\n \n++\nc\n)\n \n{\n\n        \nconst\n \nintptr_t\n \nsock\n \n=\n \nlwm2m_network_native_sock\n(\ncontextP\n,\n \nc\n);\n\n        \nif\n \n(\nsock\n \n!=\n \n-\n1\n \n \nFD_ISSET\n(\nsock\n,\n \nreadfds\n))\n \n{\n\n            \nreturn\n \n(\nint\n)\nc\n;\n\n        \n}\n\n    \n}\n\n\n    \nreturn\n \n0\n;\n\n\n}", 
            "title": "Own mainloop"
        }, 
        {
            "location": "/advanced-usage/own-mainloop/#add-own-file-descriptors-to-lwm2m_block_wait", 
            "text": "You can access the epoll descriptor this way:  #include   lwm2m/../../network/network_common.h  network_t *   network   =   ( network_t * ) contextP - userData ;  int   epoll_desc   =   network - epfd ;   Add your file descriptor:  struct   epoll_event   ev = {   . events = EPOLLIN   |   EPOLLPRI   |   EPOLLERR   |   EPOLLHUP ,   { 0 }   };  ev . data . fd = your_file_desc ;  epoll_ctl ( epoll_desc ,   EPOLL_CTL_ADD ,   your_file_desc ,   ev );", 
            "title": "Add own file descriptors to lwm2m_block_wait"
        }, 
        {
            "location": "/advanced-usage/own-mainloop/#example-implementation-of-a-select-based-lwm2m_block_wait", 
            "text": "int   lwm2m_block_wait ( lwm2m_context_t   *   contextP ,   struct   timeval   next_event )   { \n     fd_set   readfds   =   {{ 0 }}; \n     unsigned   sockets   =   (( network_t * ) contextP - userData ) - open_listen_sockets ; \n     for   ( unsigned   c   =   0 ;   c     sockets ;   ++ c )   { \n         intptr_t   sock   =   lwm2m_network_native_sock ( contextP ,   c ); \n         if   ( sock   ==   - 1 )   continue ; \n         FD_SET ( sock ,   readfds ); \n     } \n\n     const   int   select_result   =   select ( FD_SETSIZE ,   readfds ,   NULL ,   NULL ,   next_event ); \n\n     if   ( select_result     0     errno   !=   EINTR )   { \n         fprintf ( stderr ,   Error in select(): %d %s \\r\\n ,   errno ,   strerror ( errno )); \n         return   - 1 ; \n     } \n\n     for   ( unsigned   c   =   0 ;   c     sockets ;   ++ c )   { \n         const   intptr_t   sock   =   lwm2m_network_native_sock ( contextP ,   c ); \n         if   ( sock   !=   - 1     FD_ISSET ( sock ,   readfds ))   { \n             return   ( int ) c ; \n         } \n     } \n\n     return   0 ;  }", 
            "title": "Example implementation of a select() based lwm2m_block_wait"
        }, 
        {
            "location": "/advanced-usage/thread-safety/", 
            "text": "The library itself is not thread safe. You need to push new data into the library\nin the same thread that handles received data. Lwm2m object instances and resources\nmay only be manipulated withing the same thread as well. \n\n\nHow to read object instance data from another thread?\n\n\nCreate a Mutex and lock the access to \nlwm2m_network_process\n.\nWhenever you want to access object instance resources, lock the mutex as well, for example:\n\n\n#include\n \nmutex\n\n\nstd\n::\nmutex\n \nm\n;\n\n\n\n// Changed sources of network/network_posix.c\n\n\ninline\n \nint\n \nlwm2m_process\n(\nlwm2m_context_t\n \n*\ncontextP\n,\n \nstruct\n \ntimeval\n \n*\nnext_event\n)\n \n{\n\n    \nstd\n::\nlock_guard\nstd\n::\nmutex\n \nlock\n(\nm\n);\n\n    \nif\n \n(\n!\nlwm2m_network_process\n(\ncontextP\n,\n \nnext_event\n))\n\n        \nreturn\n \nCOAP_505_NO_NETWORK_CONNECTION\n;\n\n    \nreturn\n \nlwm2m_step\n(\ncontextP\n,\n \nnext_event\n-\ntv_sec\n);\n\n\n}\n\n\n\nvoid\n \nmyOtherThreadLoop\n()\n \n{\n\n    \n...\n\n    \n// Access object instance data\n\n    \n{\n\n        \nstd\n::\nlock_guard\nstd\n::\nmutex\n \nlock\n(\nm\n);\n\n        \nif\n \n(\nmy_object_instance\n.\nmy_res\n \n==\n \n3\n)\n\n            \ndo_something\n();\n\n    \n}\n\n    \n...\n\n\n}\n\n\n\n\n\nHow to write object instance data from another thread?\n\n\nThe safest way is to use a thread safe queue that you push your object instance resource changes into\nand which is processed in your lwM2M thread.\n\n\nHow to react on object instance changes in another thread?\n\n\nCreate a Mutex and lock the access to \nlwm2m_network_process\n.\nWhenever you receive data via the \nwriteVerify\n callback for example, lock the mutex as well.", 
            "title": "Thread safety"
        }, 
        {
            "location": "/advanced-usage/thread-safety/#how-to-read-object-instance-data-from-another-thread", 
            "text": "Create a Mutex and lock the access to  lwm2m_network_process .\nWhenever you want to access object instance resources, lock the mutex as well, for example:  #include   mutex  std :: mutex   m ;  // Changed sources of network/network_posix.c  inline   int   lwm2m_process ( lwm2m_context_t   * contextP ,   struct   timeval   * next_event )   { \n     std :: lock_guard std :: mutex   lock ( m ); \n     if   ( ! lwm2m_network_process ( contextP ,   next_event )) \n         return   COAP_505_NO_NETWORK_CONNECTION ; \n     return   lwm2m_step ( contextP ,   next_event - tv_sec );  }  void   myOtherThreadLoop ()   { \n     ... \n     // Access object instance data \n     { \n         std :: lock_guard std :: mutex   lock ( m ); \n         if   ( my_object_instance . my_res   ==   3 ) \n             do_something (); \n     } \n     ...  }", 
            "title": "How to read object instance data from another thread?"
        }, 
        {
            "location": "/advanced-usage/thread-safety/#how-to-write-object-instance-data-from-another-thread", 
            "text": "The safest way is to use a thread safe queue that you push your object instance resource changes into\nand which is processed in your lwM2M thread.", 
            "title": "How to write object instance data from another thread?"
        }, 
        {
            "location": "/advanced-usage/thread-safety/#how-to-react-on-object-instance-changes-in-another-thread", 
            "text": "Create a Mutex and lock the access to  lwm2m_network_process .\nWhenever you receive data via the  writeVerify  callback for example, lock the mutex as well.", 
            "title": "How to react on object instance changes in another thread?"
        }, 
        {
            "location": "/advanced-usage/memory/", 
            "text": "A target device needs \n5kb RAM\n and \n10kb ROM\n for the library without DTLS and some user defined objects.\n\n\nMost of the API can be used in a staticly allocated memory environment.\nWakaama on the other hand uses dynamic memory allocation for events like server\nconnections, message receiving, message resends. \n\n\n\n\nInfo\n\n\nYou may influence the memory layout by implementing \nlwm2m_malloc\n, \nlwm2m_free\n and \nlwm2m_strdup\n accordingly.\n\n\n\n\nThe DTLS implementation that is optionally included (mbedTLS) makes use of dynamic memory allocation.\n\n\n\n\nInfo\n\n\nYou may influence the memory layout by implementing \nmbedtls_malloc\n and \nmbedtls_free\n accordingly.", 
            "title": "Memory"
        }, 
        {
            "location": "/others/limitations-and-known-issues/", 
            "text": "Limitations\n\n\nAuto generated registry objects\n\n\nUnfortunately the lwm2m description does not consistently contain information about the maximum size of a string or an opaque block.\nCurrently strings and opaque resources are hardcoded to 30 bytes in size. Each string and opaque resource is defined as Macro\nand can be overridden before including the respective header file.\n\n\nResources: Object links\n\n\nThe library does not support object links as resources if you use the C or C++ objects API.\n\n\nResources: Multiple instances\n\n\nThe library does not support multiple instances of resources. Those are mostly used for object links though.\n\n\nDTLS: Certificate based encryption + public raw key\n\n\nThe library only supports to configure the embedded mbedtls to use preshared (PSK) ciphers suits. Public raw keys are not yet fully supported by mbedtls\nand certificate based encryption needs further configuration tuning of mbedtls.\n\n\nDTLS: Handshake\n\n\nThe lwm2m state machine will freeze as soon as a dtls handshake takes place.\nThis avoids the state machine to issue new packets or setup timers, while the actuall\nconnection have not been established yet.\nIf multiple servers are configured, all dtls handshakes take place in parallel.\n\n\nBut only if all have finished (successfully or timed out), the lwm2m state machine and lwm2m handshake will be processed.\n\n\nMain loop timing\n\n\nA connection to a lwM2M server or a dtls session may get expired if the libraries main loop method is not called in time.\nDo not \ndelay()\n/\nsleep()\n or call blocking functions for too long. The \nlwm2m_process\n method will return a \ntimeval\n value\nin microseconds+seconds to let you know when the next call is due.", 
            "title": "Limitations"
        }, 
        {
            "location": "/others/limitations-and-known-issues/#limitations", 
            "text": "", 
            "title": "Limitations"
        }, 
        {
            "location": "/others/limitations-and-known-issues/#auto-generated-registry-objects", 
            "text": "Unfortunately the lwm2m description does not consistently contain information about the maximum size of a string or an opaque block.\nCurrently strings and opaque resources are hardcoded to 30 bytes in size. Each string and opaque resource is defined as Macro\nand can be overridden before including the respective header file.", 
            "title": "Auto generated registry objects"
        }, 
        {
            "location": "/others/limitations-and-known-issues/#resources-object-links", 
            "text": "The library does not support object links as resources if you use the C or C++ objects API.", 
            "title": "Resources: Object links"
        }, 
        {
            "location": "/others/limitations-and-known-issues/#resources-multiple-instances", 
            "text": "The library does not support multiple instances of resources. Those are mostly used for object links though.", 
            "title": "Resources: Multiple instances"
        }, 
        {
            "location": "/others/limitations-and-known-issues/#dtls-certificate-based-encryption-public-raw-key", 
            "text": "The library only supports to configure the embedded mbedtls to use preshared (PSK) ciphers suits. Public raw keys are not yet fully supported by mbedtls\nand certificate based encryption needs further configuration tuning of mbedtls.", 
            "title": "DTLS: Certificate based encryption + public raw key"
        }, 
        {
            "location": "/others/limitations-and-known-issues/#dtls-handshake", 
            "text": "The lwm2m state machine will freeze as soon as a dtls handshake takes place.\nThis avoids the state machine to issue new packets or setup timers, while the actuall\nconnection have not been established yet.\nIf multiple servers are configured, all dtls handshakes take place in parallel.  But only if all have finished (successfully or timed out), the lwm2m state machine and lwm2m handshake will be processed.", 
            "title": "DTLS: Handshake"
        }, 
        {
            "location": "/others/limitations-and-known-issues/#main-loop-timing", 
            "text": "A connection to a lwM2M server or a dtls session may get expired if the libraries main loop method is not called in time.\nDo not  delay() / sleep()  or call blocking functions for too long. The  lwm2m_process  method will return a  timeval  value\nin microseconds+seconds to let you know when the next call is due.", 
            "title": "Main loop timing"
        }, 
        {
            "location": "/others/troubleshooting/", 
            "text": "The network is completely unstable... What's going on?\n\n\nThe library needs work to be done periodically (ie. \nlwm2m_process()\n needs to be called frequently). In other words, don't use \ndelay()\n (see \navoid delay\n) or anything that might block the code for more than 50ms or so. There is also a known Arduino for ESP8266 issue with \nanalogRead()\n, see \nLimitations and known issues\n.\n\n\nMy device resets itself / crashes\n\n\nYou probably run into a memory shortage. The wakaama library is using heap memory\nfor incoming packets, as well as outgoing packets if \nlwm2m_add_server\n is called with\nthe storing flag enabled. Adding a server consumes heap memory as well.\n\n\nMake sure to have around 3kb free heap memory available, disable \nstoring\n, limit the added servers.\nBlock1 type coap blocks consume additional memory as well as observing/observed resources.\n\n\nIf json is enabled via LWM2M_SUPPORT_JSON, the json encoding/decoding temporarly consumes\nheap memory as well.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/others/troubleshooting/#the-network-is-completely-unstable-whats-going-on", 
            "text": "The library needs work to be done periodically (ie.  lwm2m_process()  needs to be called frequently). In other words, don't use  delay()  (see  avoid delay ) or anything that might block the code for more than 50ms or so. There is also a known Arduino for ESP8266 issue with  analogRead() , see  Limitations and known issues .", 
            "title": "The network is completely unstable... What's going on?"
        }, 
        {
            "location": "/others/troubleshooting/#my-device-resets-itself-crashes", 
            "text": "You probably run into a memory shortage. The wakaama library is using heap memory\nfor incoming packets, as well as outgoing packets if  lwm2m_add_server  is called with\nthe storing flag enabled. Adding a server consumes heap memory as well.  Make sure to have around 3kb free heap memory available, disable  storing , limit the added servers.\nBlock1 type coap blocks consume additional memory as well as observing/observed resources.  If json is enabled via LWM2M_SUPPORT_JSON, the json encoding/decoding temporarly consumes\nheap memory as well.", 
            "title": "My device resets itself / crashes"
        }, 
        {
            "location": "/examples/", 
            "text": "Examples\n\n\nLinux/Windows custom object (C-API)\n\n\nThis example client provides a custom lwm2m object that shows a logging message on the console window.\n\n\nShows how to use:\n\n\n\n\nThe object definition C-API\n\n\nThe connection C-API\n\n\nA custom main loop integration based on select()\n\n\n\n\nFind it in \n src/examples/linux_win_custom_object_c\n.\n\n\nLinux/Windows screen control (C++-API)\n\n\nThis example client features the lwm2m \nurn:oma:lwm2m:ext:3342\n Switch object.\nFor each screen on the running windows/linux system another instance of the object is created.\n\n\nIt uses the win32 API on windows and the dbus power interface on Linux.\n\n\nShows how to use:\n\n\n\n\nThe object definition C++-API\n\n\nThe connection C++-API\n\n\nThe firmware update C++-API\n\n\nA predefined object of the lwm2m registry\n\n\n\n\nFind it in \n src/examples/linux_win_screen_control\n.\n\n\nNodeMCU/ESP8266 Led control (C++-API)\n\n\nThis example client provides an lwm2m object to switch the led of an esp01/nodemcu on/off.\n\n\nShows how to use:\n\n\n\n\nThe object definition C++-API\n\n\nThe connection C++-API\n\n\nThe firmware update C++-API\n\n\nA predefined object of the lwm2m registry\n\n\n\n\nFind it in \n src/examples/nodemcu_with_led\n.", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#examples", 
            "text": "", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#linuxwindows-custom-object-c-api", 
            "text": "This example client provides a custom lwm2m object that shows a logging message on the console window.  Shows how to use:   The object definition C-API  The connection C-API  A custom main loop integration based on select()   Find it in   src/examples/linux_win_custom_object_c .", 
            "title": "Linux/Windows custom object (C-API)"
        }, 
        {
            "location": "/examples/#linuxwindows-screen-control-c-api", 
            "text": "This example client features the lwm2m  urn:oma:lwm2m:ext:3342  Switch object.\nFor each screen on the running windows/linux system another instance of the object is created.  It uses the win32 API on windows and the dbus power interface on Linux.  Shows how to use:   The object definition C++-API  The connection C++-API  The firmware update C++-API  A predefined object of the lwm2m registry   Find it in   src/examples/linux_win_screen_control .", 
            "title": "Linux/Windows screen control (C++-API)"
        }, 
        {
            "location": "/examples/#nodemcuesp8266-led-control-c-api", 
            "text": "This example client provides an lwm2m object to switch the led of an esp01/nodemcu on/off.  Shows how to use:   The object definition C++-API  The connection C++-API  The firmware update C++-API  A predefined object of the lwm2m registry   Find it in   src/examples/nodemcu_with_led .", 
            "title": "NodeMCU/ESP8266 Led control (C++-API)"
        }
    ]
}