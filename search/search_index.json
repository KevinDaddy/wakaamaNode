{
    "docs": [
        {
            "location": "/", 
            "text": "WakaamaNode \n\n\nThis is a Lightweight M2M library meant to be used for embedded/constrained devices with a convenient C and C++ API.\n\n\n\n\n\n\nLightweight M2M is a protocol from the Open Mobile Alliance for M2M/IoT device management and communication.\nIt is a convention on top of CoAP/UDP, a light and compact protocol with an efficient resource data model.\nIt follows a server/client architecture with Request/Response semantics (GET, POST, PUT, DELETE), as well as observable resources.\nOptional DTLS (Datagram TLS) ensures secure communication between LWM2M Servers and LWM2M Clients.\n\n\n\n\nEach service on a constrained device/sensor/actor is modeled as an lwM2M object instance with a set of so called resources,\naccessible via a unique CoAP URI.\nlwM2M URIs have a clear hierarchy of \nobjectID\n/\nobjectInstanceID\n/\nresourceID\n.\nA lot of common and not so common object and resource identifiers are standardised via the \nOMA Object \n Resource Registry\n.\n\n\nFor example object \n3311\n is for light controls, \n3312\n for power sources such as smart plugs.\n\n\nGetting started\n\n\nHead over to the \nGet started\n page to dive right into installing and including the library in your project.\n\n\nFeatures\n\n\n\n\nA connection API\n (that implements lwm2m objects security, server and device) makes it simple to connect to a lwM2M server.\n\n\nLwM2M object definition API\n for C and C++ and \nready-to-use c++ classes\n for all objects of the OMA Object \n Resource Registry.\n\n\nThe well-tested \nEclipse Wakaama\n provides the underlying lwM2M protocol implementation.\n\n\nAlways up-to-date/in-sync Wakaama code (using a Travis CI daily cron job).\n\n\n\n\n\n\nSecure connections\n via optional DTLS and the mbedTLS library\n\n\nTest coverage\n - All API functionallity and library\nwakaama server communication is covered by tests.\n\n\n\n\nPlatform/network:\n\n\n\n\n3 Platform integrations (posix/win32, esp8266-sdk, freertos)\n\n\n2 Network stack integrations (posix/win32, lwIP)\n\n\n2 Firmware update integrations (posix/Win32, arduino OTA)\n\n\n\n\nBuilding:\n\n\n\n\n2 build toolchains supported: platformio and cmake\n\n\nConnection API and object API compilable with a C-only compiler (OTA support requires a c++ compiler though)\n\n\n\n\nTarget device requirements\n\n\nA target device needs \n5kb RAM\n and \n10kb ROM\n for the library and some user defined  objects.\n\n\nMost of the API can be used in a staticly allocated memory environment.\nWakaama on the other hand uses dynamic memory allocation for events like server\nconnections, message receiving, message resends.\nYou may influence the memory layout by implementing \nlwm2m_malloc\n, \nlwm2m_free\n and \nlwm2m_strdup\n accordingly.\nThe DTLS implementation that is included (mbedTLS) makes use of dynamic memory allocation.\n\n\nAutomatic synchronisation to the latest Wakaama/mbed TLS sources\n\n\nTravis CI is executed on every commit and additionally every day by a travis cron job.\nThe CI script syncronizes:\n\n\n\n\nthe \nsrc/wakaama\n directory to the latest code found in the core directory of\n\nhttps://github.com/eclipse/wakaama.git\n.\n\n\nthe \nsrc/network/mbedtls\n directory to the latest code found in the inc/mbedtls/ and src/ directory of\n\nhttps://github.com/ARMmbed/mbed-os/tree/master/features/mbedtls\n.\n\n\n\n\nThis may cause tests in the master branch to fail, please use a tagged release of the library in this case.\n\n\nLicense\n\n\nThis platform code and API wrappers are provided under the MIT license.\nWakaama is provided under the Eclipse Public License - v2.0.", 
            "title": "Welcome"
        }, 
        {
            "location": "/#wakaamanode", 
            "text": "This is a Lightweight M2M library meant to be used for embedded/constrained devices with a convenient C and C++ API.    Lightweight M2M is a protocol from the Open Mobile Alliance for M2M/IoT device management and communication.\nIt is a convention on top of CoAP/UDP, a light and compact protocol with an efficient resource data model.\nIt follows a server/client architecture with Request/Response semantics (GET, POST, PUT, DELETE), as well as observable resources.\nOptional DTLS (Datagram TLS) ensures secure communication between LWM2M Servers and LWM2M Clients.   Each service on a constrained device/sensor/actor is modeled as an lwM2M object instance with a set of so called resources,\naccessible via a unique CoAP URI.\nlwM2M URIs have a clear hierarchy of  objectID / objectInstanceID / resourceID .\nA lot of common and not so common object and resource identifiers are standardised via the  OMA Object   Resource Registry .  For example object  3311  is for light controls,  3312  for power sources such as smart plugs.", 
            "title": "WakaamaNode"
        }, 
        {
            "location": "/#getting-started", 
            "text": "Head over to the  Get started  page to dive right into installing and including the library in your project.", 
            "title": "Getting started"
        }, 
        {
            "location": "/#features", 
            "text": "A connection API  (that implements lwm2m objects security, server and device) makes it simple to connect to a lwM2M server.  LwM2M object definition API  for C and C++ and  ready-to-use c++ classes  for all objects of the OMA Object   Resource Registry.  The well-tested  Eclipse Wakaama  provides the underlying lwM2M protocol implementation.  Always up-to-date/in-sync Wakaama code (using a Travis CI daily cron job).    Secure connections  via optional DTLS and the mbedTLS library  Test coverage  - All API functionallity and library wakaama server communication is covered by tests.   Platform/network:   3 Platform integrations (posix/win32, esp8266-sdk, freertos)  2 Network stack integrations (posix/win32, lwIP)  2 Firmware update integrations (posix/Win32, arduino OTA)   Building:   2 build toolchains supported: platformio and cmake  Connection API and object API compilable with a C-only compiler (OTA support requires a c++ compiler though)", 
            "title": "Features"
        }, 
        {
            "location": "/#target-device-requirements", 
            "text": "A target device needs  5kb RAM  and  10kb ROM  for the library and some user defined  objects.  Most of the API can be used in a staticly allocated memory environment.\nWakaama on the other hand uses dynamic memory allocation for events like server\nconnections, message receiving, message resends.\nYou may influence the memory layout by implementing  lwm2m_malloc ,  lwm2m_free  and  lwm2m_strdup  accordingly.\nThe DTLS implementation that is included (mbedTLS) makes use of dynamic memory allocation.", 
            "title": "Target device requirements"
        }, 
        {
            "location": "/#automatic-synchronisation-to-the-latest-wakaamambed-tls-sources", 
            "text": "Travis CI is executed on every commit and additionally every day by a travis cron job.\nThe CI script syncronizes:   the  src/wakaama  directory to the latest code found in the core directory of https://github.com/eclipse/wakaama.git .  the  src/network/mbedtls  directory to the latest code found in the inc/mbedtls/ and src/ directory of https://github.com/ARMmbed/mbed-os/tree/master/features/mbedtls .   This may cause tests in the master branch to fail, please use a tagged release of the library in this case.", 
            "title": "Automatic synchronisation to the latest Wakaama/mbed TLS sources"
        }, 
        {
            "location": "/#license", 
            "text": "This platform code and API wrappers are provided under the MIT license.\nWakaama is provided under the Eclipse Public License - v2.0.", 
            "title": "License"
        }, 
        {
            "location": "/quickstart/getting-started/", 
            "text": "This \nGetting Started\n guide assumes you have an ESP8266 board with an user-configurable LED, like a NodeMCU DevKit or a Linux/Windows system.\n\n\nInstalling WakamaNode for \nPlatformIO\n development\n\n\nThere is a YouTube video with instructions:\n\n\n  How to install WakamaNode library in Visual Studio Code for PlatformIO\n\n\nIn a terminal, run \nplatformio lib install WakamaNode\n.\n\n\nAdd this in your \nplatformio.ini\n for the development branch:\n\n\nlib_deps = git+https://github.com/Openhab-Nodes/wakaamaNode.git#master\n\n\n\n\nAdd this in your \nplatformio.ini\n for the release branch:\n\n\nlib_deps = git+https://github.com/Openhab-Nodes/wakaamaNode.git#v1.0\n\n\n\n\nDependencies are installed automatically.\n\n\nSome build flags can to be provided to enable certain platform codes:\n\n\n\n\nNetwork stack: Compile with \nPOSIX_NETWORK\n for posix network sockets or with \nLWIP\n for the lwIP stack support. Windows and Unix/Linux builds automatically pick the posix/bsd socket API if \nLWIP\n is not set.\n\n\nPlatform (memory, time): Compile with \nESP8266\n for ESP8266 SDK support, \nPOSIX\n for posix/windows system functions, \nFREERTOS\n for freeRTOS support. Windows and Unix/Linux builds automatically pick the posix/windows platform code.\n\n\n\n\nCMake\n\n\nIf you target an x86 system, you may use the cmake buildsystem instead.\nJust include the \n.cmake\n file of the src directory like in the following example:\n\n\ninclude\n(\n${\nCMAKE_CURRENT_LIST_DIR\n}\n/lib/wakaamaNode/src/wakaama_simple_client.cmake\n)\n\n\n\nadd_executable\n(\n${\nPROJECT_NAME\n}\n \n${\nYOUR_FILES\n}\n \n${\nWAKAAMA_SIMPLE_CLIENT_SOURCES\n}\n)\n\n\n# We need C++11 and C11 support\n\n\ntarget_compile_features\n(\n${\nPROJECT_NAME\n}\n \nPRIVATE\n \ncxx_range_for\n)\n\n\nset_property\n(\nTARGET\n \n${\nPROJECT_NAME\n}\n \nPROPERTY\n \nC_STANDARD\n \n11\n)\n\n\n\ntarget_include_directories\n(\n${\nPROJECT_NAME\n}\n \nPRIVATE\n \n{WAKAAMA_SIMPLE_CLIENT_INCLUDE_DIRS}\n)\n\n\n\n\n\nBare minimum sketch\n\n\nThe following example shows how to connect to a lwm2m server, optionally with\na preshared key DTLS connection. It is still your responsibility to connect to the\nwifi/network and to bootstrap the device with the lwm2m server address if it is not a fixed address.\n\n\n#include\n \nArduino.h\n\n\n\n#include\n \nwakaama_simple_client.h\n\n\n#include\n \nwakaama_network.h\n\n\n#include\n \nwakaama_object_utils.h\n\n\n\nlwm2m_context_t\n \n*\n \nlwm2mH\n;\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n    \n// connect to network/wifi\n\n    \n// ......\n\n\n    \n// Tell something about this device. This will be published as lwM2M device object (#3).\n\n    \ndevice_instance_t\n \n*\n \ndevice_data\n \n=\n \nlwm2m_device_data_get\n();\n\n    \ndevice_data\n-\nmanufacturer\n \n=\n \ntest manufacturer\n;\n\n    \ndevice_data\n-\nmodel_name\n \n=\n \ntest model\n;\n\n    \ndevice_data\n-\ndevice_type\n \n=\n \nled\n;\n\n    \ndevice_data\n-\nfirmware_ver\n \n=\n \n1.0\n;\n\n    \ndevice_data\n-\nserial_number\n \n=\n \n140234-645235-12353\n;\n\n\n    \n// The client name will be used by the lwm2m server for identification.\n\n    \nlwm2mH\n \n=\n \nlwm2m_client_init\n(\ntestClient\n);\n\n\n    \n// You don\nt need to use the network helper methods. If you do, call\n\n    \n// the lwm2m_network_init() method early in your code.\n\n    \n// Posix and LwIP network stacks are support\n\n    \nlwm2m_network_init\n(\nlwm2mH\n,\n \nnullptr\n);\n\n\n    \n// Add your lwm2m objects here\n\n    \n// .....\n\n\n    \n// Connect to the lwm2m server with unique id 123, lifetime of 100s, no storing of\n\n    \n// unsend messages. The host url is either coap:// or coaps://.\n\n    \nlwm2m_add_server\n(\n123\n,\n \ncoap://192.168.1.18\n,\n \n100\n,\n \nfalse\n)\n\n\n    \n// If you want to establish a DTLS secured connection, you need to alter the security\n\n    \n// information:\n\n    \n// lwm2m_server_security_preshared(123, \npublicid\n, \nPSK\n, sizeof(\nPSK\n));\n\n\n}\n\n\n\nvoid\n \ndisconnect\n()\n \n{\n\n    \n// Deregisters from the lwm2m server, frees ressources taken by wakaama.\n\n    \nlwm2m_client_close\n();\n\n    \n// Close the network connection and release network ressoures.\n\n    \nlwm2m_network_close\n(\nlwm2mH\n);\n\n\n}\n\n\n\nvoid\n \nloop\n()\n \n{\n\n    \n// Call the lwm2m state machine (lwm2m_step) periodically. \n\n    \n// tv will be used as output variable.\n\n    \n// Wakaama tells us about the next required call to lwm2m_step().    \n\n    \n// In this simple example we ignore this request and call\n\n    \n// the state machine in each main loop cycle.\n\n    \nstruct\n \ntimeval\n \ntv\n \n=\n \n{\n5\n,\n0\n};\n\n    \nuint8_t\n \nresult\n \n=\n \nlwm2m_step\n(\nlwm2mH\n,\n \ntv\n.\ntv_sec\n);\n\n\n    \n// let the network stack do its thing.\n\n    \nlwm2m_network_process\n(\nlwm2mH\n);\n\n\n}\n\n\n\n\n\nConfigure features with config_wakama.h\n\n\nCopy the\n\n examples/nodemcu_with_led_object/src/config_wakama.h\n\nfile to your project or create a \nconfig_wakama.h\n file in your project source directory with the following\ncontent:\n\n\n// Enables the wifi object where you may provide information about the wifi strength, connected ssid etc.\n\n\n#define LWM2M_DEV_INFO_WIFI_METRICS\n\n\n\n// Allows to perform a reboot of the device. Implement lwm2m_reboot() for this to work.\n\n\n#define LWM2M_DEVICE_WITH_REBOOT\n\n\n\n// Allows to perform a factory reset. Implement lwm2m_factory_reset() for this to work.\n\n\n// In this method you should erase all user memory, connection setups and so on.\n\n\n#define LWM2M_DEVICE_WITH_FACTORY_RESET\n\n\n\n// Implement lwm2m_get_bat_level() and lwm2m_get_bat_status().\n\n\n#define LWM2M_DEVICE_INFO_WITH_BATTERY\n\n\n\n// Implement lwm2m_get_free_mem() and lwm2m_get_total_mem().\n\n\n#define LWM2M_DEVICE_INFO_WITH_MEMINFO\n\n\n\n// Implement lwm2m_get_last_error() and lwm2m_reset_last_error().\n\n\n#define LWM2M_DEVICE_INFO_WITH_ERRCODE\n\n\n\n// Implement lwm2m_gettime() and update the fields  **timezone** and **time_offset**\n\n\n// of the device information object.\n\n\n#define LWM2M_DEVICE_INFO_WITH_TIME\n\n\n\n// Adds a **hardware_ver** and a **software_ver** c-string field.\n\n\n#define LWM2M_DEVICE_INFO_WITH_ADDITIONAL_VERSIONS\n\n\n\n// Enables the firmware update mechanism.\n\n\n#define LWM2M_FIRMWARE_UPGRADES\n\n\n\n// Enable DTLS support\n\n\n#define LWM2M_WITH_DTLS\n\n\n\n\n\nEdit the file to your needs, by commenting out unwanted features.\n\n\nDemo/Example\n\n\nAn example for the ESP8266 and for linux/windows is located in\n\n src/examples\n.\n\n\n\n\nExecute \npio run -e esp01\n or \npio run -e nodemcu\n to compile an example with a simple l2mwm object (res id 1024) with a boolean state ressource at ID 0. True/False switches the BUILTIN_LED on/off. Use \npio run -e esp01 -t upload\n to upload the example.\n\n\nExecute \npio run -e native\n to compile a linux/windows compatible example for switching on/off the current monitor screen. The firmware provides a lwm2m object (res id 1024) with a boolean state ressource at ID 0 for switching the screen on/off. At ID 1 there a read only string ressource which states the host name and at ID 2 there is a read only \"name\" string ressource.", 
            "title": "Getting started"
        }, 
        {
            "location": "/quickstart/getting-started/#installing-wakamanode-for-platformio-development", 
            "text": "There is a YouTube video with instructions:    How to install WakamaNode library in Visual Studio Code for PlatformIO  In a terminal, run  platformio lib install WakamaNode .  Add this in your  platformio.ini  for the development branch:  lib_deps = git+https://github.com/Openhab-Nodes/wakaamaNode.git#master  Add this in your  platformio.ini  for the release branch:  lib_deps = git+https://github.com/Openhab-Nodes/wakaamaNode.git#v1.0  Dependencies are installed automatically.  Some build flags can to be provided to enable certain platform codes:   Network stack: Compile with  POSIX_NETWORK  for posix network sockets or with  LWIP  for the lwIP stack support. Windows and Unix/Linux builds automatically pick the posix/bsd socket API if  LWIP  is not set.  Platform (memory, time): Compile with  ESP8266  for ESP8266 SDK support,  POSIX  for posix/windows system functions,  FREERTOS  for freeRTOS support. Windows and Unix/Linux builds automatically pick the posix/windows platform code.", 
            "title": "Installing WakamaNode for PlatformIO development"
        }, 
        {
            "location": "/quickstart/getting-started/#cmake", 
            "text": "If you target an x86 system, you may use the cmake buildsystem instead.\nJust include the  .cmake  file of the src directory like in the following example:  include ( ${ CMAKE_CURRENT_LIST_DIR } /lib/wakaamaNode/src/wakaama_simple_client.cmake )  add_executable ( ${ PROJECT_NAME }   ${ YOUR_FILES }   ${ WAKAAMA_SIMPLE_CLIENT_SOURCES } )  # We need C++11 and C11 support  target_compile_features ( ${ PROJECT_NAME }   PRIVATE   cxx_range_for )  set_property ( TARGET   ${ PROJECT_NAME }   PROPERTY   C_STANDARD   11 )  target_include_directories ( ${ PROJECT_NAME }   PRIVATE   {WAKAAMA_SIMPLE_CLIENT_INCLUDE_DIRS} )", 
            "title": "CMake"
        }, 
        {
            "location": "/quickstart/getting-started/#bare-minimum-sketch", 
            "text": "The following example shows how to connect to a lwm2m server, optionally with\na preshared key DTLS connection. It is still your responsibility to connect to the\nwifi/network and to bootstrap the device with the lwm2m server address if it is not a fixed address.  #include   Arduino.h  #include   wakaama_simple_client.h  #include   wakaama_network.h  #include   wakaama_object_utils.h  lwm2m_context_t   *   lwm2mH ;  void   setup ()   { \n     // connect to network/wifi \n     // ...... \n\n     // Tell something about this device. This will be published as lwM2M device object (#3). \n     device_instance_t   *   device_data   =   lwm2m_device_data_get (); \n     device_data - manufacturer   =   test manufacturer ; \n     device_data - model_name   =   test model ; \n     device_data - device_type   =   led ; \n     device_data - firmware_ver   =   1.0 ; \n     device_data - serial_number   =   140234-645235-12353 ; \n\n     // The client name will be used by the lwm2m server for identification. \n     lwm2mH   =   lwm2m_client_init ( testClient ); \n\n     // You don t need to use the network helper methods. If you do, call \n     // the lwm2m_network_init() method early in your code. \n     // Posix and LwIP network stacks are support \n     lwm2m_network_init ( lwm2mH ,   nullptr ); \n\n     // Add your lwm2m objects here \n     // ..... \n\n     // Connect to the lwm2m server with unique id 123, lifetime of 100s, no storing of \n     // unsend messages. The host url is either coap:// or coaps://. \n     lwm2m_add_server ( 123 ,   coap://192.168.1.18 ,   100 ,   false ) \n\n     // If you want to establish a DTLS secured connection, you need to alter the security \n     // information: \n     // lwm2m_server_security_preshared(123,  publicid ,  PSK , sizeof( PSK ));  }  void   disconnect ()   { \n     // Deregisters from the lwm2m server, frees ressources taken by wakaama. \n     lwm2m_client_close (); \n     // Close the network connection and release network ressoures. \n     lwm2m_network_close ( lwm2mH );  }  void   loop ()   { \n     // Call the lwm2m state machine (lwm2m_step) periodically.  \n     // tv will be used as output variable. \n     // Wakaama tells us about the next required call to lwm2m_step().     \n     // In this simple example we ignore this request and call \n     // the state machine in each main loop cycle. \n     struct   timeval   tv   =   { 5 , 0 }; \n     uint8_t   result   =   lwm2m_step ( lwm2mH ,   tv . tv_sec ); \n\n     // let the network stack do its thing. \n     lwm2m_network_process ( lwm2mH );  }", 
            "title": "Bare minimum sketch"
        }, 
        {
            "location": "/quickstart/getting-started/#configure-features-with-config_wakamah", 
            "text": "Copy the  examples/nodemcu_with_led_object/src/config_wakama.h \nfile to your project or create a  config_wakama.h  file in your project source directory with the following\ncontent:  // Enables the wifi object where you may provide information about the wifi strength, connected ssid etc.  #define LWM2M_DEV_INFO_WIFI_METRICS  // Allows to perform a reboot of the device. Implement lwm2m_reboot() for this to work.  #define LWM2M_DEVICE_WITH_REBOOT  // Allows to perform a factory reset. Implement lwm2m_factory_reset() for this to work.  // In this method you should erase all user memory, connection setups and so on.  #define LWM2M_DEVICE_WITH_FACTORY_RESET  // Implement lwm2m_get_bat_level() and lwm2m_get_bat_status().  #define LWM2M_DEVICE_INFO_WITH_BATTERY  // Implement lwm2m_get_free_mem() and lwm2m_get_total_mem().  #define LWM2M_DEVICE_INFO_WITH_MEMINFO  // Implement lwm2m_get_last_error() and lwm2m_reset_last_error().  #define LWM2M_DEVICE_INFO_WITH_ERRCODE  // Implement lwm2m_gettime() and update the fields  **timezone** and **time_offset**  // of the device information object.  #define LWM2M_DEVICE_INFO_WITH_TIME  // Adds a **hardware_ver** and a **software_ver** c-string field.  #define LWM2M_DEVICE_INFO_WITH_ADDITIONAL_VERSIONS  // Enables the firmware update mechanism.  #define LWM2M_FIRMWARE_UPGRADES  // Enable DTLS support  #define LWM2M_WITH_DTLS   Edit the file to your needs, by commenting out unwanted features.", 
            "title": "Configure features with config_wakama.h"
        }, 
        {
            "location": "/quickstart/getting-started/#demoexample", 
            "text": "An example for the ESP8266 and for linux/windows is located in  src/examples .   Execute  pio run -e esp01  or  pio run -e nodemcu  to compile an example with a simple l2mwm object (res id 1024) with a boolean state ressource at ID 0. True/False switches the BUILTIN_LED on/off. Use  pio run -e esp01 -t upload  to upload the example.  Execute  pio run -e native  to compile a linux/windows compatible example for switching on/off the current monitor screen. The firmware provides a lwm2m object (res id 1024) with a boolean state ressource at ID 0 for switching the screen on/off. At ID 1 there a read only string ressource which states the host name and at ID 2 there is a read only \"name\" string ressource.", 
            "title": "Demo/Example"
        }, 
        {
            "location": "/api/connection-api/", 
            "text": "Connection/Device API\n\n\nThe connection/device API is implemented in C.\nThis library is designed to be used as a single instance. You cannot request or manage multiple Wakaama contexts.\n\n\nConnection API\n\n\nInclude \nwakaama_simple_client.h\n.\n\n\n/**\n\n\n * @param endpointName The server uses this name to identify a client over multiple sessions\n\n\n * @return A wakaama context.\n\n\n */\n\n\nlwm2m_context_t\n \n*\n \nlwm2m_client_init\n(\nconst\n \nchar\n \n*\n \nendpointName\n);\n\n\n\n\n\nInitialize wakaame in client mode.\nWill allocate objects and initializes them.\nThis method can only be called once! Close the client context with lwm2m_client_close().\n\n\n/**\n\n\n * @brief Return the context created by lwm2m_client_init().\n\n\n * @return A wakaama context.\n\n\n */\n\n\nlwm2m_context_t\n \n*\n \nlwm2m_client_get_context\n(\nvoid\n);\n\n\n\n\n\nvoid\n \nlwm2m_client_close\n(\nvoid\n);\n\n\n\n\n\nClose the wakaama client context and release dynamically aquired ressources.\nThis will not release objects created by lwm2m_object_create.\n\n\n/**\n\n\n * Adds a new server to the lwm2m client. The client statemachine will try to connect to this\n\n\n * server in the next iteration (usually caused by calling lwm2m_network_process(context)).\n\n\n * @param shortServerID A unique server id\n\n\n * @param shortServerID The server URI\n\n\n * @param lifetime A lifetime in seconds\n\n\n * @param storing If notifications should be stored and resend if a server connection was interruppted and then reconnected.\n\n\n * @param publicId publicIdentity for DTLS. May be NULL if no secure connection is used.\n\n\n * @param psk Passkey if DTLS is used. May be NULL.\n\n\n * @param pskLen Passkey length. Should be 0 if no passkey is used.\n\n\n * @return Return true if successfully added and false if aborted due to no memory.\n\n\n */\n\n\nbool\n \nlwm2m_add_server\n(\nuint16_t\n \nshortServerID\n,\n \nconst\n \nchar\n*\n \nuri\n,\n \nuint32_t\n \nlifetime\n,\n \nbool\n \nstoring\n,\n\n    \nconst\n \nchar\n*\n \npublicId\n,\n \nconst\n \nchar\n*\n \npsk\n,\n \nsize_t\n \npskLen\n);\n\n\n\n\n\n/**\n\n\n * Unregisteres from a connected server.\n\n\n * @param security_instance_id The security instance id which refers to a specific server\n\n\n */\n\n\nbool\n \nlwm2m_unregister_server\n(\nuint16_t\n \nsecurity_instance_id\n);\n\n\n\n\n\n/**\n\n\n * Removes all unregistered server, by removing all related security objects.\n\n\n * Puts the client back to STATE_INITIAL if the server list has been altered.\n\n\n */\n\n\nvoid\n \nlwm2m_remove_unregistered_servers\n(\nvoid\n);\n\n\n\n\n\n/**\n\n\n * Returns the uri of a server by providing the security object id of that server connection.\n\n\n * @param security_instance_id The security instance id which refers to a specific server\n\n\n * @param uriBuffer The destination buffer\n\n\n * @param buffer_len The destination buffer length\n\n\n */\n\n\nbool\n \nlwm2m_get_server_uri\n(\nuint16_t\n \nsecurity_instance_id\n,\n \nchar\n*\n \nuriBuffer\n,\n \nsize_t\n \nbuffer_len\n);\n\n\n\n\n\n/**\n\n\n * @brief Return true if wakaama is connected to a lwm2m server.\n\n\n * @return\n\n\n */\n\n\nbool\n \nlwm2m_is_connected\n(\nvoid\n);\n\n\n\n\n\nExample\n\n\nTo setup the library, you would follow the the outlined schema of the following C code:\n\n\n// The client name will be used by the lwm2m server for identification.\n\n\nlwm2m_context_t\n \n*\n \nlwm2mH\n \n=\n \nlwm2m_client_init\n(\ntestClient\n);\n\n\n// Posix and Lwip network support is implemented.\n\n\nlwm2m_network_init\n(\nlwm2mH\n,\n \nNULL\n);\n\n\n\nwhile\n(\n1\n)\n \n{\n\n   \n// Call the lwm2m state machine (lwm2m_step) periodically. \n\n   \n// tv will be used as output variable. Wakaama tells us about the next required call to lwm2m_step().\n\n   \n// In this simple example we ignore this request and call the state machine in each main loop cycle.\n\n   \nstruct\n \ntimeval\n \ntv\n \n=\n \n{\n5\n,\n0\n};\n\n   \nuint8_t\n \nresult\n \n=\n \nlwm2m_step\n(\nlwm2mH\n,\n \ntv\n.\ntv_sec\n);\n\n   \n// let the network stack do its thing.\n\n   \nlwm2m_network_process\n(\nlwm2mH\n);\n\n\n}\n\n\n\n// Deregisters from the lwm2m server, frees ressources taken by wakaama.\n\n\nlwm2m_client_close\n();\n\n\n// Close the network connection and release network ressoures.\n\n\nlwm2m_network_close\n(\nlwm2mH\n);\n\n\n\n\n\nProvide device information API\n\n\nThe library implements the lwm2m device object for you.\n\n\n\n\nThe Device Object provides a range of device related information which can be queried by the LWM2M Server, and a device reboot and factory reset function.\n\n\n\n\nIn this section you learn how to enable some optional information fields\nof the device object and how to feed data into that object.\n\n\ndevice_instance_t\n \n*\n \nlwm2m_device_data_get\n(\nvoid\n);\n\n\n\n\n\nReturn the device information object.\nChange this object before you connect to a server.\n\n\n/**\n\n\n * @param res_id The ressource id of the value you have changed in device_instance_t.\n\n\n */\n\n\nvoid\n \nlwm2m_device_res_has_changed\n(\nuint16_t\n \nres_id\n);\n\n\n\n\n\nCall this if you have changed a ressource in the device_instance_t object.\nYou only have to do this after you have connected to a lwm2m server.\n\n\nTo change a device information (version number etc), do the following:\n\ndevice_instance_t\n*\n \ndevice\n \n=\n \nlwm2m_device_data_get\n();\n\n\ndevice\n-\nfirmware_ver\n \n=\n \n1.2\n;\n\n\nlwm2m_device_res_has_changed\n(\nRES_O_FIRMWARE_VERSION\n);\n\n\n\n\nSome device information are obtained by calling a function.\nThe battery level is an example.\nJust call \nlwm2m_device_res_has_changed(RES_O_BATTERY_LEVEL)\n periodically or after\nthe battery level has changed and the runtime will retrieve the new data by\nfrom \nlwm2m_get_bat_level()\n.\n\n\nExample\n\n\nYou need to provide some static c-strings stating the manufacturer, the model_name, device_type,\nfirmware version and a serial number, before you connect to a lwm2m server (but after you called \nlwm2m_client_init\n).\nYou would do this like in the following example:\n\n\n    \n// do initalisation first\n\n    \nlwm2m_context_t\n \n*\n \nlwm2mH\n \n=\n \nlwm2m_client_init\n(\ntestClient\n);\n\n\n    \n// Get the device object instance.\n\n    \ndevice_instance_t\n \n*\n \ndevice_data\n \n=\n \nlwm2m_device_data_get\n();\n\n    \ndevice_data\n-\nmanufacturer\n \n=\n \ntest manufacturer\n;\n\n    \ndevice_data\n-\nmodel_name\n \n=\n \ntest model\n;\n\n    \ndevice_data\n-\ndevice_type\n \n=\n \nsensor\n;\n\n    \ndevice_data\n-\nfirmware_ver\n \n=\n \n1.0\n;\n\n    \ndevice_data\n-\nserial_number\n \n=\n \n140234-645235-12353\n;\n\n    \n// if LWM2M_DEV_INFO_TIME is enabled\n\n    \ndevice_data\n-\ntime_offset\n \n=\n \n5\n;\n\n    \ndevice_data\n-\ntimezone\n \n=\n \n+05:00\n\n\n\n\n\nIf you change data after you have connected to a server, you need to call\n\nlwm2m_device_res_has_changed(res_id)\n after the change.\n\n\nFirmware update / OTA\n\n\nTo enable OTA, define LWM2M_FIRMWARE_UPGRADES in \nconfig_wakama.h\n.\n\n\nAn implementation exist for posix/win32 systems and for Arduino OTA compliant platforms.\n\n\nControl how firmware updates can be performed by defining \nLWM2M_FIRMWARE_UPGRADE_METHOD to \nHTTP\n, \nHTTPS\n or \nCOAP\n, \nCOAPS\n. If you do no define\nLWM2M_FIRMWARE_UPGRADE_METHOD, the best option is choosen.\nESP8266 prefers \nHTTP\n, posix/win32 systems prefer \nCOAP\n.\n\n\nThe Http(s) method signals the lwM2M server that only firmware polling is enabled\nand that a URL should be provided where the new firmware can be found.\n\n\nThe Coap(s) method makes the server send the new firmware via coap as an opaque data chunk.\nBecause that data chunk is expected to be huge and need to be memory buffered, ESP8266 does\nnot support this method.", 
            "title": "Connection API"
        }, 
        {
            "location": "/api/connection-api/#connectiondevice-api", 
            "text": "The connection/device API is implemented in C.\nThis library is designed to be used as a single instance. You cannot request or manage multiple Wakaama contexts.", 
            "title": "Connection/Device API"
        }, 
        {
            "location": "/api/connection-api/#connection-api", 
            "text": "Include  wakaama_simple_client.h .  /**   * @param endpointName The server uses this name to identify a client over multiple sessions   * @return A wakaama context.   */  lwm2m_context_t   *   lwm2m_client_init ( const   char   *   endpointName );   Initialize wakaame in client mode.\nWill allocate objects and initializes them.\nThis method can only be called once! Close the client context with lwm2m_client_close().  /**   * @brief Return the context created by lwm2m_client_init().   * @return A wakaama context.   */  lwm2m_context_t   *   lwm2m_client_get_context ( void );   void   lwm2m_client_close ( void );   Close the wakaama client context and release dynamically aquired ressources.\nThis will not release objects created by lwm2m_object_create.  /**   * Adds a new server to the lwm2m client. The client statemachine will try to connect to this   * server in the next iteration (usually caused by calling lwm2m_network_process(context)).   * @param shortServerID A unique server id   * @param shortServerID The server URI   * @param lifetime A lifetime in seconds   * @param storing If notifications should be stored and resend if a server connection was interruppted and then reconnected.   * @param publicId publicIdentity for DTLS. May be NULL if no secure connection is used.   * @param psk Passkey if DTLS is used. May be NULL.   * @param pskLen Passkey length. Should be 0 if no passkey is used.   * @return Return true if successfully added and false if aborted due to no memory.   */  bool   lwm2m_add_server ( uint16_t   shortServerID ,   const   char *   uri ,   uint32_t   lifetime ,   bool   storing , \n     const   char *   publicId ,   const   char *   psk ,   size_t   pskLen );   /**   * Unregisteres from a connected server.   * @param security_instance_id The security instance id which refers to a specific server   */  bool   lwm2m_unregister_server ( uint16_t   security_instance_id );   /**   * Removes all unregistered server, by removing all related security objects.   * Puts the client back to STATE_INITIAL if the server list has been altered.   */  void   lwm2m_remove_unregistered_servers ( void );   /**   * Returns the uri of a server by providing the security object id of that server connection.   * @param security_instance_id The security instance id which refers to a specific server   * @param uriBuffer The destination buffer   * @param buffer_len The destination buffer length   */  bool   lwm2m_get_server_uri ( uint16_t   security_instance_id ,   char *   uriBuffer ,   size_t   buffer_len );   /**   * @brief Return true if wakaama is connected to a lwm2m server.   * @return   */  bool   lwm2m_is_connected ( void );", 
            "title": "Connection API"
        }, 
        {
            "location": "/api/connection-api/#example", 
            "text": "To setup the library, you would follow the the outlined schema of the following C code:  // The client name will be used by the lwm2m server for identification.  lwm2m_context_t   *   lwm2mH   =   lwm2m_client_init ( testClient );  // Posix and Lwip network support is implemented.  lwm2m_network_init ( lwm2mH ,   NULL );  while ( 1 )   { \n    // Call the lwm2m state machine (lwm2m_step) periodically.  \n    // tv will be used as output variable. Wakaama tells us about the next required call to lwm2m_step(). \n    // In this simple example we ignore this request and call the state machine in each main loop cycle. \n    struct   timeval   tv   =   { 5 , 0 }; \n    uint8_t   result   =   lwm2m_step ( lwm2mH ,   tv . tv_sec ); \n    // let the network stack do its thing. \n    lwm2m_network_process ( lwm2mH );  }  // Deregisters from the lwm2m server, frees ressources taken by wakaama.  lwm2m_client_close ();  // Close the network connection and release network ressoures.  lwm2m_network_close ( lwm2mH );", 
            "title": "Example"
        }, 
        {
            "location": "/api/connection-api/#provide-device-information-api", 
            "text": "The library implements the lwm2m device object for you.   The Device Object provides a range of device related information which can be queried by the LWM2M Server, and a device reboot and factory reset function.   In this section you learn how to enable some optional information fields\nof the device object and how to feed data into that object.  device_instance_t   *   lwm2m_device_data_get ( void );   Return the device information object.\nChange this object before you connect to a server.  /**   * @param res_id The ressource id of the value you have changed in device_instance_t.   */  void   lwm2m_device_res_has_changed ( uint16_t   res_id );   Call this if you have changed a ressource in the device_instance_t object.\nYou only have to do this after you have connected to a lwm2m server.  To change a device information (version number etc), do the following: device_instance_t *   device   =   lwm2m_device_data_get ();  device - firmware_ver   =   1.2 ;  lwm2m_device_res_has_changed ( RES_O_FIRMWARE_VERSION );   Some device information are obtained by calling a function.\nThe battery level is an example.\nJust call  lwm2m_device_res_has_changed(RES_O_BATTERY_LEVEL)  periodically or after\nthe battery level has changed and the runtime will retrieve the new data by\nfrom  lwm2m_get_bat_level() .", 
            "title": "Provide device information API"
        }, 
        {
            "location": "/api/connection-api/#example_1", 
            "text": "You need to provide some static c-strings stating the manufacturer, the model_name, device_type,\nfirmware version and a serial number, before you connect to a lwm2m server (but after you called  lwm2m_client_init ).\nYou would do this like in the following example:       // do initalisation first \n     lwm2m_context_t   *   lwm2mH   =   lwm2m_client_init ( testClient ); \n\n     // Get the device object instance. \n     device_instance_t   *   device_data   =   lwm2m_device_data_get (); \n     device_data - manufacturer   =   test manufacturer ; \n     device_data - model_name   =   test model ; \n     device_data - device_type   =   sensor ; \n     device_data - firmware_ver   =   1.0 ; \n     device_data - serial_number   =   140234-645235-12353 ; \n     // if LWM2M_DEV_INFO_TIME is enabled \n     device_data - time_offset   =   5 ; \n     device_data - timezone   =   +05:00   If you change data after you have connected to a server, you need to call lwm2m_device_res_has_changed(res_id)  after the change.", 
            "title": "Example"
        }, 
        {
            "location": "/api/connection-api/#firmware-update-ota", 
            "text": "To enable OTA, define LWM2M_FIRMWARE_UPGRADES in  config_wakama.h .  An implementation exist for posix/win32 systems and for Arduino OTA compliant platforms.  Control how firmware updates can be performed by defining \nLWM2M_FIRMWARE_UPGRADE_METHOD to  HTTP ,  HTTPS  or  COAP ,  COAPS . If you do no define\nLWM2M_FIRMWARE_UPGRADE_METHOD, the best option is choosen.\nESP8266 prefers  HTTP , posix/win32 systems prefer  COAP .  The Http(s) method signals the lwM2M server that only firmware polling is enabled\nand that a URL should be provided where the new firmware can be found.  The Coap(s) method makes the server send the new firmware via coap as an opaque data chunk.\nBecause that data chunk is expected to be huge and need to be memory buffered, ESP8266 does\nnot support this method.", 
            "title": "Firmware update / OTA"
        }, 
        {
            "location": "/api/about/", 
            "text": "About OMA Lightweight M2M\n\n\nStandards for constrained devices are rapidly consolidating and the availability of IP on constrained devices enabled these devices to easily connect to the Internet. The IETF has also created a set of specifications for such IP-enabled devices to work in a Web-like fashion. One such protocol is the \nConstrained Application Protocol (CoAP)\n that provides request/response methods, ways to identify resources, discovery mechanisms, etc. similar to the \nHypertext Transfer Protocol\n but for use in constrained environments.\n\n\nHowever, the use of standardized protocols does not ensure interoperability on the application layer. Therefore, there is a clear need for being able to communicate using structured data models on top of protocols like CoAP and HTTP.\n\n\nOMA (Open Mobile Alliance) has defined a standard for IoT or M2M devices, building on CoAP (and DTLS). It defines bootstrap and device management, as well as a data model.\n\n\nData model\n\n\nEach LwM2M client presents a data model - standardized, symbolic representation of its configuration and state that is accessible for reading and modifying by LwM2M Servers. It can be thought of as a combination of a hierarchical configuration file, and a view on statistical information about the device and its environment.\n\n\nThe LwM2M data model is very strictly organized as a three-level tree. Entities on each of those levels are identified with numerical identifiers. Those three levels are:\n\n\n\n\n\n\nObject\n - each Object represent some different concept of data accessible via the LwM2M client. For example, separate Objects are defined for managing connections with LwM2M servers, for managing network connections, for accessing data from various types of sensors, etc.\n\nEach Object is assigned a unique numerical identifier in the range 0-65535, inclusive. OMA manages a registry of known Object IDs. Each Object defines a set of Resources whose meanings are common for each Object Instance.\n\n\n\n\n\n\nObject Instance\n - some Objects are described as \u201csingle-instance\u201d - such Objects always have exactly one Instance with identifier 0. Examples of such Objects include the Device object which describes the device itself, and the Firmware Update object which is used to perform firmware upgrades.\n\nOther Objects may have multiple Instances; sometimes the number of Instances may be variable and the Instances themselves may be creatable via LwM2M. Examples of such Objects include the Object that manages connections to LwM2M Servers, Object that represents optional software packages installed on the device, and Objects representing sensors (whose instances are, however, not creatable). Identifiers for each Instance of such Objects may be arbitrarily chosen in the range 0-65534, inclusive - note that 65535 is reserved and forbidden in this context.\n\n\n\n\n\n\nResource\n - each Object Instance of a given Object supports the same set of Resources, as defined by the Object definition. Within a given Object, each Resource ID (which may be in the range 0-65535, inclusive) has a well-defined meaning, and represent the same concept. However, some Resources may not be present in some Object Instances, and, obviously, their values and mapping onto real-world entities may be different.\n\n\n\n\n\n\nThe numerical identifiers on each of these levels form a path, which is used as the path portion of CoAP URLs. For example, a path \n/1/2/3\n refers to Resource ID=3 in Object Instance ID=2 of Object ID=1. Whole Object Instances (/\n) or event Objects (/1) may be referred to using this syntax as well.\n\n\nFind an example for an object definition in LWM2M xml schema at \nurn:oma:lwm2m:ext:3303\n.\n\n\nObjects\n\n\nEach Object definition, which may be found in the LwM2M specification, features the following information:\n\n\n\n\nName\n - description of the object; it is not used in the actual on-wire protocol.\n\n\nObject ID\n - numerical identifier of the Object\n\n\nInstances\n - Single (always has one Instance with ID=0) or Multiple (may have arbitrary number of Instances depending on current configuration)\n\n\nMandatory\n - Mandatory (must be supported by all LwM2M Client implementations) or Optional (may not be supported)\n\n\nObject URN\n -  For example \nurn:oma:lwm2m:ext:3347\n\n\nResource definitions\n: A list of resource definitions. See section further down.\n\n\n\n\nImplemented objects\n\n\nThe current set of mandatory and therefore implemented Objects consists of:\n\n\n\n\n/0 - LwM2M Security\n - contains confidential part of information about connections to the LwM2M Servers configured in the Client. From the on-wire protocol perspective, it is write-only and accessible only via the Bootstrap Interface.\n\n\n/1 - LwM2M Server\n - contains non-confidential part of information about connections to the LwM2M Servers configured in the Client.\n\n\n/2 - Access Control\n needs to be supported and present if the Client supports more than one LwM2M Server connection at once.\n\n\n/3 - Device\n - contains basic information about the device, such as e.g. serial number.\n\n\n/5 - Firmware\n - enables OTA/Over-the-Air update support\n\n\n\n\nResources\n\n\nEach of the Resource definitions, contained in each Object definition, features the following information:\n\n\n\n\nID\n - numerical identifier of the Object.\n\n\nName\n - short description of the resource; it is not used in the actual on-wire protocol.\n\n\nOperations\n - one of:\n\n\nR\n - read-only Resource\n\n\nW\n - write-only Resource\n\n\nRW\n - writeable Resource\n\n\nE\n - executable Resource\n\n\n\n\n\n\nInstances\n - Single or Multiple; \u201cMultiple\u201d allows to have more than one instance of an object\n\n\nMandatory\n - Mandatory or Optional; Mandatory resources need to be present in all Instances on all devices. Optional resources may not be present in all Instances, and may even be not supported at all on some Clients.\n\n\nType\n - data type of the Resource value (or its instances in case of Multiple Resources).\n\n\nRange or Enumeration\n - specification of valid values for the Resource, within the given data type.\n\n\nUnits\n - units in which a numerical value is given.\n\n\nDescription\n - detailed description of the resource.\n\n\n\n\nReferences to specifications and further sources\n\n\n\n\n\"Anjay LwM2M library documentation\" \nhttps://avsystem.github.io/Anjay-doc\n\n\n\"IP for Smart Objects - IPSO Objects\" \nhttps://github.com/IPSO-Alliance/pub/edit/master/README.md\n\n\n\"The Constrained Application Protocol (CoAP)\". April 2017. \nhttps://tools.ietf.org/html/rfc7252\n\n\n\"Lightweight Machine to Machine Technical Specification, Approved Version 1.0\". Feb 2017. \nOMA-TS-LightweightM2M-V1_0-20170208-A.pdf\n\n\n\"Observing Resources in the Constrained Application Protocol (CoAP)\". April 2017. \nhttps://tools.ietf.org/html/rfc7641\n\n\n\"Constrained RESTful Environments (CoRE) Link Format\". April 2017. \nhttps://tools.ietf.org/html/rfc6690", 
            "title": "Introduction"
        }, 
        {
            "location": "/api/about/#about-oma-lightweight-m2m", 
            "text": "Standards for constrained devices are rapidly consolidating and the availability of IP on constrained devices enabled these devices to easily connect to the Internet. The IETF has also created a set of specifications for such IP-enabled devices to work in a Web-like fashion. One such protocol is the  Constrained Application Protocol (CoAP)  that provides request/response methods, ways to identify resources, discovery mechanisms, etc. similar to the  Hypertext Transfer Protocol  but for use in constrained environments.  However, the use of standardized protocols does not ensure interoperability on the application layer. Therefore, there is a clear need for being able to communicate using structured data models on top of protocols like CoAP and HTTP.  OMA (Open Mobile Alliance) has defined a standard for IoT or M2M devices, building on CoAP (and DTLS). It defines bootstrap and device management, as well as a data model.", 
            "title": "About OMA Lightweight M2M"
        }, 
        {
            "location": "/api/about/#data-model", 
            "text": "Each LwM2M client presents a data model - standardized, symbolic representation of its configuration and state that is accessible for reading and modifying by LwM2M Servers. It can be thought of as a combination of a hierarchical configuration file, and a view on statistical information about the device and its environment.  The LwM2M data model is very strictly organized as a three-level tree. Entities on each of those levels are identified with numerical identifiers. Those three levels are:    Object  - each Object represent some different concept of data accessible via the LwM2M client. For example, separate Objects are defined for managing connections with LwM2M servers, for managing network connections, for accessing data from various types of sensors, etc.\n\nEach Object is assigned a unique numerical identifier in the range 0-65535, inclusive. OMA manages a registry of known Object IDs. Each Object defines a set of Resources whose meanings are common for each Object Instance.   Object Instance  - some Objects are described as \u201csingle-instance\u201d - such Objects always have exactly one Instance with identifier 0. Examples of such Objects include the Device object which describes the device itself, and the Firmware Update object which is used to perform firmware upgrades.\n\nOther Objects may have multiple Instances; sometimes the number of Instances may be variable and the Instances themselves may be creatable via LwM2M. Examples of such Objects include the Object that manages connections to LwM2M Servers, Object that represents optional software packages installed on the device, and Objects representing sensors (whose instances are, however, not creatable). Identifiers for each Instance of such Objects may be arbitrarily chosen in the range 0-65534, inclusive - note that 65535 is reserved and forbidden in this context.   Resource  - each Object Instance of a given Object supports the same set of Resources, as defined by the Object definition. Within a given Object, each Resource ID (which may be in the range 0-65535, inclusive) has a well-defined meaning, and represent the same concept. However, some Resources may not be present in some Object Instances, and, obviously, their values and mapping onto real-world entities may be different.   The numerical identifiers on each of these levels form a path, which is used as the path portion of CoAP URLs. For example, a path  /1/2/3  refers to Resource ID=3 in Object Instance ID=2 of Object ID=1. Whole Object Instances (/ ) or event Objects (/1) may be referred to using this syntax as well.  Find an example for an object definition in LWM2M xml schema at  urn:oma:lwm2m:ext:3303 .", 
            "title": "Data model"
        }, 
        {
            "location": "/api/about/#objects", 
            "text": "Each Object definition, which may be found in the LwM2M specification, features the following information:   Name  - description of the object; it is not used in the actual on-wire protocol.  Object ID  - numerical identifier of the Object  Instances  - Single (always has one Instance with ID=0) or Multiple (may have arbitrary number of Instances depending on current configuration)  Mandatory  - Mandatory (must be supported by all LwM2M Client implementations) or Optional (may not be supported)  Object URN  -  For example  urn:oma:lwm2m:ext:3347  Resource definitions : A list of resource definitions. See section further down.", 
            "title": "Objects"
        }, 
        {
            "location": "/api/about/#implemented-objects", 
            "text": "The current set of mandatory and therefore implemented Objects consists of:   /0 - LwM2M Security  - contains confidential part of information about connections to the LwM2M Servers configured in the Client. From the on-wire protocol perspective, it is write-only and accessible only via the Bootstrap Interface.  /1 - LwM2M Server  - contains non-confidential part of information about connections to the LwM2M Servers configured in the Client.  /2 - Access Control  needs to be supported and present if the Client supports more than one LwM2M Server connection at once.  /3 - Device  - contains basic information about the device, such as e.g. serial number.  /5 - Firmware  - enables OTA/Over-the-Air update support", 
            "title": "Implemented objects"
        }, 
        {
            "location": "/api/about/#resources", 
            "text": "Each of the Resource definitions, contained in each Object definition, features the following information:   ID  - numerical identifier of the Object.  Name  - short description of the resource; it is not used in the actual on-wire protocol.  Operations  - one of:  R  - read-only Resource  W  - write-only Resource  RW  - writeable Resource  E  - executable Resource    Instances  - Single or Multiple; \u201cMultiple\u201d allows to have more than one instance of an object  Mandatory  - Mandatory or Optional; Mandatory resources need to be present in all Instances on all devices. Optional resources may not be present in all Instances, and may even be not supported at all on some Clients.  Type  - data type of the Resource value (or its instances in case of Multiple Resources).  Range or Enumeration  - specification of valid values for the Resource, within the given data type.  Units  - units in which a numerical value is given.  Description  - detailed description of the resource.", 
            "title": "Resources"
        }, 
        {
            "location": "/api/about/#references-to-specifications-and-further-sources", 
            "text": "\"Anjay LwM2M library documentation\"  https://avsystem.github.io/Anjay-doc  \"IP for Smart Objects - IPSO Objects\"  https://github.com/IPSO-Alliance/pub/edit/master/README.md  \"The Constrained Application Protocol (CoAP)\". April 2017.  https://tools.ietf.org/html/rfc7252  \"Lightweight Machine to Machine Technical Specification, Approved Version 1.0\". Feb 2017.  OMA-TS-LightweightM2M-V1_0-20170208-A.pdf  \"Observing Resources in the Constrained Application Protocol (CoAP)\". April 2017.  https://tools.ietf.org/html/rfc7641  \"Constrained RESTful Environments (CoRE) Link Format\". April 2017.  https://tools.ietf.org/html/rfc6690", 
            "title": "References to specifications and further sources"
        }, 
        {
            "location": "/api/objects-registry/", 
            "text": "OMA defined LwM2M objects and resources\n\n\nThe \nOMA LwM2M Registry\n contains a wide range of defined objects and resources,\nin a machine readable way (XML).\nNew objects and resources can be proposed via the \nLwM2M Editor\n.\n\n\nWakaamaNode provides ready-to-consume C++ objects for all lwM2M objects of the registry. Just be aware that\nspecial implementations exist for object ID 1 (LWM2M Server), 2 (Access Control), 3 (device) and 5 (firmware)\nand you should not use the auto generated ones.\n\n\nFor example if you want to use the \"Light Control\" lwM2M object:\n\n\n\n\nSearch the list below for \"Light Control\".\n\n\nFind it under object id 3311.\n\n\nInclude \nsrc/lwm2mObjects/3311.h\n and use the class \nobject\n in namespace \nKnownObjects/id311\n.\n\n\nCreate as many object instances as you need and add them to the object via \nobject.addInstance(objectInstance)\n.\n\n\nMake the object itself known to WakaamaNode with \nobject.register(lwm2mContext)\n.\n\n\n\n\nExample\n\n\n#include\n \nlwm2mObjects/3311.h\n\n\n#include\n \nArduino.h\n\n\n\nusing\n \nnamespace\n \nKnownObjects\n;\n\n\n\nid3311\n::\nobject\n \nlights\n(\nfalse\n);\n\n\n\nid3311\n::\ninstance\n \nled\n;\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n    \n// Overwrite the verifyFunction and \nabuse\n it as value changed event.\n\n    \nled\n.\npower\n.\nverifyFunction\n \n=\n \n[](\nbool\n \nvalue\n)\n \n{\n\n        \n// Change the led pin depending on the power value\n\n        \ndigitalWrite\n(\nledPin\n,\n \nvalue\n);\n\n        \n// Return true to accept the value and ACK to the server\n\n        \nreturn\n \ntrue\n;\n\n    \n};\n\n\n    \nlights\n.\naddInstance\n(\nled\n);\n\n    \nlights\n.\nregister\n(\nlwm2mContext\n);\n\n\n}\n\n\n\n\n\nList of supported objects\n\n\n\n#lwm2mObjects tr:nth-child(even){background-color: #f2f2f2;}\n\n#lwm2mObjects tr:hover {background-color: #ddd;}\n\n#lwm2mObjects th {\n    padding-top: 12px;\n    padding-bottom: 12px;\n    text-align: left;\n    background-color: #ef5350;\n    color: white;\n}\n  \n\n\n\n\n   \n\n      \n\n         \nObject ID\n\n         \nName\n\n         \nDescription\n\n      \n\n   \n\n   \n\n      \n\n         \n\n            \n1\n\n         \n\n         \nLWM2M Server\n\n         \nIt provides the data related to a LWM2M Server. A Bootstrap Server has no such an Object Instance associated to it.\n\n      \n\n      \n\n         \n\n            \n2\n\n         \n\n         \nAccess Control\n\n         \nIt is used to check whether the LWM2M Server has access right for performing a operation.\n\n      \n\n      \n\n         \n\n            \n3\n\n         \n\n         \nDevice\n\n         \nIt provides a range of device related information which can be queried by the LWM2M Server, and a device reboot and factory reset function.\n\n      \n\n      \n\n         \n\n            \n4\n\n         \n\n         \nConnectivity Monitoring\n\n         \nIt enables monitoring of parameters related to network connectivity. In this general connectivity Object, the Resources are limited to the most general cases common to most network bearers. It is recommended to read the description, which refers to relevant standard development organizations (e.g. 3GPP, IEEE). The goal of the Connectivity Monitoring Object is to carry information reflecting the more up to date values of the current connection for monitoring purposes. Resources such as Link Quality, Radio Signal Strenght, Cell ID are retrieved during connected mode at least for cellular networks.\n\n      \n\n      \n\n         \n\n            \n5\n\n         \n\n         \nFirmware\n\n         \nIt enables management of firmware which is to be updated. This Object includes installing firmware package, updating firmware, and performing actions after updating firmware\n\n      \n\n      \n\n         \n\n            \n6\n\n         \n\n         \nLocation\n\n         \nIt provides a range of device related information which can be queried by the LWM2M Server, and a device reboot and factory reset function.\n\n      \n\n      \n\n         \n\n            \n7\n\n         \n\n         \nConnectivity Statistics\n\n         \nThis LWM2M Objects enables client to collect statistical information and enables the LWM2M Server to retrieve these information, set the collection duration and reset the statistical parameters.\n\n      \n\n      \n\n         \n\n            \n8\n\n         \n\n         \nLock and Wipe\n\n         \nThis LWM2M objects provides the resources needed to perform the lock and wipe operations\n\n      \n\n      \n\n         \n\n            \n9\n\n         \n\n         \nSofware Management\n\n         \nThis LWM2M objects provides the resources needed to perform software management on the device. Each software component is managed via a dedicated Software Management Object instance\n\n      \n\n      \n\n         \n\n            \n10\n\n         \n\n         \nCellular connectivity\n\n         \nIt specifies resources to enable a device to connect to a 3GPP or 3GPP2 bearer, including GPRS/EDGE, UMTS, LTE, SMS. For cellular connectivity, this object focuses on Packet Switched (PS) connectivity and doesn't aim to provide comprehensive Circuit Switched (CS) connectivity management.\n\n      \n\n      \n\n         \n\n            \n11\n\n         \n\n         \nAPN connection profile\n\n         \nIt specifies resources to enable a device to connect to an APN.\n\n      \n\n      \n\n         \n\n            \n12\n\n         \n\n         \nWLAN connectivity\n\n         \nIt specifies resources to enable a device to connect to a WLAN bearer.\n\n      \n\n      \n\n         \n\n            \n13\n\n         \n\n         \nBearer selection\n\n         \nIt specifies resources to enable a device to choose a communications bearer on which to connect.\n\n      \n\n      \n\n         \n\n            \n14\n\n         \n\n         \nSoftware Component\n\n         \nThe LWM2M software management object enables remote software management in M2M devices\n\n      \n\n      \n\n         \n\n            \n15\n\n         \n\n         \nDevCapMgmt\n\n         \nIt manages the device capabilities of a device e.g. sensors, communication, etc.\n\n      \n\n      \n\n         \n\n            \n16\n\n         \n\n         \nPorfolio\n\n         \nThe Portfolio Object allows to extend the data storage capability of other Object Instances in the LwM2M system, as well as the services which may be used to authenticate and to protect privacy of data contained in those extensions. In addition, a service of data encryption is also defined\n\n      \n\n      \n\n         \n\n            \n17\n\n         \n\n         \nCommunications Characteristics\n\n         \nThis object enables configuration of various generic communications parameters.\n\n      \n\n      \n\n         \n\n            \n18\n\n         \n\n         \nNon-Access Stratum (NAS) Configuration\n\n         \nThis object provides Non-Access Stratum (NAS) configuration and is derived from 3GPP TS 24.368.\n\n      \n\n      \n\n         \n\n            \n19\n\n         \n\n         \nLwM2M APPDATA\n\n         \nThis LwM2M object provides the application service data related to a LwM2M Server, eg. Water meter data.\n\n      \n\n      \n\n         \n\n            \n20\n\n         \n\n         \nEventLog\n\n         \nThe Event Log Object is a single Instance Object defined for logging data in a straightforward         and generic way. The Resources of that Object are based on the OMA LwM2M set of reusable Resources dedicated to logging event activity.\n\n      \n\n      \n\n         \n\n            \n21\n\n         \n\n         \nPending\n\n         \nPending\n\n      \n\n      \n\n         \n\n            \n2048\n\n         \n\n         \nCmdhPolicy\n\n         \nThis Object provides links to a set of rules associated with a specific CSE that governs the behavior             of that CSE regarding rejecting, buffering and sending request or response messages via the Mcc reference point.\n\n      \n\n      \n\n         \n\n            \n2049\n\n         \n\n         \nActiveCmdhPolicy\n\n         \nThis Object provides a link to the currently active set of CMDH policies\n\n      \n\n      \n\n         \n\n            \n2050\n\n         \n\n         \nCmdhDefaults\n\n         \nDefines which CMDH related parameters will be used by default.\n\n      \n\n      \n\n         \n\n            \n2051\n\n         \n\n         \nCmdhDefEcValues\n\n         \nThis Object represents default set of values for the Event Category parameter of an incoming request or response message.\n\n      \n\n      \n\n         \n\n            \n2052\n\n         \n\n         \nCmdhEcDefParamValues\n\n         \nThis Object represents a specific set of default values for the CMDH related parameters Request Expiration Timestamp, Result Expiration Timestamp, Operational Execution Time, Result Persistence and Delivery Aggregation that are applicable for a given Event Category if these parameters are not specified in the message.\n\n      \n\n      \n\n         \n\n            \n2053\n\n         \n\n         \nCmdhLimits\n\n         \nThis Object represents limits for CMDH related parameter values.\n\n      \n\n      \n\n         \n\n            \n2054\n\n         \n\n         \nCmdhNetworkAccessRules\n\n         \nThis Object defines the usage of underlying networks for forwarding information to other CSEs during processing of CMDH-related requests in a CSE.\n\n      \n\n      \n\n         \n\n            \n2055\n\n         \n\n         \nCmdhNwAccessRule\n\n         \nThis Object defines limits in usage of specific underlying networks for forwarding information to other CSEs during processing of CMDH-related requests in a CSE.\n\n      \n\n      \n\n         \n\n            \n2056\n\n         \n\n         \nCmdhBuffer\n\n         \nThis Object defines limits in usage of buffers for temporarily storing information that needs to be forwarded to other CSEs during processing of CMDH-related requests in a CSE.\n\n      \n\n      \n\n         \n\n            \n2057\n\n         \n\n         \nCmdhBackOffParametersSet\n\n         \nThis Object defines set of parameters which can be referenced by a specific Instance of the CmdhNwAccessRule Object (ID: 2055)\n\n      \n\n      \n\n         \n\n            \n3200\n\n         \n\n         \nDigital Input\n\n         \nThis IPSO object is a generic object that can be used with any kind of digital input interface. Specific objects for a given range of sensors are described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist.\n\n      \n\n      \n\n         \n\n            \n3201\n\n         \n\n         \nDigital Output\n\n         \nThis IPSO object is a generic object that can be used with any kind of digital output interface. Specific object for a given range of sensors is described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist.\n\n      \n\n      \n\n         \n\n            \n3202\n\n         \n\n         \nAnalogue Input\n\n         \nThis IPSO object is a generic object that can be used with any kind of analogue input interface. Specific object for a given range of sensors is described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist.\n\n      \n\n      \n\n         \n\n            \n3203\n\n         \n\n         \nAnalogue Output\n\n         \nThis IPSO object is a generic object that can be used with any kind of analogue input interface. Specific object for a given range of sensors is described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist.\n\n      \n\n      \n\n         \n\n            \n3300\n\n         \n\n         \nGeneric Sensor\n\n         \nThis IPSO object allow the description of a generic sensor. It is based on the description of a value and a unit according to the UCUM specification. Thus, any type of value defined within this specification can be reporting using this object. Specific object for a given range of sensors is described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist.\n\n      \n\n      \n\n         \n\n            \n3301\n\n         \n\n         \nIlluminance Sensor\n\n         \nThis IPSO object should be used over a luminosity sensor to report a remote luminosity measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range that can be measured by the luminosity sensor. The unit used here is Lux (ucum:lx).\n\n      \n\n      \n\n         \n\n            \n3302\n\n         \n\n         \nPresence Sensor\n\n         \nThis IPSO object should be used over a presence sensor to report a remote presence detection. It also provides resources to manage a counter, the type of sensor used (e.g the technology of the probe), and configuration for the delay between busy and clear detection state.\n\n      \n\n      \n\n         \n\n            \n3303\n\n         \n\n         \nTemperature Sensor\n\n         \nThis IPSO object should be used over a temperature sensor to report a remote temperature measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range that can be measured by the temperature sensor. The unit used here is degree Celsius (ucum:Cel).\n\n      \n\n      \n\n         \n\n            \n3304\n\n         \n\n         \nHumidity Sensor\n\n         \nThis IPSO object should be used over a humidity sensor to report a remote humidity measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range that can be measured by the humidity sensor. The unit used here is relative humidity as a percentage (ucum:%).\n\n      \n\n      \n\n         \n\n            \n3305\n\n         \n\n         \nPower Measurement\n\n         \nThis IPSO object should be used over a power measurement sensor to report a remote power measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range for both active and reactive power. Il also provides resources for cumulative energy, calibration, and the power factor.\n\n      \n\n      \n\n         \n\n            \n3306\n\n         \n\n         \nActuation\n\n         \nThis IPSO object is dedicated to remote actuation such as ON/OFF action or dimming. A multistate output can also be described as a string. This is useful to send pilot wire orders for instance. It also provides a resource to reflect the time that the device has been switched on.\n\n      \n\n      \n\n         \n\n            \n3308\n\n         \n\n         \nSet Point\n\n         \nThis IPSO object should be used to set a desired value to a controller, such as a thermostat. This object enables a setpoint to be expressed units defined in the UCUM specification, to match an associated sensor or measurement value. A special resource is added to set the colour of an object.\n\n      \n\n      \n\n         \n\n            \n3310\n\n         \n\n         \nLoad Control\n\n         \nThis Object is used for demand-response load control and other load control in automation application (not limited to power).\n\n      \n\n      \n\n         \n\n            \n3311\n\n         \n\n         \nLight Control\n\n         \nThis Object is used to control a light source, such as a LED or other light. It allows a light to be turned on or off and its dimmer setting to be control as a % between 0 and 100.\n\n      \n\n      \n\n         \n\n            \n3312\n\n         \n\n         \nPower Control\n\n         \nThis Object is used to control a power source, such as a Smart Plug. It allows a power relay to be turned on or off and its dimmer setting to be control as a % between 0 and 100.\n\n      \n\n      \n\n         \n\n            \n3313\n\n         \n\n         \nAccelerometer\n\n         \nThis IPSO object can be used to represent a 1-3 axis accelerometer.\n\n      \n\n      \n\n         \n\n            \n3314\n\n         \n\n         \nMagnetometer\n\n         \nThis IPSO object can be used to represent a 1-3 axis magnetometer with optional compass direction.\n\n      \n\n      \n\n         \n\n            \n3315\n\n         \n\n         \nBarometer\n\n         \nThis IPSO object should be used with an air pressure sensor to report a remote barometer measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range that can be measured by the barometer sensor.\n\n      \n\n      \n\n         \n\n            \n3316\n\n         \n\n         \nVoltage\n\n         \nThis IPSO object should be used with voltmeter sensor to report measured voltage between two points. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. An example measurement unit is volts (ucum: V).\n\n      \n\n      \n\n         \n\n            \n3317\n\n         \n\n         \nCurrent\n\n         \nThis IPSO object should be used with an ammeter to report measured electric current in amperes. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. An example measurement unit is volts (ucum: A).\n\n      \n\n      \n\n         \n\n            \n3318\n\n         \n\n         \nFrequency\n\n         \nThis IPSO object should be used to report frequency measurements. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. An example measurement unit is volts (ucum: Hz).\n\n      \n\n      \n\n         \n\n            \n3319\n\n         \n\n         \nDepth\n\n         \nThis IPSO object should be used to report depth measurements. It can, for example, be used to describe a generic rain gauge that measures the accumulated rainfall in millimetres (mm) or in fathoms (fth).\n\n      \n\n      \n\n         \n\n            \n3320\n\n         \n\n         \nPercentage\n\n         \nThis IPSO object should can be used to report measurements relative to a 0-100% scale. For example it could be used to measure the level of a liquid in a vessel or container in units of %.\n\n      \n\n      \n\n         \n\n            \n3321\n\n         \n\n         \nAltitude\n\n         \nThis IPSO object should be used with an altitude sensor to report altitude above sea level in meters. Note that Altitude can be calculated from the measured pressure given the local sea level pressure. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. An example measurement unit is meters (ucum: m).\n\n      \n\n      \n\n         \n\n            \n3322\n\n         \n\n         \nLoad\n\n         \nThis IPSO object should be used with a load sensor (as in a scale) to report the applied weight or force. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor.\n\n      \n\n      \n\n         \n\n            \n3323\n\n         \n\n         \nPressure\n\n         \nThis IPSO object should be used to report pressure measurements. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor.\n\n      \n\n      \n\n         \n\n            \n3324\n\n         \n\n         \nLoudness\n\n         \nThis IPSO object should be used to report loudness or noise level measurements. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor.\n\n      \n\n      \n\n         \n\n            \n3325\n\n         \n\n         \nConcentration\n\n         \nThis IPSO object should be used to the particle concentration measurement of a medium. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor.\n\n      \n\n      \n\n         \n\n            \n3326\n\n         \n\n         \nAcidity\n\n         \nThis IPSO object should be used to report an acidity measurement of a liquid. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor.\n\n      \n\n      \n\n         \n\n            \n3327\n\n         \n\n         \nConductivity\n\n         \nThis IPSO object should be used to report a measurement of the electric conductivity of a medium or sample. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor.\n\n      \n\n      \n\n         \n\n            \n3328\n\n         \n\n         \nPower\n\n         \nThis IPSO object should be used to report power measurements. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor.\n\n      \n\n      \n\n         \n\n            \n3329\n\n         \n\n         \nPower Factor\n\n         \nThis IPSO object should be used to report a measurement or calculation of the power factor of a reactive electrical load.\n\n      \n\n      \n\n         \n\n            \n3330\n\n         \n\n         \nDistance\n\n         \nThis IPSO object should be used to report a distance measurement. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor.\n\n      \n\n      \n\n         \n\n            \n3331\n\n         \n\n         \nEnergy\n\n         \nThis IPSO object should be used to report energy consumption (Cumulative Power) of an electrical load.\n\n      \n\n      \n\n         \n\n            \n3332\n\n         \n\n         \nDirection\n\n         \nThis IPSO object is used to report the direction indicated by a compass, wind vane, or other directional indicator. The units of measure is plane angle degrees (ucum:deg).\n\n      \n\n      \n\n         \n\n            \n3333\n\n         \n\n         \nTime\n\n         \nThis IPSO object is used to report the current time in seconds since January 1, 1970 UTC. There is also a fractional time counter that has a range of less than one second.\n\n      \n\n      \n\n         \n\n            \n3334\n\n         \n\n         \nGyrometer\n\n         \nThis IPSO Object is used to report the current reading of a gyrometer sensor in 3 axes. It provides tracking of the minimum and maximum angular rate in all 3 axes.\n\n      \n\n      \n\n         \n\n            \n3335\n\n         \n\n         \nColor\n\n         \nThis IPSO object should be used to report the measured value of a colour sensor in some colour space described by the units resource.\n\n      \n\n      \n\n         \n\n            \n3336\n\n         \n\n         \nGPS Location\n\n         \nThis IPSO object represents GPS coordinates. This object is compatible with the LWM2M management object for location, but uses reusable resources.\n\n      \n\n      \n\n         \n\n            \n3337\n\n         \n\n         \nPositioner\n\n         \nThis IPSO object should be used with a generic position actuator from 0 to 100%.\n\n      \n\n      \n\n         \n\n            \n3338\n\n         \n\n         \nBuzzer\n\n         \nThis IPSO object should be used to actuate an audible alarm such as a buzzer, beeper, or vibration alarm.\n\n      \n\n      \n\n         \n\n            \n3339\n\n         \n\n         \nAudio Clip\n\n         \nThis IPSO object should be used for a speaker that plays a pre-recorded audio clip or an audio output that is sent elsewhere.\n\n      \n\n      \n\n         \n\n            \n3340\n\n         \n\n         \nTimer\n\n         \nThis IPSO object is used to time events and actions, using patterns common to industrial timers. A POST to the trigger resource or On/Off input state change starts the timing operation, and the timer remaining time shows zero when the operation is complete.\n\n      \n\n      \n\n         \n\n            \n3341\n\n         \n\n         \nAddressable Text Display\n\n         \nThis IPSO object is used to send text to a text-only or text mode graphics display.\n\n      \n\n      \n\n         \n\n            \n3342\n\n         \n\n         \nOn/Off Switch\n\n         \nThis IPSO object should be used with an On/Off switch to report the state of the switch.\n\n      \n\n      \n\n         \n\n            \n3343\n\n         \n\n         \nLever Control\n\n         \nThis IPSO object should be used with a dimmer or level control to report the state of the control.\n\n      \n\n      \n\n         \n\n            \n3344\n\n         \n\n         \nUp/Down Control\n\n         \nThis IPSO object is used to report the state of an up/down control element like a pair of push buttons or a rotary encoder.\n\n      \n\n      \n\n         \n\n            \n3345\n\n         \n\n         \nMultiple Axis Joystick\n\n         \nThis IPSO object can be used to report the position of a shuttle or joystick control. A digital input is provided to report the state of an associated push button.\n\n      \n\n      \n\n         \n\n            \n3346\n\n         \n\n         \nRate\n\n         \nThis object type should be used to report a rate measurement,\n\n      \n\n      \n\n         \n\n            \n3347\n\n         \n\n         \nPush Button\n\n         \nThis IPSO object is used to report the state of a momentary action push button control and to count the number of times the control has been operated since the last observation.\n\n      \n\n      \n\n         \n\n            \n3348\n\n         \n\n         \nMultistate Selector\n\n         \nThis IPSO object is used to represent the state of a multistate selector switch with a number of fixed positions.\n\n      \n\n      \n\n         \n\n            \n3349\n\n         \n\n         \nBitmap\n\n         \nSummarize several digital inputs to one value by mapping each bit to a digital input.\n\n      \n\n      \n\n         \n\n            \n3350\n\n         \n\n         \nStopwatch\n\n         \nAn ascending timer that counts how long time has passed since the timer was started after reset.\n\n      \n\n      \n\n         \n\n            \n3351\n\n         \n\n         \npowerupLog\n\n         \nOne time event sent by the device at power up.\n\n      \n\n      \n\n         \n\n            \n3352\n\n         \n\n         \nplmnSearchEvent\n\n         \nList of all PLMNs found during the initial search/scan\n\n      \n\n      \n\n         \n\n            \n3353\n\n         \n\n         \nscellID\n\n         \nserving cell information that the RRC decides to camp on\n\n      \n\n      \n\n         \n\n            \n3354\n\n         \n\n         \ncellReselectionEvent\n\n         \ncell reselection event information\n\n      \n\n      \n\n         \n\n            \n3355\n\n         \n\n         \nhandoverEvent\n\n         \nhandover event information\n\n      \n\n      \n\n         \n\n            \n3356\n\n         \n\n         \nradioLinkFailureEvent\n\n         \nRadio Link Failure Event\n\n      \n\n      \n\n         \n\n            \n3357\n\n         \n\n         \nrrcStateChangeEvent\n\n         \nCurrent RRC state change information, including the event that triggered the state change\n\n      \n\n      \n\n         \n\n            \n3358\n\n         \n\n         \nrrcTimerExpiryEvent\n\n         \nRRC timer expiry event information\n\n      \n\n      \n\n         \n\n            \n3359\n\n         \n\n         \ncellBlacklistEvent\n\n         \nCell blacklist information\n\n      \n\n      \n\n         \n\n            \n3360\n\n         \n\n         \nesmContextInfo\n\n         \nESM context information\n\n      \n\n      \n\n         \n\n            \n3361\n\n         \n\n         \nemmStateValue\n\n         \nEMM context information\n\n      \n\n      \n\n         \n\n            \n3362\n\n         \n\n         \nnasEmmTimerExpiryEvent\n\n         \nNAS EMM timer expiry information\n\n      \n\n      \n\n         \n\n            \n3363\n\n         \n\n         \nnasEsmExpiryEvent\n\n         \nNAS ESM timer expiry information\n\n      \n\n      \n\n         \n\n            \n3364\n\n         \n\n         \nemmFailureCauseEvent\n\n         \nTriggered at EMM failure - failure cause is logged\n\n      \n\n      \n\n         \n\n            \n3365\n\n         \n\n         \nrachLatency_delay\n\n         \nRACH Latency and delay information\n\n      \n\n      \n\n         \n\n            \n3366\n\n         \n\n         \nmacRachAttemptEvent\n\n         \nRACH information. Logged at RACH TX\n\n      \n\n      \n\n         \n\n            \n3367\n\n         \n\n         \nmacRachAttemptReasonEvent\n\n         \nRACH Information - reason for initiating RACH\n\n      \n\n      \n\n         \n\n            \n3368\n\n         \n\n         \nmacTimerStatusEvent\n\n         \nMAC timer expiry information\n\n      \n\n      \n\n         \n\n            \n3369\n\n         \n\n         \nmacTimingAdvanceEvent\n\n         \nTiming advance information\n\n      \n\n      \n\n         \n\n            \n3370\n\n         \n\n         \nServingCellMeasurement\n\n         \nServing Cell Measurement\n\n      \n\n      \n\n         \n\n            \n3371\n\n         \n\n         \nNeighborCellMeasurements\n\n         \nNeighbor Cell Measurements\n\n      \n\n      \n\n         \n\n            \n3372\n\n         \n\n         \nTiming Advance Information\n\n         \nNeighbor Cell Measurements\n\n      \n\n      \n\n         \n\n            \n3373\n\n         \n\n         \ntxPowerHeadroomEvent\n\n         \nTX power headroom information\n\n      \n\n      \n\n         \n\n            \n3374\n\n         \n\n         \nradioLinkMonitoring\n\n         \nRadio Link monitoring information maintained by RRC\n\n      \n\n      \n\n         \n\n            \n3375\n\n         \n\n         \nPagingDRX\n\n         \nPaging DRX information\n\n      \n\n      \n\n         \n\n            \n3376\n\n         \n\n         \ntxPowerBackOffEvent\n\n         \nTX Power backoff information\n\n      \n\n      \n\n         \n\n            \n3377\n\n         \n\n         \nMessage3Report\n\n         \nRACH message 3 report information\n\n      \n\n      \n\n         \n\n            \n3378\n\n         \n\n         \nPbchDecodingResults\n\n         \nServing cell PBCH decoding information\n\n      \n\n      \n\n         \n\n            \n3379\n\n         \n\n         \npucchPowerControl\n\n         \nPUCCH TX power control information\n\n      \n\n      \n\n         \n\n            \n3380\n\n         \n\n         \nPrachReport\n\n         \nPRACH report information\n\n      \n\n      \n\n         \n\n            \n3381\n\n         \n\n         \nVolteCallEvent\n\n         \nVoLTE call status\n\n      \n\n      \n\n         \n\n            \n3382\n\n         \n\n         \nSipRegistrationEvent\n\n         \nSIP Registration status\n\n      \n\n      \n\n         \n\n            \n3383\n\n         \n\n         \nsipPublishEvent\n\n         \nSIP Publish status\n\n      \n\n      \n\n         \n\n            \n3384\n\n         \n\n         \nsipSubscriptionEvent\n\n         \nSIP Subscription status\n\n      \n\n      \n\n         \n\n            \n3385\n\n         \n\n         \nvolteCallStateChangeEvent\n\n         \nVoLTE call status change\n\n      \n\n      \n\n         \n\n            \n3386\n\n         \n\n         \nVoLTErtpPacketLoss\n\n         \nLog is generated at the receiving end of RTP flow when newReceivedSequenceNumber - lastReceivedSequenceNumber \n 1\n\n      \n\n      \n\n         \n\n            \n10241\n\n         \n\n         \nHostDeviceInfo\n\n         \nThis LWM2M Object provides a range of host device related information which can be queried by the LWM2M Server. The host device is any integrated device with an embedded cellular radio module.\n\n      \n\n      \n\n         \n\n            \n10242\n\n         \n\n         \n3-PhasePM\n\n         \nThis Object provides the information to represent a generic 3-Phase Power Meter\n\n      \n\n      \n\n         \n\n            \n10243\n\n         \n\n         \nsinglePhasePM\n\n         \nThis Object provides the information to represent a generic Single-Phase Power Meter\n\n      \n\n      \n\n         \n\n            \n10244\n\n         \n\n         \nvehicle control unit\n\n         \nThis Object provides the information to represent a generic VCU (vehicle control unit)\n\n      \n\n      \n\n         \n\n            \n10245\n\n         \n\n         \nRelay Management\n\n         \nThis LWM2M Object provides a range of eNB related measurements and parameters of which several are changeable. Furthermore, it includes Resources to enable/disable the eNB\n\n      \n\n      \n\n         \n\n            \n10246\n\n         \n\n         \nCrowdBox Measurements\n\n         \nThis LWM2M Object provides CrowdBox-related measurements such as serving cell parameters, backhaul timing advance, and neighbour cell reports.\n\n      \n\n      \n\n         \n\n            \n10247\n\n         \n\n         \nNeighbour Cell Report\n\n         \nThis LWM2M Object provides the neighbour cell report. The CrowdBox Measurements Object and the Connected UE Report Object have both Objlnk Resources pointing to this Object\n\n      \n\n      \n\n         \n\n            \n10248\n\n         \n\n         \nConnected UE Measurements\n\n         \nThis LWM2M Object provides a range of measurements of connected UEs and provides an Object link to the Connected UE report.\n\n      \n\n      \n\n         \n\n            \n10249\n\n         \n\n         \n   Connected UE Report\n\n         \nThis LWM2M Object provides a range of information related to the connected UEs.\n\n      \n\n      \n\n         \n\n            \n10250\n\n         \n\n         \nApp Data Container\n\n         \nThis LWM2M Object is used for reporting application data of a device.\n\n      \n\n      \n\n         \n\n            \n10251\n\n         \n\n         \nAT Command\n\n         \nUsed to execute an AT command on a cellular modem\n\n      \n\n      \n\n         \n\n            \n10252\n\n         \n\n         \nManifest\n\n         \nThis object provides a range of information related to updating packages on a device\n\n      \n\n      \n\n         \n\n            \n10253\n\n         \n\n         \nConfidential Data\n\n         \nThis LWM2M Object is used for reporting data, but in a confidential way\n\n      \n\n      \n\n         \n\n            \n10254\n\n         \n\n         \nCurrent Loop Input\n\n         \nThis LwM2M Object provides a representation of a current loop sensor, which indicates the value emitted by a current source.\n\n      \n\n      \n\n         \n\n            \n10255\n\n         \n\n         \nDevice Metadata\n\n         \nThis object provides a range of information related to device metadata\n\n      \n\n      \n\n         \n\n            \n10256\n\n         \n\n         \nECID-Signal Measurement Information\n\n         \nThis LWM2M Object provides ECID signal measurements of a device.\n\n      \n\n      \n\n         \n\n            \n10257\n\n         \n\n         \nHeat/Cooling meter\n\n         \nThis Object provides the information to represent a generic (district) heat or cooling meter\n\n      \n\n      \n\n         \n\n            \n10258\n\n         \n\n         \nCurrent Loop Output\n\n         \nThis LWM2M Object provides a representation of a current loop source, which may be used to carry control signals.\n\n      \n\n      \n\n         \n\n            \n10259\n\n         \n\n         \nSystem Log\n\n         \nThis object provides read access to log buffers as well as limited configuration of logging services.\n\n      \n\n      \n\n         \n\n            \n10260\n\n         \n\n         \nRuntime Database\n\n         \nThis object allows manipulation of Runtime Database variables.\n\n      \n\n      \n\n         \n\n            \n10260\n\n         \n\n         \nRuntime Database\n\n         \nThis object allows manipulation of Runtime Database variables.\n\n      \n\n      \n\n         \n\n            \n10262\n\n         \n\n         \nInterval Data Delivery\n\n         \nThe Interval Data Delivery object provides an optimised means for managing the delivery of interval data from multiple Interval Data Object instances. \n\n      \n\n      \n\n         \n\n            \n10263\n\n         \n\n         \nEvent Data Delivery\n\n         \nThe Event Data Delivery object provides a simple means for managing the delivery of event data from multiple Event Data Object instances.\n\n      \n\n      \n\n         \n\n            \n10264\n\n         \n\n         \nDelivery Schedule\n\n         \nThe Delivery Schedule object provides a means for controlling the periodic delivery of interval and event data to the LwM2M server.\n\n      \n\n      \n\n         \n\n            \n10265\n\n         \n\n         \nLeakage Detection Configuration\n\n         \nThe leakage detection configuration object provides a means for configuring the timing and sampling frequency of a vibration based network leak detector\n\n      \n\n      \n\n         \n\n            \n10266\n\n         \n\n         \nWater Flow Readings\n\n         \nMeasures the flow of water in regular intervals\n\n      \n\n      \n\n         \n\n            \n10267\n\n         \n\n         \nDaily Maximum Flow Rate Readings\n\n         \nMeasures the maximum flow rate and its time stamp for specified period\n\n      \n\n      \n\n         \n\n            \n10268\n\n         \n\n         \nTemperature Readings\n\n         \nPeriodic temperature measurements\n\n      \n\n      \n\n         \n\n            \n10269\n\n         \n\n         \nPressure Readings\n\n         \nPeriodic pressure measurements\n\n      \n\n      \n\n         \n\n            \n10270\n\n         \n\n         \nBattery Level Readings\n\n         \nPeriodic battery level measurements\n\n      \n\n      \n\n         \n\n            \n10271\n\n         \n\n         \nCommunications Activity Time Readings\n\n         \nMeasures the total duration that the meter was activating its radio for packet transmission or receipt for the period. Used to monitor for excess poower usage over time.\n\n      \n\n      \n\n         \n\n            \n10272\n\n         \n\n         \nWater Meter Customer Leakage Alarm\n\n         \nA binary flag indicating continual usage (e.g. greater than 5 L/h for 24 hours and the flow never returning to zero at any time).\n\n      \n\n      \n\n         \n\n            \n10273\n\n         \n\n         \nWater Meter Reverse Flow Alarm\n\n         \nAn alarm indicating reverse flow through the pipe. Also supports delivery of the approximate volume of water flowing in the reverse direction in the preceding period.\n\n      \n\n      \n\n         \n\n            \n10274\n\n         \n\n         \nWater Meter Empty Pipe Alarm\n\n         \nAn alarm when meter detects there is no liquid in the pipe\n\n      \n\n      \n\n         \n\n            \n10275\n\n         \n\n         \nWater Meter Tamper Alarm\n\n         \n            Detects interference from strong magnetic field or other electrical sources. If this is not relevant for            ultrasonic meters then the tamper alarm may be used to            indicate someone attempting to open the physical enclosure or other options the manufacturer may present.        \n\n      \n\n      \n\n         \n\n            \n10276\n\n         \n\n         \nWater Meter High Pressure Alarm\n\n         \nWhere supported by the meter this is an alarm that should be raised if the meter detects pressure above a pre-configured threshold.\n\n      \n\n      \n\n         \n\n            \n10277\n\n         \n\n         \nWater Meter Low Pressure Alarm\n\n         \nWhere supported by the meter this is an alarm that should be raised if the meter detects pressure below a pre-configured threshold.\n\n      \n\n      \n\n         \n\n            \n10278\n\n         \n\n         \nHigh Temperature Alarm\n\n         \n            Where supported by the meter this is an alarm that should be raised if the meter detects temperature above a pre-configured threshold.            When the temperature drops below the clear threshold, the alarm should be cleared.        \n\n      \n\n      \n\n         \n\n            \n10279\n\n         \n\n         \nLow Temperature Alarm\n\n         \n            Where supported by the meter this is an alarm that should be raised if the meter detects temperature below a pre-configured threshold.            When the temperature rises above the clear threshold, the alarm should be cleared        \n\n      \n\n      \n\n         \n\n            \n10280\n\n         \n\n         \nWater Network Leak Alarm\n\n         \nAll meters must support the following default configuration. This alarm will be based on the frequency output of the vibration sensor/accelerometer on the SEW Daughter board. When a frequency is identified that has the characteristics of an upstream network leak, and its amplitude is above the defined threshold, the meter will report this as a network leak alarm.\n\n      \n\n      \n\n         \n\n            \n10281\n\n         \n\n         \nLow Battery Alarm \n\n         \nThis Alarm is raised when the battery voltage drops below a defined level\n\n      \n\n      \n\n         \n\n            \n10282\n\n         \n\n         \nDaughter Board Failure Alarm\n\n         \nThis binary status should indicate that the meter MCU can no longer communicate with a daughter board\n\n      \n\n      \n\n         \n\n            \n10283\n\n         \n\n         \nDevice Reboot Event\n\n         \nThis binary status should indicate that the meter MCU can no longer communicate with a daughter board\n\n      \n\n      \n\n         \n\n            \n10284\n\n         \n\n         \nTime Synchronisation Event\n\n         \nThis event records the fact that the device has rebooted\n\n      \n\n      \n\n         \n\n            \n10286\n\n         \n\n         \nApp Fota Container\n\n         \nThis LWM2M Object is used to download the firmware package of a device's application.\n\n      \n\n      \n\n         \n\n            \n10299\n\n         \n\n         \nHostDevice\n\n         \nThis LWM2M Object provides a range of host device related information which can be queried by the LWM2M Server. The host device is any integrated device with an embedded cellular radio module.\n\n      \n\n      \n\n         \n\n            \n10300\n\n         \n\n         \nPending\n\n         \nPending", 
            "title": "Registry objects"
        }, 
        {
            "location": "/api/objects-registry/#oma-defined-lwm2m-objects-and-resources", 
            "text": "The  OMA LwM2M Registry  contains a wide range of defined objects and resources,\nin a machine readable way (XML).\nNew objects and resources can be proposed via the  LwM2M Editor .  WakaamaNode provides ready-to-consume C++ objects for all lwM2M objects of the registry. Just be aware that\nspecial implementations exist for object ID 1 (LWM2M Server), 2 (Access Control), 3 (device) and 5 (firmware)\nand you should not use the auto generated ones.  For example if you want to use the \"Light Control\" lwM2M object:   Search the list below for \"Light Control\".  Find it under object id 3311.  Include  src/lwm2mObjects/3311.h  and use the class  object  in namespace  KnownObjects/id311 .  Create as many object instances as you need and add them to the object via  object.addInstance(objectInstance) .  Make the object itself known to WakaamaNode with  object.register(lwm2mContext) .", 
            "title": "OMA defined LwM2M objects and resources"
        }, 
        {
            "location": "/api/objects-registry/#example", 
            "text": "#include   lwm2mObjects/3311.h  #include   Arduino.h  using   namespace   KnownObjects ;  id3311 :: object   lights ( false );  id3311 :: instance   led ;  void   setup ()   { \n     // Overwrite the verifyFunction and  abuse  it as value changed event. \n     led . power . verifyFunction   =   []( bool   value )   { \n         // Change the led pin depending on the power value \n         digitalWrite ( ledPin ,   value ); \n         // Return true to accept the value and ACK to the server \n         return   true ; \n     }; \n\n     lights . addInstance ( led ); \n     lights . register ( lwm2mContext );  }", 
            "title": "Example"
        }, 
        {
            "location": "/api/objects-registry/#list-of-supported-objects", 
            "text": "#lwm2mObjects tr:nth-child(even){background-color: #f2f2f2;}\n\n#lwm2mObjects tr:hover {background-color: #ddd;}\n\n#lwm2mObjects th {\n    padding-top: 12px;\n    padding-bottom: 12px;\n    text-align: left;\n    background-color: #ef5350;\n    color: white;\n}\n    \n    \n       \n          Object ID \n          Name \n          Description \n       \n    \n    \n       \n          \n             1 \n          \n          LWM2M Server \n          It provides the data related to a LWM2M Server. A Bootstrap Server has no such an Object Instance associated to it. \n       \n       \n          \n             2 \n          \n          Access Control \n          It is used to check whether the LWM2M Server has access right for performing a operation. \n       \n       \n          \n             3 \n          \n          Device \n          It provides a range of device related information which can be queried by the LWM2M Server, and a device reboot and factory reset function. \n       \n       \n          \n             4 \n          \n          Connectivity Monitoring \n          It enables monitoring of parameters related to network connectivity. In this general connectivity Object, the Resources are limited to the most general cases common to most network bearers. It is recommended to read the description, which refers to relevant standard development organizations (e.g. 3GPP, IEEE). The goal of the Connectivity Monitoring Object is to carry information reflecting the more up to date values of the current connection for monitoring purposes. Resources such as Link Quality, Radio Signal Strenght, Cell ID are retrieved during connected mode at least for cellular networks. \n       \n       \n          \n             5 \n          \n          Firmware \n          It enables management of firmware which is to be updated. This Object includes installing firmware package, updating firmware, and performing actions after updating firmware \n       \n       \n          \n             6 \n          \n          Location \n          It provides a range of device related information which can be queried by the LWM2M Server, and a device reboot and factory reset function. \n       \n       \n          \n             7 \n          \n          Connectivity Statistics \n          This LWM2M Objects enables client to collect statistical information and enables the LWM2M Server to retrieve these information, set the collection duration and reset the statistical parameters. \n       \n       \n          \n             8 \n          \n          Lock and Wipe \n          This LWM2M objects provides the resources needed to perform the lock and wipe operations \n       \n       \n          \n             9 \n          \n          Sofware Management \n          This LWM2M objects provides the resources needed to perform software management on the device. Each software component is managed via a dedicated Software Management Object instance \n       \n       \n          \n             10 \n          \n          Cellular connectivity \n          It specifies resources to enable a device to connect to a 3GPP or 3GPP2 bearer, including GPRS/EDGE, UMTS, LTE, SMS. For cellular connectivity, this object focuses on Packet Switched (PS) connectivity and doesn't aim to provide comprehensive Circuit Switched (CS) connectivity management. \n       \n       \n          \n             11 \n          \n          APN connection profile \n          It specifies resources to enable a device to connect to an APN. \n       \n       \n          \n             12 \n          \n          WLAN connectivity \n          It specifies resources to enable a device to connect to a WLAN bearer. \n       \n       \n          \n             13 \n          \n          Bearer selection \n          It specifies resources to enable a device to choose a communications bearer on which to connect. \n       \n       \n          \n             14 \n          \n          Software Component \n          The LWM2M software management object enables remote software management in M2M devices \n       \n       \n          \n             15 \n          \n          DevCapMgmt \n          It manages the device capabilities of a device e.g. sensors, communication, etc. \n       \n       \n          \n             16 \n          \n          Porfolio \n          The Portfolio Object allows to extend the data storage capability of other Object Instances in the LwM2M system, as well as the services which may be used to authenticate and to protect privacy of data contained in those extensions. In addition, a service of data encryption is also defined \n       \n       \n          \n             17 \n          \n          Communications Characteristics \n          This object enables configuration of various generic communications parameters. \n       \n       \n          \n             18 \n          \n          Non-Access Stratum (NAS) Configuration \n          This object provides Non-Access Stratum (NAS) configuration and is derived from 3GPP TS 24.368. \n       \n       \n          \n             19 \n          \n          LwM2M APPDATA \n          This LwM2M object provides the application service data related to a LwM2M Server, eg. Water meter data. \n       \n       \n          \n             20 \n          \n          EventLog \n          The Event Log Object is a single Instance Object defined for logging data in a straightforward         and generic way. The Resources of that Object are based on the OMA LwM2M set of reusable Resources dedicated to logging event activity. \n       \n       \n          \n             21 \n          \n          Pending \n          Pending \n       \n       \n          \n             2048 \n          \n          CmdhPolicy \n          This Object provides links to a set of rules associated with a specific CSE that governs the behavior             of that CSE regarding rejecting, buffering and sending request or response messages via the Mcc reference point. \n       \n       \n          \n             2049 \n          \n          ActiveCmdhPolicy \n          This Object provides a link to the currently active set of CMDH policies \n       \n       \n          \n             2050 \n          \n          CmdhDefaults \n          Defines which CMDH related parameters will be used by default. \n       \n       \n          \n             2051 \n          \n          CmdhDefEcValues \n          This Object represents default set of values for the Event Category parameter of an incoming request or response message. \n       \n       \n          \n             2052 \n          \n          CmdhEcDefParamValues \n          This Object represents a specific set of default values for the CMDH related parameters Request Expiration Timestamp, Result Expiration Timestamp, Operational Execution Time, Result Persistence and Delivery Aggregation that are applicable for a given Event Category if these parameters are not specified in the message. \n       \n       \n          \n             2053 \n          \n          CmdhLimits \n          This Object represents limits for CMDH related parameter values. \n       \n       \n          \n             2054 \n          \n          CmdhNetworkAccessRules \n          This Object defines the usage of underlying networks for forwarding information to other CSEs during processing of CMDH-related requests in a CSE. \n       \n       \n          \n             2055 \n          \n          CmdhNwAccessRule \n          This Object defines limits in usage of specific underlying networks for forwarding information to other CSEs during processing of CMDH-related requests in a CSE. \n       \n       \n          \n             2056 \n          \n          CmdhBuffer \n          This Object defines limits in usage of buffers for temporarily storing information that needs to be forwarded to other CSEs during processing of CMDH-related requests in a CSE. \n       \n       \n          \n             2057 \n          \n          CmdhBackOffParametersSet \n          This Object defines set of parameters which can be referenced by a specific Instance of the CmdhNwAccessRule Object (ID: 2055) \n       \n       \n          \n             3200 \n          \n          Digital Input \n          This IPSO object is a generic object that can be used with any kind of digital input interface. Specific objects for a given range of sensors are described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist. \n       \n       \n          \n             3201 \n          \n          Digital Output \n          This IPSO object is a generic object that can be used with any kind of digital output interface. Specific object for a given range of sensors is described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist. \n       \n       \n          \n             3202 \n          \n          Analogue Input \n          This IPSO object is a generic object that can be used with any kind of analogue input interface. Specific object for a given range of sensors is described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist. \n       \n       \n          \n             3203 \n          \n          Analogue Output \n          This IPSO object is a generic object that can be used with any kind of analogue input interface. Specific object for a given range of sensors is described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist. \n       \n       \n          \n             3300 \n          \n          Generic Sensor \n          This IPSO object allow the description of a generic sensor. It is based on the description of a value and a unit according to the UCUM specification. Thus, any type of value defined within this specification can be reporting using this object. Specific object for a given range of sensors is described later in the document, enabling to identify the type of sensors directly from its Object ID. This object may be used as a generic object if a dedicated one does not exist. \n       \n       \n          \n             3301 \n          \n          Illuminance Sensor \n          This IPSO object should be used over a luminosity sensor to report a remote luminosity measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range that can be measured by the luminosity sensor. The unit used here is Lux (ucum:lx). \n       \n       \n          \n             3302 \n          \n          Presence Sensor \n          This IPSO object should be used over a presence sensor to report a remote presence detection. It also provides resources to manage a counter, the type of sensor used (e.g the technology of the probe), and configuration for the delay between busy and clear detection state. \n       \n       \n          \n             3303 \n          \n          Temperature Sensor \n          This IPSO object should be used over a temperature sensor to report a remote temperature measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range that can be measured by the temperature sensor. The unit used here is degree Celsius (ucum:Cel). \n       \n       \n          \n             3304 \n          \n          Humidity Sensor \n          This IPSO object should be used over a humidity sensor to report a remote humidity measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range that can be measured by the humidity sensor. The unit used here is relative humidity as a percentage (ucum:%). \n       \n       \n          \n             3305 \n          \n          Power Measurement \n          This IPSO object should be used over a power measurement sensor to report a remote power measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range for both active and reactive power. Il also provides resources for cumulative energy, calibration, and the power factor. \n       \n       \n          \n             3306 \n          \n          Actuation \n          This IPSO object is dedicated to remote actuation such as ON/OFF action or dimming. A multistate output can also be described as a string. This is useful to send pilot wire orders for instance. It also provides a resource to reflect the time that the device has been switched on. \n       \n       \n          \n             3308 \n          \n          Set Point \n          This IPSO object should be used to set a desired value to a controller, such as a thermostat. This object enables a setpoint to be expressed units defined in the UCUM specification, to match an associated sensor or measurement value. A special resource is added to set the colour of an object. \n       \n       \n          \n             3310 \n          \n          Load Control \n          This Object is used for demand-response load control and other load control in automation application (not limited to power). \n       \n       \n          \n             3311 \n          \n          Light Control \n          This Object is used to control a light source, such as a LED or other light. It allows a light to be turned on or off and its dimmer setting to be control as a % between 0 and 100. \n       \n       \n          \n             3312 \n          \n          Power Control \n          This Object is used to control a power source, such as a Smart Plug. It allows a power relay to be turned on or off and its dimmer setting to be control as a % between 0 and 100. \n       \n       \n          \n             3313 \n          \n          Accelerometer \n          This IPSO object can be used to represent a 1-3 axis accelerometer. \n       \n       \n          \n             3314 \n          \n          Magnetometer \n          This IPSO object can be used to represent a 1-3 axis magnetometer with optional compass direction. \n       \n       \n          \n             3315 \n          \n          Barometer \n          This IPSO object should be used with an air pressure sensor to report a remote barometer measurement. It also provides resources for minimum/maximum measured values and the minimum/maximum range that can be measured by the barometer sensor. \n       \n       \n          \n             3316 \n          \n          Voltage \n          This IPSO object should be used with voltmeter sensor to report measured voltage between two points. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. An example measurement unit is volts (ucum: V). \n       \n       \n          \n             3317 \n          \n          Current \n          This IPSO object should be used with an ammeter to report measured electric current in amperes. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. An example measurement unit is volts (ucum: A). \n       \n       \n          \n             3318 \n          \n          Frequency \n          This IPSO object should be used to report frequency measurements. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. An example measurement unit is volts (ucum: Hz). \n       \n       \n          \n             3319 \n          \n          Depth \n          This IPSO object should be used to report depth measurements. It can, for example, be used to describe a generic rain gauge that measures the accumulated rainfall in millimetres (mm) or in fathoms (fth). \n       \n       \n          \n             3320 \n          \n          Percentage \n          This IPSO object should can be used to report measurements relative to a 0-100% scale. For example it could be used to measure the level of a liquid in a vessel or container in units of %. \n       \n       \n          \n             3321 \n          \n          Altitude \n          This IPSO object should be used with an altitude sensor to report altitude above sea level in meters. Note that Altitude can be calculated from the measured pressure given the local sea level pressure. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. An example measurement unit is meters (ucum: m). \n       \n       \n          \n             3322 \n          \n          Load \n          This IPSO object should be used with a load sensor (as in a scale) to report the applied weight or force. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. \n       \n       \n          \n             3323 \n          \n          Pressure \n          This IPSO object should be used to report pressure measurements. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. \n       \n       \n          \n             3324 \n          \n          Loudness \n          This IPSO object should be used to report loudness or noise level measurements. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. \n       \n       \n          \n             3325 \n          \n          Concentration \n          This IPSO object should be used to the particle concentration measurement of a medium. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. \n       \n       \n          \n             3326 \n          \n          Acidity \n          This IPSO object should be used to report an acidity measurement of a liquid. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. \n       \n       \n          \n             3327 \n          \n          Conductivity \n          This IPSO object should be used to report a measurement of the electric conductivity of a medium or sample. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. \n       \n       \n          \n             3328 \n          \n          Power \n          This IPSO object should be used to report power measurements. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. \n       \n       \n          \n             3329 \n          \n          Power Factor \n          This IPSO object should be used to report a measurement or calculation of the power factor of a reactive electrical load. \n       \n       \n          \n             3330 \n          \n          Distance \n          This IPSO object should be used to report a distance measurement. It also provides resources for minimum and maximum measured values, as well as the minimum and maximum range that can be measured by the sensor. \n       \n       \n          \n             3331 \n          \n          Energy \n          This IPSO object should be used to report energy consumption (Cumulative Power) of an electrical load. \n       \n       \n          \n             3332 \n          \n          Direction \n          This IPSO object is used to report the direction indicated by a compass, wind vane, or other directional indicator. The units of measure is plane angle degrees (ucum:deg). \n       \n       \n          \n             3333 \n          \n          Time \n          This IPSO object is used to report the current time in seconds since January 1, 1970 UTC. There is also a fractional time counter that has a range of less than one second. \n       \n       \n          \n             3334 \n          \n          Gyrometer \n          This IPSO Object is used to report the current reading of a gyrometer sensor in 3 axes. It provides tracking of the minimum and maximum angular rate in all 3 axes. \n       \n       \n          \n             3335 \n          \n          Color \n          This IPSO object should be used to report the measured value of a colour sensor in some colour space described by the units resource. \n       \n       \n          \n             3336 \n          \n          GPS Location \n          This IPSO object represents GPS coordinates. This object is compatible with the LWM2M management object for location, but uses reusable resources. \n       \n       \n          \n             3337 \n          \n          Positioner \n          This IPSO object should be used with a generic position actuator from 0 to 100%. \n       \n       \n          \n             3338 \n          \n          Buzzer \n          This IPSO object should be used to actuate an audible alarm such as a buzzer, beeper, or vibration alarm. \n       \n       \n          \n             3339 \n          \n          Audio Clip \n          This IPSO object should be used for a speaker that plays a pre-recorded audio clip or an audio output that is sent elsewhere. \n       \n       \n          \n             3340 \n          \n          Timer \n          This IPSO object is used to time events and actions, using patterns common to industrial timers. A POST to the trigger resource or On/Off input state change starts the timing operation, and the timer remaining time shows zero when the operation is complete. \n       \n       \n          \n             3341 \n          \n          Addressable Text Display \n          This IPSO object is used to send text to a text-only or text mode graphics display. \n       \n       \n          \n             3342 \n          \n          On/Off Switch \n          This IPSO object should be used with an On/Off switch to report the state of the switch. \n       \n       \n          \n             3343 \n          \n          Lever Control \n          This IPSO object should be used with a dimmer or level control to report the state of the control. \n       \n       \n          \n             3344 \n          \n          Up/Down Control \n          This IPSO object is used to report the state of an up/down control element like a pair of push buttons or a rotary encoder. \n       \n       \n          \n             3345 \n          \n          Multiple Axis Joystick \n          This IPSO object can be used to report the position of a shuttle or joystick control. A digital input is provided to report the state of an associated push button. \n       \n       \n          \n             3346 \n          \n          Rate \n          This object type should be used to report a rate measurement, \n       \n       \n          \n             3347 \n          \n          Push Button \n          This IPSO object is used to report the state of a momentary action push button control and to count the number of times the control has been operated since the last observation. \n       \n       \n          \n             3348 \n          \n          Multistate Selector \n          This IPSO object is used to represent the state of a multistate selector switch with a number of fixed positions. \n       \n       \n          \n             3349 \n          \n          Bitmap \n          Summarize several digital inputs to one value by mapping each bit to a digital input. \n       \n       \n          \n             3350 \n          \n          Stopwatch \n          An ascending timer that counts how long time has passed since the timer was started after reset. \n       \n       \n          \n             3351 \n          \n          powerupLog \n          One time event sent by the device at power up. \n       \n       \n          \n             3352 \n          \n          plmnSearchEvent \n          List of all PLMNs found during the initial search/scan \n       \n       \n          \n             3353 \n          \n          scellID \n          serving cell information that the RRC decides to camp on \n       \n       \n          \n             3354 \n          \n          cellReselectionEvent \n          cell reselection event information \n       \n       \n          \n             3355 \n          \n          handoverEvent \n          handover event information \n       \n       \n          \n             3356 \n          \n          radioLinkFailureEvent \n          Radio Link Failure Event \n       \n       \n          \n             3357 \n          \n          rrcStateChangeEvent \n          Current RRC state change information, including the event that triggered the state change \n       \n       \n          \n             3358 \n          \n          rrcTimerExpiryEvent \n          RRC timer expiry event information \n       \n       \n          \n             3359 \n          \n          cellBlacklistEvent \n          Cell blacklist information \n       \n       \n          \n             3360 \n          \n          esmContextInfo \n          ESM context information \n       \n       \n          \n             3361 \n          \n          emmStateValue \n          EMM context information \n       \n       \n          \n             3362 \n          \n          nasEmmTimerExpiryEvent \n          NAS EMM timer expiry information \n       \n       \n          \n             3363 \n          \n          nasEsmExpiryEvent \n          NAS ESM timer expiry information \n       \n       \n          \n             3364 \n          \n          emmFailureCauseEvent \n          Triggered at EMM failure - failure cause is logged \n       \n       \n          \n             3365 \n          \n          rachLatency_delay \n          RACH Latency and delay information \n       \n       \n          \n             3366 \n          \n          macRachAttemptEvent \n          RACH information. Logged at RACH TX \n       \n       \n          \n             3367 \n          \n          macRachAttemptReasonEvent \n          RACH Information - reason for initiating RACH \n       \n       \n          \n             3368 \n          \n          macTimerStatusEvent \n          MAC timer expiry information \n       \n       \n          \n             3369 \n          \n          macTimingAdvanceEvent \n          Timing advance information \n       \n       \n          \n             3370 \n          \n          ServingCellMeasurement \n          Serving Cell Measurement \n       \n       \n          \n             3371 \n          \n          NeighborCellMeasurements \n          Neighbor Cell Measurements \n       \n       \n          \n             3372 \n          \n          Timing Advance Information \n          Neighbor Cell Measurements \n       \n       \n          \n             3373 \n          \n          txPowerHeadroomEvent \n          TX power headroom information \n       \n       \n          \n             3374 \n          \n          radioLinkMonitoring \n          Radio Link monitoring information maintained by RRC \n       \n       \n          \n             3375 \n          \n          PagingDRX \n          Paging DRX information \n       \n       \n          \n             3376 \n          \n          txPowerBackOffEvent \n          TX Power backoff information \n       \n       \n          \n             3377 \n          \n          Message3Report \n          RACH message 3 report information \n       \n       \n          \n             3378 \n          \n          PbchDecodingResults \n          Serving cell PBCH decoding information \n       \n       \n          \n             3379 \n          \n          pucchPowerControl \n          PUCCH TX power control information \n       \n       \n          \n             3380 \n          \n          PrachReport \n          PRACH report information \n       \n       \n          \n             3381 \n          \n          VolteCallEvent \n          VoLTE call status \n       \n       \n          \n             3382 \n          \n          SipRegistrationEvent \n          SIP Registration status \n       \n       \n          \n             3383 \n          \n          sipPublishEvent \n          SIP Publish status \n       \n       \n          \n             3384 \n          \n          sipSubscriptionEvent \n          SIP Subscription status \n       \n       \n          \n             3385 \n          \n          volteCallStateChangeEvent \n          VoLTE call status change \n       \n       \n          \n             3386 \n          \n          VoLTErtpPacketLoss \n          Log is generated at the receiving end of RTP flow when newReceivedSequenceNumber - lastReceivedSequenceNumber   1 \n       \n       \n          \n             10241 \n          \n          HostDeviceInfo \n          This LWM2M Object provides a range of host device related information which can be queried by the LWM2M Server. The host device is any integrated device with an embedded cellular radio module. \n       \n       \n          \n             10242 \n          \n          3-PhasePM \n          This Object provides the information to represent a generic 3-Phase Power Meter \n       \n       \n          \n             10243 \n          \n          singlePhasePM \n          This Object provides the information to represent a generic Single-Phase Power Meter \n       \n       \n          \n             10244 \n          \n          vehicle control unit \n          This Object provides the information to represent a generic VCU (vehicle control unit) \n       \n       \n          \n             10245 \n          \n          Relay Management \n          This LWM2M Object provides a range of eNB related measurements and parameters of which several are changeable. Furthermore, it includes Resources to enable/disable the eNB \n       \n       \n          \n             10246 \n          \n          CrowdBox Measurements \n          This LWM2M Object provides CrowdBox-related measurements such as serving cell parameters, backhaul timing advance, and neighbour cell reports. \n       \n       \n          \n             10247 \n          \n          Neighbour Cell Report \n          This LWM2M Object provides the neighbour cell report. The CrowdBox Measurements Object and the Connected UE Report Object have both Objlnk Resources pointing to this Object \n       \n       \n          \n             10248 \n          \n          Connected UE Measurements \n          This LWM2M Object provides a range of measurements of connected UEs and provides an Object link to the Connected UE report. \n       \n       \n          \n             10249 \n          \n             Connected UE Report \n          This LWM2M Object provides a range of information related to the connected UEs. \n       \n       \n          \n             10250 \n          \n          App Data Container \n          This LWM2M Object is used for reporting application data of a device. \n       \n       \n          \n             10251 \n          \n          AT Command \n          Used to execute an AT command on a cellular modem \n       \n       \n          \n             10252 \n          \n          Manifest \n          This object provides a range of information related to updating packages on a device \n       \n       \n          \n             10253 \n          \n          Confidential Data \n          This LWM2M Object is used for reporting data, but in a confidential way \n       \n       \n          \n             10254 \n          \n          Current Loop Input \n          This LwM2M Object provides a representation of a current loop sensor, which indicates the value emitted by a current source. \n       \n       \n          \n             10255 \n          \n          Device Metadata \n          This object provides a range of information related to device metadata \n       \n       \n          \n             10256 \n          \n          ECID-Signal Measurement Information \n          This LWM2M Object provides ECID signal measurements of a device. \n       \n       \n          \n             10257 \n          \n          Heat/Cooling meter \n          This Object provides the information to represent a generic (district) heat or cooling meter \n       \n       \n          \n             10258 \n          \n          Current Loop Output \n          This LWM2M Object provides a representation of a current loop source, which may be used to carry control signals. \n       \n       \n          \n             10259 \n          \n          System Log \n          This object provides read access to log buffers as well as limited configuration of logging services. \n       \n       \n          \n             10260 \n          \n          Runtime Database \n          This object allows manipulation of Runtime Database variables. \n       \n       \n          \n             10260 \n          \n          Runtime Database \n          This object allows manipulation of Runtime Database variables. \n       \n       \n          \n             10262 \n          \n          Interval Data Delivery \n          The Interval Data Delivery object provides an optimised means for managing the delivery of interval data from multiple Interval Data Object instances.  \n       \n       \n          \n             10263 \n          \n          Event Data Delivery \n          The Event Data Delivery object provides a simple means for managing the delivery of event data from multiple Event Data Object instances. \n       \n       \n          \n             10264 \n          \n          Delivery Schedule \n          The Delivery Schedule object provides a means for controlling the periodic delivery of interval and event data to the LwM2M server. \n       \n       \n          \n             10265 \n          \n          Leakage Detection Configuration \n          The leakage detection configuration object provides a means for configuring the timing and sampling frequency of a vibration based network leak detector \n       \n       \n          \n             10266 \n          \n          Water Flow Readings \n          Measures the flow of water in regular intervals \n       \n       \n          \n             10267 \n          \n          Daily Maximum Flow Rate Readings \n          Measures the maximum flow rate and its time stamp for specified period \n       \n       \n          \n             10268 \n          \n          Temperature Readings \n          Periodic temperature measurements \n       \n       \n          \n             10269 \n          \n          Pressure Readings \n          Periodic pressure measurements \n       \n       \n          \n             10270 \n          \n          Battery Level Readings \n          Periodic battery level measurements \n       \n       \n          \n             10271 \n          \n          Communications Activity Time Readings \n          Measures the total duration that the meter was activating its radio for packet transmission or receipt for the period. Used to monitor for excess poower usage over time. \n       \n       \n          \n             10272 \n          \n          Water Meter Customer Leakage Alarm \n          A binary flag indicating continual usage (e.g. greater than 5 L/h for 24 hours and the flow never returning to zero at any time). \n       \n       \n          \n             10273 \n          \n          Water Meter Reverse Flow Alarm \n          An alarm indicating reverse flow through the pipe. Also supports delivery of the approximate volume of water flowing in the reverse direction in the preceding period. \n       \n       \n          \n             10274 \n          \n          Water Meter Empty Pipe Alarm \n          An alarm when meter detects there is no liquid in the pipe \n       \n       \n          \n             10275 \n          \n          Water Meter Tamper Alarm \n                      Detects interference from strong magnetic field or other electrical sources. If this is not relevant for            ultrasonic meters then the tamper alarm may be used to            indicate someone attempting to open the physical enclosure or other options the manufacturer may present.         \n       \n       \n          \n             10276 \n          \n          Water Meter High Pressure Alarm \n          Where supported by the meter this is an alarm that should be raised if the meter detects pressure above a pre-configured threshold. \n       \n       \n          \n             10277 \n          \n          Water Meter Low Pressure Alarm \n          Where supported by the meter this is an alarm that should be raised if the meter detects pressure below a pre-configured threshold. \n       \n       \n          \n             10278 \n          \n          High Temperature Alarm \n                      Where supported by the meter this is an alarm that should be raised if the meter detects temperature above a pre-configured threshold.            When the temperature drops below the clear threshold, the alarm should be cleared.         \n       \n       \n          \n             10279 \n          \n          Low Temperature Alarm \n                      Where supported by the meter this is an alarm that should be raised if the meter detects temperature below a pre-configured threshold.            When the temperature rises above the clear threshold, the alarm should be cleared         \n       \n       \n          \n             10280 \n          \n          Water Network Leak Alarm \n          All meters must support the following default configuration. This alarm will be based on the frequency output of the vibration sensor/accelerometer on the SEW Daughter board. When a frequency is identified that has the characteristics of an upstream network leak, and its amplitude is above the defined threshold, the meter will report this as a network leak alarm. \n       \n       \n          \n             10281 \n          \n          Low Battery Alarm  \n          This Alarm is raised when the battery voltage drops below a defined level \n       \n       \n          \n             10282 \n          \n          Daughter Board Failure Alarm \n          This binary status should indicate that the meter MCU can no longer communicate with a daughter board \n       \n       \n          \n             10283 \n          \n          Device Reboot Event \n          This binary status should indicate that the meter MCU can no longer communicate with a daughter board \n       \n       \n          \n             10284 \n          \n          Time Synchronisation Event \n          This event records the fact that the device has rebooted \n       \n       \n          \n             10286 \n          \n          App Fota Container \n          This LWM2M Object is used to download the firmware package of a device's application. \n       \n       \n          \n             10299 \n          \n          HostDevice \n          This LWM2M Object provides a range of host device related information which can be queried by the LWM2M Server. The host device is any integrated device with an embedded cellular radio module. \n       \n       \n          \n             10300 \n          \n          Pending \n          Pending", 
            "title": "List of supported objects"
        }, 
        {
            "location": "/api/objects-custom/", 
            "text": "Custom lwM2M objects\n\n\nThe last chapter introducted you to objects of the OMA lwM2M registry. WakaamaNode allows you to define\nyour own  custom lwm2m object. A unique object ID is necessary.\n\n\nThe next section explains some background information about the object ID namespace.\nThereafter you will find the C++ and C API for lwm2m object definitions.\n\n\nAbout the object ID namespace\n\n\nThe object id namespace is divided into several ObjectID Classes.\n\n\n\n\n\n\n\n\nCategory\n\n\nURN\n\n\nObject ID\n\n\nrange\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\noma-label\n\n\nurn:oma:lwm2m:oma:\nid\n:\nversion\n\n\n0 - 1023\n\n\nObjects Produced by OMA. Only OMA can use this range\n\n\n\n\n\n\n\n\nreserved\n\n\n\n\n1024 - 2047\n\n\nReserved for future use\n\n\n\n\n\n\n\n\next-label\n\n\nurn:oma:lwm2m:ext:\nid\n:\nversion\n\n\n2048 - 10240\n\n\nObjects registered by 3\nrd\n party standards organisations or alliances\n\n\n\n\n\n\n\n\nx-label\n\n\nurn:oma:lwm2m: x:\nid\n:\nversion\n\n\n10241 - 26240\n26241 - 32768\n32769 - 42768\n\n\nObjects registered by companies or individuals.\nObjects Produced by Vendors to re-use\nBlock of objects reserved by vendors (Max 50). Private range, Objects will not be published\n\n\n\n\n\n\n\n\n\n\nIf your use case is not yet considered within the registries objects, it is time to fill out an application for a new object.\n\n\nFor testing purposes, you can use one of the undefined ids (range 42769..65000). If possible, you should at least\nmake use of the \npredefined resource ids (range: 2048..26240)\n.\n\n\nDefine your custom objects either via C or the C++ interface.\n\n\nObject definition C++ API\n\n\nInclude \nlwm2m_objects.hpp\n.\n\n\nLwm2mObject class\n\n\nclass\n \nLwm2mObject\nObjectID\n,\n \nDerivedObject\n,\n \nObjectInstance\n\n\n\n\n\nLwm2mObject is not to be used directly.\nInherit from Lwm2mObject to implement your own lwM2M object. Specify the \nObjectID\n, for example \"1024\",\nthe derived object class and the associated object instance class.\n\n\nTo allow WakaamaNode to handle all read/write/execute handling for you, you need to describe the available\nresources of an lwM2M object.\nExample:\n\n\nclass\n \nMyObject\n: \npublic\n \nLwm2mObject\n1024\n,\n \nMyObject\n,\n \nMyObjectInstance\n\n\n{\n\n\npublic\n:\n\n    \nResource\n(\n0\n,\n \nMyObjectInstance\n::\ntest\n,\n \nO_RES_RW\n)\n \ntest\n;\n\n\n};\n\n\n\n\n\nHere a Readable/Writable(O_RES_RW) resource with ResourceID 0 is declared. It references the \nMyObjectInstance::test\n class member of \"MyObjectInstance\"\nfor reading the resource value and writing to it.\nThe name of the class member is not relevant and should describe the resource, for example \"power\" or \"volume\".\n\n\nThe exact syntax and semantic of \nResource\n is described further down in the \nResource class\n section.\n\n\n/**\n\n\n * @param instance The object instance to add. See Lwm2mObjectInstance. May not be null.\n\n\n */\n\n\nvoid\n \nLwm2mObject\n::\naddInstance\n(\nLwm2mObjectInstance\n \n*\n \ninstance\n);\n\n\n\n\n\nAdd a \nLwm2mObjectInstance\n to your object.\nThe instance is automatically registered to the lwm2m server, if already connected.\n\n\n/**\n\n\n * @param instance The instance ID for the instance to remove. See Lwm2mObjectInstance.\n\n\n *        Nothing happens if the instance is not known to the object.\n\n\n */\n\n\nvoid\n \nLwm2mObject\n::\nremoveInstance\n(\nuint16\n \ninstanceID\n);\n\n\n\n\n\nRemoves a \nLwm2mObjectInstance\n from your object.\nThe instance is automatically unregistered from the lwm2m server, if already connected.\n\n\n/**\n\n\n * @param lwm2mContext The Wakaama context.\n\n\n */\n\n\nvoid\n \nLwm2mObject\n::\nregisterObject\n(\nvoid\n*\n \nlwm2mContext\n,\n \nbool\n \nallow_dynamic_instance_creation\n);\n\n\n\n\n\nRegisters the object to Wakaama.\nThe object is automatically registered to the lwM2M server, if already connected.\n\n\n/**\n\n\n * @param lwm2mContext The Wakaama context.\n\n\n */\n\n\nvoid\n \nLwm2mObject\n::\nunregisterObject\n(\nvoid\n*\n \nlwm2mContext\n);\n\n\n\n\n\nUnregisters the object from Wakaama.\n\n\n/**\n\n\n * @param instance_id Instance ID\n\n\n */\n\n\nvirtual\n \nLwm2mObjectInstance\n*\n \ncreateInstance\n(\nuint16_t\n \ninstance_id\n);\n\n\n\n\n\nImplement this function in your object class and either return \nnullptr\n\nif creating instances dynamically by the server or with the given ID is not supported or\nreturn a working object instance with the given instance ID.\n\n\nThe default does nothing and returns a \nnullptr\n.\n\n\n/**\n\n\n * @param instance Object instance to delete\n\n\n * @return Return COAP_NO_ERROR if no error happened.\n\n\n */\n\n\nvirtual\n \nint\n \ndeleteInstance\n(\nLwm2mObjectInstance\n*\n \ninstance\n);\n\n\n\n\n\nImplement this function in your object class to allow to delete an object instance.\n\n\n/**\n\n\n * @param instance Object instance that is going to be modified\n\n\n * @param res_id The resource that will get changed\n\n\n * @return Return true if change is accepted or false if change is denied.\n\n\n */\n\n\nvirtual\n \nbool\n \nverifyWrite\n(\nLwm2mObjectInstance\n*\n \ninstance\n,\n \nuint16_t\n \nres_id\n);\n\n\n\n\n\nImplement this function in your object class to verify a change on an object instance resource.\n\n\nLwm2mObjectInstance class\n\n\nclass\n \nLwm2mObjectInstance\n\n\n\n\n\nLwm2mObjectInstance is not to be used directly.\nInherit from this class to implement a data holder for an object instance.\nExample:\n\nstruct\n \nMyObjectInstance\n:\n \npublic\n \nLwm2mObjectInstance\n \n{\n\n    \nuint8_t\n  \nfirstResource\n;\n\n\n}\n\n\n\n\nAllowed data types are 8/16/32/64 bit unsigned/signed integers,\nfloats, doubles, booleans and unsigned/signed c-strings.\n\n\n\nCoAP and lwM2M support opaque resources.\nWakaamaNode provides the \nOpaque\nN\n and \nOpaqueIndirect\n type.\nSee \nOpaque Resources\n for an example.\n\n\nResources can be executable. Declare a class member of type \nExecutable\n that will be used\nas function pointer. See \nExecutable Resource\n for an example.\n\n\nThe name of the class member is not relevant and should describe the resource, for example \"power\" or \"volume\".\n\n\nLwm2mObjectInstance does not have any methods.\n\n\nResource class\n\n\nclass\n \nResource\nResID\n,\n \nResourceValueReference\n,\n \nOperations\n\n\n\n\n\nUse the templated \nResource\n class to describe the resource ID, reference to the member variable that stores the value and supported operations in this order.\n\nUntil C++17, the syntax of declaring a Resource needs \"(\" instead of \"\n\" brackets.\n\n\nSupported operations are O_RES_R (read only), O_RES_W (assign only), O_RES_RW (read/write).\n\n\nExecutable Resources\n\n\nFor an executable resource, you do not need to specify the Operations, because it will always be O_RES_E.\n\n\nIn the following example a constructor is used to force the \nMyObjectInstance\n\nuser to assign a function:\n\n\nstruct\n \nMyObjectInstance\n:\n \npublic\n \nLwm2mObjectInstance\n \n{\n\n    \nExecutable\n \nexec\n;\n\n\n    \nMyObjectInstance\n(\nExecutable\n \nanExecutableResourceFunction\n)\n \n:\n \nexec\n(\nanExecutableResourceFunction\n)\n \n{}\n\n\n}\n\n\n\n\n\nThe corresponding object looks like this:\n\n\nclass\n \nMyObject\n: \npublic\n \nLwm2mObject\n1024\n,\nMyObject\n,\nMyObjectInstance\n\n\n{\n\n\npublic\n:\n\n    \nResource\n0\n,\n \nMyObjectInstance\n::\nexec\n \nexec\n;\n\n\n};\n\n\n\n\n\nOpaque Resources\n\n\nIf you have an opaque resource, you have two options. Either you directly reserve enough space in-place via the \nOpaque\nN\n\ntemplated class, or you let the class variable point to a memory location, which basically means an indirect memory access. Use \nOpaqueIndirect\n in this case.\nAn example:\n\n\nchar\n \nmemory\n[\n100\n];\n\n\n\nstruct\n \nMyObjectInstance\n:\n \npublic\n \nLwm2mObjectInstance\n \n{\n\n   \n// Equals an in-place array with the size of 20 bytes\n\n   \nOpaque\n20\n \nopaqueRes\n;\n\n\n   \n// Similar to Opaque, but will be designated as string resource\n\n   \nPreallocString\n20\n \npreallocStringRes\n;\n   \n\n   \n// You need to assign the OpaqueIndirect::data pointer a memory location.\n\n   \nOpaqueIndirect\n \nopaqueIndirectRes\n;\n\n\n   \nMyObjectInstance\n()\n \n:\n \nopaqueIndirectRes\n{\n100\n,\n0\n,\nmemory\n}\n \n{}\n\n\n};\n\n\n\n\n\nRead from / Write to resource value function\n\n\nInstead of storing data in member variables of your object instance, you can make the library to retrieve\nthe resource value from a function call, or store a new resource value by calling a function.\n\n\nIn the example of an object instance below you can see all three types (read from function, write to function, read/write from/to function):\n\n\nstruct\n \nMyObjectInstance\n:\n \npublic\n \nLwm2mObjectInstance\n \n{\n\n    \nIndirectRead\nint8_t\n \ntest_read_fun_int8\n;\n\n    \nIndirectRead\nuint32_t\n \ntest_read_fun_uint32\n;\n\n\n    \nIndirectRead\nconst\n \nchar\n*\n \ntest_read_fun_string\n;\n\n    \nIndirectWrite\nconst\n \nchar\n*\n \ntest_write_fun_string\n;\n\n    \nIndirectReadWrite\nconst\n \nchar\n*\n \ntest_readWrite_fun_string\n;\n\n\n}\n \nyour_object_instance_t\n;\n\n\n\n\n\nAs you can see, you will use the templated classes \nIndirectRead\n, \nIndirectWrite\n and \nIndirectReadWrite\n.\nThe first two expect a parameter tuple (type, variable name). The third expects the type only.\n\n\nThe library will crash, if the function pointer is dangling / not assigned to a valid function!\n\n\nAn example object looks like this, with a constructor setting the function pointer:\n\n\nint\n \nmy_read_method() {\n \nreturn\n \n12\n;\n \n}\n\n\nusing\n \nMyReadIntFunction\n \n=\n \nint\n \n(\n*\n)();\n\n\n\nclass\n \nMyObject\n: \npublic\n \nLwm2mObject\n1024\n,\nMyObject\n,\nMyObjectInstance\n\n\n{\n\n\npublic\n:\n\n    \nResource\n(\n0\n,\n \nMyObjectInstance\n::\nreadFunctionPtr\n)\n \nreadFunctionPtr\n;\n\n\n    \nMyObject\n(\nMyReadIntFunction\n \nfun\n)\n \n:\n \nreadFunctionPtr\n(\nfun\n)\n \n{}\n\n\n};\n\n\n\nMyObject\n \no\n(\nmy_read_method\n);\n\n\n\n\n\nObject definition C API\n\n\nInclude \nlwm2m_objects.h\n.\n\n\n/**\n\n\n * @param context   The wakaama context.\n\n\n * @param object   The wakaama lwm2m object with meta information attached.\n\n\n * @param allow_dynamic_instance_creation Allows or disallows the use of lwm2m_object_instances_add(). Heap memory will be used.\n\n\n * @return The error code or COAP_NO_ERROR if no error.\n\n\n */\n\n\nint\n \nlwm2m_add_initialize_object\n(\nlwm2m_context_t\n \n*\n \ncontextP\n,\n\n                                \nlwm2m_object_t\n*\n \nobject\n,\n\n                                \nbool\n \nallow_dynamic_instance_creation\n);\n\n\n\nInitializes an lwm2m object, created with OBJECT_META().\nThis will also add the object to the wakaama object registry. If the client\nis already connected to a server, the server will be notified.\n\n\nRemove an object with lwm2m_remove_object(context, object_id) again.\n\n\n/**\n\n\n * @param context   The wakaama context.\n\n\n * @param object The lwm2m_object.\n\n\n * @param instance An object instance.\n\n\n */\n\n\nvoid\n \nlwm2m_object_instance_add\n(\nlwm2m_context_t\n \n*\n \ncontext\n,\n \nlwm2m_object_t\n*\n \nobject\n,\n \nlwm2m_list_t\n*\n \ninstance\n);\n\n\n\nAdd an instance to an object.\n\n\nIdeally you do this before you connect to a server and before you call \nlwm2m_add_initialize_object\n.\nThe server will be notified of the updated object otherwise.\n\n\nA lwm2m object instance consists of one ore more ressources identified by their ressource ids.\nA ressource may be an uint8, int8, uint16, int16, uint32, int32, uint64, int64, double, c-string.\n\n\nPlease be aware that your object instance\nhave to \"inherit\" lwm2m_list_t::next and lwm2m_list_t::id like in the following example:\n\n\ntypedef\n \nstruct\n \n{\n\n   \nstruct\n \n_prv_instance_next\n;\n \n// matches lwm2m_list_t::next\n\n   \nuint16_t\n \nshortID\n;\n             \n// matches lwm2m_list_t::id\n\n   \n...\n \nYour\n \nmembers\n \nare\n \ndefined\n \nhere\n...\n\n\n}\n \nyour_object_instance_t\n;\n\n\n\n\n\nIf you implement any object with an id registered at\n\nOMA Object \n Resource Registry\n,\nyour object instances have to provide all of the defined ressources\n\n\nOBJECT_META\n\n\nTo allow WakaamaNode to\n\n\n\n\nread from resources,\n\n\nwrite to resources and\n\n\nexecute resources\n\n\n\n\nyou have to provide a machine readable description. You do this by definining a\nlwm2m_object_meta_information_t. Imagine you have defined an object instance looking like below:\n\n\ntypedef\n \nstruct\n \n{\n\n   \nstruct\n \n_prv_instance_next\n;\n \n// matches lwm2m_list_t::next\n\n   \nuint16_t\n \nshortID\n;\n          \n// matches lwm2m_list_t::id\n\n\n   \nuint8_t\n \ntest\n;\n\n   \nExecutableType\n \nexec\n;\n\n   \ndouble\n \ndec\n;\n\n\n}\n \nyour_object_instance_t\n;\n\n\n\n\n\nUse OBJECT_META() for the machine readable description part:\n\n\nOBJECT_META\n(\nyour_object_instance_t\n,\n \ntest_object\n,\n \n1024\n,\n \ntest_object_write_verify_cb\n,\n\n    \n{\n0\n,\n \nO_RES_RW\n,\nO_RES_UINT8\n \n,\n \noffsetof\n(\nyour_object_instance_t\n,\ntest\n)},\n\n    \n{\n1\n,\n \nO_RES_E\n \n,\nO_RES_EXEC\n  \n,\n \noffsetof\n(\nyour_object_instance_t\n,\nexec\n)},\n\n    \n{\n2\n,\n \nO_RES_RW\n,\nO_RES_DOUBLE\n,\n \noffsetof\n(\nyour_object_instance_t\n,\ndec\n)}\n\n\n);\n\n\n\n\n\nWhich results in a \ntest_object\n variable, that can be handed over to \nlwm2m_add_initialize_object\n.\n\n\nOBJECT_META expects the object instance (here: \nyour_object_instance_t\n), and the variable name for the object via\nthe first and second argument.\n\n\nThe third argument is the object ID.\n\n\nThe 4\nth\n argument may be set to NULL. Otherwise set it to a callback method which is called on\na write to your object instance. You may react on a write in this method and you may deny the write if the new value\nis not in range of your allowed values. The callback method needs this signature:\n\n\nbool test_object_write_verify_cb(lwm2m_list_t* instance, uint16_t changed_res_id);\n\n\nThe subsequent arguments describe the ressources of your object instances. Each entry is enclosed in curly brackets and consists of these values:\n\n\n\n\nThe id of the ressource\n\n\nThe Resource access modifier (see next sections).\n\n\nThe Resource type (see next sections).\n\n\nMember pointer\n\n\n\n\nResource Access modifier\n\n\nYou can use the following access modifiers:\n\n\n\n\nO_RES_R\n: Read only access\n\n\nO_RES_W\n:Write only access\n\n\nO_RES_RW\n: Read/Write access\n\n\nO_RES_E\n: Makes this resource executable\n\n\nO_RES_E|O_RES_R\n: Reads the resource value from a function\n\n\nO_RES_E|O_RES_W\n: Writes the resource value to a function\n\n\nO_RES_E|O_RES_RW\n: The resource value is read from and written to a function\n\n\n\n\nResource type\n\n\nYou can use the following types:\n\n\ntypedef\n \nenum\n \n_lwm2m_object_util_type_\n \n{\n\n    \nO_RES_EXEC\n   \n=\n \n0\n,\n \n///\n Executable resource == no type\n\n    \nO_RES_BOOL\n   \n=\n \n1\n,\n \n///\n A boolean value\n\n    \nO_RES_DOUBLE\n \n=\n \n2\n,\n \n///\n A floating point decimal value\n\n    \nO_RES_INT8\n   \n=\n \n3\n,\n \n///\n Int with range [-128,127]\n\n    \nO_RES_UINT8\n  \n=\n \n4\n,\n \n///\n Int with range [0,255]\n\n    \nO_RES_INT16\n  \n=\n \n5\n,\n \n///\n Int with range [-32000,32000]\n\n    \nO_RES_UINT16\n \n=\n \n6\n,\n \n///\n Int with range [0,65500]\n\n    \nO_RES_INT32\n  \n=\n \n7\n,\n \n///\n Int with range [-2^31,2^31-1]\n\n    \nO_RES_UINT32\n \n=\n \n8\n,\n \n///\n Int with range [0, 2^32-1]\n\n    \nO_RES_INT64\n  \n=\n \n9\n,\n \n///\n Int with range [-2^63, 2^63-1]\n\n    \nO_RES_STRING\n          \n=\n \n10\n,\n \n///\n Readonly c-string\n\n    \nO_RES_STRING_PREALLOC\n \n=\n \n11\n,\n \n///\n preallocated space. To be used with OpaqueType(N) in C or Opaque\nN\n in C++.\n\n    \nO_RES_OPAQUE_INDIRECT\n \n=\n \n12\n,\n \n///\n To be used with type OpaqueIndirect\n\n    \nO_RES_OPAQUE_PREALLOC\n \n=\n \n13\n  \n///\n preallocated space. To be used with OpaqueType(N) in C or Opaque\nN\n in C++.\n\n\n}\n \nlwm2m_object_util_type_t\n;\n\n\n\n\n\nExecutable Resources\n\n\nAn executable resource expects a function pointer in your object instance struct. Use the special \nExecutableType\n type:\n\n\ntypedef\n \nstruct\n \n{\n\n   \nstruct\n \n_prv_instance_next\n;\n \n// matches lwm2m_list_t::next\n\n   \nuint16_t\n \nshortID\n;\n          \n// matches lwm2m_list_t::id\n\n   \nExecutableType\n \nmyExecRes\n;\n\n\n}\n \nyour_object_instance_t\n;\n\n\n\n\n\nThe signature of your executabe function pointer should be: \nvoid myFun();\n.\n\n\nOpaque Resources\n\n\nIf you have an opaque resource, you have two options. Either you directly reserve enough space in-place via the \nOpaqueType(N)\n\nmacro, or you let the struct variable point to a memory location, which basically means an indirect memory access. Use \nOpaqueIndirect\n in this case.\nAn example:\n\n\ntypedef\n \nstruct\n \n{\n\n   \nstruct\n \n_prv_instance_next\n;\n \n// matches lwm2m_list_t::next\n\n   \nuint16_t\n \nshortID\n;\n          \n// matches lwm2m_list_t::id\n\n\n   \n// Equals an in-place array with the size of 20 bytes\n\n   \nOpaqueType\n(\n20\n)\n \nopaqueRes\n;\n\n\n   \n// You need to assign the OpaqueIndirect::data pointer a memory location.\n\n   \nOpaqueIndirect\n \nopaqueIndirectRes\n;\n\n\n}\n \nyour_object_instance_t\n;\n\n\n\n\n\nBefore you can actually use \nyour_object_instance_t\n, you need to initialize opaque members.\n\n\n\n\nSet the reserved size: For \nopaqueRes\n this is done by: \nopaqueRes.reserved_len = 20;\n.\n\n\nSet the used size to 0: \nopaqueRes.used_len = 0;\n. This value will be updated on a write access.\n\n\nSet the function pointer for \nOpaqueIndirect\n: \nopaqueIndirectRes.data = myMemory;\n.\n\n\n\n\nThe C-API does not reallocate memory. If there's not enough space, a \nCOAP_413_ENTITY_TOO_LARGE\n error code is returned.\n\n\nRead from / Write to resource value function\n\n\nInstead of storing data in member variables of your object instance, you can make the library to retrieve\nthe resource value from a function call, or store a new resource value by calling a function.\n\n\nIn the example of an object instance below you can see all three types (read from function, write to function, read/write from/to function):\n\n\ntypedef\n \nstruct\n \n{\n\n    \nstruct\n \n_prv_instance_next\n;\n \n// matches lwm2m_list_t::next\n\n    \nuint16_t\n \nshortID\n;\n          \n// matches lwm2m_list_t::id\n\n\n    \nIndirectReadType\n(\nint8_t\n,\ntest_read_fun_int8\n);\n\n    \nIndirectReadType\n(\nuint32_t\n,\ntest_read_fun_uint32\n);\n\n\n    \nIndirectReadType\n(\nconst\n \nchar\n*\n,\ntest_read_fun_string\n);\n\n    \nIndirectWriteType\n(\nconst\n \nchar\n*\n,\ntest_write_fun_string\n);\n\n    \nIndirectReadWriteType\n(\nconst\n \nchar\n*\n)\n \ntest_readWrite_fun_string\n;\n\n\n}\n \nyour_object_instance_t\n;\n\n\n\n\n\nAs you can see, you will use the macros \nIndirectReadType\n, \nIndirectWriteType\n and \nIndirectReadWriteType\n.\nThe first two expect a parameter tuple (type, variable name). The third expects the type only.\n\n\nThe library will crash, if the function pointer is dangling / not assigned to a valid function!\n\n\nBefore you can actually use \nyour_object_instance_t\n, you need to initialize indirect read/write members.\n\n\nFor the example above this would look like:\n\n    \nyour_object_instance_t\n.\ntest_read_fun_int8\n \n=\n \nreadFun8\n;\n\n    \nyour_object_instance_t\n.\ntest_read_fun_uint32\n \n=\n \nreadFun32\n;\n\n\n    \nyour_object_instance_t\n.\ntest_read_fun_string\n \n=\n \nreadFunStr\n;\n\n    \nyour_object_instance_t\n.\ntest_write_fun_string\n \n=\n \nwriteFunStr\n;\n\n    \nyour_object_instance_t\n.\ntest_readWrite_fun_string\n.\nread\n \n=\n \nreadFunStr\n;\n\n    \nyour_object_instance_t\n.\ntest_readWrite_fun_string\n.\nwrite\n \n=\n \nwriteFunStr\n;", 
            "title": "Custom objects"
        }, 
        {
            "location": "/api/objects-custom/#custom-lwm2m-objects", 
            "text": "The last chapter introducted you to objects of the OMA lwM2M registry. WakaamaNode allows you to define\nyour own  custom lwm2m object. A unique object ID is necessary.  The next section explains some background information about the object ID namespace.\nThereafter you will find the C++ and C API for lwm2m object definitions.", 
            "title": "Custom lwM2M objects"
        }, 
        {
            "location": "/api/objects-custom/#about-the-object-id-namespace", 
            "text": "The object id namespace is divided into several ObjectID Classes.     Category  URN  Object ID  range  Description      oma-label  urn:oma:lwm2m:oma: id : version  0 - 1023  Objects Produced by OMA. Only OMA can use this range     reserved   1024 - 2047  Reserved for future use     ext-label  urn:oma:lwm2m:ext: id : version  2048 - 10240  Objects registered by 3 rd  party standards organisations or alliances     x-label  urn:oma:lwm2m: x: id : version  10241 - 26240 26241 - 32768 32769 - 42768  Objects registered by companies or individuals. Objects Produced by Vendors to re-use Block of objects reserved by vendors (Max 50). Private range, Objects will not be published      If your use case is not yet considered within the registries objects, it is time to fill out an application for a new object.  For testing purposes, you can use one of the undefined ids (range 42769..65000). If possible, you should at least\nmake use of the  predefined resource ids (range: 2048..26240) .  Define your custom objects either via C or the C++ interface.", 
            "title": "About the object ID namespace"
        }, 
        {
            "location": "/api/objects-custom/#object-definition-c-api", 
            "text": "Include  lwm2m_objects.hpp .", 
            "title": "Object definition C++ API"
        }, 
        {
            "location": "/api/objects-custom/#lwm2mobject-class", 
            "text": "class   Lwm2mObject ObjectID ,   DerivedObject ,   ObjectInstance   Lwm2mObject is not to be used directly.\nInherit from Lwm2mObject to implement your own lwM2M object. Specify the  ObjectID , for example \"1024\",\nthe derived object class and the associated object instance class.  To allow WakaamaNode to handle all read/write/execute handling for you, you need to describe the available\nresources of an lwM2M object.\nExample:  class   MyObject :  public   Lwm2mObject 1024 ,   MyObject ,   MyObjectInstance  {  public : \n     Resource ( 0 ,   MyObjectInstance :: test ,   O_RES_RW )   test ;  };   Here a Readable/Writable(O_RES_RW) resource with ResourceID 0 is declared. It references the  MyObjectInstance::test  class member of \"MyObjectInstance\"\nfor reading the resource value and writing to it.\nThe name of the class member is not relevant and should describe the resource, for example \"power\" or \"volume\".  The exact syntax and semantic of  Resource  is described further down in the  Resource class  section.  /**   * @param instance The object instance to add. See Lwm2mObjectInstance. May not be null.   */  void   Lwm2mObject :: addInstance ( Lwm2mObjectInstance   *   instance );   Add a  Lwm2mObjectInstance  to your object.\nThe instance is automatically registered to the lwm2m server, if already connected.  /**   * @param instance The instance ID for the instance to remove. See Lwm2mObjectInstance.   *        Nothing happens if the instance is not known to the object.   */  void   Lwm2mObject :: removeInstance ( uint16   instanceID );   Removes a  Lwm2mObjectInstance  from your object.\nThe instance is automatically unregistered from the lwm2m server, if already connected.  /**   * @param lwm2mContext The Wakaama context.   */  void   Lwm2mObject :: registerObject ( void *   lwm2mContext ,   bool   allow_dynamic_instance_creation );   Registers the object to Wakaama.\nThe object is automatically registered to the lwM2M server, if already connected.  /**   * @param lwm2mContext The Wakaama context.   */  void   Lwm2mObject :: unregisterObject ( void *   lwm2mContext );   Unregisters the object from Wakaama.  /**   * @param instance_id Instance ID   */  virtual   Lwm2mObjectInstance *   createInstance ( uint16_t   instance_id );   Implement this function in your object class and either return  nullptr \nif creating instances dynamically by the server or with the given ID is not supported or\nreturn a working object instance with the given instance ID.  The default does nothing and returns a  nullptr .  /**   * @param instance Object instance to delete   * @return Return COAP_NO_ERROR if no error happened.   */  virtual   int   deleteInstance ( Lwm2mObjectInstance *   instance );   Implement this function in your object class to allow to delete an object instance.  /**   * @param instance Object instance that is going to be modified   * @param res_id The resource that will get changed   * @return Return true if change is accepted or false if change is denied.   */  virtual   bool   verifyWrite ( Lwm2mObjectInstance *   instance ,   uint16_t   res_id );   Implement this function in your object class to verify a change on an object instance resource.", 
            "title": "Lwm2mObject class"
        }, 
        {
            "location": "/api/objects-custom/#lwm2mobjectinstance-class", 
            "text": "class   Lwm2mObjectInstance   Lwm2mObjectInstance is not to be used directly.\nInherit from this class to implement a data holder for an object instance.\nExample: struct   MyObjectInstance :   public   Lwm2mObjectInstance   { \n     uint8_t    firstResource ;  }   Allowed data types are 8/16/32/64 bit unsigned/signed integers,\nfloats, doubles, booleans and unsigned/signed c-strings.  \nCoAP and lwM2M support opaque resources.\nWakaamaNode provides the  Opaque N  and  OpaqueIndirect  type.\nSee  Opaque Resources  for an example.  Resources can be executable. Declare a class member of type  Executable  that will be used\nas function pointer. See  Executable Resource  for an example.  The name of the class member is not relevant and should describe the resource, for example \"power\" or \"volume\".  Lwm2mObjectInstance does not have any methods.", 
            "title": "Lwm2mObjectInstance class"
        }, 
        {
            "location": "/api/objects-custom/#resource-class", 
            "text": "class   Resource ResID ,   ResourceValueReference ,   Operations   Use the templated  Resource  class to describe the resource ID, reference to the member variable that stores the value and supported operations in this order. Until C++17, the syntax of declaring a Resource needs \"(\" instead of \" \" brackets.  Supported operations are O_RES_R (read only), O_RES_W (assign only), O_RES_RW (read/write).", 
            "title": "Resource class"
        }, 
        {
            "location": "/api/objects-custom/#executable-resources", 
            "text": "For an executable resource, you do not need to specify the Operations, because it will always be O_RES_E.  In the following example a constructor is used to force the  MyObjectInstance \nuser to assign a function:  struct   MyObjectInstance :   public   Lwm2mObjectInstance   { \n     Executable   exec ; \n\n     MyObjectInstance ( Executable   anExecutableResourceFunction )   :   exec ( anExecutableResourceFunction )   {}  }   The corresponding object looks like this:  class   MyObject :  public   Lwm2mObject 1024 , MyObject , MyObjectInstance  {  public : \n     Resource 0 ,   MyObjectInstance :: exec   exec ;  };", 
            "title": "Executable Resources"
        }, 
        {
            "location": "/api/objects-custom/#opaque-resources", 
            "text": "If you have an opaque resource, you have two options. Either you directly reserve enough space in-place via the  Opaque N \ntemplated class, or you let the class variable point to a memory location, which basically means an indirect memory access. Use  OpaqueIndirect  in this case.\nAn example:  char   memory [ 100 ];  struct   MyObjectInstance :   public   Lwm2mObjectInstance   { \n    // Equals an in-place array with the size of 20 bytes \n    Opaque 20   opaqueRes ; \n\n    // Similar to Opaque, but will be designated as string resource \n    PreallocString 20   preallocStringRes ;    \n\n    // You need to assign the OpaqueIndirect::data pointer a memory location. \n    OpaqueIndirect   opaqueIndirectRes ; \n\n    MyObjectInstance ()   :   opaqueIndirectRes { 100 , 0 , memory }   {}  };", 
            "title": "Opaque Resources"
        }, 
        {
            "location": "/api/objects-custom/#read-from-write-to-resource-value-function", 
            "text": "Instead of storing data in member variables of your object instance, you can make the library to retrieve\nthe resource value from a function call, or store a new resource value by calling a function.  In the example of an object instance below you can see all three types (read from function, write to function, read/write from/to function):  struct   MyObjectInstance :   public   Lwm2mObjectInstance   { \n     IndirectRead int8_t   test_read_fun_int8 ; \n     IndirectRead uint32_t   test_read_fun_uint32 ; \n\n     IndirectRead const   char *   test_read_fun_string ; \n     IndirectWrite const   char *   test_write_fun_string ; \n     IndirectReadWrite const   char *   test_readWrite_fun_string ;  }   your_object_instance_t ;   As you can see, you will use the templated classes  IndirectRead ,  IndirectWrite  and  IndirectReadWrite .\nThe first two expect a parameter tuple (type, variable name). The third expects the type only.  The library will crash, if the function pointer is dangling / not assigned to a valid function!  An example object looks like this, with a constructor setting the function pointer:  int   my_read_method() {   return   12 ;   }  using   MyReadIntFunction   =   int   ( * )();  class   MyObject :  public   Lwm2mObject 1024 , MyObject , MyObjectInstance  {  public : \n     Resource ( 0 ,   MyObjectInstance :: readFunctionPtr )   readFunctionPtr ; \n\n     MyObject ( MyReadIntFunction   fun )   :   readFunctionPtr ( fun )   {}  };  MyObject   o ( my_read_method );", 
            "title": "Read from / Write to resource value function"
        }, 
        {
            "location": "/api/objects-custom/#object-definition-c-api_1", 
            "text": "Include  lwm2m_objects.h .  /**   * @param context   The wakaama context.   * @param object   The wakaama lwm2m object with meta information attached.   * @param allow_dynamic_instance_creation Allows or disallows the use of lwm2m_object_instances_add(). Heap memory will be used.   * @return The error code or COAP_NO_ERROR if no error.   */  int   lwm2m_add_initialize_object ( lwm2m_context_t   *   contextP , \n                                 lwm2m_object_t *   object , \n                                 bool   allow_dynamic_instance_creation );  \nInitializes an lwm2m object, created with OBJECT_META().\nThis will also add the object to the wakaama object registry. If the client\nis already connected to a server, the server will be notified.  Remove an object with lwm2m_remove_object(context, object_id) again.  /**   * @param context   The wakaama context.   * @param object The lwm2m_object.   * @param instance An object instance.   */  void   lwm2m_object_instance_add ( lwm2m_context_t   *   context ,   lwm2m_object_t *   object ,   lwm2m_list_t *   instance );  \nAdd an instance to an object.  Ideally you do this before you connect to a server and before you call  lwm2m_add_initialize_object .\nThe server will be notified of the updated object otherwise.  A lwm2m object instance consists of one ore more ressources identified by their ressource ids.\nA ressource may be an uint8, int8, uint16, int16, uint32, int32, uint64, int64, double, c-string.  Please be aware that your object instance\nhave to \"inherit\" lwm2m_list_t::next and lwm2m_list_t::id like in the following example:  typedef   struct   { \n    struct   _prv_instance_next ;   // matches lwm2m_list_t::next \n    uint16_t   shortID ;               // matches lwm2m_list_t::id \n    ...   Your   members   are   defined   here ...  }   your_object_instance_t ;   If you implement any object with an id registered at OMA Object   Resource Registry ,\nyour object instances have to provide all of the defined ressources", 
            "title": "Object definition C API"
        }, 
        {
            "location": "/api/objects-custom/#object_meta", 
            "text": "To allow WakaamaNode to   read from resources,  write to resources and  execute resources   you have to provide a machine readable description. You do this by definining a\nlwm2m_object_meta_information_t. Imagine you have defined an object instance looking like below:  typedef   struct   { \n    struct   _prv_instance_next ;   // matches lwm2m_list_t::next \n    uint16_t   shortID ;            // matches lwm2m_list_t::id \n\n    uint8_t   test ; \n    ExecutableType   exec ; \n    double   dec ;  }   your_object_instance_t ;   Use OBJECT_META() for the machine readable description part:  OBJECT_META ( your_object_instance_t ,   test_object ,   1024 ,   test_object_write_verify_cb , \n     { 0 ,   O_RES_RW , O_RES_UINT8   ,   offsetof ( your_object_instance_t , test )}, \n     { 1 ,   O_RES_E   , O_RES_EXEC    ,   offsetof ( your_object_instance_t , exec )}, \n     { 2 ,   O_RES_RW , O_RES_DOUBLE ,   offsetof ( your_object_instance_t , dec )}  );   Which results in a  test_object  variable, that can be handed over to  lwm2m_add_initialize_object .  OBJECT_META expects the object instance (here:  your_object_instance_t ), and the variable name for the object via\nthe first and second argument.  The third argument is the object ID.  The 4 th  argument may be set to NULL. Otherwise set it to a callback method which is called on\na write to your object instance. You may react on a write in this method and you may deny the write if the new value\nis not in range of your allowed values. The callback method needs this signature:  bool test_object_write_verify_cb(lwm2m_list_t* instance, uint16_t changed_res_id);  The subsequent arguments describe the ressources of your object instances. Each entry is enclosed in curly brackets and consists of these values:   The id of the ressource  The Resource access modifier (see next sections).  The Resource type (see next sections).  Member pointer", 
            "title": "OBJECT_META"
        }, 
        {
            "location": "/api/objects-custom/#resource-access-modifier", 
            "text": "You can use the following access modifiers:   O_RES_R : Read only access  O_RES_W :Write only access  O_RES_RW : Read/Write access  O_RES_E : Makes this resource executable  O_RES_E|O_RES_R : Reads the resource value from a function  O_RES_E|O_RES_W : Writes the resource value to a function  O_RES_E|O_RES_RW : The resource value is read from and written to a function", 
            "title": "Resource Access modifier"
        }, 
        {
            "location": "/api/objects-custom/#resource-type", 
            "text": "You can use the following types:  typedef   enum   _lwm2m_object_util_type_   { \n     O_RES_EXEC     =   0 ,   ///  Executable resource == no type \n     O_RES_BOOL     =   1 ,   ///  A boolean value \n     O_RES_DOUBLE   =   2 ,   ///  A floating point decimal value \n     O_RES_INT8     =   3 ,   ///  Int with range [-128,127] \n     O_RES_UINT8    =   4 ,   ///  Int with range [0,255] \n     O_RES_INT16    =   5 ,   ///  Int with range [-32000,32000] \n     O_RES_UINT16   =   6 ,   ///  Int with range [0,65500] \n     O_RES_INT32    =   7 ,   ///  Int with range [-2^31,2^31-1] \n     O_RES_UINT32   =   8 ,   ///  Int with range [0, 2^32-1] \n     O_RES_INT64    =   9 ,   ///  Int with range [-2^63, 2^63-1] \n     O_RES_STRING            =   10 ,   ///  Readonly c-string \n     O_RES_STRING_PREALLOC   =   11 ,   ///  preallocated space. To be used with OpaqueType(N) in C or Opaque N  in C++. \n     O_RES_OPAQUE_INDIRECT   =   12 ,   ///  To be used with type OpaqueIndirect \n     O_RES_OPAQUE_PREALLOC   =   13    ///  preallocated space. To be used with OpaqueType(N) in C or Opaque N  in C++.  }   lwm2m_object_util_type_t ;", 
            "title": "Resource type"
        }, 
        {
            "location": "/api/objects-custom/#executable-resources_1", 
            "text": "An executable resource expects a function pointer in your object instance struct. Use the special  ExecutableType  type:  typedef   struct   { \n    struct   _prv_instance_next ;   // matches lwm2m_list_t::next \n    uint16_t   shortID ;            // matches lwm2m_list_t::id \n    ExecutableType   myExecRes ;  }   your_object_instance_t ;   The signature of your executabe function pointer should be:  void myFun(); .", 
            "title": "Executable Resources"
        }, 
        {
            "location": "/api/objects-custom/#opaque-resources_1", 
            "text": "If you have an opaque resource, you have two options. Either you directly reserve enough space in-place via the  OpaqueType(N) \nmacro, or you let the struct variable point to a memory location, which basically means an indirect memory access. Use  OpaqueIndirect  in this case.\nAn example:  typedef   struct   { \n    struct   _prv_instance_next ;   // matches lwm2m_list_t::next \n    uint16_t   shortID ;            // matches lwm2m_list_t::id \n\n    // Equals an in-place array with the size of 20 bytes \n    OpaqueType ( 20 )   opaqueRes ; \n\n    // You need to assign the OpaqueIndirect::data pointer a memory location. \n    OpaqueIndirect   opaqueIndirectRes ;  }   your_object_instance_t ;   Before you can actually use  your_object_instance_t , you need to initialize opaque members.   Set the reserved size: For  opaqueRes  this is done by:  opaqueRes.reserved_len = 20; .  Set the used size to 0:  opaqueRes.used_len = 0; . This value will be updated on a write access.  Set the function pointer for  OpaqueIndirect :  opaqueIndirectRes.data = myMemory; .   The C-API does not reallocate memory. If there's not enough space, a  COAP_413_ENTITY_TOO_LARGE  error code is returned.", 
            "title": "Opaque Resources"
        }, 
        {
            "location": "/api/objects-custom/#read-from-write-to-resource-value-function_1", 
            "text": "Instead of storing data in member variables of your object instance, you can make the library to retrieve\nthe resource value from a function call, or store a new resource value by calling a function.  In the example of an object instance below you can see all three types (read from function, write to function, read/write from/to function):  typedef   struct   { \n     struct   _prv_instance_next ;   // matches lwm2m_list_t::next \n     uint16_t   shortID ;            // matches lwm2m_list_t::id \n\n     IndirectReadType ( int8_t , test_read_fun_int8 ); \n     IndirectReadType ( uint32_t , test_read_fun_uint32 ); \n\n     IndirectReadType ( const   char * , test_read_fun_string ); \n     IndirectWriteType ( const   char * , test_write_fun_string ); \n     IndirectReadWriteType ( const   char * )   test_readWrite_fun_string ;  }   your_object_instance_t ;   As you can see, you will use the macros  IndirectReadType ,  IndirectWriteType  and  IndirectReadWriteType .\nThe first two expect a parameter tuple (type, variable name). The third expects the type only.  The library will crash, if the function pointer is dangling / not assigned to a valid function!  Before you can actually use  your_object_instance_t , you need to initialize indirect read/write members.  For the example above this would look like:      your_object_instance_t . test_read_fun_int8   =   readFun8 ; \n     your_object_instance_t . test_read_fun_uint32   =   readFun32 ; \n\n     your_object_instance_t . test_read_fun_string   =   readFunStr ; \n     your_object_instance_t . test_write_fun_string   =   writeFunStr ; \n     your_object_instance_t . test_readWrite_fun_string . read   =   readFunStr ; \n     your_object_instance_t . test_readWrite_fun_string . write   =   writeFunStr ;", 
            "title": "Read from / Write to resource value function"
        }, 
        {
            "location": "/api/objects-custom-cpp-example/", 
            "text": "Example\n\n\nIf you are going to use a lwM2M object, that is defined in the \nOMA lwM2M registry\n,\nhead over to the \nRegistry objects\n page.\nWakamaNode provides ready-to-use, auto-generated c++ classes for all those objects.\n\n\nFor this example, we assume the following custom lwM2M object definition:\n\n\n\n\n\n\n\n\nObject\n\n\nID\n\n\nMultiple Instances\n\n\nMandatoty\n\n\n\n\n\n\n\n\n\n\nTest\n\n\n1024\n\n\nYes\n\n\nNo\n\n\n\n\n\n\n\n\nRessources:\n\n\n\n\n\n\n\n\nName\n\n\nID\n\n\nOperations\n\n\nMult Inst\n\n\nMandatory\n\n\nType\n\n\nRange\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntest\n\n\n0\n\n\nR/W\n\n\nNo\n\n\nYes\n\n\nInteger\n\n\n0-128\n\n\n\n\n\n\n\n\nexec\n\n\n1\n\n\nE\n\n\nNo\n\n\nYes\n\n\n\n\n\n\n\n\n\n\n\n\ndec\n\n\n2\n\n\nR/W\n\n\nNo\n\n\nYes\n\n\nFloat\n\n\n\n\n\n\n\n\n\n\nsig\n\n\n3\n\n\nR/W\n\n\nNo\n\n\nYes\n\n\nInteger\n\n\n\n\n16-bit signed integer\n\n\n\n\n\n\ntext\n\n\n4\n\n\nR/W\n\n\nNo\n\n\nYes\n\n\nString\n\n\n\n\nchar* c-string\n\n\n\n\n\n\nopaq\n\n\n5\n\n\nW\n\n\nNo\n\n\nYes\n\n\nOpaque\n\n\n32 Byte\n\n\nvoid* data\n\n\n\n\n\n\nread\n\n\n9\n\n\nR\n\n\nNo\n\n\nYes\n\n\nInteger\n\n\n\n\nRead value from method\n\n\n\n\n\n\n\n\nIf you use the C++ object definition API, you only need to provide an object description (meta object data)\nand all read/write/execute handling is done for you. \n\n\nCreate an object instance class, that serves as data holder for each individual instance.\n\n\nusing\n \nMyReadIntFunction\n \n=\n \nint\n \n(\n*\n)();\n\n\n\nstruct\n \nMyObjectInstance\n:\n \npublic\n \nLwm2mObjectInstance\n \n{\n\n    \nuint8_t\n  \ntest\n;\n\n    \nExecutable\n \nexec\n;\n\n    \ndouble\n   \ndec\n;\n\n    \nint16_t\n  \nsig\n;\n\n\n    \nchar\n*\n    \ntext\n;\n\n\n    \nOpaque\n32\n \nopaque\n;\n\n\n    \nIndirectRead\nint\n    \nread\n;\n\n\n    \n// Force the MyObjectInstance user to assign a read and execute funtion. We don\nt want to crash!\n\n    \nMyObjectInstance\n(\nMyReadIntFunction\n*\n \nreadF\n,\n \nMyExecuteFunction\n*\n \nexecF\n)\n \n:\n \nexec\n(\nexecF\n)\n \nread\n(\nreadF\n)\n \n{}\n\n\n};\n\n\n\n\n\nYou inherit from \nLwm2mObjectInstance\n for the object instance data holder.\n\n\nDeclare an object class that describes object 1024 to the library:\n\n\n// Object with LwM2M ID 1024\n\n\nclass\n \nMyObject\n:\n \npublic\n \nLwm2mObject\n1024\n,\nMyObject\n,\nMyObjectInstance\n\n\n{\n\n\npublic\n:\n\n    \nResource\n(\n0\n,\n \nMyObjectInstance\n::\ntest\n,\n \nO_RES_RW\n)\n \ntest\n;\n\n    \nResource\n(\n1\n,\n \nMyObjectInstance\n::\nexec\n,\n \nO_RES_E\n \n)\n \nexec\n;\n\n    \nResource\n(\n2\n,\n \nMyObjectInstance\n::\ndec\n,\n  \nO_RES_RW\n)\n \ndec\n;\n\n    \nResource\n(\n3\n,\n \nMyObjectInstance\n::\nsig\n,\n  \nO_RES_RW\n)\n \nsig\n;\n\n\n    \nResource\n(\n4\n,\n \nMyObjectInstance\n::\ntext\n,\n \nO_RES_RW\n)\n \ntext\n;\n\n\n    \nResource\n(\n5\n,\n \nMyObjectInstance\n::\nopaque\n,\nO_RES_W\n)\n \nopaque\n;\n\n\n    \n// You don\nt need to specify the operation, if it is a\n\n    \n// IndirectRead, IndirectWrite, IndirectReadWrite type\n\n    \nResource\n(\n9\n,\n \nMyObjectInstance\n::\nread\n)\n \nread\n;\n\n\n    \nMyObject\n()\n \n:\n \ntest\n([](\nuint8_t\n \nval\n){\nreturn\n \nval\n=\n128\n;});\n\n\n    \n// Allow dynamic new instances. Default is to not allow new instances\n\n    \nvirtual\n \nbool\n \nallowNewInstance\n(\nuint16_t\n \ninstanceID\n)\n \noverride\n \n{\n \nreturn\n \ntrue\n;\n \n}\n \n\n};\n\n\n\n\n\nInherit from \nLwm2mObject\n and specify the object ID as template parameter for your object class.\nNotice the \n#pragma pack\n, which is important!\n\n\nUse the templated \nResource\n class to describe the resource ID, reference to the member variable and supported operations in this order.\n\n\nSupported operations are O_RES_R (read only), O_RES_W (assign only), O_RES_RW (read/write), O_RES_E (executable).\n\n\nRead resource value from function\n\n\nIt is possible to read a resource value from a function instead of a classes member variable.\nUse \nPollingResource\n and define the resource ID and resource type.\n\n\nIn this example \nmy_read_method\n would look like this:\n\n\nint\n \nmy_read_method\n()\n \n{\n \nreturn\n \n12\n;\n \n}\n\n\n\n\n\nInput validation\n\n\nIf you have looked carefully at the object definition, you see that \ntest\n is restricted to 0..128:\n\n              \nSupported\n    \nMultiple\n\n  \nName\n \n|\n \nID\n \n|\n \nOperations\n \n|\n \nInstances\n \n|\n \nMandatory\n \n|\n  \nType\n   \n|\n \nRange\n \n|\n\n  \ntest\n \n|\n  \n0\n \n|\n    \nR\n/\nW\n     \n|\n    \nNo\n     \n|\n    \nYes\n    \n|\n \nInteger\n \n|\n \n0\n-\n128\n \n|\n\n\n\n\nThis is less that the data type allows, so we have to provide an input validation method. Thankfully, the\n\nResource\n classes constructor takes a validation function.\n\n\nWe provide it in the \nTest\n constructor as a lambda function, that takes an input value \nval\n and returns \nfalse\n if the value is greater than 128:\n\n\nMyObject\n()\n \n:\n \ntest\n([](\nuint8_t\n \nval\n){\nreturn\n \nval\n=\n128\n;});\n\n\n\n\n\nReact to resource write operations\n\n\nYou may \"abuse\" the validation function to react on an altered resource.\n\n\nAnother way is a giant switch in\na defined \nvoid lwm2m_resource_changed_event(uint16_t object_id, uint16_t object_instance_id, uint16_t resource_id)\n.\nIf you do not implement this method somewhere, a default no-op method will be used.\n\n\nAdd object and object instances\n\n\nAn example for adding an object \nMyObject\n with one instance \nMyObjectInstance\n is provided below.\n\n\nMyObject\n \nmyObj\n(\nfalse\n);\n\n\n\nint\n \nmy_read_method\n()\n \n{\n \nreturn\n \n12\n;\n \n}\n\n\nMyObjectInstance\n \nmyInstance\n(\nmy_read_method\n);\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n    \nmyObj\n.\naddInstance\n(\nlwm2mContext\n,\n \nmyInstance\n);\n\n    \nmyObj\n.\nregisterObject\n(\nlwm2mContext\n);\n\n\n}\n\n\n\n\n\nYou can register objects either before or after you are connected to a lwM2M server. If you are already connected,\nthe register call will be a little bit more expensive, because the object need to be published to the server.\n\n\nRemove object or object instance\n\n\nMyObject\n \nmyObj\n(\nfalse\n);\n\n\n\nint\n \nmy_read_method\n()\n \n{\n \nreturn\n \n12\n;\n \n}\n\n\nMyObjectInstance\n \nmyInstance\n(\nmy_read_method\n);\n\n\n\nvoid\n \nexit\n()\n \n{\n\n    \nmyObj\n.\nremoveInstance\n(\nlwm2mContext\n,\n \nmyInstance\n.\ninstanceID\n);\n\n    \nmyObj\n.\nunregisterObject\n(\nlwm2mContext\n);\n\n\n}", 
            "title": "Custom objects /CPP Example"
        }, 
        {
            "location": "/api/objects-custom-cpp-example/#example", 
            "text": "If you are going to use a lwM2M object, that is defined in the  OMA lwM2M registry ,\nhead over to the  Registry objects  page.\nWakamaNode provides ready-to-use, auto-generated c++ classes for all those objects.  For this example, we assume the following custom lwM2M object definition:     Object  ID  Multiple Instances  Mandatoty      Test  1024  Yes  No     Ressources:     Name  ID  Operations  Mult Inst  Mandatory  Type  Range  Description      test  0  R/W  No  Yes  Integer  0-128     exec  1  E  No  Yes       dec  2  R/W  No  Yes  Float      sig  3  R/W  No  Yes  Integer   16-bit signed integer    text  4  R/W  No  Yes  String   char* c-string    opaq  5  W  No  Yes  Opaque  32 Byte  void* data    read  9  R  No  Yes  Integer   Read value from method     If you use the C++ object definition API, you only need to provide an object description (meta object data)\nand all read/write/execute handling is done for you.   Create an object instance class, that serves as data holder for each individual instance.  using   MyReadIntFunction   =   int   ( * )();  struct   MyObjectInstance :   public   Lwm2mObjectInstance   { \n     uint8_t    test ; \n     Executable   exec ; \n     double     dec ; \n     int16_t    sig ; \n\n     char *      text ; \n\n     Opaque 32   opaque ; \n\n     IndirectRead int      read ; \n\n     // Force the MyObjectInstance user to assign a read and execute funtion. We don t want to crash! \n     MyObjectInstance ( MyReadIntFunction *   readF ,   MyExecuteFunction *   execF )   :   exec ( execF )   read ( readF )   {}  };   You inherit from  Lwm2mObjectInstance  for the object instance data holder.  Declare an object class that describes object 1024 to the library:  // Object with LwM2M ID 1024  class   MyObject :   public   Lwm2mObject 1024 , MyObject , MyObjectInstance  {  public : \n     Resource ( 0 ,   MyObjectInstance :: test ,   O_RES_RW )   test ; \n     Resource ( 1 ,   MyObjectInstance :: exec ,   O_RES_E   )   exec ; \n     Resource ( 2 ,   MyObjectInstance :: dec ,    O_RES_RW )   dec ; \n     Resource ( 3 ,   MyObjectInstance :: sig ,    O_RES_RW )   sig ; \n\n     Resource ( 4 ,   MyObjectInstance :: text ,   O_RES_RW )   text ; \n\n     Resource ( 5 ,   MyObjectInstance :: opaque , O_RES_W )   opaque ; \n\n     // You don t need to specify the operation, if it is a \n     // IndirectRead, IndirectWrite, IndirectReadWrite type \n     Resource ( 9 ,   MyObjectInstance :: read )   read ; \n\n     MyObject ()   :   test ([]( uint8_t   val ){ return   val = 128 ;}); \n\n     // Allow dynamic new instances. Default is to not allow new instances \n     virtual   bool   allowNewInstance ( uint16_t   instanceID )   override   {   return   true ;   }   };   Inherit from  Lwm2mObject  and specify the object ID as template parameter for your object class.\nNotice the  #pragma pack , which is important!  Use the templated  Resource  class to describe the resource ID, reference to the member variable and supported operations in this order.  Supported operations are O_RES_R (read only), O_RES_W (assign only), O_RES_RW (read/write), O_RES_E (executable).", 
            "title": "Example"
        }, 
        {
            "location": "/api/objects-custom-cpp-example/#read-resource-value-from-function", 
            "text": "It is possible to read a resource value from a function instead of a classes member variable.\nUse  PollingResource  and define the resource ID and resource type.  In this example  my_read_method  would look like this:  int   my_read_method ()   {   return   12 ;   }", 
            "title": "Read resource value from function"
        }, 
        {
            "location": "/api/objects-custom-cpp-example/#input-validation", 
            "text": "If you have looked carefully at the object definition, you see that  test  is restricted to 0..128:                Supported      Multiple \n   Name   |   ID   |   Operations   |   Instances   |   Mandatory   |    Type     |   Range   | \n   test   |    0   |      R / W       |      No       |      Yes      |   Integer   |   0 - 128   |   This is less that the data type allows, so we have to provide an input validation method. Thankfully, the Resource  classes constructor takes a validation function.  We provide it in the  Test  constructor as a lambda function, that takes an input value  val  and returns  false  if the value is greater than 128:  MyObject ()   :   test ([]( uint8_t   val ){ return   val = 128 ;});", 
            "title": "Input validation"
        }, 
        {
            "location": "/api/objects-custom-cpp-example/#react-to-resource-write-operations", 
            "text": "You may \"abuse\" the validation function to react on an altered resource.  Another way is a giant switch in\na defined  void lwm2m_resource_changed_event(uint16_t object_id, uint16_t object_instance_id, uint16_t resource_id) .\nIf you do not implement this method somewhere, a default no-op method will be used.", 
            "title": "React to resource write operations"
        }, 
        {
            "location": "/api/objects-custom-cpp-example/#add-object-and-object-instances", 
            "text": "An example for adding an object  MyObject  with one instance  MyObjectInstance  is provided below.  MyObject   myObj ( false );  int   my_read_method ()   {   return   12 ;   }  MyObjectInstance   myInstance ( my_read_method );  void   setup ()   { \n     myObj . addInstance ( lwm2mContext ,   myInstance ); \n     myObj . registerObject ( lwm2mContext );  }   You can register objects either before or after you are connected to a lwM2M server. If you are already connected,\nthe register call will be a little bit more expensive, because the object need to be published to the server.", 
            "title": "Add object and object instances"
        }, 
        {
            "location": "/api/objects-custom-cpp-example/#remove-object-or-object-instance", 
            "text": "MyObject   myObj ( false );  int   my_read_method ()   {   return   12 ;   }  MyObjectInstance   myInstance ( my_read_method );  void   exit ()   { \n     myObj . removeInstance ( lwm2mContext ,   myInstance . instanceID ); \n     myObj . unregisterObject ( lwm2mContext );  }", 
            "title": "Remove object or object instance"
        }, 
        {
            "location": "/api/objects-custom-c-example/", 
            "text": "Example\n\n\nIf you are going to use a lwM2M object, that is defined in the \nOMA lwM2M registry\n,\nhead over to the \nRegistry objects\n page.\nWakamaNode provides ready-to-use, auto-generated c++ classes for all those objects.\n\n\nFor this example, we assume the following custom lwM2M object definition:\n\n\n\n\n\n\n\n\nObject\n\n\nID\n\n\nMultiple Instances\n\n\nMandatoty\n\n\n\n\n\n\n\n\n\n\nTest\n\n\n1024\n\n\nYes\n\n\nNo\n\n\n\n\n\n\n\n\nRessources:\n\n\n\n\n\n\n\n\nName\n\n\nID\n\n\nOperations\n\n\nMult Inst\n\n\nMandatory\n\n\nType\n\n\nRange\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\ntest\n\n\n1\n\n\nR/W\n\n\nNo\n\n\nYes\n\n\nInteger\n\n\n0-128\n\n\n\n\n\n\n\n\nexec\n\n\n2\n\n\nE\n\n\nNo\n\n\nYes\n\n\n\n\n\n\n\n\n\n\n\n\ndec\n\n\n3\n\n\nR/W\n\n\nNo\n\n\nYes\n\n\nFloat\n\n\n\n\n\n\n\n\n\n\n\n\nIf you use the object definition API, you only need to provide an object description (meta object data)\nand all read/write/execute handling is done for you. \n\n\nThe meta object data is usually definied in your custom \nmy_object.c\n. We assume the following custom object:\n\n\ntypedef\n \nstruct\n\n\n{\n\n    \nstruct\n \ntest_object_instance_t\n \n*\n \nnext\n;\n   \n// matches lwm2m_list_t::next\n\n    \nuint16_t\n \nshortID\n;\n                       \n// matches lwm2m_list_t::id\n\n\n    \nuint8_t\n  \ntest\n;\n\n    \nExecutable\n    \nexecF\n;\n \n// function pointer\n\n    \ndouble\n   \ndec\n;\n\n    \nint16_t\n  \nsig\n;\n\n\n}\n \ntest_object_instance_t\n;\n\n\n\n\n\nWith the help of the \nOBJECT_META(object_struct, result_variable_name, write_verify_callback, ressources...)\n macro we define the object description:\n\n\nOBJECT_META\n(\ntest_object_instance_t\n,\n \ntest_object_meta\n,\n \ntest_object_write_verify_cb\n,\n\n    \n{\n0\n,\n \nO_RES_RW\n,\nO_RES_UINT8\n     \n,\n \noffsetof\n(\ntest_object_instance_t\n,\ntest\n)},\n\n    \n{\n1\n,\n \nO_RES_E\n \n,\n0\n               \n,\n \noffsetof\n(\ntest_object_instance_t\n,\nexecF\n)},\n\n    \n{\n2\n,\n \nO_RES_RW\n,\nO_RES_DOUBLE\n    \n,\n \noffsetof\n(\ntest_object_instance_t\n,\ndec\n)},\n\n    \n{\n3\n,\n \nO_RES_RW\n,\nO_RES_INT16\n     \n,\n \noffsetof\n(\ntest_object_instance_t\n,\nsig\n)}\n\n\n);\n\n\n\nlwm2m_object_meta_information_t\n \n*\ntest_object_get_meta\n()\n \n{\n\n    \nreturn\n \ntest_object_meta\n;\n\n\n}\n\n\n\n\n\nThe ressources are described each with an entry of the following form:\n\n{RES_ID, RES_ACCESS, RES_TYPE, offsetof(object_struct, res_name)}\n.\n\n\nInput validation\n\n\nIf you have looked carefully at the object definition above, you see that \ntest\n is restricted to 0..128.\nThis is less that the data type allows, so we have to provide an input validation method and\nmake it known to the meta object via the third argument (write_verify_callback).\n\n\nFor the above example such a method could look like this:\n\n\nbool\n \ntest_object_write_verify_cb\n(\nlwm2m_list_t\n*\n \ninstance\n,\n \nuint16_t\n \nchanged_res_id\n)\n \n{\n\n    \ntest_object_instance_t\n*\n \ni\n \n=\n \n(\ntest_object_instance_t\n*\n)\ninstance\n;\n\n    \n// Return false for an invalid object\n\n    \nif\n(\nchanged_res_id\n==\n1\n \n \ni\n-\ntest\n \n \n128\n)\n \nreturn\n \nfalse\n;\n\n    \n// If we return true, the new value will be applied to the instance object for us.\n\n    \nreturn\n \ntrue\n;\n\n\n}\n\n\n\n\n\nReact to resource write operations\n\n\nYou may \"misuse\" the validation function to react on an altered resource. Another way is to implement\n\nvoid lwm2m_resource_changed_event(uint16_t object_id, uint16_t object_instance_id, uint16_t resource_id)\n\nand have a giant switch for all resources.\n\n\nAdd object and object instances\n\n\nFirst define a method in your \nmy_object.c\n unit that creates a new object instance, like in the code below:\n\n\nlwm2m_list_t\n*\n \nled_object_create_instances\n()\n \n{\n\n    \ntest_object_instance_t\n \n*\n \ntargetP\n \n=\n \n(\ntest_object_instance_t\n \n*\n)\nmalloc\n(\nsizeof\n(\ntest_object_instance_t\n));\n\n    \nif\n \n(\nNULL\n \n==\n \ntargetP\n)\n \nreturn\n \nNULL\n;\n\n    \nmemset\n(\ntargetP\n,\n \n0\n,\n \nsizeof\n(\ntest_object_instance_t\n));\n\n    \ntargetP\n-\nshortID\n \n=\n \n0\n;\n \n// Assign instance ID\n\n    \ntargetP\n-\nstate\n \n=\n \n0\n;\n\n    \nreturn\n \n(\nlwm2m_list_t\n*\n)\ntargetP\n;\n\n\n}\n\n\n\n\n\nIn your \nmy_object.h\n file, make the method declaration available:\n\n\n#pragma once\n\n\n\nlwm2m_object_meta_information_t\n*\n \nled_object_get_meta\n();\n\n\nlwm2m_list_t\n*\n \nled_object_create_instances\n()\n \n;\n\n\n\n\n\nIn you application file, create the object and instance and register each.\n\n\n#include\n \nmy_object.h\n\n\n\nvoid\n \nsetup\n()\n \n{\n\n    \n// Create object\n\n    \nlwm2m_object_t\n*\n \ntest_object\n \n=\n \nlwm2m_object_create\n(\n5850\n,\n \ntrue\n,\n \nled_object_get_meta\n());\n\n    \n// Add instance\n\n    \nlwm2m_object_instances_add\n(\ntest_object\n,\n \nled_object_create_instances\n());\n\n    \n// Register object\n\n    \nlwm2m_add_object\n(\nclient_context\n,\n \ntest_object\n);\n\n\n\n}\n\n\n\n\n\nYou can register objects either before or after you are connected to a lwM2M server. If you are already connected,\nthe register call will be a little bit more expensive, because the object need to be published to the server.\n\n\nRemove object or object instance\n\n\n#include\n \nmy_object.h\n\n\n\nlwm2m_object_t\n*\n \ntest_object\n \n=\n \n...;\n\n\n\nvoid\n \nexit\n()\n \n{\n\n    \nlwm2m_object_free\n(\ntest_object\n);\n\n\n}", 
            "title": "Custom objects /C Example"
        }, 
        {
            "location": "/api/objects-custom-c-example/#example", 
            "text": "If you are going to use a lwM2M object, that is defined in the  OMA lwM2M registry ,\nhead over to the  Registry objects  page.\nWakamaNode provides ready-to-use, auto-generated c++ classes for all those objects.  For this example, we assume the following custom lwM2M object definition:     Object  ID  Multiple Instances  Mandatoty      Test  1024  Yes  No     Ressources:     Name  ID  Operations  Mult Inst  Mandatory  Type  Range  Description      test  1  R/W  No  Yes  Integer  0-128     exec  2  E  No  Yes       dec  3  R/W  No  Yes  Float       If you use the object definition API, you only need to provide an object description (meta object data)\nand all read/write/execute handling is done for you.   The meta object data is usually definied in your custom  my_object.c . We assume the following custom object:  typedef   struct  { \n     struct   test_object_instance_t   *   next ;     // matches lwm2m_list_t::next \n     uint16_t   shortID ;                         // matches lwm2m_list_t::id \n\n     uint8_t    test ; \n     Executable      execF ;   // function pointer \n     double     dec ; \n     int16_t    sig ;  }   test_object_instance_t ;   With the help of the  OBJECT_META(object_struct, result_variable_name, write_verify_callback, ressources...)  macro we define the object description:  OBJECT_META ( test_object_instance_t ,   test_object_meta ,   test_object_write_verify_cb , \n     { 0 ,   O_RES_RW , O_RES_UINT8       ,   offsetof ( test_object_instance_t , test )}, \n     { 1 ,   O_RES_E   , 0                 ,   offsetof ( test_object_instance_t , execF )}, \n     { 2 ,   O_RES_RW , O_RES_DOUBLE      ,   offsetof ( test_object_instance_t , dec )}, \n     { 3 ,   O_RES_RW , O_RES_INT16       ,   offsetof ( test_object_instance_t , sig )}  );  lwm2m_object_meta_information_t   * test_object_get_meta ()   { \n     return   test_object_meta ;  }   The ressources are described each with an entry of the following form: {RES_ID, RES_ACCESS, RES_TYPE, offsetof(object_struct, res_name)} .", 
            "title": "Example"
        }, 
        {
            "location": "/api/objects-custom-c-example/#input-validation", 
            "text": "If you have looked carefully at the object definition above, you see that  test  is restricted to 0..128.\nThis is less that the data type allows, so we have to provide an input validation method and\nmake it known to the meta object via the third argument (write_verify_callback).  For the above example such a method could look like this:  bool   test_object_write_verify_cb ( lwm2m_list_t *   instance ,   uint16_t   changed_res_id )   { \n     test_object_instance_t *   i   =   ( test_object_instance_t * ) instance ; \n     // Return false for an invalid object \n     if ( changed_res_id == 1     i - test     128 )   return   false ; \n     // If we return true, the new value will be applied to the instance object for us. \n     return   true ;  }", 
            "title": "Input validation"
        }, 
        {
            "location": "/api/objects-custom-c-example/#react-to-resource-write-operations", 
            "text": "You may \"misuse\" the validation function to react on an altered resource. Another way is to implement void lwm2m_resource_changed_event(uint16_t object_id, uint16_t object_instance_id, uint16_t resource_id) \nand have a giant switch for all resources.", 
            "title": "React to resource write operations"
        }, 
        {
            "location": "/api/objects-custom-c-example/#add-object-and-object-instances", 
            "text": "First define a method in your  my_object.c  unit that creates a new object instance, like in the code below:  lwm2m_list_t *   led_object_create_instances ()   { \n     test_object_instance_t   *   targetP   =   ( test_object_instance_t   * ) malloc ( sizeof ( test_object_instance_t )); \n     if   ( NULL   ==   targetP )   return   NULL ; \n     memset ( targetP ,   0 ,   sizeof ( test_object_instance_t )); \n     targetP - shortID   =   0 ;   // Assign instance ID \n     targetP - state   =   0 ; \n     return   ( lwm2m_list_t * ) targetP ;  }   In your  my_object.h  file, make the method declaration available:  #pragma once  lwm2m_object_meta_information_t *   led_object_get_meta ();  lwm2m_list_t *   led_object_create_instances ()   ;   In you application file, create the object and instance and register each.  #include   my_object.h  void   setup ()   { \n     // Create object \n     lwm2m_object_t *   test_object   =   lwm2m_object_create ( 5850 ,   true ,   led_object_get_meta ()); \n     // Add instance \n     lwm2m_object_instances_add ( test_object ,   led_object_create_instances ()); \n     // Register object \n     lwm2m_add_object ( client_context ,   test_object );  }   You can register objects either before or after you are connected to a lwM2M server. If you are already connected,\nthe register call will be a little bit more expensive, because the object need to be published to the server.", 
            "title": "Add object and object instances"
        }, 
        {
            "location": "/api/objects-custom-c-example/#remove-object-or-object-instance", 
            "text": "#include   my_object.h  lwm2m_object_t *   test_object   =   ...;  void   exit ()   { \n     lwm2m_object_free ( test_object );  }", 
            "title": "Remove object or object instance"
        }, 
        {
            "location": "/advanced-usage/custom-platform/", 
            "text": "Custom platform\n\n\nPlatform code need to implement the following methods:\n\n\nvoid\n*\n \nlwm2m_malloc\n(\nsize_t\n \ns\n);\n\n\n\nvoid\n \nlwm2m_free\n(\nvoid\n \n*\n \np\n);\n\n\n\nchar\n*\n \nlwm2m_strdup\n(\nconst\n \nchar\n \n*\n \nstr\n);\n\n\n\nint\n \nlwm2m_strncmp\n(\nconst\n \nchar\n \n*\n \ns1\n,\n\n                     \nconst\n \nchar\n \n*\n \ns2\n,\n\n                     \nsize_t\n \nn\n);\n\n\n\ntime_t\n \n__attribute__\n((\nweak\n))\n \nlwm2m_gettime\n(\nvoid\n);\n\n\n\n#ifdef LWM2M_WITH_LOGS\n\n\nvoid\n \n__attribute__\n((\nweak\n))\n \nlwm2m_printf\n(\nconst\n \nchar\n \n*\n \nformat\n,\n \n...);\n\n\n#endif\n\n\n\n\n\nlwm2m_printf\n is implemented with a weak linkage, so that the application is\nable to override the log destination.\n\n\nThe implementation is expected to reside in the\n\n src/platform\n\ndirectory.", 
            "title": "Custom platform"
        }, 
        {
            "location": "/advanced-usage/custom-platform/#custom-platform", 
            "text": "Platform code need to implement the following methods:  void *   lwm2m_malloc ( size_t   s );  void   lwm2m_free ( void   *   p );  char *   lwm2m_strdup ( const   char   *   str );  int   lwm2m_strncmp ( const   char   *   s1 , \n                      const   char   *   s2 , \n                      size_t   n );  time_t   __attribute__ (( weak ))   lwm2m_gettime ( void );  #ifdef LWM2M_WITH_LOGS  void   __attribute__ (( weak ))   lwm2m_printf ( const   char   *   format ,   ...);  #endif   lwm2m_printf  is implemented with a weak linkage, so that the application is\nable to override the log destination.  The implementation is expected to reside in the  src/platform \ndirectory.", 
            "title": "Custom platform"
        }, 
        {
            "location": "/advanced-usage/custom-network/", 
            "text": "Network integration\n\n\nThis directory consists of files for different network stack integrations. Currently\nthe lwip stack and a posix compatible stack as well as the windows network stack is supported.\n\n\nBasically an implementation has to keep track of open connections,\nopen up an udp connection and close an udp connection.\n\n\nThe implementation is expected to reside in the\n\n src/network\n\ndirectory.\n\n\nRequired methods\n\n\nNetwork stack code need to implement the following methods:\n\n\n/**\n\n\n * @brief Initializes the network layer\n\n\n *\n\n\n * @param contextP  The wakaama context. Network socket information is stored in the\n\n\n *                  contexts userdata.\n\n\n * @param localPort Must be NULL for clients in which case a port is automatically choosen.\n\n\n *                  For servers LWM2M_DEFAULT_SERVER_PORT is recommended.\n\n\n * @return Return 0 if socket binding failed. Otherwise returns the number\n\n\n *     of sockets we could bind to (for IPv4 and IPv6 each on all available interfaces).\n\n\n */\n\n\nuint8_t\n \nlwm2m_network_init\n(\nlwm2m_context_t\n \n*\n \ncontextP\n,\n \nconst\n \nchar\n*\n \nlocalPort\n);\n\n\n\n/**\n\n\n * @brief Return the native socket handler for the given socket number.\n\n\n * Usually this method is relevant if posix sockets are used and you need the socket handlers for select().\n\n\n * @param contextP The wakaama context.\n\n\n * @param sock_no Number from 0..v-1 where v has been returned by lwm2m_network_init().\n\n\n * @return Native socket handler for the given socket number\n\n\n */\n\n\nint\n \nlwm2m_network_native_sock\n(\nlwm2m_context_t\n \n*\n \ncontextP\n,\n \nuint8_t\n \nsock_no\n);\n\n\n\n/**\n\n\n * @brief lwm2m_network_process\n\n\n * Processes incoming network traffic and calls lwm2m_handle_packet.\n\n\n * @param contextP The wakaama context.\n\n\n * @return Return false if no open sockets are available.\n\n\n */\n\n\nbool\n \nlwm2m_network_process\n(\nlwm2m_context_t\n \n*\n \ncontextP\n);\n\n\n\n/**\n\n\n * @brief Closes all opened sockets and clean context-\nuserdata.\n\n\n * @param contextP The wakaama context.\n\n\n */\n\n\nvoid\n \nlwm2m_network_close\n(\nlwm2m_context_t\n \n*\n \ncontextP\n);\n\n\n\n/**\n\n\n * @brief Force the network stack to use the given network interface\n\n\n * This is useful for testing purposes. The routing table will be ignored\n\n\n * and the given interface will be used for outgoing traffic.\n\n\n * @param contextP The wakaama context.\n\n\n * @param interface A generic value which can be used to point to a network\n\n\n * interface. The interpretation depends on the network backend.\n\n\n */\n\n\nvoid\n \nlwm2m_network_force_interface\n(\nlwm2m_context_t\n \n*\n \ncontextP\n,\n \nvoid\n*\n \ninterface\n);\n\n\n\n\n\nDTLS\n\n\nA reference network stack implementation for a DTLS secured connection based on mbed TLS is included.\nYou need to define \n#define LWM2M_WITH_DTLS\n in your \nwakaama_config.h\n.\nDo not expect this to be safe in any way without a security audit on your side!\n\n\nhttps://tls.mbed.org/kb/how-to/how-do-i-port-mbed-tls-to-a-new-environment-OS\n explains the required\nplatform and network code for mbed TLS to work.\n\n\nPlease be aware that mbed TLS uses heap memory and maximum buffer sizes need to be tuned for your use-cases.", 
            "title": "Custom network stack"
        }, 
        {
            "location": "/advanced-usage/custom-network/#network-integration", 
            "text": "This directory consists of files for different network stack integrations. Currently\nthe lwip stack and a posix compatible stack as well as the windows network stack is supported.  Basically an implementation has to keep track of open connections,\nopen up an udp connection and close an udp connection.  The implementation is expected to reside in the  src/network \ndirectory.", 
            "title": "Network integration"
        }, 
        {
            "location": "/advanced-usage/custom-network/#required-methods", 
            "text": "Network stack code need to implement the following methods:  /**   * @brief Initializes the network layer   *   * @param contextP  The wakaama context. Network socket information is stored in the   *                  contexts userdata.   * @param localPort Must be NULL for clients in which case a port is automatically choosen.   *                  For servers LWM2M_DEFAULT_SERVER_PORT is recommended.   * @return Return 0 if socket binding failed. Otherwise returns the number   *     of sockets we could bind to (for IPv4 and IPv6 each on all available interfaces).   */  uint8_t   lwm2m_network_init ( lwm2m_context_t   *   contextP ,   const   char *   localPort );  /**   * @brief Return the native socket handler for the given socket number.   * Usually this method is relevant if posix sockets are used and you need the socket handlers for select().   * @param contextP The wakaama context.   * @param sock_no Number from 0..v-1 where v has been returned by lwm2m_network_init().   * @return Native socket handler for the given socket number   */  int   lwm2m_network_native_sock ( lwm2m_context_t   *   contextP ,   uint8_t   sock_no );  /**   * @brief lwm2m_network_process   * Processes incoming network traffic and calls lwm2m_handle_packet.   * @param contextP The wakaama context.   * @return Return false if no open sockets are available.   */  bool   lwm2m_network_process ( lwm2m_context_t   *   contextP );  /**   * @brief Closes all opened sockets and clean context- userdata.   * @param contextP The wakaama context.   */  void   lwm2m_network_close ( lwm2m_context_t   *   contextP );  /**   * @brief Force the network stack to use the given network interface   * This is useful for testing purposes. The routing table will be ignored   * and the given interface will be used for outgoing traffic.   * @param contextP The wakaama context.   * @param interface A generic value which can be used to point to a network   * interface. The interpretation depends on the network backend.   */  void   lwm2m_network_force_interface ( lwm2m_context_t   *   contextP ,   void *   interface );", 
            "title": "Required methods"
        }, 
        {
            "location": "/advanced-usage/custom-network/#dtls", 
            "text": "A reference network stack implementation for a DTLS secured connection based on mbed TLS is included.\nYou need to define  #define LWM2M_WITH_DTLS  in your  wakaama_config.h .\nDo not expect this to be safe in any way without a security audit on your side!  https://tls.mbed.org/kb/how-to/how-do-i-port-mbed-tls-to-a-new-environment-OS  explains the required\nplatform and network code for mbed TLS to work.  Please be aware that mbed TLS uses heap memory and maximum buffer sizes need to be tuned for your use-cases.", 
            "title": "DTLS"
        }, 
        {
            "location": "/advanced-usage/ota/", 
            "text": "OTA updates\n\n\nlwM2M defines a firmware upgrade object. The wakaamaNode library provides two\nreference implementations: For the Arduino OTA model and for Posix/Windows binaries.\n\n\nFind the implementations in the\n\n src/firmware\n\ndirectory.\n\n\nUpdating or even checking the version is a server initatiated operation, wakaamaNode\nwill not perform any checks on its own.\n\n\nOTA security\n\n\nYou should only accept an OTA request, if you are connected to a DTLS secured connection\nwith an authentificated server.", 
            "title": "Over-the-air updates"
        }, 
        {
            "location": "/advanced-usage/ota/#ota-updates", 
            "text": "lwM2M defines a firmware upgrade object. The wakaamaNode library provides two\nreference implementations: For the Arduino OTA model and for Posix/Windows binaries.  Find the implementations in the  src/firmware \ndirectory.  Updating or even checking the version is a server initatiated operation, wakaamaNode\nwill not perform any checks on its own.", 
            "title": "OTA updates"
        }, 
        {
            "location": "/advanced-usage/ota/#ota-security", 
            "text": "You should only accept an OTA request, if you are connected to a DTLS secured connection\nwith an authentificated server.", 
            "title": "OTA security"
        }, 
        {
            "location": "/advanced-usage/deep-sleep/", 
            "text": "After a deep sleep a new IP may be assigned, which requires a new DTLS security context and a new lwM2M handshake, therefore a proper session closing is recommended. To ensure that all messages are sent and the session is shutdown correctly,  do a \nlwm2m_network_close(lwm2mH);\n and \nlwm2m_client_close();\n. This will disconnect everything cleanly, so that you can call \nESP.deepSleep()\n. \n\n\nvoid\n \nreconnect\n()\n \n{\n\n  \n// ...\n\n\n}\n\n\n\nvoid\n \nloop\n()\n \n{\n\n  \nif\n \n(\nrequestDeepsleep\n)\n \n{\n\n    \nrequestDeepsleep\n \n=\n \nfalse\n;\n\n    \nlwm2m_network_close\n(\nlwm2mH\n);\n\n    \nlwm2m_client_close\n();\n\n\n    \nESP\n.\ndeepSleep\n();\n\n\n    \nsleep\n(\n10\n);\n\n    \nreconnect\n();\n\n  \n}\n\n\n}", 
            "title": "Deep sleep"
        }, 
        {
            "location": "/others/limitations-and-known-issues/", 
            "text": "ESP8266: ADC readings\n\n\nThis is a known esp8266/Arduino issue\n that polling \nanalogRead()\n too frequently forces the Wi-Fi to disconnect. As a workaround, don't poll the ADC more than one time every 3ms.\n\n\nESP8266: Wi-Fi connection\n\n\nIf you encouter any issues with the Wi-Fi, try changing the flash size build parameter, or try to erase the flash.", 
            "title": "Limitations and known issues"
        }, 
        {
            "location": "/others/limitations-and-known-issues/#esp8266-adc-readings", 
            "text": "This is a known esp8266/Arduino issue  that polling  analogRead()  too frequently forces the Wi-Fi to disconnect. As a workaround, don't poll the ADC more than one time every 3ms.", 
            "title": "ESP8266: ADC readings"
        }, 
        {
            "location": "/others/limitations-and-known-issues/#esp8266-wi-fi-connection", 
            "text": "If you encouter any issues with the Wi-Fi, try changing the flash size build parameter, or try to erase the flash.", 
            "title": "ESP8266: Wi-Fi connection"
        }, 
        {
            "location": "/others/troubleshooting/", 
            "text": "The network is completely unstable... What's going on?\n\n\nThe library needs work to be done periodically (ie. \nlwm2m_network_process(context)\n needs to be called frequently). In other words, don't use \ndelay()\n (see \navoid delay\n) or anything that might block the code for more than 50ms or so. There is also a known Arduino for ESP8266 issue with \nanalogRead()\n, see \nLimitations and known issues\n.\n\n\nMy device resets itself / crashes\n\n\nYou probably run into a memory shortage. The wakaama library is using heap memory\nfor incoming packets, as well as outgoing packets if \nlwm2m_add_server\n is called with\nthe storing flag enabled. Adding a server consumes heap memory as well.\n\n\nMake sure to have around 3kb free heap memory available, disable \nstoring\n, limit the added servers.\nBlock1 type coap blocks consume additional memory as well as observing/observed resources.\n\n\nif json is enabled via LWM2M_SUPPORT_JSON, the json encoding/decoding temporarly consumes\nheap memory as well.", 
            "title": "Troubleshooting"
        }, 
        {
            "location": "/others/troubleshooting/#the-network-is-completely-unstable-whats-going-on", 
            "text": "The library needs work to be done periodically (ie.  lwm2m_network_process(context)  needs to be called frequently). In other words, don't use  delay()  (see  avoid delay ) or anything that might block the code for more than 50ms or so. There is also a known Arduino for ESP8266 issue with  analogRead() , see  Limitations and known issues .", 
            "title": "The network is completely unstable... What's going on?"
        }, 
        {
            "location": "/others/troubleshooting/#my-device-resets-itself-crashes", 
            "text": "You probably run into a memory shortage. The wakaama library is using heap memory\nfor incoming packets, as well as outgoing packets if  lwm2m_add_server  is called with\nthe storing flag enabled. Adding a server consumes heap memory as well.  Make sure to have around 3kb free heap memory available, disable  storing , limit the added servers.\nBlock1 type coap blocks consume additional memory as well as observing/observed resources.  if json is enabled via LWM2M_SUPPORT_JSON, the json encoding/decoding temporarly consumes\nheap memory as well.", 
            "title": "My device resets itself / crashes"
        }
    ]
}